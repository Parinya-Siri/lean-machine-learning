import category_theory.limits.shapes.equalizers
namespace category_theory
universes v vâ‚‚ u uâ‚‚
variables {C : Type u} [category.{v} C]
variables {D : Type uâ‚‚} [category.{vâ‚‚} D]
variables (G : C â¥¤ D)
variables {X Y : C} (f g : X âŸ¶ Y)
structure is_split_coequalizer {Z : C} (Ï€ : Y âŸ¶ Z) :=
(right_section : Z âŸ¶ Y)
(left_section : Y âŸ¶ X)
(condition : f â‰« Ï€ = g â‰« Ï€)
(right_section_Ï€ : right_section â‰« Ï€ = ğŸ™ Z)
(left_section_bottom : left_section â‰« g = ğŸ™ Y)
(left_section_top : left_section â‰« f = Ï€ â‰« right_section)
instance {X : C} : inhabited (is_split_coequalizer (ğŸ™ X) (ğŸ™ X) (ğŸ™ X)) :=
âŸ¨âŸ¨ğŸ™ _, ğŸ™ _, rfl, category.id_comp _, category.id_comp _, rflâŸ©âŸ©
open is_split_coequalizer
attribute [reassoc] condition
attribute [simp, reassoc] right_section_Ï€ left_section_bottom left_section_top
variables {f g}
@[simps]
def is_split_coequalizer.map {Z : C} {Ï€ : Y âŸ¶ Z} (q : is_split_coequalizer f g Ï€) (F : C â¥¤ D) :
  is_split_coequalizer (F.map f) (F.map g) (F.map Ï€) :=
{ right_section := F.map q.right_section,
  left_section := F.map q.left_section,
  condition := by rw [â†F.map_comp, q.condition, F.map_comp],
  right_section_Ï€ := by rw [â†F.map_comp, q.right_section_Ï€, F.map_id],
  left_section_bottom := by rw [â†F.map_comp, q.left_section_bottom, F.map_id],
  left_section_top := by rw [â†F.map_comp, q.left_section_top, F.map_comp] }
section
open limits
@[simps X]
def is_split_coequalizer.as_cofork {Z : C} {h : Y âŸ¶ Z} (t : is_split_coequalizer f g h) :
  cofork f g :=
cofork.of_Ï€ h t.condition
@[simp] lemma is_split_coequalizer.as_cofork_Ï€  {Z : C} {h : Y âŸ¶ Z}
  (t : is_split_coequalizer f g h) : t.as_cofork.Ï€ = h := rfl
def is_split_coequalizer.is_coequalizer
  {Z : C} {h : Y âŸ¶ Z} (t : is_split_coequalizer f g h) :
  is_colimit t.as_cofork :=
cofork.is_colimit.mk' _ $ Î» s,
âŸ¨t.right_section â‰« s.Ï€,
 by { dsimp, rw [â† t.left_section_top_assoc, s.condition, t.left_section_bottom_assoc] },
 Î» m hm, by { simp [â†hm] }âŸ©
end
variables (f g)
class has_split_coequalizer : Prop :=
(splittable [] : âˆƒ {Z : C} (h : Y âŸ¶ Z), nonempty (is_split_coequalizer f g h))
abbreviation functor.is_split_pair : Prop := has_split_coequalizer (G.map f) (G.map g)
noncomputable def has_split_coequalizer.coequalizer_of_split [has_split_coequalizer f g] : C :=
(has_split_coequalizer.splittable f g).some
noncomputable def has_split_coequalizer.coequalizer_Ï€ [has_split_coequalizer f g] :
  Y âŸ¶ has_split_coequalizer.coequalizer_of_split f g :=
(has_split_coequalizer.splittable f g).some_spec.some
noncomputable def has_split_coequalizer.is_split_coequalizer [has_split_coequalizer f g] :
  is_split_coequalizer f g (has_split_coequalizer.coequalizer_Ï€ f g) :=
classical.choice (has_split_coequalizer.splittable f g).some_spec.some_spec
instance map_is_split_pair [has_split_coequalizer f g] :
  has_split_coequalizer (G.map f) (G.map g) :=
{ splittable :=
  âŸ¨_, _, âŸ¨is_split_coequalizer.map (has_split_coequalizer.is_split_coequalizer f g) _âŸ©âŸ© }
namespace limits
@[priority 1]
instance has_coequalizer_of_has_split_coequalizer [has_split_coequalizer f g] :
  has_coequalizer f g :=
has_colimit.mk âŸ¨_, (has_split_coequalizer.is_split_coequalizer f g).is_coequalizerâŸ©
end limits
end category_theory
