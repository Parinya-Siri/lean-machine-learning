import geometry.manifold.algebra.structures
import geometry.manifold.bump_function
import topology.paracompact
import topology.partition_of_unity
import topology.shrinking_lemma
universes uŒπ uE uH uM
open function filter finite_dimensional set
open_locale topological_space manifold classical filter big_operators
noncomputable theory
variables {Œπ : Type uŒπ}
{E : Type uE} [normed_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E]
{H : Type uH} [topological_space H] (I : model_with_corners ‚Ñù E H)
{M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]
variables (Œπ M)
@[nolint has_inhabited_instance]
structure smooth_bump_covering (s : set M := univ) :=
(c : Œπ ‚Üí M)
(to_fun : Œ† i, smooth_bump_function I (c i))
(c_mem' : ‚àÄ i, c i ‚àà s)
(locally_finite' : locally_finite (Œª i, support (to_fun i)))
(eventually_eq_one' : ‚àÄ x ‚àà s, ‚àÉ i, to_fun i =·∂†[ùìù x] 1)
structure smooth_partition_of_unity (s : set M := univ) :=
(to_fun : Œπ ‚Üí C^‚àû‚üÆI, M; ùìò(‚Ñù), ‚Ñù‚üØ)
(locally_finite' : locally_finite (Œª i, support (to_fun i)))
(nonneg' : ‚àÄ i x, 0 ‚â§ to_fun i x)
(sum_eq_one' : ‚àÄ x ‚àà s, ‚àë·∂† i, to_fun i x = 1)
(sum_le_one' : ‚àÄ x, ‚àë·∂† i, to_fun i x ‚â§ 1)
variables {Œπ I M}
namespace smooth_partition_of_unity
variables {s : set M} (f : smooth_partition_of_unity Œπ I M s)
instance {s : set M} : has_coe_to_fun (smooth_partition_of_unity Œπ I M s)
  (Œª _, Œπ ‚Üí C^‚àû‚üÆI, M; ùìò(‚Ñù), ‚Ñù‚üØ) :=
‚ü®smooth_partition_of_unity.to_fun‚ü©
protected lemma locally_finite : locally_finite (Œª i, support (f i)) :=
f.locally_finite'
lemma nonneg (i : Œπ) (x : M) : 0 ‚â§ f i x := f.nonneg' i x
lemma sum_eq_one {x} (hx : x ‚àà s) : ‚àë·∂† i, f i x = 1 := f.sum_eq_one' x hx
lemma sum_le_one (x : M) : ‚àë·∂† i, f i x ‚â§ 1 := f.sum_le_one' x
def to_partition_of_unity : partition_of_unity Œπ M s :=
{ to_fun := Œª i, f i, .. f }
lemma smooth_sum : smooth I ùìò(‚Ñù) (Œª x, ‚àë·∂† i, f i x) :=
smooth_finsum (Œª i, (f i).smooth) f.locally_finite
lemma le_one (i : Œπ) (x : M) : f i x ‚â§ 1 := f.to_partition_of_unity.le_one i x
lemma sum_nonneg (x : M) : 0 ‚â§ ‚àë·∂† i, f i x := f.to_partition_of_unity.sum_nonneg x
def is_subordinate (f : smooth_partition_of_unity Œπ I M s) (U : Œπ ‚Üí set M) :=
‚àÄ i, tsupport (f i) ‚äÜ U i
@[simp] lemma is_subordinate_to_partition_of_unity {f : smooth_partition_of_unity Œπ I M s}
  {U : Œπ ‚Üí set M} :
  f.to_partition_of_unity.is_subordinate U ‚Üî f.is_subordinate U :=
iff.rfl
alias is_subordinate_to_partition_of_unity ‚Üî _ is_subordinate.to_partition_of_unity
end smooth_partition_of_unity
namespace bump_covering
def to_smooth_partition_of_unity (f : bump_covering Œπ M s) (hf : ‚àÄ i, smooth I ùìò(‚Ñù) (f i)) :
  smooth_partition_of_unity Œπ I M s :=
{ to_fun := Œª i, ‚ü®f.to_partition_of_unity i, f.smooth_to_partition_of_unity hf i‚ü©,
  .. f.to_partition_of_unity }
@[simp] lemma to_smooth_partition_of_unity_to_partition_of_unity (f : bump_covering Œπ M s)
  (hf : ‚àÄ i, smooth I ùìò(‚Ñù) (f i)) :
  (f.to_smooth_partition_of_unity hf).to_partition_of_unity = f.to_partition_of_unity :=
rfl
@[simp] lemma coe_to_smooth_partition_of_unity (f : bump_covering Œπ M s)
  (hf : ‚àÄ i, smooth I ùìò(‚Ñù) (f i)) (i : Œπ) :
  ‚áë(f.to_smooth_partition_of_unity hf i) = f.to_partition_of_unity i :=
rfl
lemma is_subordinate.to_smooth_partition_of_unity {f : bump_covering Œπ M s}
  {U : Œπ ‚Üí set M} (h : f.is_subordinate U) (hf : ‚àÄ i, smooth I ùìò(‚Ñù) (f i)) :
  (f.to_smooth_partition_of_unity hf).is_subordinate U :=
h.to_partition_of_unity
end bump_covering
namespace smooth_bump_covering
variables {s : set M} {U : M ‚Üí set M} (fs : smooth_bump_covering Œπ I M s) {I}
instance : has_coe_to_fun (smooth_bump_covering Œπ I M s)
  (Œª x, Œ† (i : Œπ), smooth_bump_function I (x.c i)) :=
‚ü®to_fun‚ü©
@[simp] lemma coe_mk (c : Œπ ‚Üí M) (to_fun : Œ† i, smooth_bump_function I (c i))
  (h‚ÇÅ h‚ÇÇ h‚ÇÉ) : ‚áë(mk c to_fun h‚ÇÅ h‚ÇÇ h‚ÇÉ : smooth_bump_covering Œπ I M s) = to_fun :=
rfl
def is_subordinate {s : set M} (f : smooth_bump_covering Œπ I M s) (U : M ‚Üí set M) :=
‚àÄ i, tsupport (f i) ‚äÜ U (f.c i)
lemma is_subordinate.support_subset {fs : smooth_bump_covering Œπ I M s} {U : M ‚Üí set M}
  (h : fs.is_subordinate U) (i : Œπ) :
  support (fs i) ‚äÜ U (fs.c i) :=
subset.trans subset_closure (h i)
variable (I)
lemma exists_is_subordinate [t2_space M] [sigma_compact_space M] (hs : is_closed s)
  (hU : ‚àÄ x ‚àà s, U x ‚àà ùìù x) :
  ‚àÉ (Œπ : Type uM) (f : smooth_bump_covering Œπ I M s), f.is_subordinate U :=
begin
  rcases exists_subset_Union_closed_subset hs (Œª i, (f i).open_support)
    (Œª x hx, hfin.point_finite x) hsub' with ‚ü®V, hsV, hVc, hVf‚ü©,
  choose r hrR hr using Œª i, (f i).exists_r_pos_lt_subset_ball (hVc i) (hVf i),
  refine ‚ü®Œπ, ‚ü®c, Œª i, (f i).update_r (r i) (hrR i), hcs, _, Œª x hx, _‚ü©, Œª i, _‚ü©,
  { simpa only [smooth_bump_function.support_update_r] },
  { refine (mem_Union.1 $ hsV hx).imp (Œª i hi, _),
    exact ((f i).update_r _ _).eventually_eq_one_of_dist_lt
      ((f i).support_subset_source $ hVf _ hi) (hr i hi).2 },
  { simpa only [coe_mk, smooth_bump_function.support_update_r, tsupport] using hfU i }
end
variables {I M}
protected lemma locally_finite : locally_finite (Œª i, support (fs i)) := fs.locally_finite'
protected lemma point_finite (x : M) : {i | fs i x ‚â† 0}.finite :=
fs.locally_finite.point_finite x
lemma mem_chart_at_source_of_eq_one {i : Œπ} {x : M} (h : fs i x = 1) :
  x ‚àà (chart_at H (fs.c i)).source :=
(fs i).support_subset_source $ by simp [h]
lemma mem_ext_chart_at_source_of_eq_one {i : Œπ} {x : M} (h : fs i x = 1) :
  x ‚àà (ext_chart_at I (fs.c i)).source :=
by { rw ext_chart_at_source, exact fs.mem_chart_at_source_of_eq_one h }
def ind (x : M) (hx : x ‚àà s) : Œπ := (fs.eventually_eq_one' x hx).some
lemma eventually_eq_one (x : M) (hx : x ‚àà s) : fs (fs.ind x hx) =·∂†[ùìù x] 1 :=
(fs.eventually_eq_one' x hx).some_spec
lemma apply_ind (x : M) (hx : x ‚àà s) : fs (fs.ind x hx) x = 1 :=
(fs.eventually_eq_one x hx).eq_of_nhds
lemma mem_support_ind (x : M) (hx : x ‚àà s) : x ‚àà support (fs $ fs.ind x hx) :=
by simp [fs.apply_ind x hx]
lemma mem_chart_at_ind_source (x : M) (hx : x ‚àà s) :
  x ‚àà (chart_at H (fs.c (fs.ind x hx))).source :=
fs.mem_chart_at_source_of_eq_one (fs.apply_ind x hx)
lemma mem_ext_chart_at_ind_source (x : M) (hx : x ‚àà s) :
  x ‚àà (ext_chart_at I (fs.c (fs.ind x hx))).source :=
fs.mem_ext_chart_at_source_of_eq_one (fs.apply_ind x hx)
protected def fintype [compact_space M] : fintype Œπ :=
fs.locally_finite.fintype_of_compact $ Œª i, (fs i).nonempty_support
variable [t2_space M]
def to_bump_covering : bump_covering Œπ M s :=
{ to_fun := Œª i, ‚ü®fs i, (fs i).continuous‚ü©,
  locally_finite' := fs.locally_finite,
  nonneg' := Œª i x, (fs i).nonneg,
  le_one' := Œª i x, (fs i).le_one,
  eventually_eq_one' := fs.eventually_eq_one' }
@[simp] lemma is_subordinate_to_bump_covering {f : smooth_bump_covering Œπ I M s} {U : M ‚Üí set M} :
  f.to_bump_covering.is_subordinate (Œª i, U (f.c i)) ‚Üî f.is_subordinate U :=
iff.rfl
alias is_subordinate_to_bump_covering ‚Üî _ is_subordinate.to_bump_covering
def to_smooth_partition_of_unity : smooth_partition_of_unity Œπ I M s :=
fs.to_bump_covering.to_smooth_partition_of_unity (Œª i, (fs i).smooth)
lemma to_smooth_partition_of_unity_apply (i : Œπ) (x : M) :
  fs.to_smooth_partition_of_unity i x = fs i x * ‚àè·∂† j (hj : well_ordering_rel j i), (1 - fs j x) :=
rfl
lemma to_smooth_partition_of_unity_eq_mul_prod (i : Œπ) (x : M) (t : finset Œπ)
  (ht : ‚àÄ j, well_ordering_rel j i ‚Üí fs j x ‚â† 0 ‚Üí j ‚àà t) :
  fs.to_smooth_partition_of_unity i x =
    fs i x * ‚àè j in t.filter (Œª j, well_ordering_rel j i), (1 - fs j x) :=
fs.to_bump_covering.to_partition_of_unity_eq_mul_prod i x t ht
lemma exists_finset_to_smooth_partition_of_unity_eventually_eq (i : Œπ) (x : M) :
  ‚àÉ t : finset Œπ, fs.to_smooth_partition_of_unity i =·∂†[ùìù x]
    fs i * ‚àè j in t.filter (Œª j, well_ordering_rel j i), (1 - fs j) :=
fs.to_bump_covering.exists_finset_to_partition_of_unity_eventually_eq i x
lemma to_smooth_partition_of_unity_zero_of_zero {i : Œπ} {x : M} (h : fs i x = 0) :
  fs.to_smooth_partition_of_unity i x = 0 :=
fs.to_bump_covering.to_partition_of_unity_zero_of_zero h
lemma support_to_smooth_partition_of_unity_subset (i : Œπ) :
  support (fs.to_smooth_partition_of_unity i) ‚äÜ support (fs i) :=
fs.to_bump_covering.support_to_partition_of_unity_subset i
lemma is_subordinate.to_smooth_partition_of_unity {f : smooth_bump_covering Œπ I M s} {U : M ‚Üí set M}
  (h : f.is_subordinate U) :
  f.to_smooth_partition_of_unity.is_subordinate (Œª i, U (f.c i)) :=
h.to_bump_covering.to_partition_of_unity
lemma sum_to_smooth_partition_of_unity_eq (x : M) :
  ‚àë·∂† i, fs.to_smooth_partition_of_unity i x = 1 - ‚àè·∂† i, (1 - fs i x) :=
fs.to_bump_covering.sum_to_partition_of_unity_eq x
end smooth_bump_covering
variable (I)
lemma exists_smooth_zero_one_of_closed [t2_space M] [sigma_compact_space M] {s t : set M}
  (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :
  ‚àÉ f : C^‚àû‚üÆI, M; ùìò(‚Ñù), ‚Ñù‚üØ, eq_on f 0 s ‚àß eq_on f 1 t ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 :=
begin
  have : ‚àÄ x ‚àà t, s·∂ú ‚àà ùìù x, from Œª x hx, hs.is_open_compl.mem_nhds (disjoint_right.1 hd hx),
  rcases smooth_bump_covering.exists_is_subordinate I ht this with ‚ü®Œπ, f, hf‚ü©,
  set g := f.to_smooth_partition_of_unity,
  refine ‚ü®‚ü®_, g.smooth_sum‚ü©, Œª x hx, _, Œª x, g.sum_eq_one, Œª x, ‚ü®g.sum_nonneg x, g.sum_le_one x‚ü©‚ü©,
  suffices : ‚àÄ i, g i x = 0,
    by simp only [this, cont_mdiff_map.coe_fn_mk, finsum_zero, pi.zero_apply],
  refine Œª i, f.to_smooth_partition_of_unity_zero_of_zero _,
  exact nmem_support.1 (subset_compl_comm.1 (hf.support_subset i) hx)
end
variable {I}
namespace smooth_partition_of_unity
def single (i : Œπ) (s : set M) : smooth_partition_of_unity Œπ I M s :=
(bump_covering.single i s).to_smooth_partition_of_unity $ Œª j,
  begin
    rcases eq_or_ne j i with rfl|h,
    { simp only [smooth_one, continuous_map.coe_one, bump_covering.coe_single, pi.single_eq_same] },
    { simp only [smooth_zero, bump_covering.coe_single, pi.single_eq_of_ne h,
        continuous_map.coe_zero] }
  end
instance [inhabited Œπ] (s : set M) : inhabited (smooth_partition_of_unity Œπ I M s) :=
‚ü®single default s‚ü©
variables [t2_space M] [sigma_compact_space M]
lemma exists_is_subordinate {s : set M} (hs : is_closed s) (U : Œπ ‚Üí set M) (ho : ‚àÄ i, is_open (U i))
  (hU : s ‚äÜ ‚ãÉ i, U i) :
  ‚àÉ f : smooth_partition_of_unity Œπ I M s, f.is_subordinate U :=
begin
  haveI : locally_compact_space H := I.locally_compact,
  haveI : locally_compact_space M := charted_space.locally_compact H M,
  haveI : normal_space M := normal_of_paracompact_t2,
  rcases bump_covering.exists_is_subordinate_of_prop (smooth I ùìò(‚Ñù)) _ hs U ho hU
    with ‚ü®f, hf, hfU‚ü©,
  { exact ‚ü®f.to_smooth_partition_of_unity hf, hfU.to_smooth_partition_of_unity hf‚ü© },
  { intros s t hs ht hd,
    rcases exists_smooth_zero_one_of_closed I hs ht hd with ‚ü®f, hf‚ü©,
    exact ‚ü®f, f.smooth, hf‚ü© }
end
end smooth_partition_of_unity
