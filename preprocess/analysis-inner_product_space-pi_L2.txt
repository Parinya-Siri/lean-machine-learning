import analysis.inner_product_space.projection
import analysis.normed_space.pi_Lp
open real set filter is_R_or_C
open_locale big_operators uniformity topological_space nnreal ennreal complex_conjugate direct_sum
noncomputable theory
variables {Î¹ : Type*} {Î¹' : Type*}
variables {ğ•œ : Type*} [is_R_or_C ğ•œ] {E : Type*} [inner_product_space ğ•œ E]
variables {E' : Type*} [inner_product_space ğ•œ E']
variables {F : Type*} [inner_product_space â„ F]
variables {F' : Type*} [inner_product_space â„ F']
local notation `âŸª`x`, `y`âŸ«` := @inner ğ•œ _ _ x y
instance pi_Lp.inner_product_space {Î¹ : Type*} [fintype Î¹] (f : Î¹ â†’ Type*)
  [Î  i, inner_product_space ğ•œ (f i)] : inner_product_space ğ•œ (pi_Lp 2 f) :=
{ inner := Î» x y, âˆ‘ i, inner (x i) (y i),
  norm_sq_eq_inner :=
  begin
    intro x,
    have hâ‚‚ : 0 â‰¤ âˆ‘ (i : Î¹), âˆ¥x iâˆ¥ ^ (2 : â„) :=
      finset.sum_nonneg (Î» j hj, rpow_nonneg_of_nonneg (norm_nonneg (x j)) 2),
    simp only [norm, add_monoid_hom.map_sum, â† norm_sq_eq_inner, one_div],
    rw [â† rpow_nat_cast ((âˆ‘ (i : Î¹), âˆ¥x iâˆ¥ ^ (2 : â„)) ^ (2 : â„)â»Â¹) 2, â† rpow_mul hâ‚‚],
    norm_num,
  end,
  conj_sym :=
  begin
    intros x y,
    unfold inner,
    rw ring_hom.map_sum,
    apply finset.sum_congr rfl,
    rintros z -,
    apply inner_conj_sym,
  end,
  add_left := Î» x y z,
    show âˆ‘ i, inner (x i + y i) (z i) = âˆ‘ i, inner (x i) (z i) + âˆ‘ i, inner (y i) (z i),
    by simp only [inner_add_left, finset.sum_add_distrib],
  smul_left := Î» x y r,
    show âˆ‘ (i : Î¹), inner (r â€¢ x i) (y i) = (conj r) * âˆ‘ i, inner (x i) (y i),
    by simp only [finset.mul_sum, inner_smul_left] }
@[simp] lemma pi_Lp.inner_apply {Î¹ : Type*} [fintype Î¹] {f : Î¹ â†’ Type*}
  [Î  i, inner_product_space ğ•œ (f i)] (x y : pi_Lp 2 f) :
  âŸªx, yâŸ« = âˆ‘ i, âŸªx i, y iâŸ« :=
rfl
@[reducible, nolint unused_arguments]
def euclidean_space (ğ•œ : Type*) [is_R_or_C ğ•œ]
  (n : Type*) [fintype n] : Type* := pi_Lp 2 (Î» (i : n), ğ•œ)
lemma euclidean_space.norm_eq {ğ•œ : Type*} [is_R_or_C ğ•œ] {n : Type*} [fintype n]
  (x : euclidean_space ğ•œ n) : âˆ¥xâˆ¥ = real.sqrt (âˆ‘ i, âˆ¥x iâˆ¥ ^ 2) :=
pi_Lp.norm_eq_of_L2 x
lemma euclidean_space.nnnorm_eq {ğ•œ : Type*} [is_R_or_C ğ•œ] {n : Type*} [fintype n]
  (x : euclidean_space ğ•œ n) : âˆ¥xâˆ¥â‚Š = nnreal.sqrt (âˆ‘ i, âˆ¥x iâˆ¥â‚Š ^ 2) :=
pi_Lp.nnnorm_eq_of_L2 x
lemma euclidean_space.dist_eq {ğ•œ : Type*} [is_R_or_C ğ•œ] {n : Type*} [fintype n]
  (x y : euclidean_space ğ•œ n) : dist x y = (âˆ‘ i, dist (x i) (y i) ^ 2).sqrt :=
(pi_Lp.dist_eq_of_L2 x y : _)
lemma euclidean_space.nndist_eq {ğ•œ : Type*} [is_R_or_C ğ•œ] {n : Type*} [fintype n]
  (x y : euclidean_space ğ•œ n) : nndist x y = (âˆ‘ i, nndist (x i) (y i) ^ 2).sqrt :=
(pi_Lp.nndist_eq_of_L2 x y : _)
lemma euclidean_space.edist_eq {ğ•œ : Type*} [is_R_or_C ğ•œ] {n : Type*} [fintype n]
  (x y : euclidean_space ğ•œ n) : edist x y = (âˆ‘ i, edist (x i) (y i) ^ 2) ^ (1 / 2 : â„) :=
(pi_Lp.edist_eq_of_L2 x y : _)
variables [fintype Î¹]
section
local attribute [reducible] pi_Lp
instance : finite_dimensional ğ•œ (euclidean_space ğ•œ Î¹) := by apply_instance
instance : inner_product_space ğ•œ (euclidean_space ğ•œ Î¹) := by apply_instance
@[simp] lemma finrank_euclidean_space :
  finite_dimensional.finrank ğ•œ (euclidean_space ğ•œ Î¹) = fintype.card Î¹ := by simp
lemma finrank_euclidean_space_fin {n : â„•} :
  finite_dimensional.finrank ğ•œ (euclidean_space ğ•œ (fin n)) = n := by simp
lemma euclidean_space.inner_eq_star_dot_product (x y : euclidean_space ğ•œ Î¹) :
  âŸªx, yâŸ« = matrix.dot_product (star $ pi_Lp.equiv _ _ x) (pi_Lp.equiv _ _ y) := rfl
def direct_sum.is_internal.isometry_L2_of_orthogonal_family
  [decidable_eq Î¹] {V : Î¹ â†’ submodule ğ•œ E} (hV : direct_sum.is_internal V)
  (hV' : @orthogonal_family ğ•œ _ _ _ _ (Î» i, V i) _ (Î» i, (V i).subtypeâ‚—áµ¢)) :
  E â‰ƒâ‚—áµ¢[ğ•œ] pi_Lp 2 (Î» i, V i) :=
begin
  let eâ‚ := direct_sum.linear_equiv_fun_on_fintype ğ•œ Î¹ (Î» i, V i),
  let eâ‚‚ := linear_equiv.of_bijective (direct_sum.coe_linear_map V) hV.injective hV.surjective,
  refine (eâ‚‚.symm.trans eâ‚).isometry_of_inner _,
  suffices : âˆ€ v w, âŸªv, wâŸ« = âŸªeâ‚‚ (eâ‚.symm v), eâ‚‚ (eâ‚.symm w)âŸ«,
  { intros vâ‚€ wâ‚€,
    convert this (eâ‚ (eâ‚‚.symm vâ‚€)) (eâ‚ (eâ‚‚.symm wâ‚€));
    simp only [linear_equiv.symm_apply_apply, linear_equiv.apply_symm_apply] },
  intros v w,
  transitivity âŸª(âˆ‘ i, (V i).subtypeâ‚—áµ¢ (v i)), âˆ‘ i, (V i).subtypeâ‚—áµ¢ (w i)âŸ«,
  { simp only [sum_inner, hV'.inner_right_fintype, pi_Lp.inner_apply] },
  { congr; simp }
end
@[simp] lemma direct_sum.is_internal.isometry_L2_of_orthogonal_family_symm_apply
  [decidable_eq Î¹] {V : Î¹ â†’ submodule ğ•œ E} (hV : direct_sum.is_internal V)
  (hV' : @orthogonal_family ğ•œ _ _ _ _ (Î» i, V i) _ (Î» i, (V i).subtypeâ‚—áµ¢))
  (w : pi_Lp 2 (Î» i, V i)) :
  (hV.isometry_L2_of_orthogonal_family hV').symm w = âˆ‘ i, (w i : E) :=
begin
  classical,
  let eâ‚ := direct_sum.linear_equiv_fun_on_fintype ğ•œ Î¹ (Î» i, V i),
  let eâ‚‚ := linear_equiv.of_bijective (direct_sum.coe_linear_map V) hV.injective hV.surjective,
  suffices : âˆ€ v : â¨ i, V i, eâ‚‚ v = âˆ‘ i, eâ‚ v i,
  { exact this (eâ‚.symm w) },
  intros v,
  simp [eâ‚‚, direct_sum.coe_linear_map, direct_sum.to_module, dfinsupp.sum_add_hom_apply]
end
end
def euclidean_space.single [decidable_eq Î¹] (i : Î¹) (a : ğ•œ) :
  euclidean_space ğ•œ Î¹ :=
(pi_Lp.equiv _ _).symm (pi.single i a)
@[simp] lemma pi_Lp.equiv_single [decidable_eq Î¹] (i : Î¹) (a : ğ•œ) :
  pi_Lp.equiv _ _ (euclidean_space.single i a) = pi.single i a := rfl
@[simp] lemma pi_Lp.equiv_symm_single [decidable_eq Î¹] (i : Î¹) (a : ğ•œ) :
  (pi_Lp.equiv _ _).symm (pi.single i a) = euclidean_space.single i a := rfl
@[simp] theorem euclidean_space.single_apply [decidable_eq Î¹] (i : Î¹) (a : ğ•œ) (j : Î¹) :
  (euclidean_space.single i a) j = ite (j = i) a 0 :=
by { rw [euclidean_space.single, pi_Lp.equiv_symm_apply, â† pi.single_apply i a j] }
lemma euclidean_space.inner_single_left [decidable_eq Î¹] (i : Î¹) (a : ğ•œ) (v : euclidean_space ğ•œ Î¹) :
  âŸªeuclidean_space.single i (a : ğ•œ), vâŸ« = conj a * (v i) :=
by simp [apply_ite conj]
lemma euclidean_space.inner_single_right [decidable_eq Î¹] (i : Î¹) (a : ğ•œ)
  (v : euclidean_space ğ•œ Î¹) :
  âŸªv, euclidean_space.single i (a : ğ•œ)âŸ« =  a * conj (v i) :=
by simp [apply_ite conj, mul_comm]
variables (Î¹ ğ•œ E)
structure orthonormal_basis := of_repr :: (repr : E â‰ƒâ‚—áµ¢[ğ•œ] euclidean_space ğ•œ Î¹)
variables {Î¹ ğ•œ E}
namespace orthonormal_basis
instance : inhabited (orthonormal_basis Î¹ ğ•œ (euclidean_space ğ•œ Î¹)) :=
âŸ¨of_repr (linear_isometry_equiv.refl ğ•œ (euclidean_space ğ•œ Î¹))âŸ©
instance : has_coe_to_fun (orthonormal_basis Î¹ ğ•œ E) (Î» _, Î¹ â†’ E) :=
{ coe := Î» b i, by classical; exact b.repr.symm (euclidean_space.single i (1 : ğ•œ)) }
@[simp] protected lemma repr_symm_single [decidable_eq Î¹] (b : orthonormal_basis Î¹ ğ•œ E) (i : Î¹) :
  b.repr.symm (euclidean_space.single i (1:ğ•œ)) = b i :=
by { classical, congr, simp, }
@[simp] protected lemma repr_self [decidable_eq Î¹] (b : orthonormal_basis Î¹ ğ•œ E) (i : Î¹) :
  b.repr (b i) = euclidean_space.single i (1:ğ•œ) :=
by rw [â† b.repr_symm_single i, linear_isometry_equiv.apply_symm_apply]
protected lemma repr_apply_apply (b : orthonormal_basis Î¹ ğ•œ E) (v : E) (i : Î¹) :
  b.repr v i = âŸªb i, vâŸ« :=
begin
  classical,
  rw [â† b.repr.inner_map_map (b i) v, b.repr_self i, euclidean_space.inner_single_left],
  simp only [one_mul, eq_self_iff_true, map_one],
end
@[simp]
protected lemma orthonormal (b : orthonormal_basis Î¹ ğ•œ E) : orthonormal ğ•œ b :=
begin
  classical,
  rw orthonormal_iff_ite,
  intros i j,
  rw [â† b.repr.inner_map_map (b i) (b j), b.repr_self i, b.repr_self j],
  rw euclidean_space.inner_single_left,
  rw euclidean_space.single_apply,
  simp only [mul_boole, map_one],
end
protected def to_basis (b : orthonormal_basis Î¹ ğ•œ E) : basis Î¹ ğ•œ E :=
basis.of_equiv_fun b.repr.to_linear_equiv
@[simp] protected lemma coe_to_basis (b : orthonormal_basis Î¹ ğ•œ E) :
  (â‡‘b.to_basis : Î¹ â†’ E) = â‡‘b :=
begin
  change â‡‘(basis.of_equiv_fun b.repr.to_linear_equiv) = b,
  ext j,
  rw basis.coe_of_equiv_fun,
  simp only [orthonormal_basis.repr_symm_single],
  congr,
end
@[simp] protected lemma coe_to_basis_repr (b : orthonormal_basis Î¹ ğ•œ E) :
  b.to_basis.equiv_fun = b.repr.to_linear_equiv :=
begin
  change (basis.of_equiv_fun b.repr.to_linear_equiv).equiv_fun = b.repr.to_linear_equiv,
  ext x j,
  simp only [basis.of_equiv_fun_repr_apply, eq_self_iff_true,
    linear_isometry_equiv.coe_to_linear_equiv, basis.equiv_fun_apply],
end
protected lemma sum_repr_symm (b : orthonormal_basis Î¹ ğ•œ E) (v : euclidean_space ğ•œ Î¹) :
  âˆ‘ i , v i â€¢ b i = (b.repr.symm v) :=
by { classical, simpa using (b.to_basis.equiv_fun_symm_apply v).symm }
variable {v : Î¹ â†’ E}
def _root_.basis.to_orthonormal_basis (v : basis Î¹ ğ•œ E) (hv : orthonormal ğ•œ v) :
  orthonormal_basis Î¹ ğ•œ E :=
orthonormal_basis.of_repr $
linear_equiv.isometry_of_inner v.equiv_fun
begin
  intros x y,
  let p : euclidean_space ğ•œ Î¹ := v.equiv_fun x,
  let q : euclidean_space ğ•œ Î¹ := v.equiv_fun y,
  have key : âŸªp, qâŸ« = âŸªâˆ‘ i, p i â€¢ v i, âˆ‘ i, q i â€¢ v iâŸ«,
  { simp [sum_inner, inner_smul_left, hv.inner_right_fintype] },
  convert key,
  { rw [â† v.equiv_fun.symm_apply_apply x, v.equiv_fun_symm_apply] },
  { rw [â† v.equiv_fun.symm_apply_apply y, v.equiv_fun_symm_apply] }
end
@[simp] lemma _root_.basis.coe_to_orthonormal_basis_repr (v : basis Î¹ ğ•œ E) (hv : orthonormal ğ•œ v) :
  ((v.to_orthonormal_basis hv).repr : E â†’ euclidean_space ğ•œ Î¹) = v.equiv_fun :=
rfl
@[simp] lemma _root_.basis.coe_to_orthonormal_basis_repr_symm
  (v : basis Î¹ ğ•œ E) (hv : orthonormal ğ•œ v) :
  ((v.to_orthonormal_basis hv).repr.symm : euclidean_space ğ•œ Î¹ â†’ E) = v.equiv_fun.symm :=
rfl
@[simp] lemma _root_.basis.to_basis_to_orthonormal_basis (v : basis Î¹ ğ•œ E) (hv : orthonormal ğ•œ v) :
  (v.to_orthonormal_basis hv).to_basis = v :=
by simp [basis.to_orthonormal_basis, orthonormal_basis.to_basis]
@[simp] lemma _root_.basis.coe_to_orthonormal_basis (v : basis Î¹ ğ•œ E) (hv : orthonormal ğ•œ v) :
  (v.to_orthonormal_basis hv : Î¹ â†’ E) = (v : Î¹ â†’ E) :=
calc (v.to_orthonormal_basis hv : Î¹ â†’ E) = ((v.to_orthonormal_basis hv).to_basis : Î¹ â†’ E) :
  by { classical, rw orthonormal_basis.coe_to_basis }
... = (v : Î¹ â†’ E) : by simp
protected def mk (hon : orthonormal ğ•œ v) (hsp: submodule.span ğ•œ (set.range v) = âŠ¤):
  orthonormal_basis Î¹ ğ•œ E :=
(basis.mk (orthonormal.linear_independent hon) hsp).to_orthonormal_basis (by rwa basis.coe_mk)
@[simp]
protected lemma coe_mk (hon : orthonormal ğ•œ v) (hsp: submodule.span ğ•œ (set.range v) = âŠ¤) :
  â‡‘(orthonormal_basis.mk hon hsp) = v :=
by classical; rw [orthonormal_basis.mk, _root_.basis.coe_to_orthonormal_basis, basis.coe_mk]
end orthonormal_basis
@[simp] lemma basis.map_isometry_euclidean_of_orthonormal (v : basis Î¹ ğ•œ E) (hv : orthonormal ğ•œ v)
  (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') :
  ((v.map f.to_linear_equiv).to_orthonormal_basis (hv.map_linear_isometry_equiv f)).repr =
    f.symm.trans (v.to_orthonormal_basis hv).repr :=
linear_isometry_equiv.to_linear_equiv_injective $ v.map_equiv_fun _
def complex.isometry_euclidean : â„‚ â‰ƒâ‚—áµ¢[â„] (euclidean_space â„ (fin 2)) :=
(complex.basis_one_I.to_orthonormal_basis
begin
  rw orthonormal_iff_ite,
  intros i, fin_cases i;
  intros j; fin_cases j;
  simp [real_inner_eq_re_inner]
end).repr
@[simp] lemma complex.isometry_euclidean_symm_apply (x : euclidean_space â„ (fin 2)) :
  complex.isometry_euclidean.symm x = (x 0) + (x 1) * I :=
begin
  convert complex.basis_one_I.equiv_fun_symm_apply x,
  { simpa },
  { simp },
end
lemma complex.isometry_euclidean_proj_eq_self (z : â„‚) :
  â†‘(complex.isometry_euclidean z 0) + â†‘(complex.isometry_euclidean z 1) * (I : â„‚) = z :=
by rw [â† complex.isometry_euclidean_symm_apply (complex.isometry_euclidean z),
  complex.isometry_euclidean.symm_apply_apply z]
@[simp] lemma complex.isometry_euclidean_apply_zero (z : â„‚) :
  complex.isometry_euclidean z 0 = z.re :=
by { conv_rhs { rw â† complex.isometry_euclidean_proj_eq_self z }, simp }
@[simp] lemma complex.isometry_euclidean_apply_one (z : â„‚) :
  complex.isometry_euclidean z 1 = z.im :=
by { conv_rhs { rw â† complex.isometry_euclidean_proj_eq_self z }, simp }
def complex.isometry_of_orthonormal {v : basis (fin 2) â„ F} (hv : orthonormal â„ v) : â„‚ â‰ƒâ‚—áµ¢[â„] F :=
complex.isometry_euclidean.trans (v.to_orthonormal_basis hv).repr.symm
@[simp] lemma complex.map_isometry_of_orthonormal {v : basis (fin 2) â„ F} (hv : orthonormal â„ v)
  (f : F â‰ƒâ‚—áµ¢[â„] F') :
  complex.isometry_of_orthonormal (hv.map_linear_isometry_equiv f) =
    (complex.isometry_of_orthonormal hv).trans f :=
by simp [complex.isometry_of_orthonormal, linear_isometry_equiv.trans_assoc]
lemma complex.isometry_of_orthonormal_symm_apply
  {v : basis (fin 2) â„ F} (hv : orthonormal â„ v) (f : F) :
  (complex.isometry_of_orthonormal hv).symm f = (v.coord 0 f : â„‚) + (v.coord 1 f : â„‚) * I :=
by simp [complex.isometry_of_orthonormal]
lemma complex.isometry_of_orthonormal_apply
  {v : basis (fin 2) â„ F} (hv : orthonormal â„ v) (z : â„‚) :
  complex.isometry_of_orthonormal hv z = z.re â€¢ v 0 + z.im â€¢ v 1 :=
by simp [complex.isometry_of_orthonormal, (dec_trivial : (finset.univ : finset (fin 2)) = {0, 1})]
open finite_dimensional
def linear_isometry_equiv.of_inner_product_space
  [finite_dimensional ğ•œ E] {n : â„•} (hn : finrank ğ•œ E = n) :
  E â‰ƒâ‚—áµ¢[ğ•œ] (euclidean_space ğ•œ (fin n)) :=
((fin_std_orthonormal_basis hn).to_orthonormal_basis
  (fin_std_orthonormal_basis_orthonormal hn)).repr
local attribute [instance] fact_finite_dimensional_of_finrank_eq_succ
def linear_isometry_equiv.from_orthogonal_span_singleton
  (n : â„•) [fact (finrank ğ•œ E = n + 1)] {v : E} (hv : v â‰  0) :
  (ğ•œ âˆ™ v)á—® â‰ƒâ‚—áµ¢[ğ•œ] (euclidean_space ğ•œ (fin n)) :=
linear_isometry_equiv.of_inner_product_space (finrank_orthogonal_span_singleton hv)
section linear_isometry
variables {V : Type*} [inner_product_space ğ•œ V] [finite_dimensional ğ•œ V]
variables {S : submodule ğ•œ V} {L : S â†’â‚—áµ¢[ğ•œ] V}
open finite_dimensional
noncomputable def linear_isometry.extend (L : S â†’â‚—áµ¢[ğ•œ] V): V â†’â‚—áµ¢[ğ•œ] V :=
begin
lemma inner_matrix_row_row (A B : matrix (fin n) (fin m) ğ•œ) (i j : (fin n)) :
  âŸªA i, B jâŸ«â‚˜ = (B â¬ Aá´´) j i := by {simp only [inner, matrix.mul_apply, star_ring_end_apply,
    matrix.conj_transpose_apply,mul_comm]}
lemma inner_matrix_col_col (A B : matrix (fin n) (fin m) ğ•œ) (i j : (fin m)) :
  âŸªAáµ€ i, Báµ€ jâŸ«â‚™ = (Aá´´ â¬ B) i j := rfl
end matrix
