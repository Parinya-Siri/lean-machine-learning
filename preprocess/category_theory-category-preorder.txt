import category_theory.adjunction.basic
import order.galois_connection
universes u v
namespace preorder
open category_theory
def hom_of_le {x y : X} (h : x ‚â§ y) : x ‚ü∂ y := ulift.up (plift.up h)
alias hom_of_le ‚Üê _root_.has_le.le.hom
@[simp] lemma hom_of_le_refl {x : X} : (le_refl x).hom = ùüô x := rfl
@[simp] lemma hom_of_le_comp {x y z : X} (h : x ‚â§ y) (k : y ‚â§ z) :
  h.hom ‚â´ k.hom = (h.trans k).hom := rfl
lemma le_of_hom {x y : X} (h : x ‚ü∂ y) : x ‚â§ y := h.down.down
alias le_of_hom ‚Üê _root_.quiver.hom.le
@[simp] lemma le_of_hom_hom_of_le {x y : X} (h : x ‚â§ y) : h.hom.le = h := rfl
@[simp] lemma hom_of_le_le_of_hom {x y : X} (h : x ‚ü∂ y) : h.le.hom = h :=
by { cases h, cases h, refl, }
def op_hom_of_le {x y : X·µí·µñ} (h : unop x ‚â§ unop y) : y ‚ü∂ x := h.hom.op
lemma le_of_op_hom {x y : X·µí·µñ} (h : x ‚ü∂ y) : unop y ‚â§ unop x := h.unop.le
instance unique_to_top [order_top X] {x : X} : unique (x ‚ü∂ ‚ä§) := by tidy
instance unique_from_bot [order_bot X] {x : X} : unique (‚ä• ‚ü∂ x) := by tidy
end category_theory
section
variables {X : Type u} {Y : Type v} [preorder X] [preorder Y]
def monotone.functor {f : X ‚Üí Y} (h : monotone f) : X ‚•§ Y :=
{ obj := f,
  map := Œª x‚ÇÅ x‚ÇÇ g, (h g.le).hom }
@[simp] lemma monotone.functor_obj {f : X ‚Üí Y} (h : monotone f) : h.functor.obj = f := rfl
def galois_connection.adjunction {l : X ‚Üí Y} {u : Y ‚Üí X} (gc : galois_connection l u) :
  gc.monotone_l.functor ‚ä£ gc.monotone_u.functor :=
category_theory.adjunction.mk_of_hom_equiv
{ hom_equiv := Œª X Y, ‚ü®Œª f, (gc.le_u f.le).hom, Œª f, (gc.l_le f.le).hom, by tidy, by tidy‚ü© }
end
namespace category_theory
section preorder
variables {X : Type u} {Y : Type v} [preorder X] [preorder Y]
@[mono] lemma functor.monotone (f : X ‚•§ Y) : monotone f.obj :=
Œª x y hxy, (f.map hxy.hom).le
lemma adjunction.gc {L : X ‚•§ Y} {R : Y ‚•§ X} (adj : L ‚ä£ R) :
  galois_connection L.obj R.obj :=
Œª x y, ‚ü®Œª h, ((adj.hom_equiv x y).to_fun h.hom).le, Œª h, ((adj.hom_equiv x y).inv_fun h.hom).le‚ü©
end preorder
section partial_order
variables {X : Type u} {Y : Type v} [partial_order X] [partial_order Y]
lemma iso.to_eq {x y : X} (f : x ‚âÖ y) : x = y := le_antisymm f.hom.le f.inv.le
def equivalence.to_order_iso (e : X ‚âå Y) : X ‚âÉo Y :=
{ to_fun := e.functor.obj,
  inv_fun := e.inverse.obj,
  left_inv := Œª a, (e.unit_iso.app a).to_eq.symm,
  right_inv := Œª b, (e.counit_iso.app b).to_eq,
  map_rel_iff' := Œª a a',
    ‚ü®Œª h, ((equivalence.unit e).app a ‚â´ e.inverse.map h.hom ‚â´ (equivalence.unit_inv e).app a').le,
     Œª (h : a ‚â§ a'), (e.functor.map h.hom).le‚ü©, }
