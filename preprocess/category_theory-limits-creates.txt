import category_theory.limits.preserves.basic
open category_theory category_theory.limits
noncomputable theory
namespace category_theory
universes w' w vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ
variables {C : Type uâ‚} [category.{vâ‚} C]
section creates
variables {D : Type uâ‚‚} [category.{vâ‚‚} D]
variables {J : Type w} [category.{w'} J] {K : J â¥¤ C}
structure liftable_cone (K : J â¥¤ C) (F : C â¥¤ D) (c : cone (K â‹™ F)) :=
(lifted_cone : cone K)
(valid_lift : F.map_cone lifted_cone â‰… c)
structure liftable_cocone (K : J â¥¤ C) (F : C â¥¤ D) (c : cocone (K â‹™ F)) :=
(lifted_cocone : cocone K)
(valid_lift : F.map_cocone lifted_cocone â‰… c)
class creates_limit (K : J â¥¤ C) (F : C â¥¤ D) extends reflects_limit K F :=
(lifts : Î  c, is_limit c â†’ liftable_cone K F c)
class creates_limits_of_shape (J : Type w) [category.{w'} J] (F : C â¥¤ D) :=
(creates_limit : Î  {K : J â¥¤ C}, creates_limit K F . tactic.apply_instance)
abbreviation creates_limits (F : C â¥¤ D) := creates_limits_of_size.{vâ‚‚ vâ‚‚} F
class creates_colimit (K : J â¥¤ C) (F : C â¥¤ D) extends reflects_colimit K F :=
(lifts : Î  c, is_colimit c â†’ liftable_cocone K F c)
class creates_colimits_of_shape (J : Type w) [category.{w'} J] (F : C â¥¤ D) :=
(creates_colimit : Î  {K : J â¥¤ C}, creates_colimit K F . tactic.apply_instance)
abbreviation creates_colimits (F : C â¥¤ D) := creates_colimits_of_size.{vâ‚‚ vâ‚‚} F
def lift_limit {K : J â¥¤ C} {F : C â¥¤ D} [creates_limit K F] {c : cone (K â‹™ F)} (t : is_limit c) :
  cone K :=
(creates_limit.lifts c t).lifted_cone
def lifted_limit_maps_to_original {K : J â¥¤ C} {F : C â¥¤ D}
  [creates_limit K F] {c : cone (K â‹™ F)} (t : is_limit c) :
  F.map_cone (lift_limit t) â‰… c :=
(creates_limit.lifts c t).valid_lift
def lifted_limit_is_limit {K : J â¥¤ C} {F : C â¥¤ D}
  [creates_limit K F] {c : cone (K â‹™ F)} (t : is_limit c) :
  is_limit (lift_limit t) :=
reflects_limit.reflects (is_limit.of_iso_limit t (lifted_limit_maps_to_original t).symm)
lemma has_limit_of_created (K : J â¥¤ C) (F : C â¥¤ D)
  [has_limit (K â‹™ F)] [creates_limit K F] : has_limit K :=
has_limit.mk { cone := lift_limit (limit.is_limit (K â‹™ F)),
  is_limit := lifted_limit_is_limit _ }
lemma has_limits_of_shape_of_has_limits_of_shape_creates_limits_of_shape (F : C â¥¤ D)
  [has_limits_of_shape J D] [creates_limits_of_shape J F] : has_limits_of_shape J C :=
âŸ¨Î» G, has_limit_of_created G FâŸ©
lemma has_limits_of_has_limits_creates_limits (F : C â¥¤ D) [has_limits_of_size.{w w'} D]
  [creates_limits_of_size.{w w'} F] : has_limits_of_size.{w w'} C :=
âŸ¨Î» J I, by exactI has_limits_of_shape_of_has_limits_of_shape_creates_limits_of_shape FâŸ©
def lift_colimit {K : J â¥¤ C} {F : C â¥¤ D} [creates_colimit K F] {c : cocone (K â‹™ F)}
  (t : is_colimit c) :
  cocone K :=
(creates_colimit.lifts c t).lifted_cocone
def lifted_colimit_maps_to_original {K : J â¥¤ C} {F : C â¥¤ D}
  [creates_colimit K F] {c : cocone (K â‹™ F)} (t : is_colimit c) :
  F.map_cocone (lift_colimit t) â‰… c :=
(creates_colimit.lifts c t).valid_lift
def lifted_colimit_is_colimit {K : J â¥¤ C} {F : C â¥¤ D}
  [creates_colimit K F] {c : cocone (K â‹™ F)} (t : is_colimit c) :
  is_colimit (lift_colimit t) :=
reflects_colimit.reflects (is_colimit.of_iso_colimit t (lifted_colimit_maps_to_original t).symm)
lemma has_colimit_of_created (K : J â¥¤ C) (F : C â¥¤ D)
  [has_colimit (K â‹™ F)] [creates_colimit K F] : has_colimit K :=
has_colimit.mk { cocone := lift_colimit (colimit.is_colimit (K â‹™ F)),
  is_colimit := lifted_colimit_is_colimit _ }
lemma has_colimits_of_shape_of_has_colimits_of_shape_creates_colimits_of_shape (F : C â¥¤ D)
  [has_colimits_of_shape J D] [creates_colimits_of_shape J F] : has_colimits_of_shape J C :=
âŸ¨Î» G, has_colimit_of_created G FâŸ©
lemma has_colimits_of_has_colimits_creates_colimits (F : C â¥¤ D) [has_colimits_of_size.{w w'} D]
  [creates_colimits_of_size.{w w'} F] : has_colimits_of_size.{w w'} C :=
âŸ¨Î» J I, by exactI has_colimits_of_shape_of_has_colimits_of_shape_creates_colimits_of_shape FâŸ©
@[priority 10] instance reflects_limits_of_shape_of_creates_limits_of_shape (F : C â¥¤ D)
  [creates_limits_of_shape J F] : reflects_limits_of_shape J F := {}
@[priority 10] instance reflects_limits_of_creates_limits (F : C â¥¤ D)
  [creates_limits_of_size.{w w'} F] : reflects_limits_of_size.{w w'} F := {}
@[priority 10] instance reflects_colimits_of_shape_of_creates_colimits_of_shape (F : C â¥¤ D)
  [creates_colimits_of_shape J F] : reflects_colimits_of_shape J F := {}
@[priority 10] instance reflects_colimits_of_creates_colimits (F : C â¥¤ D)
  [creates_colimits_of_size.{w w'} F] : reflects_colimits_of_size.{w w'} F := {}
structure lifts_to_limit (K : J â¥¤ C) (F : C â¥¤ D) (c : cone (K â‹™ F)) (t : is_limit c)
  extends liftable_cone K F c :=
(makes_limit : is_limit lifted_cone)
structure lifts_to_colimit (K : J â¥¤ C) (F : C â¥¤ D) (c : cocone (K â‹™ F)) (t : is_colimit c)
  extends liftable_cocone K F c :=
(makes_colimit : is_colimit lifted_cocone)
def creates_limit_of_reflects_iso {K : J â¥¤ C} {F : C â¥¤ D} [reflects_isomorphisms F]
  (h : Î  c t, lifts_to_limit K F c t) :
  creates_limit K F :=
{ lifts := Î» c t, (h c t).to_liftable_cone,
  to_reflects_limit :=
  { reflects := Î» (d : cone K) (hd : is_limit (F.map_cone d)),
    begin
      let d' : cone K := (h (F.map_cone d) hd).to_liftable_cone.lifted_cone,
      let i : F.map_cone d' â‰… F.map_cone d := (h (F.map_cone d) hd).to_liftable_cone.valid_lift,
      let hd' : is_limit d' := (h (F.map_cone d) hd).makes_limit,
      let f : d âŸ¶ d' := hd'.lift_cone_morphism d,
      have : (cones.functoriality K F).map f = i.inv := (hd.of_iso_limit i.symm).uniq_cone_morphism,
      haveI : is_iso ((cones.functoriality K F).map f) := (by { rw this, apply_instance }),
      haveI : is_iso f := is_iso_of_reflects_iso f (cones.functoriality K F),
      exact is_limit.of_iso_limit hd' (as_iso f).symm,
    end } }
def creates_colimit_of_reflects_iso {K : J â¥¤ C} {F : C â¥¤ D} [reflects_isomorphisms F]
  (h : Î  c t, lifts_to_colimit K F c t) :
  creates_colimit K F :=
{ lifts := Î» c t, (h c t).to_liftable_cocone,
  to_reflects_colimit :=
  { reflects := Î» (d : cocone K) (hd : is_colimit (F.map_cocone d)),
    begin
      let d' : cocone K := (h (F.map_cocone d) hd).to_liftable_cocone.lifted_cocone,
      let i : F.map_cocone d' â‰… F.map_cocone d :=
        (h (F.map_cocone d) hd).to_liftable_cocone.valid_lift,
      let hd' : is_colimit d' := (h (F.map_cocone d) hd).makes_colimit,
      let f : d' âŸ¶ d := hd'.desc_cocone_morphism d,
      have : (cocones.functoriality K F).map f = i.hom :=
        (hd.of_iso_colimit i.symm).uniq_cocone_morphism,
      haveI : is_iso ((cocones.functoriality K F).map f) := (by { rw this, apply_instance }),
      haveI := is_iso_of_reflects_iso f (cocones.functoriality K F),
      exact is_colimit.of_iso_colimit hd' (as_iso f),
    end } }
def creates_limit_of_iso_diagram {Kâ‚ Kâ‚‚ : J â¥¤ C} (F : C â¥¤ D) (h : Kâ‚ â‰… Kâ‚‚)
  [creates_limit Kâ‚ F] : creates_limit Kâ‚‚ F :=
{ lifts := Î» c t,
  let t' := (is_limit.postcompose_inv_equiv (iso_whisker_right h F : _) c).symm t in
  { lifted_cone := (cones.postcompose h.hom).obj (lift_limit t'),
    valid_lift :=
        F.map_cone_postcompose â‰ªâ‰«
        (cones.postcompose (iso_whisker_right h F).hom).map_iso
            (lifted_limit_maps_to_original t') â‰ªâ‰«
        cones.ext (iso.refl _) (Î» j, by { dsimp, rw [category.assoc, â†F.map_comp], simp }) }
  ..reflects_limit_of_iso_diagram F h }
def creates_limit_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [creates_limit K F] :
  creates_limit K G :=
{ lifts := Î» c t,
  { lifted_cone :=
      lift_limit ((is_limit.postcompose_inv_equiv (iso_whisker_left K h : _) c).symm t),
    valid_lift :=
    begin
      refine (is_limit.map_cone_equiv h _).unique_up_to_iso t,
      apply is_limit.of_iso_limit _ ((lifted_limit_maps_to_original _).symm),
      apply (is_limit.postcompose_inv_equiv _ _).symm t,
    end },
  to_reflects_limit := reflects_limit_of_nat_iso _ h }
def creates_limits_of_shape_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [creates_limits_of_shape J F] :
  creates_limits_of_shape J G :=
{ creates_limit := Î» K, creates_limit_of_nat_iso h }
def creates_limits_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [creates_limits_of_size.{w w'} F] :
  creates_limits_of_size.{w w'} G :=
{ creates_limits_of_shape := Î» J ğ’¥â‚, by exactI creates_limits_of_shape_of_nat_iso h }
def creates_colimit_of_iso_diagram {Kâ‚ Kâ‚‚ : J â¥¤ C} (F : C â¥¤ D) (h : Kâ‚ â‰… Kâ‚‚)
  [creates_colimit Kâ‚ F] : creates_colimit Kâ‚‚ F :=
{ lifts := Î» c t,
  let t' := (is_colimit.precompose_hom_equiv (iso_whisker_right h F : _) c).symm t in
  { lifted_cocone := (cocones.precompose h.inv).obj (lift_colimit t'),
    valid_lift :=
        F.map_cocone_precompose â‰ªâ‰«
        (cocones.precompose (iso_whisker_right h F).inv).map_iso
            (lifted_colimit_maps_to_original t') â‰ªâ‰«
        cocones.ext (iso.refl _) (Î» j, by { dsimp, rw â†F.map_comp_assoc, simp }) },
  ..reflects_colimit_of_iso_diagram F h }
def creates_colimit_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [creates_colimit K F] :
  creates_colimit K G :=
{ lifts := Î» c t,
  { lifted_cocone :=
      lift_colimit ((is_colimit.precompose_hom_equiv (iso_whisker_left K h : _) c).symm t),
    valid_lift :=
    begin
      refine (is_colimit.map_cocone_equiv h _).unique_up_to_iso t,
      apply is_colimit.of_iso_colimit _ ((lifted_colimit_maps_to_original _).symm),
      apply (is_colimit.precompose_hom_equiv _ _).symm t,
    end },
  to_reflects_colimit := reflects_colimit_of_nat_iso _ h }
def creates_colimits_of_shape_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G)
  [creates_colimits_of_shape J F] : creates_colimits_of_shape J G :=
{ creates_colimit := Î» K, creates_colimit_of_nat_iso h }
def creates_colimits_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [creates_colimits_of_size.{w w'} F] :
  creates_colimits_of_size.{w w'} G :=
{ creates_colimits_of_shape := Î» J ğ’¥â‚, by exactI creates_colimits_of_shape_of_nat_iso h }
def lifts_to_limit_of_creates (K : J â¥¤ C) (F : C â¥¤ D)
  [creates_limit K F] (c : cone (K â‹™ F)) (t : is_limit c) :
  lifts_to_limit K F c t :=
{ lifted_cone := lift_limit t,
  valid_lift := lifted_limit_maps_to_original t,
  makes_limit := lifted_limit_is_limit t }
def lifts_to_colimit_of_creates (K : J â¥¤ C) (F : C â¥¤ D)
  [creates_colimit K F] (c : cocone (K â‹™ F)) (t : is_colimit c) :
  lifts_to_colimit K F c t :=
{ lifted_cocone := lift_colimit t,
  valid_lift := lifted_colimit_maps_to_original t,
  makes_colimit := lifted_colimit_is_colimit t }
def id_lifts_cone (c : cone (K â‹™ ğŸ­ C)) : liftable_cone K (ğŸ­ C) c :=
{ lifted_cone :=
  { X := c.X,
    Ï€ := c.Ï€ â‰« K.right_unitor.hom },
  valid_lift := cones.ext (iso.refl _) (by tidy) }
instance id_creates_limits : creates_limits_of_size.{w w'} (ğŸ­ C) :=
{ creates_limits_of_shape := Î» J ğ’¥, by exactI
  { creates_limit := Î» F, { lifts := Î» c t, id_lifts_cone c } } }
def id_lifts_cocone (c : cocone (K â‹™ ğŸ­ C)) : liftable_cocone K (ğŸ­ C) c :=
{ lifted_cocone :=
  { X := c.X,
    Î¹ := K.right_unitor.inv â‰« c.Î¹ },
  valid_lift := cocones.ext (iso.refl _) (by tidy) }
instance id_creates_colimits : creates_colimits_of_size.{w w'} (ğŸ­ C) :=
{ creates_colimits_of_shape := Î» J ğ’¥, by exactI
  { creates_colimit := Î» F, { lifts := Î» c t, id_lifts_cocone c } } }
instance inhabited_liftable_cone (c : cone (K â‹™ ğŸ­ C)) :
  inhabited (liftable_cone K (ğŸ­ C) c) :=
âŸ¨id_lifts_cone câŸ©
instance inhabited_liftable_cocone (c : cocone (K â‹™ ğŸ­ C)) :
  inhabited (liftable_cocone K (ğŸ­ C) c) :=
âŸ¨id_lifts_cocone câŸ©
instance inhabited_lifts_to_limit (K : J â¥¤ C) (F : C â¥¤ D)
  [creates_limit K F] (c : cone (K â‹™ F)) (t : is_limit c) :
  inhabited (lifts_to_limit _ _ _ t) :=
âŸ¨lifts_to_limit_of_creates K F c tâŸ©
instance inhabited_lifts_to_colimit (K : J â¥¤ C) (F : C â¥¤ D)
  [creates_colimit K F] (c : cocone (K â‹™ F)) (t : is_colimit c) :
  inhabited (lifts_to_colimit _ _ _ t) :=
âŸ¨lifts_to_colimit_of_creates K F c tâŸ©
section comp
variables {E : Type uâ‚ƒ} [â„° : category.{vâ‚ƒ} E]
variables (F : C â¥¤ D) (G : D â¥¤ E)
instance comp_creates_limit [creates_limit K F] [creates_limit (K â‹™ F) G] :
  creates_limit K (F â‹™ G) :=
{ lifts := Î» c t,
  { lifted_cone := lift_limit (lifted_limit_is_limit t),
    valid_lift := (cones.functoriality (K â‹™ F) G).map_iso
      (lifted_limit_maps_to_original (lifted_limit_is_limit t)) â‰ªâ‰«
      (lifted_limit_maps_to_original t) } }
instance comp_creates_limits_of_shape [creates_limits_of_shape J F] [creates_limits_of_shape J G] :
  creates_limits_of_shape J (F â‹™ G) :=
{ creates_limit := infer_instance }
instance comp_creates_limits [creates_limits_of_size.{w w'} F] [creates_limits_of_size.{w w'} G] :
  creates_limits_of_size.{w w'} (F â‹™ G) :=
{ creates_limits_of_shape := infer_instance }
instance comp_creates_colimit [creates_colimit K F] [creates_colimit (K â‹™ F) G] :
  creates_colimit K (F â‹™ G) :=
{ lifts := Î» c t,
  { lifted_cocone := lift_colimit (lifted_colimit_is_colimit t),
    valid_lift := (cocones.functoriality (K â‹™ F) G).map_iso
      (lifted_colimit_maps_to_original (lifted_colimit_is_colimit t)) â‰ªâ‰«
      (lifted_colimit_maps_to_original t) } }
instance comp_creates_colimits_of_shape
  [creates_colimits_of_shape J F] [creates_colimits_of_shape J G] :
  creates_colimits_of_shape J (F â‹™ G) :=
{ creates_colimit := infer_instance }
instance comp_creates_colimits [creates_colimits_of_size.{w w'} F]
  [creates_colimits_of_size.{w w'} G] : creates_colimits_of_size.{w w'} (F â‹™ G) :=
{ creates_colimits_of_shape := infer_instance }
end comp
end creates
end category_theory
