import analysis.normed_space.operator_norm
import topology.metric_space.baire
import topology.algebra.module.basic
open set
variables
{E F ğ•œ ğ•œâ‚‚ : Type*}
[semi_normed_group E] [semi_normed_group F]
[nondiscrete_normed_field ğ•œ] [nondiscrete_normed_field ğ•œâ‚‚]
[normed_space ğ•œ E] [normed_space ğ•œâ‚‚ F]
{Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚]
theorem banach_steinhaus {Î¹ : Type*} [complete_space E] {g : Î¹ â†’ E â†’SL[Ïƒâ‚â‚‚] F}
  (h : âˆ€ x, âˆƒ C, âˆ€ i, âˆ¥g i xâˆ¥ â‰¤ C) :
  âˆƒ C', âˆ€ i, âˆ¥g iâˆ¥ â‰¤ C' :=
begin
  let e : â„• â†’ set E := Î» n, (â‹‚ i : Î¹, { x : E | âˆ¥g i xâˆ¥ â‰¤ n }),
  have hc : âˆ€ n : â„•, is_closed (e n), from Î» i, is_closed_Inter (Î» i,
    is_closed_le (continuous.norm (g i).cont) continuous_const),
  have hU : (â‹ƒ n : â„•, e n) = univ,
  { refine eq_univ_of_forall (Î» x, _),
    cases h x with C hC,
    obtain âŸ¨m, hmâŸ© := exists_nat_ge C,
    exact âŸ¨e m, mem_range_self m, mem_Inter.mpr (Î» i, le_trans (hC i) hm)âŸ© },
  rcases nonempty_interior_of_Union_of_closed hc hU with âŸ¨m, x, hxâŸ©,
  rcases metric.is_open_iff.mp is_open_interior x hx with âŸ¨Îµ, Îµ_pos, hÎµâŸ©,
  obtain âŸ¨k, hkâŸ© := normed_field.exists_one_lt_norm ğ•œ,
  have real_norm_le : âˆ€ z : E, z âˆˆ metric.ball x Îµ â†’ âˆ€ i : Î¹, âˆ¥g i zâˆ¥ â‰¤ m,
  { intros z hz i,
    replace hz := mem_Inter.mp (interior_Inter_subset _ (hÎµ hz)) i,
    apply interior_subset hz },
  have Îµk_pos : 0 < Îµ / âˆ¥kâˆ¥ := div_pos Îµ_pos (zero_lt_one.trans hk),
  refine âŸ¨(m + m : â„•) / (Îµ / âˆ¥kâˆ¥), Î» i, continuous_linear_map.op_norm_le_of_shell Îµ_pos _ hk _âŸ©,
  { exact div_nonneg (nat.cast_nonneg _) Îµk_pos.le },
  intros y le_y y_lt,
  calc âˆ¥g i yâˆ¥
      = âˆ¥g i (y + x) - g i xâˆ¥   : by rw [continuous_linear_map.map_add, add_sub_cancel]
  ... â‰¤ âˆ¥g i (y + x)âˆ¥ + âˆ¥g i xâˆ¥ : norm_sub_le _ _
  ... â‰¤ m + m : add_le_add (real_norm_le (y + x) (by rwa [add_comm, add_mem_ball_iff_norm]) i)
          (real_norm_le x (metric.mem_ball_self Îµ_pos) i)
  ... = (m + m : â„•) : (m.cast_add m).symm
  ... â‰¤ (m + m : â„•) * (âˆ¥yâˆ¥ / (Îµ / âˆ¥kâˆ¥))
      : le_mul_of_one_le_right (nat.cast_nonneg _)
          ((one_le_div $ div_pos Îµ_pos (zero_lt_one.trans hk)).2 le_y)
  ... = (m + m : â„•) / (Îµ / âˆ¥kâˆ¥) * âˆ¥yâˆ¥ : (mul_comm_div _ _ _).symm,
end
open_locale ennreal
open ennreal
theorem banach_steinhaus_supr_nnnorm {Î¹ : Type*} [complete_space E] {g : Î¹ â†’ E â†’SL[Ïƒâ‚â‚‚] F}
  (h : âˆ€ x, (â¨† i, â†‘âˆ¥g i xâˆ¥â‚Š) < âˆ) :
  (â¨† i, â†‘âˆ¥g iâˆ¥â‚Š) < âˆ :=
begin
  have h' : âˆ€ x : E, âˆƒ C : â„, âˆ€ i : Î¹, âˆ¥g i xâˆ¥ â‰¤ C,
  { intro x,
    rcases lt_iff_exists_coe.mp (h x) with âŸ¨p, hpâ‚, _âŸ©,
    refine âŸ¨p, (Î» i, _)âŸ©,
    exact_mod_cast
    calc (âˆ¥g i xâˆ¥â‚Š : â„â‰¥0âˆ) â‰¤ â¨† j,  âˆ¥g j xâˆ¥â‚Š : le_supr _ i
      ...                  = p              : hpâ‚ },
  cases banach_steinhaus h' with C' hC',
  refine (supr_le $ Î» i, _).trans_lt (@coe_lt_top C'.to_nnreal),
  rw â†norm_to_nnreal,
  exact coe_mono (real.to_nnreal_le_to_nnreal $ hC' i),
end
open_locale topological_space
open filter
def continuous_linear_map_of_tendsto [complete_space E] [t2_space F]
  (g : â„• â†’ E â†’SL[Ïƒâ‚â‚‚] F) {f : E â†’ F} (h : tendsto (Î» n x, g n x) at_top (ğ“ f)) :
  E â†’SL[Ïƒâ‚â‚‚] F :=
{ to_fun := f,
  map_add' := (linear_map_of_tendsto _ _ h).map_add',
  map_smul' := (linear_map_of_tendsto _ _ h).map_smul',
  cont :=
    begin
      have h_point_bdd : âˆ€ x : E, âˆƒ C : â„, âˆ€ n : â„•, âˆ¥g n xâˆ¥ â‰¤ C,
      { intro x,
        rcases cauchy_seq_bdd (tendsto_pi_nhds.mp h x).cauchy_seq with âŸ¨C, C_pos, hCâŸ©,
        refine âŸ¨C + âˆ¥g 0 xâˆ¥, (Î» n, _)âŸ©,
        simp_rw dist_eq_norm at hC,
        calc âˆ¥g n xâˆ¥ â‰¤ âˆ¥g 0 xâˆ¥ + âˆ¥g n x - g 0 xâˆ¥ : norm_le_insert' _ _
          ...        â‰¤ C + âˆ¥g 0 xâˆ¥               : by linarith [hC n 0] },
      cases banach_steinhaus h_point_bdd with C' hC',
      refine add_monoid_hom_class.continuous_of_bound (linear_map_of_tendsto _ _ h) C'
        (Î» x, le_of_forall_pos_lt_add (Î» Îµ Îµ_pos, _)),
      cases metric.tendsto_at_top.mp (tendsto_pi_nhds.mp h x) Îµ Îµ_pos with n hn,
      have lt_Îµ : âˆ¥g n x - f xâˆ¥ < Îµ, by {rw â†dist_eq_norm, exact hn n (le_refl n)},
      calc âˆ¥f xâˆ¥ â‰¤ âˆ¥g n xâˆ¥ + âˆ¥g n x - f xâˆ¥ : norm_le_insert _ _
        ...      < âˆ¥g nâˆ¥ * âˆ¥xâˆ¥ + Îµ        : by linarith [lt_Îµ, (g n).le_op_norm x]
        ...      â‰¤ C' * âˆ¥xâˆ¥ + Îµ           : by nlinarith [hC' n, norm_nonneg x],
    end }
