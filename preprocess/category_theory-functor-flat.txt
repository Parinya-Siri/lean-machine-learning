import category_theory.limits.filtered_colimit_commutes_finite_limit
import category_theory.limits.preserves.functor_category
import category_theory.limits.preserves.shapes.equalizers
import category_theory.limits.bicones
import category_theory.limits.comma
import category_theory.limits.preserves.finite
import category_theory.limits.shapes.finite_limits
universes w vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ
open category_theory
open category_theory.limits
open opposite
namespace category_theory
namespace structured_arrow_cone
open structured_arrow
variables {C : Type uâ‚} [category.{vâ‚} C] {D : Type uâ‚‚} [category.{vâ‚} D]
variables {J : Type w} [small_category J]
variables {K : J â¥¤ C} (F : C â¥¤ D) (c : cone K)
@[simps]
def to_diagram : J â¥¤ structured_arrow c.X K :=
{ obj := Î» j, structured_arrow.mk (c.Ï€.app j),
  map := Î» j k g, structured_arrow.hom_mk g (by simpa) }
@[simps]
def diagram_to_cone {X : D} (G : J â¥¤ structured_arrow X F) : cone (G â‹™ proj X F â‹™ F) :=
{ X := X, Ï€ := { app := Î» j, (G.obj j).hom } }
@[simps]
def to_cone {X : D} (f : X âŸ¶ F.obj c.X) :
  cone (to_diagram (F.map_cone c) â‹™ map f â‹™ pre _ K F) :=
{ X := mk f, Ï€ := { app := Î» j, hom_mk (c.Ï€.app j) rfl,
                    naturality' := Î» j k g, by { ext, dsimp, simp } } }
end structured_arrow_cone
section representably_flat
variables {C : Type uâ‚} [category.{vâ‚} C] {D : Type uâ‚‚} [category.{vâ‚‚} D]
variables {E : Type uâ‚ƒ} [category.{vâ‚ƒ} E]
class representably_flat (F : C â¥¤ D) : Prop :=
(cofiltered : âˆ€ (X : D), is_cofiltered (structured_arrow X F))
attribute [instance] representably_flat.cofiltered
local attribute [instance] is_cofiltered.nonempty
instance representably_flat.id : representably_flat (ğŸ­ C) :=
begin
  constructor,
  intro X,
  haveI : nonempty (structured_arrow X (ğŸ­ C)) := âŸ¨structured_arrow.mk (ğŸ™ _)âŸ©,
  suffices : is_cofiltered_or_empty (structured_arrow X (ğŸ­ C)),
  { resetI, constructor },
  constructor,
  { intros Y Z,
    use structured_arrow.mk (ğŸ™ _),
    use structured_arrow.hom_mk Y.hom (by erw [functor.id_map, category.id_comp]),
    use structured_arrow.hom_mk Z.hom (by erw [functor.id_map, category.id_comp]) },
  { intros Y Z f g,
    use structured_arrow.mk (ğŸ™ _),
    use structured_arrow.hom_mk Y.hom (by erw [functor.id_map, category.id_comp]),
    ext,
    transitivity Z.hom; simp }
end
instance representably_flat.comp (F : C â¥¤ D) (G : D â¥¤ E)
  [representably_flat F] [representably_flat G] : representably_flat (F â‹™ G) :=
begin
  constructor,
  intro X,
  haveI : nonempty (structured_arrow X (F â‹™ G)),
  { have fâ‚ : structured_arrow X G := nonempty.some infer_instance,
    have fâ‚‚ : structured_arrow fâ‚.right F := nonempty.some infer_instance,
    exact âŸ¨structured_arrow.mk (fâ‚.hom â‰« G.map fâ‚‚.hom)âŸ© },
  suffices : is_cofiltered_or_empty (structured_arrow X (F â‹™ G)),
  { resetI, constructor },
  constructor,
  { intros Y Z,
    let W := @is_cofiltered.min (structured_arrow X G) _ _
      (structured_arrow.mk Y.hom) (structured_arrow.mk Z.hom),
    let Y' : W âŸ¶ _ := is_cofiltered.min_to_left _ _,
    let Z' : W âŸ¶ _ := is_cofiltered.min_to_right _ _,
    let W' := @is_cofiltered.min (structured_arrow W.right F) _ _
      (structured_arrow.mk Y'.right) (structured_arrow.mk Z'.right),
    let Y'' : W' âŸ¶ _ := is_cofiltered.min_to_left _ _,
    let Z'' : W' âŸ¶ _ := is_cofiltered.min_to_right _ _,
    use structured_arrow.mk (W.hom â‰« G.map W'.hom),
    use structured_arrow.hom_mk Y''.right (by simp [â† G.map_comp]),
    use structured_arrow.hom_mk Z''.right (by simp [â† G.map_comp]) },
  { intros Y Z f g,
    let W := @is_cofiltered.eq (structured_arrow X G) _ _
        (structured_arrow.mk Y.hom) (structured_arrow.mk Z.hom)
        (structured_arrow.hom_mk (F.map f.right) (structured_arrow.w f))
        (structured_arrow.hom_mk (F.map g.right) (structured_arrow.w g)),
    let h : W âŸ¶ _ := is_cofiltered.eq_hom _ _,
    let h_cond : h â‰« _ = h â‰« _ := is_cofiltered.eq_condition _ _,
    let W' := @is_cofiltered.eq (structured_arrow W.right F) _ _
        (structured_arrow.mk h.right) (structured_arrow.mk (h.right â‰« F.map f.right))
        (structured_arrow.hom_mk f.right rfl)
        (structured_arrow.hom_mk g.right (congr_arg comma_morphism.right h_cond).symm),
    let h' : W' âŸ¶ _ := is_cofiltered.eq_hom _ _,
    let h'_cond : h' â‰« _ = h' â‰« _ := is_cofiltered.eq_condition _ _,
    use structured_arrow.mk (W.hom â‰« G.map W'.hom),
    use structured_arrow.hom_mk h'.right (by simp [â† G.map_comp]),
    ext,
    exact (congr_arg comma_morphism.right h'_cond : _) }
end
end representably_flat
section has_limit
variables {C : Type uâ‚} [category.{vâ‚} C] {D : Type uâ‚‚} [category.{vâ‚} D]
local attribute [instance] has_finite_limits_of_has_finite_limits_of_size
@[priority 100]
instance cofiltered_of_has_finite_limits [has_finite_limits C] : is_cofiltered C :=
{ cocone_objs := Î» A B, âŸ¨limits.prod A B, limits.prod.fst, limits.prod.snd, trivialâŸ©,
  cocone_maps :=  Î» A B f g, âŸ¨equalizer f g, equalizer.Î¹ f g, equalizer.condition f gâŸ©,
  nonempty := âŸ¨âŠ¤_ CâŸ© }
lemma flat_of_preserves_finite_limits [has_finite_limits C] (F : C â¥¤ D)
  [preserves_finite_limits F] : representably_flat F := âŸ¨Î» X,
begin
  haveI : has_finite_limits (structured_arrow X F) :=
  begin
    apply has_finite_limits_of_has_finite_limits_of_size.{vâ‚} (structured_arrow X F),
    intros J sJ fJ, resetI, constructor
  end,
  apply_instance
endâŸ©
namespace preserves_finite_limits_of_flat
open structured_arrow
open structured_arrow_cone
variables {J : Type vâ‚} [small_category J] [fin_category J] {K : J â¥¤ C}
variables (F : C â¥¤ D) [representably_flat F] {c : cone K} (hc : is_limit c) (s : cone (K â‹™ F))
include hc
noncomputable def lift : s.X âŸ¶ F.obj c.X :=
let s' := is_cofiltered.cone (to_diagram s â‹™ structured_arrow.pre _ K F) in
s'.X.hom â‰« (F.map $ hc.lift $
  (cones.postcompose ({ app := Î» X, ğŸ™ _, naturality' := by simp }
      : (to_diagram s â‹™ pre s.X K F) â‹™ proj s.X F âŸ¶ K)).obj $
  (structured_arrow.proj s.X F).map_cone s')
lemma fac (x : J) : lift F hc s â‰« (F.map_cone c).Ï€.app x = s.Ï€.app x :=
by simpa [lift, â†functor.map_comp]
local attribute [simp] eq_to_hom_map
lemma uniq {K : J â¥¤ C} {c : cone K} (hc : is_limit c)
  (s : cone (K â‹™ F)) (fâ‚ fâ‚‚ : s.X âŸ¶ F.obj c.X)
  (hâ‚ : âˆ€ (j : J), fâ‚ â‰« (F.map_cone c).Ï€.app j = s.Ï€.app j)
  (hâ‚‚ : âˆ€ (j : J), fâ‚‚ â‰« (F.map_cone c).Ï€.app j = s.Ï€.app j) : fâ‚ = fâ‚‚ :=
begin
noncomputable
def preserves_finite_limits_of_flat (F : C â¥¤ D) [representably_flat F] :
  preserves_finite_limits F :=
begin
  apply preserves_finite_limits_of_preserves_finite_limits_of_size,
  intros J _ _, constructor,
  intros K, constructor,
  intros c hc,
  exactI { lift := preserves_finite_limits_of_flat.lift F hc,
    fac' := preserves_finite_limits_of_flat.fac F hc,
    uniq' := Î» s m h, by
    { apply preserves_finite_limits_of_flat.uniq F hc,
      exact h,
      exact preserves_finite_limits_of_flat.fac F hc s } }
end
noncomputable
def preserves_finite_limits_iff_flat [has_finite_limits C] (F : C â¥¤ D) :
  representably_flat F â‰ƒ preserves_finite_limits F :=
{ to_fun := Î» _, by exactI preserves_finite_limits_of_flat F,
  inv_fun := Î» _, by exactI flat_of_preserves_finite_limits F,
  left_inv := Î» _, proof_irrel _ _,
  right_inv := Î» x, by { cases x, unfold preserves_finite_limits_of_flat,
    dunfold preserves_finite_limits_of_preserves_finite_limits_of_size, congr } }
end has_limit
section small_category
variables {C D : Type uâ‚} [small_category C] [small_category D] (E : Type uâ‚‚) [category.{uâ‚} E]
noncomputable
def Lan_evaluation_iso_colim (F : C â¥¤ D) (X : D)
  [âˆ€ (X : D), has_colimits_of_shape (costructured_arrow F X) E] :
  Lan F â‹™ (evaluation D E).obj X â‰…
  ((whiskering_left _ _ E).obj (costructured_arrow.proj F X)) â‹™ colim :=
nat_iso.of_components (Î» G, colim.map_iso (iso.refl _))
begin
  intros G H i,
  ext,
  simp only [functor.comp_map, colimit.Î¹_desc_assoc, functor.map_iso_refl, evaluation_obj_map,
    whiskering_left_obj_map, category.comp_id, Lan_map_app, category.assoc],
  erw [colimit.Î¹_pre_assoc (Lan.diagram F H X) (costructured_arrow.map j.hom),
    category.id_comp, category.comp_id, colimit.Î¹_map],
  rcases j with âŸ¨j_left, âŸ¨âŸ¨âŸ©âŸ©, j_homâŸ©,
  congr,
  rw [costructured_arrow.map_mk, category.id_comp, costructured_arrow.mk]
end
variables [concrete_category.{uâ‚} E] [has_limits E] [has_colimits E]
variables [reflects_limits (forget E)] [preserves_filtered_colimits (forget E)]
variables [preserves_limits (forget E)]
noncomputable
instance Lan_preserves_finite_limits_of_flat (F : C â¥¤ D) [representably_flat F] :
  preserves_finite_limits (Lan F.op : _ â¥¤ (Dáµ’áµ– â¥¤ E)) :=
begin
  apply preserves_finite_limits_of_preserves_finite_limits_of_size.{uâ‚},
  intros J _ _, resetI,
  apply preserves_limits_of_shape_of_evaluation (Lan F.op : (Cáµ’áµ– â¥¤ E) â¥¤ (Dáµ’áµ– â¥¤ E)) J,
  intro K,
  haveI : is_filtered (costructured_arrow F.op K) :=
    is_filtered.of_equivalence (structured_arrow_op_equivalence F (unop K)),
  exact preserves_limits_of_shape_of_nat_iso (Lan_evaluation_iso_colim _ _ _).symm,
end
instance Lan_flat_of_flat (F : C â¥¤ D) [representably_flat F] :
  representably_flat (Lan F.op : _ â¥¤ (Dáµ’áµ– â¥¤ E)) := flat_of_preserves_finite_limits _
variable [has_finite_limits C]
noncomputable
instance Lan_preserves_finite_limits_of_preserves_finite_limits (F : C â¥¤ D)
  [preserves_finite_limits F] : preserves_finite_limits (Lan F.op : _ â¥¤ (Dáµ’áµ– â¥¤ E)) :=
begin
  haveI := flat_of_preserves_finite_limits F,
  apply_instance
end
lemma flat_iff_Lan_flat (F : C â¥¤ D) :
  representably_flat F â†” representably_flat (Lan F.op : _ â¥¤ (Dáµ’áµ– â¥¤ Type uâ‚)) :=
âŸ¨Î» H, by exactI infer_instance, Î» H,
begin
  resetI,
  haveI := preserves_finite_limits_of_flat (Lan F.op : _ â¥¤ (Dáµ’áµ– â¥¤ Type uâ‚)),
  haveI : preserves_finite_limits F :=
    begin
      apply preserves_finite_limits_of_preserves_finite_limits_of_size.{uâ‚},
      intros, resetI, apply preserves_limit_of_Lan_presesrves_limit
    end,
  apply flat_of_preserves_finite_limits
endâŸ©
noncomputable
def preserves_finite_limits_iff_Lan_preserves_finite_limits (F : C â¥¤ D) :
  preserves_finite_limits F â‰ƒ preserves_finite_limits (Lan F.op : _ â¥¤ (Dáµ’áµ– â¥¤ Type uâ‚)) :=
{ to_fun := Î» _, by exactI infer_instance,
  inv_fun := Î» _,
  begin
    apply preserves_finite_limits_of_preserves_finite_limits_of_size.{uâ‚},
    intros, resetI, apply preserves_limit_of_Lan_presesrves_limit
  end,
  left_inv := Î» x,
  begin
    cases x, unfold preserves_finite_limits_of_flat,
    dunfold preserves_finite_limits_of_preserves_finite_limits_of_size, congr
  end,
  right_inv := Î» x,
  begin
    cases x,
    unfold preserves_finite_limits_of_flat,
    congr,
    unfold category_theory.Lan_preserves_finite_limits_of_preserves_finite_limits
      category_theory.Lan_preserves_finite_limits_of_flat,
    dunfold preserves_finite_limits_of_preserves_finite_limits_of_size, congr
  end }
end small_category
end category_theory
