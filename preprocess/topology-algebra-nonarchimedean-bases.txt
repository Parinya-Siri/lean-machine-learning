import topology.algebra.nonarchimedean.basic
import topology.algebra.filter_basis
import algebra.module.submodule.pointwise
open set filter function lattice add_group_with_zero_nhd
open_locale topological_space filter pointwise
structure ring_subgroups_basis {A Œπ : Type*} [ring A] (B : Œπ ‚Üí add_subgroup A) : Prop :=
(inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j)
(mul : ‚àÄ i, ‚àÉ j, (B j : set A) * B j ‚äÜ B i)
(left_mul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : set A) ‚äÜ (Œª y : A, x*y) ‚Åª¬π' (B i))
(right_mul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : set A) ‚äÜ (Œª y : A, y*x) ‚Åª¬π' (B i))
namespace ring_subgroups_basis
variables {A Œπ : Type*} [ring A]
lemma of_comm {A Œπ : Type*} [comm_ring A] (B : Œπ ‚Üí add_subgroup A)
  (inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j)
  (mul : ‚àÄ i, ‚àÉ j, (B j : set A) * B j ‚äÜ B i)
  (left_mul : ‚àÄ x : A, ‚àÄ i, ‚àÉ j, (B j : set A) ‚äÜ (Œª y : A, x*y) ‚Åª¬π' (B i)) :
  ring_subgroups_basis B :=
{ inter := inter,
  mul := mul,
  left_mul := left_mul,
  right_mul := begin
    intros x i,
    cases left_mul x i with j hj,
    use j,
    simpa [mul_comm] using hj
  end }
def to_ring_filter_basis [nonempty Œπ] {B : Œπ ‚Üí add_subgroup A}
  (hB : ring_subgroups_basis B) : ring_filter_basis A :=
{ sets := {U | ‚àÉ i, U = B i},
  nonempty := by { inhabit Œπ, exact ‚ü®B default, default, rfl‚ü© },
  inter_sets := begin
    rintros _ _ ‚ü®i, rfl‚ü© ‚ü®j, rfl‚ü©,
    cases hB.inter i j with k hk,
    use [B k, k, rfl, hk]
  end,
  zero' := by { rintros _ ‚ü®i, rfl‚ü©, exact (B i).zero_mem },
  add' := begin
    rintros _ ‚ü®i, rfl‚ü©,
    use [B i, i, rfl],
    rintros x ‚ü®y, z, y_in, z_in, rfl‚ü©,
    exact (B i).add_mem y_in z_in
  end,
  neg' := begin
    rintros _ ‚ü®i, rfl‚ü©,
    use [B i, i, rfl],
    intros x x_in,
    exact (B i).neg_mem x_in
  end,
  conj' := begin
    rintros x‚ÇÄ _ ‚ü®i, rfl‚ü©,
    use [B i, i, rfl],
    simp
  end,
  mul' := begin
    rintros _ ‚ü®i, rfl‚ü©,
    cases hB.mul i with k hk,
    use [B k, k, rfl, hk]
  end,
  mul_left' := begin
    rintros x‚ÇÄ _ ‚ü®i, rfl‚ü©,
    cases hB.left_mul x‚ÇÄ i with k hk,
    use [B k, k, rfl, hk]
  end,
  mul_right' := begin
    rintros x‚ÇÄ _ ‚ü®i, rfl‚ü©,
    cases hB.right_mul x‚ÇÄ i with k hk,
    use [B k, k, rfl, hk]
  end }
variables [nonempty Œπ] {B : Œπ ‚Üí add_subgroup A} (hB : ring_subgroups_basis B)
lemma mem_add_group_filter_basis_iff {V : set A} :
  V ‚àà hB.to_ring_filter_basis.to_add_group_filter_basis ‚Üî ‚àÉ i, V = B i :=
iff.rfl
lemma mem_add_group_filter_basis (i) :
  (B i : set A) ‚àà hB.to_ring_filter_basis.to_add_group_filter_basis :=
‚ü®i, rfl‚ü©
def topology : topological_space A :=
hB.to_ring_filter_basis.to_add_group_filter_basis.topology
lemma has_basis_nhds_zero : has_basis (@nhds A hB.topology 0) (Œª _, true) (Œª i, B i) :=
‚ü®begin
  intros s,
  rw hB.to_ring_filter_basis.to_add_group_filter_basis.nhds_zero_has_basis.mem_iff,
  split,
  { rintro ‚ü®-, ‚ü®i, rfl‚ü©, hi‚ü©,
    exact ‚ü®i, trivial, hi‚ü© },
  { rintro ‚ü®i, -, hi‚ü©,
    exact ‚ü®B i, ‚ü®i, rfl‚ü©, hi‚ü© }
end‚ü©
lemma has_basis_nhds (a : A) :
  has_basis (@nhds A hB.topology a) (Œª _, true) (Œª i, {b | b - a ‚àà B i}) :=
‚ü®begin
  intros s,
  rw (hB.to_ring_filter_basis.to_add_group_filter_basis.nhds_has_basis a).mem_iff,
  simp only [exists_prop, exists_true_left],
  split,
  { rintro ‚ü®-, ‚ü®i, rfl‚ü©, hi‚ü©,
    use i,
    convert hi,
    ext b,
    split,
    { intros h,
      use [b - a, h],
      abel },
    { rintros ‚ü®c, hc, rfl‚ü©,
      simpa using hc } },
  { rintros ‚ü®i, hi‚ü©,
    use [B i, i, rfl],
    rw image_subset_iff,
    rintro b b_in,
    apply hi,
    simpa using b_in }
end‚ü©
def open_add_subgroup (i : Œπ) : @open_add_subgroup A _ hB.topology:=
{ is_open' := begin
    letI := hB.topology,
    rw is_open_iff_mem_nhds,
    intros a a_in,
    rw (hB.has_basis_nhds a).mem_iff,
    use [i, trivial],
    rintros b b_in,
    simpa using (B i).add_mem a_in b_in
  end,
  ..B i }
structure submodules_ring_basis (B : Œπ ‚Üí submodule R A) : Prop :=
(inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j)
(left_mul : ‚àÄ (a : A) i, ‚àÉ j, a ‚Ä¢ B j ‚â§ B i)
(mul      : ‚àÄ i, ‚àÉ j, (B j : set A) * B j ‚äÜ B i)
namespace submodules_ring_basis
variables {B : Œπ ‚Üí submodule R A} (hB : submodules_ring_basis B)
lemma to_ring_subgroups_basis (hB : submodules_ring_basis B) :
  ring_subgroups_basis (Œª i, (B i).to_add_subgroup) :=
begin
  apply ring_subgroups_basis.of_comm (Œª i, (B i).to_add_subgroup) hB.inter hB.mul,
  intros a i,
  rcases hB.left_mul a i with ‚ü®j, hj‚ü©,
  use j,
  rintros b (b_in : b ‚àà B j),
  exact hj ‚ü®b, b_in, rfl‚ü©
end
def topology [nonempty Œπ] (hB : submodules_ring_basis B) : topological_space A :=
hB.to_ring_subgroups_basis.topology
end submodules_ring_basis
variables {M : Type*} [add_comm_group M] [module R M]
structure submodules_basis [topological_space R]
  (B : Œπ ‚Üí submodule R M) : Prop :=
(inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j)
(smul : ‚àÄ (m : M) (i : Œπ), ‚àÄ·∂† a in ùìù (0 : R), a ‚Ä¢ m ‚àà B i)
namespace submodules_basis
variables [topological_space R] [nonempty Œπ] {B : Œπ ‚Üí submodule R M}
          (hB : submodules_basis B)
include hB
def to_module_filter_basis : module_filter_basis R M :=
{ sets := {U | ‚àÉ i, U = B i},
  nonempty := by { inhabit Œπ, exact ‚ü®B default, default, rfl‚ü© },
  inter_sets := begin
    rintros _ _ ‚ü®i, rfl‚ü© ‚ü®j, rfl‚ü©,
    cases hB.inter i j with k hk,
    use [B k, k, rfl, hk]
  end,
  zero' := by { rintros _ ‚ü®i, rfl‚ü©, exact (B i).zero_mem },
  add' := begin
    rintros _ ‚ü®i, rfl‚ü©,
    use [B i, i, rfl],
    rintros x ‚ü®y, z, y_in, z_in, rfl‚ü©,
    exact (B i).add_mem y_in z_in
  end,
  neg' := begin
    rintros _ ‚ü®i, rfl‚ü©,
    use [B i, i, rfl],
    intros x x_in,
    exact (B i).neg_mem x_in
  end,
  conj' := begin
    rintros x‚ÇÄ _ ‚ü®i, rfl‚ü©,
    use [B i, i, rfl],
    simp
  end,
  smul' := begin
    rintros _ ‚ü®i, rfl‚ü©,
    use [univ, univ_mem, B i, i, rfl],
    rintros _ ‚ü®a, m, -, hm, rfl‚ü©,
    exact (B i).smul_mem _ hm
  end,
  smul_left' := begin
    rintros x‚ÇÄ _ ‚ü®i, rfl‚ü©,
    use [B i, i, rfl],
    intros m,
    exact (B i).smul_mem _
  end,
  smul_right' := begin
    rintros m‚ÇÄ _ ‚ü®i, rfl‚ü©,
    exact hB.smul m‚ÇÄ i
  end }
def topology : topological_space M :=
hB.to_module_filter_basis.to_add_group_filter_basis.topology
def open_add_subgroup (i : Œπ) : @open_add_subgroup M _ hB.topology :=
{ is_open' := begin
    letI := hB.topology,
    rw is_open_iff_mem_nhds,
    intros a a_in,
    rw (hB.to_module_filter_basis.to_add_group_filter_basis.nhds_has_basis a).mem_iff,
    use [B i, i, rfl],
    rintros - ‚ü®b, b_in, rfl‚ü©,
    exact (B i).add_mem a_in b_in
  end,
  ..(B i).to_add_subgroup }
library_note "nonarchimedean non instances"
end submodules_basis
section
variables [topological_space R] {B : Œπ ‚Üí submodule R A} (hB : submodules_ring_basis B)
          (hsmul : ‚àÄ (m : A) (i : Œπ), ‚àÄ·∂† (a : R) in ùìù 0, a ‚Ä¢ m ‚àà B i)
lemma submodules_ring_basis.to_submodules_basis : submodules_basis B :=
{ inter := hB.inter,
  smul := hsmul }
example [nonempty Œπ] : hB.topology = (hB.to_submodules_basis hsmul).topology := rfl
end
structure ring_filter_basis.submodules_basis (BR : ring_filter_basis R)
  (B : Œπ ‚Üí submodule R M) : Prop :=
(inter : ‚àÄ i j, ‚àÉ k, B k ‚â§ B i ‚äì B j)
(smul : ‚àÄ (m : M) (i : Œπ), ‚àÉ U ‚àà BR, U ‚äÜ (Œª a, a ‚Ä¢ m) ‚Åª¬π' B i)
lemma ring_filter_basis.submodules_basis_is_basis (BR : ring_filter_basis R) {B : Œπ ‚Üí submodule R M}
  (hB : BR.submodules_basis B) : @submodules_basis Œπ R _ M _ _ BR.topology B  :=
{ inter := hB.inter,
  smul := begin
    letI := BR.topology,
    intros m i,
    rcases hB.smul m i with ‚ü®V, V_in, hV‚ü©,
    exact mem_of_superset (BR.to_add_group_filter_basis.mem_nhds_zero V_in) hV
  end }
def ring_filter_basis.module_filter_basis [nonempty Œπ] (BR : ring_filter_basis R)
  {B : Œπ ‚Üí submodule R M} (hB : BR.submodules_basis B) :
  @module_filter_basis R M _ BR.topology _ _ :=
@submodules_basis.to_module_filter_basis  Œπ R _ M _ _ BR.topology _ _
  (BR.submodules_basis_is_basis hB)
