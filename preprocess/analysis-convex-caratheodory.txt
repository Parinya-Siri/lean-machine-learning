import analysis.convex.combination
import linear_algebra.affine_space.independent
import tactic.field_simp
open set finset
open_locale big_operators
universes u
variables {ğ•œ : Type*} {E : Type u} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E]
namespace caratheodory
lemma mem_convex_hull_erase [decidable_eq E] {t : finset E}
  (h : Â¬ affine_independent ğ•œ (coe : t â†’ E)) {x : E} (m : x âˆˆ convex_hull ğ•œ (â†‘t : set E)) :
  âˆƒ (y : (â†‘t : set E)), x âˆˆ convex_hull ğ•œ (â†‘(t.erase y) : set E) :=
begin
  simp only [finset.convex_hull_eq, mem_set_of_eq] at m âŠ¢,
  obtain âŸ¨f, fpos, fsum, rflâŸ© := m,
  obtain âŸ¨g, gcombo, gsum, gposâŸ© := exists_nontrivial_relation_sum_zero_of_not_affine_ind h,
  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos,
  clear h,
  let s := @finset.filter _ (Î» z, 0 < g z) (Î» _, linear_order.decidable_lt _ _) t,
  obtain âŸ¨iâ‚€, mem, wâŸ© : âˆƒ iâ‚€ âˆˆ s, âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i,
  { apply s.exists_min_image (Î» z, f z / g z),
    obtain âŸ¨x, hx, hgxâŸ© : âˆƒ x âˆˆ t, 0 < g x := gpos,
    exact âŸ¨x, mem_filter.mpr âŸ¨hx, hgxâŸ©âŸ© },
  have hg   : 0 < g iâ‚€ := by { rw mem_filter at mem, exact mem.2 },
  have hiâ‚€  : iâ‚€ âˆˆ t   := filter_subset _ _ mem,
  let  k    : E â†’ ğ•œ    := Î» z, f z - (f iâ‚€ / g iâ‚€) * g z,
  have hk   : k iâ‚€ = 0 := by field_simp [k, ne_of_gt hg],
  have ksum : âˆ‘ e in t.erase iâ‚€, k e = 1,
  { calc âˆ‘ e in t.erase iâ‚€, k e = âˆ‘ e in t, k e :
      by conv_rhs { rw [â† insert_erase hiâ‚€, sum_insert (not_mem_erase iâ‚€ t), hk, zero_add] }
    ... = âˆ‘ e in t, (f e - f iâ‚€ / g iâ‚€ * g e) : rfl
    ... = 1 : by rw [sum_sub_distrib, fsum, â† mul_sum, gsum, mul_zero, sub_zero] },
  refine âŸ¨âŸ¨iâ‚€, hiâ‚€âŸ©, k, _, by convert ksum, _âŸ©,
  { simp only [and_imp, sub_nonneg, mem_erase, ne.def, subtype.coe_mk],
    intros e heiâ‚€ het,
    by_cases hes : e âˆˆ s,
    { have hge : 0 < g e := by { rw mem_filter at hes, exact hes.2 },
      rw â† le_div_iff hge,
      exact w _ hes },
noncomputable def min_card_finset_of_mem_convex_hull : finset E :=
function.argmin_on finset.card nat.lt_wf { t | â†‘t âŠ† s âˆ§ x âˆˆ convex_hull ğ•œ (t : set E) }
(by simpa only [convex_hull_eq_union_convex_hull_finite_subsets s, exists_prop, mem_Union] using hx)
lemma min_card_finset_of_mem_convex_hull_subseteq : â†‘(min_card_finset_of_mem_convex_hull hx) âŠ† s :=
(function.argmin_on_mem _ _ { t : finset E | â†‘t âŠ† s âˆ§ x âˆˆ convex_hull ğ•œ (t : set E) } _).1
lemma mem_min_card_finset_of_mem_convex_hull :
  x âˆˆ convex_hull ğ•œ (min_card_finset_of_mem_convex_hull hx : set E) :=
(function.argmin_on_mem _ _ { t : finset E | â†‘t âŠ† s âˆ§ x âˆˆ convex_hull ğ•œ (t : set E) } _).2
lemma min_card_finset_of_mem_convex_hull_nonempty :
  (min_card_finset_of_mem_convex_hull hx).nonempty :=
begin
  rw [â† finset.coe_nonempty, â† @convex_hull_nonempty_iff ğ•œ],
  exact âŸ¨x, mem_min_card_finset_of_mem_convex_hull hxâŸ©,
end
lemma min_card_finset_of_mem_convex_hull_card_le_card
  {t : finset E} (htâ‚ : â†‘t âŠ† s) (htâ‚‚ : x âˆˆ convex_hull ğ•œ (t : set E)) :
  (min_card_finset_of_mem_convex_hull hx).card â‰¤ t.card :=
function.argmin_on_le _ _ _ âŸ¨htâ‚, htâ‚‚âŸ©
lemma affine_independent_min_card_finset_of_mem_convex_hull :
  affine_independent ğ•œ (coe : min_card_finset_of_mem_convex_hull hx â†’ E) :=
begin
  let k := (min_card_finset_of_mem_convex_hull hx).card - 1,
  have hk : (min_card_finset_of_mem_convex_hull hx).card = k + 1,
  { exact (nat.succ_pred_eq_of_pos
      (finset.card_pos.mpr (min_card_finset_of_mem_convex_hull_nonempty hx))).symm },
  classical,
  by_contra,
  obtain âŸ¨p, hpâŸ© := mem_convex_hull_erase h (mem_min_card_finset_of_mem_convex_hull hx),
  have contra := min_card_finset_of_mem_convex_hull_card_le_card hx (set.subset.trans
    (finset.erase_subset â†‘p (min_card_finset_of_mem_convex_hull hx))
    (min_card_finset_of_mem_convex_hull_subseteq hx)) hp,
  rw [â† not_lt] at contra,
  apply contra,
  erw [card_erase_of_mem p.2, hk],
  exact lt_add_one _,
end
end caratheodory
variables {s : set E}
lemma convex_hull_eq_union :
  convex_hull ğ•œ s =
  â‹ƒ (t : finset E) (hss : â†‘t âŠ† s) (hai : affine_independent ğ•œ (coe : t â†’ E)), convex_hull ğ•œ â†‘t :=
begin
  apply set.subset.antisymm,
  { intros x hx,
    simp only [exists_prop, set.mem_Union],
    exact âŸ¨caratheodory.min_card_finset_of_mem_convex_hull hx,
           caratheodory.min_card_finset_of_mem_convex_hull_subseteq hx,
           caratheodory.affine_independent_min_card_finset_of_mem_convex_hull hx,
           caratheodory.mem_min_card_finset_of_mem_convex_hull hxâŸ© },
  { iterate 3 { convert set.Union_subset _, intro },
    exact convex_hull_mono â€¹_â€º }
end
theorem eq_pos_convex_span_of_mem_convex_hull {x : E} (hx : x âˆˆ convex_hull ğ•œ s) :
  âˆƒ (Î¹ : Sort (u+1)) (_ : fintype Î¹), by exactI âˆƒ (z : Î¹ â†’ E) (w : Î¹ â†’ ğ•œ)
    (hss : set.range z âŠ† s) (hai : affine_independent ğ•œ z)
    (hw : âˆ€ i, 0 < w i), âˆ‘ i, w i = 1 âˆ§ âˆ‘ i, w i â€¢ z i = x :=
begin
  rw convex_hull_eq_union at hx,
  simp only [exists_prop, set.mem_Union] at hx,
  obtain âŸ¨t, htâ‚, htâ‚‚, htâ‚ƒâŸ© := hx,
  simp only [t.convex_hull_eq, exists_prop, set.mem_set_of_eq] at htâ‚ƒ,
  obtain âŸ¨w, hwâ‚, hwâ‚‚, hwâ‚ƒâŸ© := htâ‚ƒ,
  let t' := t.filter (Î» i, w i â‰  0),
  refine âŸ¨t', t'.fintype_coe_sort, (coe : t' â†’ E), w âˆ˜ (coe : t' â†’ E), _, _, _, _, _âŸ©,
  { rw subtype.range_coe_subtype, exact subset.trans (finset.filter_subset _ t) htâ‚ },
  { exact htâ‚‚.comp_embedding
      âŸ¨_, inclusion_injective (finset.filter_subset (Î» i, w i â‰  0) t)âŸ© },
  { exact Î» i, (hwâ‚ _ (finset.mem_filter.mp i.2).1).lt_of_ne
      (finset.mem_filter.mp i.property).2.symm },
  { erw [finset.sum_attach, finset.sum_filter_ne_zero, hwâ‚‚] },
  { change âˆ‘ (i : t') in t'.attach, (Î» e, w e â€¢ e) â†‘i = x,
    erw [finset.sum_attach, finset.sum_filter_of_ne],
    { rw t.center_mass_eq_of_sum_1 id hwâ‚‚ at hwâ‚ƒ, exact hwâ‚ƒ },
    { intros e he hwe contra, apply hwe, rw [contra, zero_smul] } }
end
