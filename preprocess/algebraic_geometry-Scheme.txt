import algebraic_geometry.Spec
noncomputable theory
open topological_space
open category_theory
open Top
open opposite
namespace algebraic_geometry
structure Scheme extends to_LocallyRingedSpace : LocallyRingedSpace :=
(local_affine : ‚àÄ x : to_LocallyRingedSpace, ‚àÉ (U : open_nhds x) (R : CommRing),
  nonempty (to_LocallyRingedSpace.restrict U.open_embedding ‚âÖ
    Spec.to_LocallyRingedSpace.obj (op R)))
namespace Scheme
instance : category Scheme :=
induced_category.category Scheme.to_LocallyRingedSpace
protected abbreviation sheaf (X : Scheme) := X.to_SheafedSpace.sheaf
@[simps, derive[full, faithful]]
def forget_to_LocallyRingedSpace : Scheme ‚•§ LocallyRingedSpace :=
  induced_functor _
@[simp] lemma forget_to_LocallyRingedSpace_preimage {X Y : Scheme} (f : X ‚ü∂ Y) :
  Scheme.forget_to_LocallyRingedSpace.preimage f = f := rfl
@[simps]
def forget_to_Top : Scheme ‚•§ Top :=
  Scheme.forget_to_LocallyRingedSpace ‚ãô LocallyRingedSpace.forget_to_Top
instance {X Y : Scheme} : has_lift_t (X ‚ü∂ Y)
  (X.to_SheafedSpace ‚ü∂ Y.to_SheafedSpace) := (@@coe_to_lift $ @@coe_base coe_subtype)
lemma id_val_base (X : Scheme) : (subtype.val (ùüô X)).base = ùüô _ := rfl
@[simp] lemma id_coe_base (X : Scheme) :
  (‚Üë(ùüô X) : X.to_SheafedSpace ‚ü∂ X.to_SheafedSpace).base = ùüô _ := rfl
@[simp] lemma id_app {X : Scheme} (U : (opens X.carrier)·µí·µñ) :
  (subtype.val (ùüô X)).c.app U = X.presheaf.map
    (eq_to_hom (by { induction U using opposite.rec, cases U, refl })) :=
PresheafedSpace.id_c_app X.to_PresheafedSpace U
@[reassoc]
lemma comp_val {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  (f ‚â´ g).val = f.val ‚â´ g.val := rfl
@[reassoc, simp]
lemma comp_coe_base {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  (‚Üë(f ‚â´ g) : X.to_SheafedSpace ‚ü∂ Z.to_SheafedSpace).base = f.val.base ‚â´ g.val.base := rfl
@[reassoc, elementwise]
lemma comp_val_base {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  (f ‚â´ g).val.base = f.val.base ‚â´ g.val.base := rfl
@[reassoc, simp]
lemma comp_val_c_app {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (U) :
  (f ‚â´ g).val.c.app U = g.val.c.app U ‚â´ f.val.c.app _ := rfl
lemma congr_app {X Y : Scheme} {f g : X ‚ü∂ Y} (e : f = g) (U) :
  f.val.c.app U = g.val.c.app U ‚â´ X.presheaf.map (eq_to_hom (by subst e)) :=
by { subst e, dsimp, simp }
lemma app_eq {X Y : Scheme} (f : X ‚ü∂ Y) {U V : opens Y.carrier} (e : U = V) :
  f.val.c.app (op U) = Y.presheaf.map (eq_to_hom e.symm).op ‚â´
    f.val.c.app (op V) ‚â´ X.presheaf.map (eq_to_hom (congr_arg (opens.map f.val.base).obj e)).op :=
begin
  rw [‚Üê is_iso.inv_comp_eq, ‚Üê functor.map_inv, f.val.c.naturality, presheaf.pushforward_obj_map],
  congr
end
instance is_LocallyRingedSpace_iso {X Y : Scheme} (f : X ‚ü∂ Y) [is_iso f] :
  @is_iso LocallyRingedSpace _ _ _ f :=
forget_to_LocallyRingedSpace.map_is_iso f
@[simp]
lemma inv_val_c_app {X Y : Scheme} (f : X ‚ü∂ Y) [is_iso f] (U : opens X.carrier) :
  (inv f).val.c.app (op U) = X.presheaf.map (eq_to_hom $ by { rw is_iso.hom_inv_id, ext1, refl } :
    (opens.map (f ‚â´ inv f).1.base).obj U ‚ü∂ U).op ‚â´
      inv (f.val.c.app (op $ (opens.map _).obj U)) :=
begin
  rw [is_iso.eq_comp_inv],
  erw ‚Üê Scheme.comp_val_c_app,
  rw [Scheme.congr_app (is_iso.hom_inv_id f),
    Scheme.id_app, ‚Üê functor.map_comp, eq_to_hom_trans, eq_to_hom_op],
  refl
end
def Spec_obj (R : CommRing) : Scheme :=
{ local_affine := Œª x,
  ‚ü®‚ü®‚ä§, trivial‚ü©, R, ‚ü®(Spec.to_LocallyRingedSpace.obj (op R)).restrict_top_iso‚ü©‚ü©,
  to_LocallyRingedSpace := Spec.LocallyRingedSpace_obj R }
@[simp] lemma Spec_obj_to_LocallyRingedSpace (R : CommRing) :
  (Spec_obj R).to_LocallyRingedSpace = Spec.LocallyRingedSpace_obj R := rfl
def Spec_map {R S : CommRing} (f : R ‚ü∂ S) :
  Spec_obj S ‚ü∂ Spec_obj R :=
(Spec.LocallyRingedSpace_map f : Spec.LocallyRingedSpace_obj S ‚ü∂ Spec.LocallyRingedSpace_obj R)
@[simp] lemma Spec_map_id (R : CommRing) :
  Spec_map (ùüô R) = ùüô (Spec_obj R) :=
Spec.LocallyRingedSpace_map_id R
lemma Spec_map_comp {R S T : CommRing} (f : R ‚ü∂ S) (g : S ‚ü∂ T) :
  Spec_map (f ‚â´ g) = Spec_map g ‚â´ Spec_map f :=
Spec.LocallyRingedSpace_map_comp f g
@[simps] def Spec : CommRing·µí·µñ ‚•§ Scheme :=
{ obj := Œª R, Spec_obj (unop R),
  map := Œª R S f, Spec_map f.unop,
  map_id' := Œª R, by rw [unop_id, Spec_map_id],
  map_comp' := Œª R S T f g, by rw [unop_comp, Spec_map_comp] }
def empty : Scheme :=
Spec_obj (CommRing.of punit)
instance : has_emptyc Scheme := ‚ü®empty‚ü©
instance : inhabited Scheme := ‚ü®‚àÖ‚ü©
def Œì : Scheme·µí·µñ ‚•§ CommRing :=
(induced_functor Scheme.to_LocallyRingedSpace).op ‚ãô LocallyRingedSpace.Œì
lemma Œì_def : Œì = (induced_functor Scheme.to_LocallyRingedSpace).op ‚ãô LocallyRingedSpace.Œì := rfl
@[simp] lemma Œì_obj (X : Scheme·µí·µñ) : Œì.obj X = (unop X).presheaf.obj (op ‚ä§) := rfl
lemma Œì_obj_op (X : Scheme) : Œì.obj (op X) = X.presheaf.obj (op ‚ä§) := rfl
@[simp] lemma Œì_map {X Y : Scheme·µí·µñ} (f : X ‚ü∂ Y) :
  Œì.map f = f.unop.1.c.app (op ‚ä§) := rfl
lemma Œì_map_op {X Y : Scheme} (f : X ‚ü∂ Y) :
  Œì.map f.op = f.1.c.app (op ‚ä§) := rfl
section basic_open
variables (X : Scheme) {V U : opens X.carrier} (f g : X.presheaf.obj (op U))
def basic_open : opens X.carrier := X.to_LocallyRingedSpace.to_RingedSpace.basic_open f
@[simp]
lemma mem_basic_open (x : U) : ‚Üëx ‚àà X.basic_open f ‚Üî is_unit (X.presheaf.germ x f) :=
RingedSpace.mem_basic_open _ _ _
@[simp]
lemma mem_basic_open_top (f : X.presheaf.obj (op ‚ä§)) (x : X.carrier) :
  x ‚àà X.basic_open f ‚Üî is_unit (X.presheaf.germ (‚ü®x, trivial‚ü© : (‚ä§ : opens _)) f) :=
RingedSpace.mem_basic_open _ f ‚ü®x, trivial‚ü©
@[simp]
lemma basic_open_res (i : op U ‚ü∂ op V) :
  X.basic_open (X.presheaf.map i f) = V ‚à© X.basic_open f :=
RingedSpace.basic_open_res _ i f
