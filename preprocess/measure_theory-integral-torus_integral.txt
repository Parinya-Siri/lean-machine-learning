import measure_theory.integral.circle_integral
variable {n : â„•}
variables {E : Type*} [normed_group E]
noncomputable theory
open complex set measure_theory function filter topological_space
open_locale real big_operators
local notation `â„â°`:= fin 0 â†’ â„
local notation `â„‚â°`:= fin 0 â†’ â„‚
local notation `â„Â¹`:= fin 1 â†’ â„
local notation `â„‚Â¹`:= fin 1 â†’ â„‚
local notation `â„â¿`:= fin n â†’ â„
local notation `â„‚â¿`:= fin n â†’ â„‚
local notation `â„â¿âºÂ¹`:= fin (n + 1) â†’ â„
local notation `â„‚â¿âºÂ¹`:= fin (n + 1) â†’ â„‚
def torus_map (c : â„‚â¿) (R : â„â¿) : â„â¿ â†’ â„‚â¿ :=
Î» Î¸ i, c i + R i * exp(Î¸ i * I)
lemma torus_map_sub_center (c : â„‚â¿) (R : â„â¿) (Î¸ : â„â¿) :
  torus_map c R Î¸ - c = torus_map 0 R Î¸ :=
by { ext1 i, simp [torus_map] }
lemma torus_map_eq_center_iff {c : â„‚â¿} {R : â„â¿} {Î¸ : â„â¿} :
  torus_map c R Î¸ = c â†” R = 0 :=
by simp [funext_iff, torus_map, exp_ne_zero]
@[simp] lemma torus_map_zero_radius (c : â„‚â¿) : torus_map c 0 = const â„â¿ c :=
by { ext1, rw torus_map_eq_center_iff.2 rfl }
def torus_integrable (f : â„‚â¿ â†’ E) (c : â„‚â¿) (R : â„â¿) : Prop :=
  integrable_on (Î» (Î¸ : â„â¿), f (torus_map c R Î¸)) (Icc (0 : â„â¿) (Î» _, 2 * Ï€)) volume
namespace torus_integrable
variables {f g : â„‚â¿ â†’ E} {c : â„‚â¿} {R : â„â¿}
lemma torus_integrable_const (a : E) (c : â„‚â¿) (R : â„â¿) :
  torus_integrable (Î» _, a) c R :=
by simp [torus_integrable, measure_Icc_lt_top]
protected lemma neg (hf : torus_integrable f c R) : torus_integrable (-f) c R := hf.neg
protected lemma add (hf : torus_integrable f c R) (hg : torus_integrable g c R) :
  torus_integrable (f + g) c R :=
hf.add hg
protected lemma sub (hf : torus_integrable f c R) (hg : torus_integrable g c R) :
  torus_integrable (f - g) c R :=
hf.sub hg
lemma torus_integrable_zero_radius {f : â„‚â¿ â†’ E} {c : â„‚â¿} :
  torus_integrable f c 0 :=
begin
  rw [torus_integrable, torus_map_zero_radius],
  apply torus_integrable_const (f c) c 0,
end
lemma function_integrable [normed_space â„‚ E] (hf : torus_integrable f c R) :
  integrable_on (Î» (Î¸ : â„â¿), (âˆ i, R i * exp(Î¸ i * I) * I : â„‚) â€¢ f (torus_map c R Î¸))
                (Icc (0 : â„â¿) (Î» _, 2 * Ï€)) volume :=
begin
  refine (hf.norm.const_mul (âˆ i, |R i|)).mono' _ _,
  { refine (continuous.ae_strongly_measurable _).smul hf.1,
    exact continuous_finset_prod finset.univ (Î» i hi, (continuous_const.mul
      (((continuous_of_real.comp (continuous_apply i)).mul continuous_const).cexp)).mul
      continuous_const) },
  simp [norm_smul, map_prod],
end
end torus_integrable
variables [normed_space â„‚ E] [complete_space E] {f g : â„‚â¿ â†’ E} {c : â„‚â¿} {R : â„â¿}
def torus_integral (f : â„‚â¿ â†’ E) (c : â„‚â¿) (R : â„â¿) :=
âˆ« (Î¸ : â„â¿) in Icc (0 : â„â¿) (Î» _, 2 * Ï€), (âˆ i, R i * exp(Î¸ i * I) * I : â„‚) â€¢ f (torus_map c R Î¸)
notation `âˆ¯` binders ` in ` `T(` c `, ` R `)` `, ` r:(scoped:60 f, torus_integral f c R) := r
lemma torus_integral_radius_zero (hn : n â‰  0) (f : â„‚â¿ â†’ E) (c : â„‚â¿): âˆ¯ x in T(c, 0), f x = 0 :=
by simp only [torus_integral, pi.zero_apply, of_real_zero, mul_zero, zero_mul, fin.prod_const,
  zero_pow' n hn, zero_smul, integral_zero]
lemma torus_integral_neg (f : â„‚â¿ â†’ E) (c : â„‚â¿) (R : â„â¿) :
  âˆ¯ x in T(c, R), -f x = -âˆ¯ x in T(c, R), f x :=
by simp [torus_integral, integral_neg]
lemma torus_integral_add (hf : torus_integrable f c R) (hg : torus_integrable g c R) :
  âˆ¯ x in T(c, R), f x + g x = (âˆ¯ x in T(c, R), f x) + âˆ¯ x in T(c, R), g x :=
by simpa only [torus_integral, smul_add, pi.add_apply]
  using integral_add hf.function_integrable hg.function_integrable
lemma torus_integral_sub (hf : torus_integrable f c R) (hg : torus_integrable g c R) :
  âˆ¯ x in T(c, R), f x - g x = (âˆ¯ x in T(c, R), f x) - âˆ¯ x in T(c, R), g x :=
by simpa only [sub_eq_add_neg, â† torus_integral_neg] using torus_integral_add hf hg.neg
lemma torus_integral_smul {ğ•œ : Type*} [is_R_or_C ğ•œ] [normed_space ğ•œ E] [smul_comm_class ğ•œ â„‚ E]
  (a : ğ•œ) (f : â„‚â¿ â†’ E) (c : â„‚â¿) (R : â„â¿) :
  âˆ¯ x in T(c, R), a â€¢ f x = a â€¢ âˆ¯ x in T(c, R), f x :=
by simp only [torus_integral, integral_smul, â† smul_comm a]
lemma torus_integral_const_mul (a : â„‚) (f : â„‚â¿ â†’ â„‚) (c : â„‚â¿) (R : â„â¿) :
  âˆ¯ x in T(c, R), a * f x = a * âˆ¯ x in T(c, R), f x :=
torus_integral_smul a f c R
lemma norm_torus_integral_le_of_norm_le_const {C : â„} (hf : âˆ€ Î¸, âˆ¥f (torus_map c R Î¸)âˆ¥ â‰¤ C) :
  âˆ¥âˆ¯ x in T(c, R), f xâˆ¥ â‰¤ (2 * Ï€)^(n: â„•) * (âˆ i, |R i|) * C :=
calc âˆ¥âˆ¯ x in T(c, R), f xâˆ¥ â‰¤ (âˆ i, |R i|) * C * (volume (Icc (0 : â„â¿) (Î» _, 2 * Ï€))).to_real :
  norm_set_integral_le_of_norm_le_const' measure_Icc_lt_top measurable_set_Icc $ Î» Î¸ hÎ¸,
    ( calc âˆ¥(âˆ i : fin n, R i * exp (Î¸ i * I) * I : â„‚) â€¢ f (torus_map c R Î¸)âˆ¥
          = (âˆ i : fin n, |R i|) * âˆ¥f (torus_map c R Î¸)âˆ¥ : by simp [norm_smul]
      ... â‰¤ (âˆ i : fin n, |R i|) * C :
        mul_le_mul_of_nonneg_left (hf _) (finset.prod_nonneg $ Î» _ _, abs_nonneg _) )
... = (2 * Ï€)^(n: â„•) * (âˆ i, |R i|) * C :
  by simp only [pi.zero_def, real.volume_Icc_pi_to_real (Î» _, real.two_pi_pos.le), sub_zero,
      fin.prod_const, mul_assoc, mul_comm ((2 * Ï€) ^ (n : â„•))]
@[simp] lemma torus_integral_dim0 (f : â„‚â° â†’ E) (c : â„‚â°) (R : â„â°) : âˆ¯ x in T(c, R), f x = f c :=
by simp only [torus_integral, fin.prod_univ_zero, one_smul,
  subsingleton.elim (Î» i : fin 0, 2 * Ï€) 0, Icc_self, measure.restrict_singleton, volume_pi,
  integral_smul_measure, integral_dirac, measure.pi_of_empty _ 0,
  measure.dirac_apply_of_mem (mem_singleton _), subsingleton.elim (torus_map c R 0) c]
lemma torus_integral_dim1 (f : â„‚Â¹ â†’ E) (c : â„‚Â¹) (R : â„Â¹) :
  âˆ¯ x in T(c, R), f x = âˆ® z in C(c 0, R 0), f (Î» _, z) :=
begin
  have : (Î» (x : â„) (b : fin 1), x) â»Â¹' Icc 0 (Î» _, 2 * Ï€) = Icc 0 (2 * Ï€),
    from (order_iso.fun_unique (fin 1) â„).symm.preimage_Icc _ _,
  simp only [torus_integral, circle_integral, interval_integral.integral_of_le real.two_pi_pos.le,
    measure.restrict_congr_set Ioc_ae_eq_Icc, deriv_circle_map, fin.prod_univ_one,
    â† ((volume_preserving_fun_unique (fin 1) â„).symm _).set_integral_preimage_emb
      (measurable_equiv.measurable_embedding _), this, measurable_equiv.fun_unique_symm_apply],
  simp only [torus_map, circle_map, zero_add],
  rcongr
end
lemma torus_integral_succ_above {f : â„‚â¿âºÂ¹ â†’ E} {c : â„‚â¿âºÂ¹} {R : â„â¿âºÂ¹} (hf : torus_integrable f c R)
  (i : fin (n + 1)) :
  âˆ¯ x in T(c, R), f x =
    âˆ® x in C(c i, R i), âˆ¯ y in T(c âˆ˜ i.succ_above, R âˆ˜ i.succ_above), f (i.insert_nth x y) :=
begin
  set e : â„ Ã— â„â¿ â‰ƒáµ â„â¿âºÂ¹ := (measurable_equiv.pi_fin_succ_above_equiv (Î» _, â„) i).symm,
  have hem : measure_preserving e,
    from (volume_preserving_pi_fin_succ_above_equiv (Î» j : fin (n + 1), â„) i).symm _,
  have heÏ€ : e â»Â¹' (Icc 0 (Î» _, 2 * Ï€)) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc (0 : â„â¿) (Î» _, 2 * Ï€),
    from ((order_iso.pi_fin_succ_above_iso (Î» _, â„) i).symm.preimage_Icc _ _).trans
      (Icc_prod_eq _ _),
  rw [torus_integral, â† hem.map_eq, set_integral_map_equiv, heÏ€, measure.volume_eq_prod,
    set_integral_prod, circle_integral_def_Icc],
  { refine set_integral_congr measurable_set_Icc (Î» Î¸ hÎ¸, _),
    simp only [torus_integral, â† integral_smul, deriv_circle_map, i.prod_univ_succ_above _,
      smul_smul, torus_map, circle_map_zero],
    refine set_integral_congr measurable_set_Icc (Î» Î˜ hÎ˜, _),
    simp only [measurable_equiv.pi_fin_succ_above_equiv_symm_apply, i.insert_nth_apply_same,
      i.insert_nth_apply_succ_above, (âˆ˜)],
    congr' 2,
    simp only [funext_iff, i.forall_iff_succ_above, circle_map, fin.insert_nth_apply_same,
      eq_self_iff_true, fin.insert_nth_apply_succ_above, implies_true_iff, and_self] },
  { have := hf.function_integrable,
    rwa [â† hem.integrable_on_comp_preimage e.measurable_embedding, heÏ€] at this }
end
lemma torus_integral_succ {f : â„‚â¿âºÂ¹ â†’ E} {c : â„‚â¿âºÂ¹} {R : â„â¿âºÂ¹} (hf : torus_integrable f c R) :
  âˆ¯ x in T(c, R), f x =
    âˆ® x in C(c 0, R 0), âˆ¯ y in T(c âˆ˜ fin.succ, R âˆ˜ fin.succ), f (fin.cons x y) :=
by simpa using torus_integral_succ_above hf 0
