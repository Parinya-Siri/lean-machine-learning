import category_theory.category.preorder
import category_theory.limits.is_limit
noncomputable theory
universes v u
open category_theory
open category_theory.limits
namespace category_theory
inductive pairwise (Œπ : Type v)
| single : Œπ ‚Üí pairwise
| pair : Œπ ‚Üí Œπ ‚Üí pairwise
variables {Œπ : Type v}
namespace pairwise
instance pairwise_inhabited [inhabited Œπ] : inhabited (pairwise Œπ) := ‚ü®single default‚ü©
inductive hom : pairwise Œπ ‚Üí pairwise Œπ ‚Üí Type v
| id_single : Œ† i, hom (single i) (single i)
| id_pair : Œ† i j, hom (pair i j) (pair i j)
| left : Œ† i j, hom (pair i j) (single i)
| right : Œ† i j, hom (pair i j) (single j)
open hom
instance hom_inhabited [inhabited Œπ] : inhabited (hom (single (default : Œπ)) (single default)) :=
‚ü®id_single default‚ü©
def id : Œ† (o : pairwise Œπ), hom o o
| (single i) := id_single i
| (pair i j) := id_pair i j
def comp : Œ† {o‚ÇÅ o‚ÇÇ o‚ÇÉ : pairwise Œπ} (f : hom o‚ÇÅ o‚ÇÇ) (g : hom o‚ÇÇ o‚ÇÉ), hom o‚ÇÅ o‚ÇÉ
| _ _ _ (id_single i) g := g
| _ _ _ (id_pair i j) g := g
| _ _ _ (left i j) (id_single _) := left i j
| _ _ _ (right i j) (id_single _) := right i j
section
local attribute [tidy] tactic.case_bash
instance : category (pairwise Œπ) :=
{ hom := hom,
  id := id,
  comp := Œª X Y Z f g, comp f g, }
end
variables {Œ± : Type v} (U : Œπ ‚Üí Œ±)
section
variables [semilattice_inf Œ±]
@[simp]
def diagram_obj : pairwise Œπ ‚Üí Œ±
| (single i) := U i
| (pair i j) := U i ‚äì U j
@[simp]
def diagram_map : Œ† {o‚ÇÅ o‚ÇÇ : pairwise Œπ} (f : o‚ÇÅ ‚ü∂ o‚ÇÇ), diagram_obj U o‚ÇÅ ‚ü∂ diagram_obj U o‚ÇÇ
| _ _ (id_single i) := ùüô _
| _ _ (id_pair i j) := ùüô _
| _ _ (left i j) := hom_of_le inf_le_left
| _ _ (right i j) := hom_of_le inf_le_right
@[simps]
def diagram : pairwise Œπ ‚•§ Œ± :=
{ obj := diagram_obj U,
  map := Œª X Y f, diagram_map U f, }
end
section
def cocone_Œπ_app : Œ† (o : pairwise Œπ), diagram_obj U o ‚ü∂ supr U
| (single i) := hom_of_le (le_supr U i)
| (pair i j) := hom_of_le inf_le_left ‚â´ hom_of_le (le_supr U i)
@[simps]
def cocone : cocone (diagram U) :=
{ X := supr U,
  Œπ := { app := cocone_Œπ_app U, } }
def cocone_is_colimit : is_colimit (cocone U) :=
{ desc := Œª s, hom_of_le
  begin
    apply complete_lattice.Sup_le,
    rintros _ ‚ü®j, rfl‚ü©,
    exact (s.Œπ.app (single j)).le
  end }
end
end pairwise
end category_theory
