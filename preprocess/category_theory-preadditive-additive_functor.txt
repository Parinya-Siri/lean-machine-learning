import category_theory.limits.preserves.shapes.biproducts
import category_theory.preadditive.functor_category
namespace category_theory
class functor.additive {C D : Type*} [category C] [category D]
  [preadditive C] [preadditive D] (F : C ‚•§ D) : Prop :=
(map_add' : Œ† {X Y : C} {f g : X ‚ü∂ Y}, F.map (f + g) = F.map f + F.map g . obviously)
section preadditive
namespace functor
section
variables {C D : Type*} [category C] [category D] [preadditive C]
  [preadditive D] (F : C ‚•§ D) [functor.additive F]
@[simp]
lemma map_add {X Y : C} {f g : X ‚ü∂ Y} : F.map (f + g) = F.map f + F.map g :=
functor.additive.map_add'
@[simps {fully_applied := ff}]
def map_add_hom {X Y : C} : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y) :=
add_monoid_hom.mk' (Œª f, F.map f) (Œª f g, F.map_add)
lemma coe_map_add_hom {X Y : C} : ‚áë(F.map_add_hom : (X ‚ü∂ Y) ‚Üí+ _) = @map C _ D _ F X Y := rfl
@[priority 100]
instance preserves_zero_morphisms_of_additive : preserves_zero_morphisms F :=
{ map_zero' := Œª X Y, F.map_add_hom.map_zero }
instance : additive (ùü≠ C) :=
{}
instance {E : Type*} [category E] [preadditive E] (G : D ‚•§ E) [functor.additive G] :
  additive (F ‚ãô G) :=
{}
@[simp]
lemma map_neg {X Y : C} {f : X ‚ü∂ Y} : F.map (-f) = - F.map f :=
(F.map_add_hom : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y)).map_neg _
@[simp]
lemma map_sub {X Y : C} {f g : X ‚ü∂ Y} : F.map (f - g) = F.map f - F.map g :=
(F.map_add_hom : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y)).map_sub _ _
@[derive category, nolint has_inhabited_instance]
def AdditiveFunctor :=
{ F : C ‚•§ D // functor.additive F }
infixr ` ‚•§+ `:26 := AdditiveFunctor
instance : preadditive (C ‚•§+ D) :=
preadditive.induced_category.category _
@[derive full, derive faithful]
def AdditiveFunctor.forget : (C ‚•§+ D) ‚•§ (C ‚•§ D) :=
full_subcategory_inclusion _
variables {C D}
def AdditiveFunctor.of (F : C ‚•§ D) [F.additive] : C ‚•§+ D :=
‚ü®F, infer_instance‚ü©
@[simp]
lemma AdditiveFunctor.of_fst (F : C ‚•§ D) [F.additive] : (AdditiveFunctor.of F).1 = F :=
rfl
@[simp]
lemma AdditiveFunctor.forget_obj (F : C ‚•§+ D) : (AdditiveFunctor.forget C D).obj F = F.1 :=
rfl
lemma AdditiveFunctor.forget_obj_of (F : C ‚•§ D) [F.additive] :
  (AdditiveFunctor.forget C D).obj (AdditiveFunctor.of F) = F :=
rfl
@[simp]
lemma AdditiveFunctor.forget_map (F G : C ‚•§+ D) (Œ± : F ‚ü∂ G) :
  (AdditiveFunctor.forget C D).map Œ± = Œ± :=
rfl
instance : functor.additive (AdditiveFunctor.forget C D) :=
{ map_add' := Œª F G Œ± Œ≤, rfl }
instance (F : C ‚•§+ D) : functor.additive F.1 :=
F.2
end
end preadditive
end category_theory
