import algebra.algebra.subalgebra.basic
import algebra.free_algebra
import algebra.category.Ring.basic
import algebra.category.Module.basic
open category_theory
open category_theory.limits
universes v u
variables (R : Type u) [comm_ring R]
structure Algebra :=
(carrier : Type v)
[is_ring : ring carrier]
[is_algebra : algebra R carrier]
attribute [instance] Algebra.is_ring Algebra.is_algebra
namespace Algebra
instance : has_coe_to_sort (Algebra R) (Type v) := ‚ü®Algebra.carrier‚ü©
instance : category (Algebra.{v} R) :=
{ hom   := Œª A B, A ‚Üí‚Çê[R] B,
  id    := Œª A, alg_hom.id R A,
  comp  := Œª A B C f g, g.comp f }
instance : concrete_category.{v} (Algebra.{v} R) :=
{ forget := { obj := Œª R, R, map := Œª R S f, (f : R ‚Üí S) },
  forget_faithful := { } }
instance has_forget_to_Ring : has_forget‚ÇÇ (Algebra.{v} R) Ring.{v} :=
{ forget‚ÇÇ :=
  { obj := Œª A, Ring.of A,
    map := Œª A‚ÇÅ A‚ÇÇ f, alg_hom.to_ring_hom f, } }
instance has_forget_to_Module : has_forget‚ÇÇ (Algebra.{v} R) (Module.{v} R) :=
{ forget‚ÇÇ :=
  { obj := Œª M, Module.of R M,
    map := Œª M‚ÇÅ M‚ÇÇ f, alg_hom.to_linear_map f, } }
def of (X : Type v) [ring X] [algebra R X] : Algebra.{v} R := ‚ü®X‚ü©
def of_hom {R : Type u} [comm_ring R] {X Y : Type v} [ring X] [algebra R X] [ring Y] [algebra R Y]
  (f : X ‚Üí‚Çê[R] Y) : of R X ‚ü∂ of R Y := f
@[simp] lemma of_hom_apply {R : Type u} [comm_ring R]
  {X Y : Type v} [ring X] [algebra R X] [ring Y] [algebra R Y] (f : X ‚Üí‚Çê[R] Y) (x : X) :
  of_hom f x = f x := rfl
instance : inhabited (Algebra R) := ‚ü®of R R‚ü©
@[simp]
lemma coe_of (X : Type u) [ring X] [algebra R X] : (of R X : Type u) = X := rfl
variables {R}
@[simps]
def of_self_iso (M : Algebra.{v} R) : Algebra.of R M ‚âÖ M :=
{ hom := ùüô M, inv := ùüô M }
variables {R} {M N U : Module.{v} R}
@[simp] lemma id_apply (m : M) : (ùüô M : M ‚Üí M) m = m := rfl
@[simp] lemma coe_comp (f : M ‚ü∂ N) (g : N ‚ü∂ U) :
  ((f ‚â´ g) : M ‚Üí U) = g ‚àò f := rfl
variables (R)
@[simps]
def free : Type u ‚•§ Algebra.{u} R :=
{ obj := Œª S,
  { carrier := free_algebra R S,
    is_ring := algebra.semiring_to_ring R },
  map := Œª S T f, free_algebra.lift _ $ (free_algebra.Œπ _) ‚àò f,
def adj : free.{u} R ‚ä£ forget (Algebra.{u} R) :=
adjunction.mk_of_hom_equiv
{ hom_equiv := Œª X A, (free_algebra.lift _).symm,
@[simps]
def alg_equiv.to_Algebra_iso
  {g‚ÇÅ : ring X‚ÇÅ} {g‚ÇÇ : ring X‚ÇÇ} {m‚ÇÅ : algebra R X‚ÇÅ} {m‚ÇÇ : algebra R X‚ÇÇ} (e : X‚ÇÅ ‚âÉ‚Çê[R] X‚ÇÇ) :
  Algebra.of R X‚ÇÅ ‚âÖ Algebra.of R X‚ÇÇ :=
{ hom := (e : X‚ÇÅ ‚Üí‚Çê[R] X‚ÇÇ),
  inv := (e.symm : X‚ÇÇ ‚Üí‚Çê[R] X‚ÇÅ),
  hom_inv_id' := begin ext, exact e.left_inv x, end,
  inv_hom_id' := begin ext, exact e.right_inv x, end, }
namespace category_theory.iso
@[simps]
def to_alg_equiv {X Y : Algebra R} (i : X ‚âÖ Y) : X ‚âÉ‚Çê[R] Y :=
{ to_fun    := i.hom,
  inv_fun   := i.inv,
  left_inv  := by tidy,
  right_inv := by tidy,
  map_add'  := by tidy,
  map_mul'  := by tidy,
  commutes' := by tidy, }.
end category_theory.iso
@[simps]
def alg_equiv_iso_Algebra_iso {X Y : Type u}
  [ring X] [ring Y] [algebra R X] [algebra R Y] :
  (X ‚âÉ‚Çê[R] Y) ‚âÖ (Algebra.of R X ‚âÖ Algebra.of R Y) :=
{ hom := Œª e, e.to_Algebra_iso,
  inv := Œª i, i.to_alg_equiv, }
instance (X : Type u) [ring X] [algebra R X] : has_coe (subalgebra R X) (Algebra R) :=
‚ü® Œª N, Algebra.of R N ‚ü©
instance Algebra.forget_reflects_isos : reflects_isomorphisms (forget (Algebra.{u} R)) :=
{ reflects := Œª X Y f _,
  begin
    resetI,
    let i := as_iso ((forget (Algebra.{u} R)).map f),
    let e : X ‚âÉ‚Çê[R] Y := { ..f, ..i.to_equiv },
    exact ‚ü®(is_iso.of_iso e.to_Algebra_iso).1‚ü©,
  end }
