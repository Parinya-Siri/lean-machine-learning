import analysis.calculus.deriv
import measure_theory.constructions.borel_space
import measure_theory.function.strongly_measurable
import tactic.ring_exp
noncomputable theory
open set metric asymptotics filter continuous_linear_map
open topological_space (second_countable_topology) measure_theory
open_locale topological_space
namespace continuous_linear_map
variables {ğ•œ E F : Type*} [nondiscrete_normed_field ğ•œ]
  [normed_group E] [normed_space ğ•œ E] [normed_group F] [normed_space ğ•œ F]
lemma measurable_applyâ‚‚ [measurable_space E] [opens_measurable_space E]
  [second_countable_topology E] [second_countable_topology (E â†’L[ğ•œ] F)]
  [measurable_space F] [borel_space F] :
  measurable (Î» p : (E â†’L[ğ•œ] F) Ã— E, p.1 p.2) :=
is_bounded_bilinear_map_apply.continuous.measurable
end continuous_linear_map
section fderiv
variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
variables {E : Type*} [normed_group E] [normed_space ğ•œ E]
variables {F : Type*} [normed_group F] [normed_space ğ•œ F]
variables {f : E â†’ F} (K : set (E â†’L[ğ•œ] F))
namespace fderiv_measurable_aux
def A (f : E â†’ F) (L : E â†’L[ğ•œ] F) (r Îµ : â„) : set E :=
{x | âˆƒ r' âˆˆ Ioc (r/2) r, âˆ€ y z âˆˆ ball x r', âˆ¥f z - f y - L (z-y)âˆ¥ â‰¤ Îµ * r}
def B (f : E â†’ F) (K : set (E â†’L[ğ•œ] F)) (r s Îµ : â„) : set E :=
â‹ƒ (L âˆˆ K), (A f L r Îµ) âˆ© (A f L s Îµ)
def D (f : E â†’ F) (K : set (E â†’L[ğ•œ] F)) : set E :=
â‹‚ (e : â„•), â‹ƒ (n : â„•), â‹‚ (p â‰¥ n) (q â‰¥ n), B f K ((1/2) ^ p) ((1/2) ^ q) ((1/2) ^ e)
lemma is_open_A (L : E â†’L[ğ•œ] F) (r Îµ : â„) : is_open (A f L r Îµ) :=
begin
  rw metric.is_open_iff,
  rintros x âŸ¨r', r'_mem, hr'âŸ©,
  obtain âŸ¨s, s_gt, s_ltâŸ© : âˆƒ (s : â„), r / 2 < s âˆ§ s < r' := exists_between r'_mem.1,
  have : s âˆˆ Ioc (r/2) r := âŸ¨s_gt, le_of_lt (s_lt.trans_le r'_mem.2)âŸ©,
  refine âŸ¨r' - s, by linarith, Î» x' hx', âŸ¨s, this, _âŸ©âŸ©,
  have B : ball x' s âŠ† ball x r' := ball_subset (le_of_lt hx'),
  assume y hy z hz,
  exact hr' y (B hy) z (B hz)
end
lemma is_open_B {K : set (E â†’L[ğ•œ] F)} {r s Îµ : â„} : is_open (B f K r s Îµ) :=
by simp [B, is_open_Union, is_open.inter, is_open_A]
lemma A_mono (L : E â†’L[ğ•œ] F) (r : â„) {Îµ Î´ : â„} (h : Îµ â‰¤ Î´) :
  A f L r Îµ âŠ† A f L r Î´ :=
begin
  rintros x âŸ¨r', r'r, hr'âŸ©,
  refine âŸ¨r', r'r, Î» y hy z hz, (hr' y hy z hz).trans (mul_le_mul_of_nonneg_right h _)âŸ©,
  linarith [mem_ball.1 hy, r'r.2, @dist_nonneg _ _ y x],
end
lemma le_of_mem_A {r Îµ : â„} {L : E â†’L[ğ•œ] F} {x : E} (hx : x âˆˆ A f L r Îµ)
  {y z : E} (hy : y âˆˆ closed_ball x (r/2)) (hz : z âˆˆ closed_ball x (r/2)) :
  âˆ¥f z - f y - L (z-y)âˆ¥ â‰¤ Îµ * r :=
begin
  rcases hx with âŸ¨r', r'mem, hr'âŸ©,
  exact hr' _ ((mem_closed_ball.1 hy).trans_lt r'mem.1) _ ((mem_closed_ball.1 hz).trans_lt r'mem.1)
end
lemma mem_A_of_differentiable {Îµ : â„} (hÎµ : 0 < Îµ) {x : E} (hx : differentiable_at ğ•œ f x) :
  âˆƒ R > 0, âˆ€ r âˆˆ Ioo (0 : â„) R, x âˆˆ A f (fderiv ğ•œ f x) r Îµ :=
begin
  have := hx.has_fderiv_at,
  simp only [has_fderiv_at, has_fderiv_at_filter, is_o_iff] at this,
  rcases eventually_nhds_iff_ball.1 (this (half_pos hÎµ)) with âŸ¨R, R_pos, hRâŸ©,
  refine âŸ¨R, R_pos, Î» r hr, _âŸ©,
  have : r âˆˆ Ioc (r/2) r := âŸ¨half_lt_self hr.1, le_rflâŸ©,
  refine âŸ¨r, this, Î» y hy z hz, _âŸ©,
  calc  âˆ¥f z - f y - (fderiv ğ•œ f x) (z - y)âˆ¥
      = âˆ¥(f z - f x - (fderiv ğ•œ f x) (z - x)) - (f y - f x - (fderiv ğ•œ f x) (y - x))âˆ¥ :
    by { congr' 1, simp only [continuous_linear_map.map_sub], abel }
  ... â‰¤ âˆ¥(f z - f x - (fderiv ğ•œ f x) (z - x))âˆ¥ + âˆ¥f y - f x - (fderiv ğ•œ f x) (y - x)âˆ¥ :
    norm_sub_le _ _
  ... â‰¤ Îµ / 2 * âˆ¥z - xâˆ¥ + Îµ / 2 * âˆ¥y - xâˆ¥ :
    add_le_add (hR _ (lt_trans (mem_ball.1 hz) hr.2)) (hR _ (lt_trans (mem_ball.1 hy) hr.2))
  ... â‰¤ Îµ / 2 * r + Îµ / 2 * r :
    add_le_add
      (mul_le_mul_of_nonneg_left (le_of_lt (mem_ball_iff_norm.1 hz)) (le_of_lt (half_pos hÎµ)))
      (mul_le_mul_of_nonneg_left (le_of_lt (mem_ball_iff_norm.1 hy)) (le_of_lt (half_pos hÎµ)))
  ... = Îµ * r : by ring
end
lemma norm_sub_le_of_mem_A {c : ğ•œ} (hc : 1 < âˆ¥câˆ¥)
  {r Îµ : â„} (hÎµ : 0 < Îµ) (hr : 0 < r) {x : E} {Lâ‚ Lâ‚‚ : E â†’L[ğ•œ] F}
  (hâ‚ : x âˆˆ A f Lâ‚ r Îµ) (hâ‚‚ : x âˆˆ A f Lâ‚‚ r Îµ) : âˆ¥Lâ‚ - Lâ‚‚âˆ¥ â‰¤ 4 * âˆ¥câˆ¥ * Îµ :=
begin
  have : 0 â‰¤ 4 * âˆ¥câˆ¥ * Îµ :=
    mul_nonneg (mul_nonneg (by norm_num : (0 : â„) â‰¤ 4) (norm_nonneg _)) hÎµ.le,
  refine op_norm_le_of_shell (half_pos hr) this hc _,
  assume y ley ylt,
  rw [div_div,
      div_le_iff' (mul_pos (by norm_num : (0 : â„) < 2) (zero_lt_one.trans hc))] at ley,
  calc âˆ¥(Lâ‚ - Lâ‚‚) yâˆ¥
        = âˆ¥(f (x + y) - f x - Lâ‚‚ ((x + y) - x)) - (f (x + y) - f x - Lâ‚ ((x + y) - x))âˆ¥ : by simp
    ... â‰¤ âˆ¥(f (x + y) - f x - Lâ‚‚ ((x + y) - x))âˆ¥ + âˆ¥(f (x + y) - f x - Lâ‚ ((x + y) - x))âˆ¥ :
      norm_sub_le _ _
    ... â‰¤ Îµ * r + Îµ * r :
      begin
        apply add_le_add,
        { apply le_of_mem_A hâ‚‚,
          { simp only [le_of_lt (half_pos hr), mem_closed_ball, dist_self] },
          { simp only [dist_eq_norm, add_sub_cancel', mem_closed_ball, ylt.le], } },
        { apply le_of_mem_A hâ‚,
          { simp only [le_of_lt (half_pos hr), mem_closed_ball, dist_self] },
          { simp only [dist_eq_norm, add_sub_cancel', mem_closed_ball, ylt.le] } },
      end
    ... = 2 * Îµ * r : by ring
    ... â‰¤ 2 * Îµ * (2 * âˆ¥câˆ¥ * âˆ¥yâˆ¥) : mul_le_mul_of_nonneg_left ley (mul_nonneg (by norm_num) hÎµ.le)
    ... = 4 * âˆ¥câˆ¥ * Îµ * âˆ¥yâˆ¥ : by ring
end
lemma differentiable_set_subset_D : {x | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K} âŠ† D f K :=
begin
  assume x hx,
  rw [D, mem_Inter],
  assume e,
  have : (0 : â„) < (1/2) ^ e := pow_pos (by norm_num) _,
  rcases mem_A_of_differentiable this hx.1 with âŸ¨R, R_pos, hRâŸ©,
  obtain âŸ¨n, hnâŸ© : âˆƒ (n : â„•), (1/2) ^ n < R :=
    exists_pow_lt_of_lt_one R_pos (by norm_num : (1 : â„)/2 < 1),
  simp only [mem_Union, mem_Inter, B, mem_inter_eq],
  refine âŸ¨n, Î» p hp q hq, âŸ¨fderiv ğ•œ f x, hx.2, âŸ¨_, _âŸ©âŸ©âŸ©;
  { refine hR _ âŸ¨pow_pos (by norm_num) _, lt_of_le_of_lt _ hnâŸ©,
    exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption) }
end
lemma D_subset_differentiable_set {K : set (E â†’L[ğ•œ] F)} (hK : is_complete K) :
  D f K âŠ† {x | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K} :=
begin
  have P : âˆ€ {n : â„•}, (0 : â„) < (1/2) ^ n := pow_pos (by norm_num),
  rcases normed_field.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©,
  have cpos : 0 < âˆ¥câˆ¥ := lt_trans zero_lt_one hc,
  assume x hx,
  have : âˆ€ (e : â„•), âˆƒ (n : â„•), âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’ âˆƒ L âˆˆ K,
    x âˆˆ A f L ((1/2) ^ p) ((1/2) ^ e) âˆ© A f L ((1/2) ^ q) ((1/2) ^ e),
  { assume e,
    have := mem_Inter.1 hx e,
    rcases mem_Union.1 this with âŸ¨n, hnâŸ©,
    refine âŸ¨n, Î» p q hp hq, _âŸ©,
    simp only [mem_Inter, ge_iff_le] at hn,
    rcases mem_Union.1 (hn p hp q hq) with âŸ¨L, hLâŸ©,
    exact âŸ¨L, mem_Union.1 hLâŸ©, },
  choose! n L hn using this,
  have M : âˆ€ e p q e' p' q', n e â‰¤ p â†’ n e â‰¤ q â†’ n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’
    âˆ¥L e p q - L e' p' q'âˆ¥ â‰¤ 12 * âˆ¥câˆ¥ * (1/2) ^ e,
  { assume e p q e' p' q' hp hq hp' hq' he',
    let r := max (n e) (n e'),
    have I : ((1:â„)/2)^e' â‰¤ (1/2)^e := pow_le_pow_of_le_one (by norm_num) (by norm_num) he',
    have J1 : âˆ¥L e p q - L e p râˆ¥ â‰¤ 4 * âˆ¥câˆ¥ * (1/2)^e,
    { have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1/2)^e) :=
        (hn e p q hp hq).2.1,
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1/2)^e) :=
        (hn e p r hp (le_max_left _ _)).2.1,
      exact norm_sub_le_of_mem_A hc P P I1 I2 },
    have J2 : âˆ¥L e p r - L e' p' râˆ¥ â‰¤ 4 * âˆ¥câˆ¥ * (1/2)^e,
    { have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1/2)^e) :=
        (hn e p r hp (le_max_left _ _)).2.2,
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1/2)^e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2,
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2) },
    have J3 : âˆ¥L e' p' r - L e' p' q'âˆ¥ â‰¤ 4 * âˆ¥câˆ¥ * (1/2)^e,
    { have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1/2)^e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1,
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1/2)^e') :=
        (hn e' p' q' hp' hq').2.1,
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2) },
    calc âˆ¥L e p q - L e' p' q'âˆ¥
          = âˆ¥(L e p q - L e p r) + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')âˆ¥ :
        by { congr' 1, abel }
      ... â‰¤ âˆ¥L e p q - L e p râˆ¥ + âˆ¥L e p r - L e' p' râˆ¥ + âˆ¥L e' p' r - L e' p' q'âˆ¥ :
        le_trans (norm_add_le _ _) (add_le_add_right (norm_add_le _ _) _)
      ... â‰¤ 4 * âˆ¥câˆ¥ * (1/2)^e + 4 * âˆ¥câˆ¥ * (1/2)^e + 4 * âˆ¥câˆ¥ * (1/2)^e :
        by apply_rules [add_le_add]
      ... = 12 * âˆ¥câˆ¥ * (1/2)^e : by ring },
  let L0 : â„• â†’ (E â†’L[ğ•œ] F) := Î» e, L e (n e) (n e),
  have : cauchy_seq L0,
  { rw metric.cauchy_seq_iff',
    assume Îµ Îµpos,
    obtain âŸ¨e, heâŸ© : âˆƒ (e : â„•), (1/2) ^ e < Îµ / (12 * âˆ¥câˆ¥) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos (mul_pos (by norm_num) cpos)) (by norm_num),
    refine âŸ¨e, Î» e' he', _âŸ©,
    rw [dist_comm, dist_eq_norm],
    calc âˆ¥L0 e - L0 e'âˆ¥
          â‰¤ 12 * âˆ¥câˆ¥ * (1/2)^e : M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      ... < 12 * âˆ¥câˆ¥ * (Îµ / (12 * âˆ¥câˆ¥)) :
        mul_lt_mul' le_rfl he (le_of_lt P) (mul_pos (by norm_num) cpos)
      ... = Îµ : by { field_simp [(by norm_num : (12 : â„) â‰  0), ne_of_gt cpos], ring } },
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, tendsto L0 at_top (ğ“ f') :=
    cauchy_seq_tendsto_of_is_complete hK (Î» e, (hn e (n e) (n e) le_rfl le_rfl).1) this,
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ âˆ¥L e (n e) p - f'âˆ¥ â‰¤ 12 * âˆ¥câˆ¥ * (1/2)^e,
  { assume e p hp,
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm,
    rw eventually_at_top,
    exact âŸ¨e, Î» e' he', M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ© },
  have : has_fderiv_at f f' x,
  { simp only [has_fderiv_at_iff_is_o_nhds_zero, is_o_iff],
    assume Îµ Îµpos,
    have pos : 0 < 4 + 12 * âˆ¥câˆ¥ :=
      add_pos_of_pos_of_nonneg (by norm_num) (mul_nonneg (by norm_num) (norm_nonneg _)),
    obtain âŸ¨e, heâŸ© : âˆƒ (e : â„•), (1 / 2) ^ e < Îµ / (4 + 12 * âˆ¥câˆ¥) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num),
    rw eventually_nhds_iff_ball,
    refine âŸ¨(1/2) ^ (n e + 1), P, Î» y hy, _âŸ©,
theorem measurable_set_of_differentiable_at_of_is_complete
  {K : set (E â†’L[ğ•œ] F)} (hK : is_complete K) :
  measurable_set {x | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K} :=
by simp [differentiable_set_eq_D K hK, D, is_open_B.measurable_set, measurable_set.Inter_Prop,
         measurable_set.Inter, measurable_set.Union]
variable [complete_space F]
theorem measurable_set_of_differentiable_at :
  measurable_set {x | differentiable_at ğ•œ f x} :=
begin
  have : is_complete (univ : set (E â†’L[ğ•œ] F)) := complete_univ,
  convert measurable_set_of_differentiable_at_of_is_complete ğ•œ f this,
  simp
end
@[measurability] lemma measurable_fderiv : measurable (fderiv ğ•œ f) :=
begin
  refine measurable_of_is_closed (Î» s hs, _),
  have : fderiv ğ•œ f â»Â¹' s = {x | differentiable_at ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ s} âˆª
    ({x | Â¬differentiable_at ğ•œ f x} âˆ© {x | (0 : E â†’L[ğ•œ] F) âˆˆ s}) :=
    set.ext (Î» x, mem_preimage.trans fderiv_mem_iff),
  rw this,
  exact (measurable_set_of_differentiable_at_of_is_complete _ _ hs.is_complete).union
    ((measurable_set_of_differentiable_at _ _).compl.inter (measurable_set.const _))
end
@[measurability] lemma measurable_fderiv_apply_const [measurable_space F] [borel_space F] (y : E) :
  measurable (Î» x, fderiv ğ•œ f x y) :=
(continuous_linear_map.measurable_apply y).comp (measurable_fderiv ğ•œ f)
variable {ğ•œ}
@[measurability] lemma measurable_deriv [measurable_space ğ•œ] [opens_measurable_space ğ•œ]
  [measurable_space F] [borel_space F] (f : ğ•œ â†’ F) : measurable (deriv f) :=
by simpa only [fderiv_deriv] using measurable_fderiv_apply_const ğ•œ f 1
lemma strongly_measurable_deriv [measurable_space ğ•œ] [opens_measurable_space ğ•œ]
  [second_countable_topology F] (f : ğ•œ â†’ F) :
  strongly_measurable (deriv f) :=
by { borelize F, exact (measurable_deriv f).strongly_measurable }
lemma ae_measurable_deriv [measurable_space ğ•œ] [opens_measurable_space ğ•œ] [measurable_space F]
  [borel_space F] (f : ğ•œ â†’ F) (Î¼ : measure ğ•œ) : ae_measurable (deriv f) Î¼ :=
(measurable_deriv f).ae_measurable
lemma ae_strongly_measurable_deriv [measurable_space ğ•œ] [opens_measurable_space ğ•œ]
  [second_countable_topology F] (f : ğ•œ â†’ F) (Î¼ : measure ğ•œ) :
  ae_strongly_measurable (deriv f) Î¼ :=
(strongly_measurable_deriv f).ae_strongly_measurable
end fderiv
section right_deriv
variables {F : Type*} [normed_group F] [normed_space â„ F]
variables {f : â„ â†’ F} (K : set F)
namespace right_deriv_measurable_aux
def A (f : â„ â†’ F) (L : F) (r Îµ : â„) : set â„ :=
{x | âˆƒ r' âˆˆ Ioc (r/2) r, âˆ€ y z âˆˆ Icc x (x + r'), âˆ¥f z - f y - (z-y) â€¢ Lâˆ¥ â‰¤ Îµ * r}
def B (f : â„ â†’ F) (K : set F) (r s Îµ : â„) : set â„ :=
â‹ƒ (L âˆˆ K), (A f L r Îµ) âˆ© (A f L s Îµ)
def D (f : â„ â†’ F) (K : set F) : set â„ :=
â‹‚ (e : â„•), â‹ƒ (n : â„•), â‹‚ (p â‰¥ n) (q â‰¥ n), B f K ((1/2) ^ p) ((1/2) ^ q) ((1/2) ^ e)
lemma A_mem_nhds_within_Ioi {L : F} {r Îµ x : â„} (hx : x âˆˆ A f L r Îµ) :
  A f L r Îµ âˆˆ ğ“[>] x :=
begin
  rcases hx with âŸ¨r', rr', hr'âŸ©,
  rw mem_nhds_within_Ioi_iff_exists_Ioo_subset,
  obtain âŸ¨s, s_gt, s_ltâŸ© : âˆƒ (s : â„), r / 2 < s âˆ§ s < r' := exists_between rr'.1,
  have : s âˆˆ Ioc (r/2) r := âŸ¨s_gt, le_of_lt (s_lt.trans_le rr'.2)âŸ©,
  refine âŸ¨x + r' - s, by { simp only [mem_Ioi], linarith }, Î» x' hx', âŸ¨s, this, _âŸ©âŸ©,
  have A : Icc x' (x' + s) âŠ† Icc x (x + r'),
  { apply Icc_subset_Icc hx'.1.le,
    linarith [hx'.2] },
  assume y hy z hz,
  exact hr' y (A hy) z (A hz)
end
lemma B_mem_nhds_within_Ioi {K : set F} {r s Îµ x : â„} (hx : x âˆˆ B f K r s Îµ) :
  B f K r s Îµ âˆˆ ğ“[>] x :=
begin
  obtain âŸ¨L, LK, hLâ‚, hLâ‚‚âŸ© : âˆƒ (L : F), L âˆˆ K âˆ§ x âˆˆ A f L r Îµ âˆ§ x âˆˆ A f L s Îµ,
    by simpa only [B, mem_Union, mem_inter_eq, exists_prop] using hx,
  filter_upwards [A_mem_nhds_within_Ioi hLâ‚, A_mem_nhds_within_Ioi hLâ‚‚] with y hyâ‚ hyâ‚‚,
  simp only [B, mem_Union, mem_inter_eq, exists_prop],
  exact âŸ¨L, LK, hyâ‚, hyâ‚‚âŸ©
end
lemma measurable_set_B {K : set F} {r s Îµ : â„} : measurable_set (B f K r s Îµ) :=
measurable_set_of_mem_nhds_within_Ioi (Î» x hx, B_mem_nhds_within_Ioi hx)
lemma A_mono (L : F) (r : â„) {Îµ Î´ : â„} (h : Îµ â‰¤ Î´) :
  A f L r Îµ âŠ† A f L r Î´ :=
begin
  rintros x âŸ¨r', r'r, hr'âŸ©,
  refine âŸ¨r', r'r, Î» y hy z hz, (hr' y hy z hz).trans (mul_le_mul_of_nonneg_right h _)âŸ©,
  linarith [hy.1, hy.2, r'r.2],
end
lemma le_of_mem_A {r Îµ : â„} {L : F} {x : â„} (hx : x âˆˆ A f L r Îµ)
  {y z : â„} (hy : y âˆˆ Icc x (x + r/2)) (hz : z âˆˆ Icc x (x + r/2)) :
  âˆ¥f z - f y - (z-y) â€¢ Lâˆ¥ â‰¤ Îµ * r :=
begin
  rcases hx with âŸ¨r', r'mem, hr'âŸ©,
  have A : x + r / 2 â‰¤ x + r', by linarith [r'mem.1],
  exact hr' _ ((Icc_subset_Icc le_rfl A) hy) _ ((Icc_subset_Icc le_rfl A) hz),
end
lemma mem_A_of_differentiable {Îµ : â„} (hÎµ : 0 < Îµ) {x : â„}
  (hx : differentiable_within_at â„ f (Ici x) x) :
  âˆƒ R > 0, âˆ€ r âˆˆ Ioo (0 : â„) R, x âˆˆ A f (deriv_within f (Ici x) x) r Îµ :=
begin
  have := hx.has_deriv_within_at,
  simp_rw [has_deriv_within_at_iff_is_o, is_o_iff] at this,
  rcases mem_nhds_within_Ici_iff_exists_Ico_subset.1 (this (half_pos hÎµ)) with âŸ¨m, xm, hmâŸ©,
  refine âŸ¨m - x, by linarith [show x < m, from xm], Î» r hr, _âŸ©,
  have : r âˆˆ Ioc (r/2) r := âŸ¨half_lt_self hr.1, le_rflâŸ©,
  refine âŸ¨r, this, Î» y hy z hz, _âŸ©,
  calc  âˆ¥f z - f y - (z - y) â€¢ deriv_within f (Ici x) xâˆ¥
      = âˆ¥(f z - f x - (z - x) â€¢ deriv_within f (Ici x) x)
           - (f y - f x - (y - x) â€¢ deriv_within f (Ici x) x)âˆ¥ :
    by { congr' 1, simp only [sub_smul], abel }
  ... â‰¤ âˆ¥f z - f x - (z - x) â€¢ deriv_within f (Ici x) xâˆ¥
         + âˆ¥f y - f x - (y - x) â€¢ deriv_within f (Ici x) xâˆ¥ :
    norm_sub_le _ _
  ... â‰¤ Îµ / 2 * âˆ¥z - xâˆ¥ + Îµ / 2 * âˆ¥y - xâˆ¥ :
    add_le_add (hm âŸ¨hz.1, hz.2.trans_lt (by linarith [hr.2])âŸ©)
               (hm âŸ¨hy.1, hy.2.trans_lt (by linarith [hr.2])âŸ©)
  ... â‰¤ Îµ / 2 * r + Îµ / 2 * r :
  begin
    apply add_le_add,
    { apply mul_le_mul_of_nonneg_left _ (le_of_lt (half_pos hÎµ)),
      rw [real.norm_of_nonneg];
      linarith [hz.1, hz.2] },
    { apply mul_le_mul_of_nonneg_left _ (le_of_lt (half_pos hÎµ)),
      rw [real.norm_of_nonneg];
      linarith [hy.1, hy.2] },
   end
  ... = Îµ * r : by ring
end
lemma norm_sub_le_of_mem_A
  {r x : â„} (hr : 0 < r) (Îµ : â„) {Lâ‚ Lâ‚‚ : F}
  (hâ‚ : x âˆˆ A f Lâ‚ r Îµ) (hâ‚‚ : x âˆˆ A f Lâ‚‚ r Îµ) : âˆ¥Lâ‚ - Lâ‚‚âˆ¥ â‰¤ 4 * Îµ :=
begin
  suffices H : âˆ¥(r/2) â€¢ (Lâ‚ - Lâ‚‚)âˆ¥ â‰¤ (r / 2) * (4 * Îµ),
    by rwa [norm_smul, real.norm_of_nonneg (half_pos hr).le, mul_le_mul_left (half_pos hr)] at H,
  calc
  âˆ¥(r/2) â€¢ (Lâ‚ - Lâ‚‚)âˆ¥
      = âˆ¥(f (x + r/2) - f x - (x + r/2 - x) â€¢ Lâ‚‚) - (f (x + r/2) - f x - (x + r/2 - x) â€¢ Lâ‚)âˆ¥ :
    by simp [smul_sub]
  ... â‰¤ âˆ¥f (x + r/2) - f x - (x + r/2 - x) â€¢ Lâ‚‚âˆ¥ + âˆ¥f (x + r/2) - f x - (x + r/2 - x) â€¢ Lâ‚âˆ¥ :
    norm_sub_le _ _
  ... â‰¤ Îµ * r + Îµ * r :
    begin
      apply add_le_add,
      { apply le_of_mem_A hâ‚‚;
        simp [(half_pos hr).le] },
      { apply le_of_mem_A hâ‚;
        simp [(half_pos hr).le] },
    end
  ... = (r / 2) * (4 * Îµ) : by ring
end
lemma differentiable_set_subset_D :
  {x | differentiable_within_at â„ f (Ici x) x âˆ§ deriv_within f (Ici x) x âˆˆ K} âŠ† D f K :=
begin
  assume x hx,
  rw [D, mem_Inter],
  assume e,
  have : (0 : â„) < (1/2) ^ e := pow_pos (by norm_num) _,
  rcases mem_A_of_differentiable this hx.1 with âŸ¨R, R_pos, hRâŸ©,
  obtain âŸ¨n, hnâŸ© : âˆƒ (n : â„•), (1/2) ^ n < R :=
    exists_pow_lt_of_lt_one R_pos (by norm_num : (1 : â„)/2 < 1),
  simp only [mem_Union, mem_Inter, B, mem_inter_eq],
  refine âŸ¨n, Î» p hp q hq, âŸ¨deriv_within f (Ici x) x, hx.2, âŸ¨_, _âŸ©âŸ©âŸ©;
  { refine hR _ âŸ¨pow_pos (by norm_num) _, lt_of_le_of_lt _ hnâŸ©,
    exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption) }
end
lemma D_subset_differentiable_set {K : set F} (hK : is_complete K) :
  D f K âŠ† {x | differentiable_within_at â„ f (Ici x) x âˆ§ deriv_within f (Ici x) x âˆˆ K} :=
begin
  have P : âˆ€ {n : â„•}, (0 : â„) < (1/2) ^ n := pow_pos (by norm_num),
  assume x hx,
  have : âˆ€ (e : â„•), âˆƒ (n : â„•), âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’ âˆƒ L âˆˆ K,
    x âˆˆ A f L ((1/2) ^ p) ((1/2) ^ e) âˆ© A f L ((1/2) ^ q) ((1/2) ^ e),
  { assume e,
    have := mem_Inter.1 hx e,
    rcases mem_Union.1 this with âŸ¨n, hnâŸ©,
    refine âŸ¨n, Î» p q hp hq, _âŸ©,
    simp only [mem_Inter, ge_iff_le] at hn,
    rcases mem_Union.1 (hn p hp q hq) with âŸ¨L, hLâŸ©,
    exact âŸ¨L, mem_Union.1 hLâŸ©, },
  choose! n L hn using this,
  have M : âˆ€ e p q e' p' q', n e â‰¤ p â†’ n e â‰¤ q â†’ n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’
    âˆ¥L e p q - L e' p' q'âˆ¥ â‰¤ 12 * (1/2) ^ e,
  { assume e p q e' p' q' hp hq hp' hq' he',
    let r := max (n e) (n e'),
    have I : ((1:â„)/2)^e' â‰¤ (1/2)^e := pow_le_pow_of_le_one (by norm_num) (by norm_num) he',
    have J1 : âˆ¥L e p q - L e p râˆ¥ â‰¤ 4 * (1/2)^e,
    { have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1/2)^e) :=
        (hn e p q hp hq).2.1,
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1/2)^e) :=
        (hn e p r hp (le_max_left _ _)).2.1,
      exact norm_sub_le_of_mem_A P _ I1 I2 },
    have J2 : âˆ¥L e p r - L e' p' râˆ¥ â‰¤ 4 * (1/2)^e,
    { have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1/2)^e) :=
        (hn e p r hp (le_max_left _ _)).2.2,
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1/2)^e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2,
      exact norm_sub_le_of_mem_A P _ I1 (A_mono _ _ I I2) },
    have J3 : âˆ¥L e' p' r - L e' p' q'âˆ¥ â‰¤ 4 * (1/2)^e,
    { have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1/2)^e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1,
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1/2)^e') :=
        (hn e' p' q' hp' hq').2.1,
      exact norm_sub_le_of_mem_A P _ (A_mono _ _ I I1) (A_mono _ _ I I2) },
    calc âˆ¥L e p q - L e' p' q'âˆ¥
          = âˆ¥(L e p q - L e p r) + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')âˆ¥ :
        by { congr' 1, abel }
      ... â‰¤ âˆ¥L e p q - L e p râˆ¥ + âˆ¥L e p r - L e' p' râˆ¥ + âˆ¥L e' p' r - L e' p' q'âˆ¥ :
        le_trans (norm_add_le _ _) (add_le_add_right (norm_add_le _ _) _)
      ... â‰¤ 4 * (1/2)^e + 4 * (1/2)^e + 4 * (1/2)^e :
        by apply_rules [add_le_add]
      ... = 12 * (1/2)^e : by ring },
  let L0 : â„• â†’ F := Î» e, L e (n e) (n e),
  have : cauchy_seq L0,
  { rw metric.cauchy_seq_iff',
    assume Îµ Îµpos,
    obtain âŸ¨e, heâŸ© : âˆƒ (e : â„•), (1/2) ^ e < Îµ / 12 :=
      exists_pow_lt_of_lt_one (div_pos Îµpos (by norm_num)) (by norm_num),
    refine âŸ¨e, Î» e' he', _âŸ©,
    rw [dist_comm, dist_eq_norm],
    calc âˆ¥L0 e - L0 e'âˆ¥
          â‰¤ 12 * (1/2)^e : M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      ... < 12 * (Îµ / 12) :
        mul_lt_mul' le_rfl he (le_of_lt P) (by norm_num)
      ... = Îµ : by { field_simp [(by norm_num : (12 : â„) â‰  0)], ring } },
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, tendsto L0 at_top (ğ“ f') :=
    cauchy_seq_tendsto_of_is_complete hK (Î» e, (hn e (n e) (n e) le_rfl le_rfl).1) this,
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ âˆ¥L e (n e) p - f'âˆ¥ â‰¤ 12 * (1/2)^e,
  { assume e p hp,
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm,
    rw eventually_at_top,
    exact âŸ¨e, Î» e' he', M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ© },
  have : has_deriv_within_at f f' (Ici x) x,
  { simp only [has_deriv_within_at_iff_is_o, is_o_iff],
    assume Îµ Îµpos,
    obtain âŸ¨e, heâŸ© : âˆƒ (e : â„•), (1 / 2) ^ e < Îµ / 16 :=
      exists_pow_lt_of_lt_one (div_pos Îµpos (by norm_num)) (by norm_num),
    have xmem : x âˆˆ Ico x (x + (1/2)^(n e + 1)),
      by simp only [one_div, left_mem_Ico, lt_add_iff_pos_right, inv_pos, pow_pos, zero_lt_bit0,
        zero_lt_one],
    filter_upwards [Icc_mem_nhds_within_Ici xmem] with y hy,
theorem measurable_set_of_differentiable_within_at_Ici_of_is_complete
  {K : set F} (hK : is_complete K) :
  measurable_set {x | differentiable_within_at â„ f (Ici x) x âˆ§ deriv_within f (Ici x) x âˆˆ K} :=
by simp [differentiable_set_eq_D K hK, D, measurable_set_B, measurable_set.Inter_Prop,
         measurable_set.Inter, measurable_set.Union]
variable [complete_space F]
theorem measurable_set_of_differentiable_within_at_Ici :
  measurable_set {x | differentiable_within_at â„ f (Ici x) x} :=
begin
  have : is_complete (univ : set F) := complete_univ,
  convert measurable_set_of_differentiable_within_at_Ici_of_is_complete f this,
  simp
end
@[measurability] lemma measurable_deriv_within_Ici [measurable_space F] [borel_space F] :
  measurable (Î» x, deriv_within f (Ici x) x) :=
begin
  refine measurable_of_is_closed (Î» s hs, _),
  have : (Î» x, deriv_within f (Ici x) x) â»Â¹' s =
    {x | differentiable_within_at â„ f (Ici x) x âˆ§ deriv_within f (Ici x) x âˆˆ s} âˆª
    ({x | Â¬differentiable_within_at â„ f (Ici x) x} âˆ© {x | (0 : F) âˆˆ s}) :=
    set.ext (Î» x, mem_preimage.trans deriv_within_mem_iff),
  rw this,
  exact (measurable_set_of_differentiable_within_at_Ici_of_is_complete _ hs.is_complete).union
    ((measurable_set_of_differentiable_within_at_Ici _).compl.inter (measurable_set.const _))
end
lemma strongly_measurable_deriv_within_Ici [second_countable_topology F] :
  strongly_measurable (Î» x, deriv_within f (Ici x) x) :=
by { borelize F, exact (measurable_deriv_within_Ici f).strongly_measurable }
lemma ae_measurable_deriv_within_Ici [measurable_space F] [borel_space F]
  (Î¼ : measure â„) : ae_measurable (Î» x, deriv_within f (Ici x) x) Î¼ :=
(measurable_deriv_within_Ici f).ae_measurable
lemma ae_strongly_measurable_deriv_within_Ici [second_countable_topology F] (Î¼ : measure â„) :
  ae_strongly_measurable (Î» x, deriv_within f (Ici x) x) Î¼ :=
(strongly_measurable_deriv_within_Ici f).ae_strongly_measurable
theorem measurable_set_of_differentiable_within_at_Ioi :
  measurable_set {x | differentiable_within_at â„ f (Ioi x) x} :=
by simpa [differentiable_within_at_Ioi_iff_Ici]
  using measurable_set_of_differentiable_within_at_Ici f
@[measurability] lemma measurable_deriv_within_Ioi [measurable_space F] [borel_space F] :
  measurable (Î» x, deriv_within f (Ioi x) x) :=
by simpa [deriv_within_Ioi_eq_Ici] using measurable_deriv_within_Ici f
lemma strongly_measurable_deriv_within_Ioi [second_countable_topology F] :
  strongly_measurable (Î» x, deriv_within f (Ioi x) x) :=
by { borelize F, exact (measurable_deriv_within_Ioi f).strongly_measurable }
lemma ae_measurable_deriv_within_Ioi [measurable_space F] [borel_space F]
  (Î¼ : measure â„) : ae_measurable (Î» x, deriv_within f (Ioi x) x) Î¼ :=
(measurable_deriv_within_Ioi f).ae_measurable
lemma ae_strongly_measurable_deriv_within_Ioi [second_countable_topology F] (Î¼ : measure â„) :
  ae_strongly_measurable (Î» x, deriv_within f (Ioi x) x) Î¼ :=
(strongly_measurable_deriv_within_Ioi f).ae_strongly_measurable
end right_deriv
