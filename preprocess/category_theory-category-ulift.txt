import category_theory.category.basic
import category_theory.equivalence
import category_theory.eq_to_hom
universes wâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚‚
namespace category_theory
variables {C : Type uâ‚} [category.{vâ‚} C]
@[simps]
def ulift.up_functor : C â¥¤ (ulift.{uâ‚‚} C) :=
{ obj := ulift.up,
  map := Î» X Y f, f }
@[simps]
def ulift.down_functor : (ulift.{uâ‚‚} C) â¥¤ C :=
{ obj := ulift.down,
  map := Î» X Y f, f }
@[simps]
def ulift.equivalence : C â‰Œ (ulift.{uâ‚‚} C) :=
{ functor := ulift.up_functor,
  inverse := ulift.down_functor,
  unit_iso :=
  { hom := ğŸ™ _,
    inv := ğŸ™ _ },
  counit_iso :=
  { hom :=
    { app := Î» X, ğŸ™ _,
      naturality' := Î» X Y f, by {change f â‰« ğŸ™ _ = ğŸ™ _ â‰« f, simp} },
    inv :=
    { app := Î» X, ğŸ™ _,
      naturality' := Î» X Y f, by {change f â‰« ğŸ™ _ = ğŸ™ _ â‰« f, simp} },
  hom_inv_id' := by {ext, change (ğŸ™ _) â‰« (ğŸ™ _) = ğŸ™ _, simp},
  inv_hom_id' := by {ext, change (ğŸ™ _) â‰« (ğŸ™ _) = ğŸ™ _, simp} },
  functor_unit_iso_comp' := Î» X, by {change (ğŸ™ X) â‰« (ğŸ™ X) = ğŸ™ X, simp} }
section ulift_hom
def {w u} ulift_hom (C : Type u) := C
instance {C} [inhabited C] : inhabited (ulift_hom C) := âŸ¨(arbitrary C : C)âŸ©
def ulift_hom.obj_down {C} (A : ulift_hom C) : C := A
def ulift_hom.obj_up {C} (A : C) : ulift_hom C := A
@[simp] lemma obj_down_obj_up {C} (A : C) : (ulift_hom.obj_up A).obj_down = A := rfl
@[simp] lemma obj_up_obj_down {C} (A : ulift_hom C) : ulift_hom.obj_up A.obj_down = A := rfl
instance : category.{max vâ‚‚ vâ‚} (ulift_hom.{vâ‚‚} C) :=
{ hom := Î» A B, ulift.{vâ‚‚} $ A.obj_down âŸ¶ B.obj_down,
  id := Î» A, âŸ¨ğŸ™ _âŸ©,
  comp := Î» A B C f g, âŸ¨f.down â‰« g.downâŸ©}
@[simps]
def ulift_hom.up : C â¥¤ ulift_hom C :=
{ obj := ulift_hom.obj_up,
  map := Î» X Y f, âŸ¨fâŸ© }
@[simps]
def ulift_hom.down : ulift_hom C â¥¤ C :=
{ obj := ulift_hom.obj_down,
  map := Î» X Y f, f.down }
def ulift_hom.equiv : C â‰Œ ulift_hom C :=
{ functor := ulift_hom.up,
  inverse := ulift_hom.down,
  unit_iso := nat_iso.of_components (Î» A, eq_to_iso rfl) (by tidy),
  counit_iso := nat_iso.of_components (Î» A, eq_to_iso rfl) (by tidy) }
end ulift_hom
@[nolint unused_arguments]
def {w v u} as_small (C : Type u) [category.{v} C] := ulift.{max w v} C
instance : small_category (as_small.{wâ‚} C) :=
{ hom := Î» X Y, ulift.{max wâ‚ uâ‚} $ X.down âŸ¶ Y.down,
  id := Î» X, âŸ¨ğŸ™ _âŸ©,
  comp := Î» X Y Z f g, âŸ¨f.down â‰« g.downâŸ© }
@[simps]
def as_small.up : C â¥¤ as_small C :=
{ obj := Î» X, âŸ¨XâŸ©,
  map := Î» X Y f, âŸ¨fâŸ© }
@[simps]
def as_small.down : as_small C â¥¤ C :=
{ obj := Î» X, X.down,
  map := Î» X Y f, f.down }
@[simps]
def as_small.equiv : C â‰Œ as_small C :=
{ functor := as_small.up,
  inverse := as_small.down,
  unit_iso := nat_iso.of_components (Î» X, eq_to_iso rfl) (by tidy),
  counit_iso := nat_iso.of_components (Î» X, eq_to_iso $ by { ext, refl }) (by tidy) }
instance [inhabited C] : inhabited (as_small C) := âŸ¨âŸ¨arbitrary _âŸ©âŸ©
def {v' u' v u} ulift_hom_ulift_category.equiv (C : Type u) [category.{v} C] :
  C â‰Œ ulift_hom.{v'} (ulift.{u'} C) :=
ulift.equivalence.trans ulift_hom.equiv
end category_theory
