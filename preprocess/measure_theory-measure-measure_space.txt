import measure_theory.measure.null_measurable
import measure_theory.measurable_space
noncomputable theory
open set filter (hiding map) function measurable_space topological_space (second_countable_topology)
open_locale classical topological_space big_operators filter ennreal nnreal interval measure_theory
variables {Î± Î² Î³ Î´ Î¹ R R' : Type*}
namespace measure_theory
section
variables {m : measurable_space Î±} {Î¼ Î¼â‚ Î¼â‚‚ : measure Î±} {s sâ‚ sâ‚‚ t : set Î±}
instance ae_is_measurably_generated : is_measurably_generated Î¼.ae :=
âŸ¨Î» s hs, let âŸ¨t, hst, htm, htÎ¼âŸ© := exists_measurable_superset_of_null hs in
  âŸ¨tá¶œ, compl_mem_ae_iff.2 htÎ¼, htm.compl, compl_subset_comm.1 hstâŸ©âŸ©
lemma ae_interval_oc_iff [linear_order Î±] {a b : Î±} {P : Î± â†’ Prop} :
  (âˆ€áµ x âˆ‚Î¼, x âˆˆ Î™ a b â†’ P x) â†” (âˆ€áµ x âˆ‚Î¼, x âˆˆ Ioc a b â†’ P x) âˆ§ (âˆ€áµ x âˆ‚Î¼, x âˆˆ Ioc b a â†’ P x) :=
by simp only [interval_oc_eq_union, mem_union_eq, or_imp_distrib, eventually_and]
lemma measure_union (hd : disjoint sâ‚ sâ‚‚) (h : measurable_set sâ‚‚) :
  Î¼ (sâ‚ âˆª sâ‚‚) = Î¼ sâ‚ + Î¼ sâ‚‚ :=
measure_unionâ‚€ h.null_measurable_set hd.ae_disjoint
lemma measure_union' (hd : disjoint sâ‚ sâ‚‚) (h : measurable_set sâ‚) :
  Î¼ (sâ‚ âˆª sâ‚‚) = Î¼ sâ‚ + Î¼ sâ‚‚ :=
measure_unionâ‚€' h.null_measurable_set hd.ae_disjoint
lemma measure_inter_add_diff (s : set Î±) (ht : measurable_set t) :
  Î¼ (s âˆ© t) + Î¼ (s \ t) = Î¼ s :=
measure_inter_add_diffâ‚€ _ ht.null_measurable_set
lemma measure_diff_add_inter (s : set Î±) (ht : measurable_set t) :
  Î¼ (s \ t) + Î¼ (s âˆ© t) = Î¼ s :=
(add_comm _ _).trans (measure_inter_add_diff s ht)
lemma measure_union_add_inter (s : set Î±) (ht : measurable_set t) :
  Î¼ (s âˆª t) + Î¼ (s âˆ© t) = Î¼ s + Î¼ t :=
by { rw [â† measure_inter_add_diff (s âˆª t) ht, set.union_inter_cancel_right,
  union_diff_right, â† measure_inter_add_diff s ht], ac_refl }
lemma measure_union_add_inter' (hs : measurable_set s) (t : set Î±) :
  Î¼ (s âˆª t) + Î¼ (s âˆ© t) = Î¼ s + Î¼ t :=
by rw [union_comm, inter_comm, measure_union_add_inter t hs, add_comm]
lemma measure_add_measure_compl (h : measurable_set s) :
  Î¼ s + Î¼ sá¶œ = Î¼ univ :=
by { rw [â† measure_union' _ h, union_compl_self], exact disjoint_compl_right }
lemma measure_bUnionâ‚€ {s : set Î²} {f : Î² â†’ set Î±} (hs : s.countable)
  (hd : s.pairwise (ae_disjoint Î¼ on f)) (h : âˆ€ b âˆˆ s, null_measurable_set (f b) Î¼) :
  Î¼ (â‹ƒ b âˆˆ s, f b) = âˆ‘' p : s, Î¼ (f p) :=
begin
  haveI := hs.to_encodable,
  rw bUnion_eq_Union,
  exact measure_Unionâ‚€ (hd.on_injective subtype.coe_injective $ Î» x, x.2) (Î» x, h x x.2)
end
lemma measure_bUnion {s : set Î²} {f : Î² â†’ set Î±} (hs : s.countable)
  (hd : s.pairwise_disjoint f) (h : âˆ€ b âˆˆ s, measurable_set (f b)) :
  Î¼ (â‹ƒ b âˆˆ s, f b) = âˆ‘' p : s, Î¼ (f p) :=
measure_bUnionâ‚€ hs hd.ae_disjoint (Î» b hb, (h b hb).null_measurable_set)
lemma measure_sUnionâ‚€ {S : set (set Î±)} (hs : S.countable)
  (hd : S.pairwise (ae_disjoint Î¼)) (h : âˆ€ s âˆˆ S, null_measurable_set s Î¼) :
  Î¼ (â‹ƒâ‚€ S) = âˆ‘' s : S, Î¼ s :=
by rw [sUnion_eq_bUnion, measure_bUnionâ‚€ hs hd h]
lemma measure_sUnion {S : set (set Î±)} (hs : S.countable)
  (hd : S.pairwise disjoint) (h : âˆ€ s âˆˆ S, measurable_set s) :
  Î¼ (â‹ƒâ‚€ S) = âˆ‘' s : S, Î¼ s :=
by rw [sUnion_eq_bUnion, measure_bUnion hs hd h]
lemma measure_bUnion_finsetâ‚€ {s : finset Î¹} {f : Î¹ â†’ set Î±}
  (hd : set.pairwise â†‘s (ae_disjoint Î¼ on f)) (hm : âˆ€ b âˆˆ s, null_measurable_set (f b) Î¼) :
  Î¼ (â‹ƒ b âˆˆ s, f b) = âˆ‘ p in s, Î¼ (f p) :=
begin
  rw [â† finset.sum_attach, finset.attach_eq_univ, â† tsum_fintype],
  exact measure_bUnionâ‚€ s.countable_to_set hd hm
end
lemma measure_bUnion_finset {s : finset Î¹} {f : Î¹ â†’ set Î±} (hd : pairwise_disjoint â†‘s f)
  (hm : âˆ€ b âˆˆ s, measurable_set (f b)) :
  Î¼ (â‹ƒ b âˆˆ s, f b) = âˆ‘ p in s, Î¼ (f p) :=
measure_bUnion_finsetâ‚€ hd.ae_disjoint (Î» b hb, (hm b hb).null_measurable_set)
lemma tsum_measure_preimage_singleton {s : set Î²} (hs : s.countable) {f : Î± â†’ Î²}
  (hf : âˆ€ y âˆˆ s, measurable_set (f â»Â¹' {y})) :
  âˆ‘' b : s, Î¼ (f â»Â¹' {â†‘b}) = Î¼ (f â»Â¹' s) :=
by rw [â† set.bUnion_preimage_singleton, measure_bUnion hs (pairwise_disjoint_fiber _ _) hf]
lemma sum_measure_preimage_singleton (s : finset Î²) {f : Î± â†’ Î²}
  (hf : âˆ€ y âˆˆ s, measurable_set (f â»Â¹' {y})) :
  âˆ‘ b in s, Î¼ (f â»Â¹' {b}) = Î¼ (f â»Â¹' â†‘s) :=
by simp only [â† measure_bUnion_finset (pairwise_disjoint_fiber _ _) hf,
  finset.set_bUnion_preimage_singleton]
lemma measure_diff_null' (h : Î¼ (sâ‚ âˆ© sâ‚‚) = 0) : Î¼ (sâ‚ \ sâ‚‚) = Î¼ sâ‚ :=
measure_congr $ diff_ae_eq_self.2 h
lemma measure_diff_null (h : Î¼ sâ‚‚ = 0) : Î¼ (sâ‚ \ sâ‚‚) = Î¼ sâ‚ :=
measure_diff_null' $ measure_mono_null (inter_subset_right _ _) h
lemma measure_add_diff (hs : measurable_set s) (t : set Î±) : Î¼ s + Î¼ (t \ s) = Î¼ (s âˆª t) :=
by rw [â† measure_union' disjoint_diff hs, union_diff_self]
lemma measure_diff' (s : set Î±) (hm : measurable_set t) (h_fin : Î¼ t â‰  âˆ) :
  Î¼ (s \ t) = Î¼ (s âˆª t) - Î¼ t :=
eq.symm $ ennreal.sub_eq_of_add_eq h_fin $ by rw [add_comm, measure_add_diff hm, union_comm]
lemma measure_diff (h : sâ‚‚ âŠ† sâ‚) (hâ‚‚ : measurable_set sâ‚‚) (h_fin : Î¼ sâ‚‚ â‰  âˆ) :
  Î¼ (sâ‚ \ sâ‚‚) = Î¼ sâ‚ - Î¼ sâ‚‚ :=
by rw [measure_diff' _ hâ‚‚ h_fin, union_eq_self_of_subset_right h]
lemma le_measure_diff : Î¼ sâ‚ - Î¼ sâ‚‚ â‰¤ Î¼ (sâ‚ \ sâ‚‚) :=
tsub_le_iff_left.2 $
calc Î¼ sâ‚ â‰¤ Î¼ (sâ‚‚ âˆª sâ‚)        : measure_mono (subset_union_right _ _)
      ... = Î¼ (sâ‚‚ âˆª sâ‚ \ sâ‚‚)   : congr_arg Î¼ union_diff_self.symm
      ... â‰¤ Î¼ sâ‚‚ + Î¼ (sâ‚ \ sâ‚‚) : measure_union_le _ _
lemma measure_diff_lt_of_lt_add (hs : measurable_set s) (hst : s âŠ† t)
  (hs' : Î¼ s â‰  âˆ) {Îµ : â„â‰¥0âˆ} (h : Î¼ t < Î¼ s + Îµ) : Î¼ (t \ s) < Îµ :=
begin
  rw [measure_diff hst hs hs'], rw add_comm at h,
  exact ennreal.sub_lt_of_lt_add (measure_mono hst) h
end
lemma measure_diff_le_iff_le_add (hs : measurable_set s) (hst : s âŠ† t)
  (hs' : Î¼ s â‰  âˆ) {Îµ : â„â‰¥0âˆ} : Î¼ (t \ s) â‰¤ Îµ â†” Î¼ t â‰¤ Î¼ s + Îµ :=
by rwa [measure_diff hst hs hs', tsub_le_iff_left]
lemma measure_eq_measure_of_null_diff {s t : set Î±} (hst : s âŠ† t) (h_nulldiff : Î¼ (t \ s) = 0) :
  Î¼ s = Î¼ t :=
measure_congr (hst.eventually_le.antisymm $ ae_le_set.mpr h_nulldiff)
lemma measure_eq_measure_of_between_null_diff {sâ‚ sâ‚‚ sâ‚ƒ : set Î±}
  (h12 : sâ‚ âŠ† sâ‚‚) (h23 : sâ‚‚ âŠ† sâ‚ƒ) (h_nulldiff : Î¼ (sâ‚ƒ \ sâ‚) = 0) :
  (Î¼ sâ‚ = Î¼ sâ‚‚) âˆ§ (Î¼ sâ‚‚ = Î¼ sâ‚ƒ) :=
begin
  have le12 : Î¼ sâ‚ â‰¤ Î¼ sâ‚‚ := measure_mono h12,
  have le23 : Î¼ sâ‚‚ â‰¤ Î¼ sâ‚ƒ := measure_mono h23,
  have key : Î¼ sâ‚ƒ â‰¤ Î¼ sâ‚ := calc
    Î¼ sâ‚ƒ = Î¼ ((sâ‚ƒ \ sâ‚) âˆª sâ‚)  : by rw (diff_union_of_subset (h12.trans h23))
     ... â‰¤ Î¼ (sâ‚ƒ \ sâ‚) + Î¼ sâ‚  : measure_union_le _ _
     ... = Î¼ sâ‚                : by simp only [h_nulldiff, zero_add],
  exact âŸ¨le12.antisymm (le23.trans key), le23.antisymm (key.trans le12)âŸ©,
end
lemma measure_eq_measure_smaller_of_between_null_diff {sâ‚ sâ‚‚ sâ‚ƒ : set Î±}
  (h12 : sâ‚ âŠ† sâ‚‚) (h23 : sâ‚‚ âŠ† sâ‚ƒ) (h_nulldiff : Î¼ (sâ‚ƒ \ sâ‚) = 0) : Î¼ sâ‚ = Î¼ sâ‚‚ :=
(measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).1
lemma measure_eq_measure_larger_of_between_null_diff {sâ‚ sâ‚‚ sâ‚ƒ : set Î±}
  (h12 : sâ‚ âŠ† sâ‚‚) (h23 : sâ‚‚ âŠ† sâ‚ƒ) (h_nulldiff : Î¼ (sâ‚ƒ \ sâ‚) = 0) : Î¼ sâ‚‚ = Î¼ sâ‚ƒ :=
(measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).2
lemma measure_compl (hâ‚ : measurable_set s) (h_fin : Î¼ s â‰  âˆ) : Î¼ (sá¶œ) = Î¼ univ - Î¼ s :=
by { rw compl_eq_univ_diff, exact measure_diff (subset_univ s) hâ‚ h_fin }
lemma ae_eq_of_subset_of_measure_ge (hâ‚ : s âŠ† t) (hâ‚‚ : Î¼ t â‰¤ Î¼ s) (hsm : measurable_set s)
  (ht : Î¼ t â‰  âˆ) : s =áµ[Î¼] t :=
have A : Î¼ t = Î¼ s, from hâ‚‚.antisymm (measure_mono hâ‚),
have B : Î¼ s â‰  âˆ, from A â–¸ ht,
hâ‚.eventually_le.antisymm $ ae_le_set.2 $ by rw [measure_diff hâ‚ hsm B, A, tsub_self]
lemma measure_Union_congr_of_subset [encodable Î²] {s : Î² â†’ set Î±} {t : Î² â†’ set Î±}
  (hsub : âˆ€ b, s b âŠ† t b) (h_le : âˆ€ b, Î¼ (t b) â‰¤ Î¼ (s b)) :
  Î¼ (â‹ƒ b, s b) = Î¼ (â‹ƒ b, t b) :=
begin
  rcases em (âˆƒ b, Î¼ (t b) = âˆ) with âŸ¨b, hbâŸ©|htop,
  { calc Î¼ (â‹ƒ b, s b) = âˆ : top_unique (hb â–¸ (h_le b).trans $ measure_mono $ subset_Union _ _)
    ... = Î¼ (â‹ƒ b, t b) : eq.symm $ top_unique $ hb â–¸ measure_mono $ subset_Union _ _ },
  push_neg at htop,
  refine le_antisymm (measure_mono (Union_mono hsub)) _,
  set M := to_measurable Î¼,
  have H : âˆ€ b, (M (t b) âˆ© M (â‹ƒ b, s b) : set Î±) =áµ[Î¼] M (t b),
  { refine Î» b, ae_eq_of_subset_of_measure_ge (inter_subset_left _ _) _ _ _,
    { calc Î¼ (M (t b)) = Î¼ (t b) : measure_to_measurable _
      ... â‰¤ Î¼ (s b) : h_le b
      ... â‰¤ Î¼ (M (t b) âˆ© M (â‹ƒ b, s b)) : measure_mono $
        subset_inter ((hsub b).trans $ subset_to_measurable _ _)
          ((subset_Union _ _).trans $ subset_to_measurable _ _) },
    { exact (measurable_set_to_measurable _ _).inter (measurable_set_to_measurable _ _) },
    { rw measure_to_measurable, exact htop b } },
  calc Î¼ (â‹ƒ b, t b) â‰¤ Î¼ (â‹ƒ b, M (t b)) :
    measure_mono (Union_mono $ Î» b, subset_to_measurable _ _)
  ... = Î¼ (â‹ƒ b, M (t b) âˆ© M (â‹ƒ b, s b)) :
    measure_congr (eventually_eq.countable_Union H).symm
  ... â‰¤ Î¼ (M (â‹ƒ b, s b)) :
    measure_mono (Union_subset $ Î» b, inter_subset_right _ _)
  ... = Î¼ (â‹ƒ b, s b) : measure_to_measurable _
end
lemma measure_union_congr_of_subset {tâ‚ tâ‚‚ : set Î±} (hs : sâ‚ âŠ† sâ‚‚) (hsÎ¼ : Î¼ sâ‚‚ â‰¤ Î¼ sâ‚)
  (ht : tâ‚ âŠ† tâ‚‚) (htÎ¼ : Î¼ tâ‚‚ â‰¤ Î¼ tâ‚) :
  Î¼ (sâ‚ âˆª tâ‚) = Î¼ (sâ‚‚ âˆª tâ‚‚) :=
begin
  rw [union_eq_Union, union_eq_Union],
  exact measure_Union_congr_of_subset (bool.forall_bool.2 âŸ¨ht, hsâŸ©) (bool.forall_bool.2 âŸ¨htÎ¼, hsÎ¼âŸ©)
end
@[simp] lemma measure_Union_to_measurable [encodable Î²] (s : Î² â†’ set Î±) :
  Î¼ (â‹ƒ b, to_measurable Î¼ (s b)) = Î¼ (â‹ƒ b, s b) :=
eq.symm $ measure_Union_congr_of_subset (Î» b, subset_to_measurable _ _)
  (Î» b, (measure_to_measurable _).le)
lemma measure_bUnion_to_measurable {I : set Î²} (hc : I.countable) (s : Î² â†’ set Î±) :
  Î¼ (â‹ƒ b âˆˆ I, to_measurable Î¼ (s b)) = Î¼ (â‹ƒ b âˆˆ I, s b) :=
by { haveI := hc.to_encodable, simp only [bUnion_eq_Union, measure_Union_to_measurable] }
@[simp] lemma measure_to_measurable_union : Î¼ (to_measurable Î¼ s âˆª t) = Î¼ (s âˆª t) :=
eq.symm $ measure_union_congr_of_subset (subset_to_measurable _ _) (measure_to_measurable _).le
  subset.rfl le_rfl
@[simp] lemma measure_union_to_measurable : Î¼ (s âˆª to_measurable Î¼ t) = Î¼ (s âˆª t) :=
eq.symm $ measure_union_congr_of_subset subset.rfl le_rfl (subset_to_measurable _ _)
  (measure_to_measurable _).le
lemma sum_measure_le_measure_univ {s : finset Î¹} {t : Î¹ â†’ set Î±} (h : âˆ€ i âˆˆ s, measurable_set (t i))
  (H : set.pairwise_disjoint â†‘s t) :
  âˆ‘ i in s, Î¼ (t i) â‰¤ Î¼ (univ : set Î±) :=
by { rw â† measure_bUnion_finset H h, exact measure_mono (subset_univ _) }
lemma tsum_measure_le_measure_univ {s : Î¹ â†’ set Î±} (hs : âˆ€ i, measurable_set (s i))
  (H : pairwise (disjoint on s)) :
  âˆ‘' i, Î¼ (s i) â‰¤ Î¼ (univ : set Î±) :=
begin
  rw [ennreal.tsum_eq_supr_sum],
  exact supr_le (Î» s, sum_measure_le_measure_univ (Î» i hi, hs i) (Î» i hi j hj hij, H i j hij))
end
lemma exists_nonempty_inter_of_measure_univ_lt_tsum_measure {m : measurable_space Î±} (Î¼ : measure Î±)
  {s : Î¹ â†’ set Î±} (hs : âˆ€ i, measurable_set (s i)) (H : Î¼ (univ : set Î±) < âˆ‘' i, Î¼ (s i)) :
  âˆƒ i j (h : i â‰  j), (s i âˆ© s j).nonempty :=
begin
  contrapose! H,
  apply tsum_measure_le_measure_univ hs,
  exact Î» i j hij x hx, H i j hij âŸ¨x, hxâŸ©
end
lemma exists_nonempty_inter_of_measure_univ_lt_sum_measure {m : measurable_space Î±} (Î¼ : measure Î±)
  {s : finset Î¹} {t : Î¹ â†’ set Î±} (h : âˆ€ i âˆˆ s, measurable_set (t i))
  (H : Î¼ (univ : set Î±) < âˆ‘ i in s, Î¼ (t i)) :
  âˆƒ (i âˆˆ s) (j âˆˆ s) (h : i â‰  j), (t i âˆ© t j).nonempty :=
begin
  contrapose! H,
  apply sum_measure_le_measure_univ h,
  exact Î» i hi j hj hij x hx, H i hi j hj hij âŸ¨x, hxâŸ©
end
lemma nonempty_inter_of_measure_lt_add
  {m : measurable_space Î±} (Î¼ : measure Î±)
  {s t u : set Î±} (ht : measurable_set t) (h's : s âŠ† u) (h't : t âŠ† u)
  (h : Î¼ u < Î¼ s + Î¼ t) :
  (s âˆ© t).nonempty :=
begin
  contrapose! h,
  calc Î¼ s + Î¼ t = Î¼ (s âˆª t) :
    by { rw measure_union _ ht, exact Î» x hx, h âŸ¨x, hxâŸ© }
  ... â‰¤ Î¼ u : measure_mono (union_subset h's h't)
end
lemma nonempty_inter_of_measure_lt_add'
  {m : measurable_space Î±} (Î¼ : measure Î±)
  {s t u : set Î±} (hs : measurable_set s) (h's : s âŠ† u) (h't : t âŠ† u)
  (h : Î¼ u < Î¼ s + Î¼ t) :
  (s âˆ© t).nonempty :=
begin
  rw add_comm at h,
  rw inter_comm,
  exact nonempty_inter_of_measure_lt_add Î¼ hs h't h's h
end
lemma measure_Union_eq_supr [encodable Î¹] {s : Î¹ â†’ set Î±} (hd : directed (âŠ†) s) :
  Î¼ (â‹ƒ i, s i) = â¨† i, Î¼ (s i) :=
begin
lemma measure_Inter_eq_infi [encodable Î¹] {s : Î¹ â†’ set Î±}
  (h : âˆ€ i, measurable_set (s i)) (hd : directed (âŠ‡) s) (hfin : âˆƒ i, Î¼ (s i) â‰  âˆ) :
  Î¼ (â‹‚ i, s i) = (â¨… i, Î¼ (s i)) :=
begin
  rcases hfin with âŸ¨k, hkâŸ©,
  have : âˆ€ t âŠ† s k, Î¼ t â‰  âˆ, from Î» t ht, ne_top_of_le_ne_top hk (measure_mono ht),
  rw [â† ennreal.sub_sub_cancel (by exact hk) (infi_le _ k), ennreal.sub_infi,
    â† ennreal.sub_sub_cancel (by exact hk) (measure_mono (Inter_subset _ k)),
    â† measure_diff (Inter_subset _ k) (measurable_set.Inter h) (this _ (Inter_subset _ k)),
    diff_Inter, measure_Union_eq_supr],
  { congr' 1,
    refine le_antisymm (supr_mono' $ Î» i, _) (supr_mono $ Î» i, _),
    { rcases hd i k with âŸ¨j, hji, hjkâŸ©,
      use j,
      rw [â† measure_diff hjk (h _) (this _ hjk)],
      exact measure_mono (diff_subset_diff_right hji) },
    { rw [tsub_le_iff_right, â† measure_union disjoint_diff.symm (h i), set.union_comm],
      exact measure_mono (diff_subset_iff.1 $ subset.refl _) } },
  { exact hd.mono_comp _ (Î» _ _, diff_subset_diff_right) }
end
lemma tendsto_measure_Union [semilattice_sup Î¹] [encodable Î¹] {s : Î¹ â†’ set Î±} (hm : monotone s) :
  tendsto (Î¼ âˆ˜ s) at_top (ğ“ (Î¼ (â‹ƒ n, s n))) :=
begin
  rw measure_Union_eq_supr (directed_of_sup hm),
  exact tendsto_at_top_supr (Î» n m hnm, measure_mono $ hm hnm)
end
lemma tendsto_measure_Inter [encodable Î¹] [semilattice_sup Î¹] {s : Î¹ â†’ set Î±}
  (hs : âˆ€ n, measurable_set (s n)) (hm : antitone s) (hf : âˆƒ i, Î¼ (s i) â‰  âˆ) :
  tendsto (Î¼ âˆ˜ s) at_top (ğ“ (Î¼ (â‹‚ n, s n))) :=
begin
  rw measure_Inter_eq_infi hs (directed_of_sup hm) hf,
  exact tendsto_at_top_infi (Î» n m hnm, measure_mono $ hm hnm),
end
lemma tendsto_measure_bInter_gt {Î¹ : Type*} [linear_order Î¹] [topological_space Î¹]
  [order_topology Î¹] [densely_ordered Î¹] [topological_space.first_countable_topology Î¹]
  {s : Î¹ â†’ set Î±} {a : Î¹}
  (hs : âˆ€ r > a, measurable_set (s r)) (hm : âˆ€ i j, a < i â†’ i â‰¤ j â†’ s i âŠ† s j)
  (hf : âˆƒ r > a, Î¼ (s r) â‰  âˆ) :
  tendsto (Î¼ âˆ˜ s) (ğ“[Ioi a] a) (ğ“ (Î¼ (â‹‚ r > a, s r))) :=
begin
  refine tendsto_order.2 âŸ¨Î» l hl, _, Î» L hL, _âŸ©,
  { filter_upwards [self_mem_nhds_within] with r hr
      using hl.trans_le (measure_mono (bInter_subset_of_mem hr)), },
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© : âˆƒ (u : â„• â†’ Î¹), strict_anti u âˆ§ (âˆ€ (n : â„•), a < u n)
    âˆ§ tendsto u at_top (ğ“ a),
  { rcases hf with âŸ¨r, ar, hrâŸ©,
    rcases exists_seq_strict_anti_tendsto' ar with âŸ¨w, w_anti, w_mem, w_limâŸ©,
    exact âŸ¨w, w_anti, Î» n, (w_mem n).1, w_limâŸ© },
  have A : tendsto (Î¼ âˆ˜ (s âˆ˜ u)) at_top (ğ“(Î¼ (â‹‚ n, s (u n)))),
  { refine tendsto_measure_Inter (Î» n, hs _ (u_pos n)) _ _,
    { intros m n hmn,
      exact hm _ _ (u_pos n) (u_anti.antitone hmn) },
    { rcases hf with âŸ¨r, rpos, hrâŸ©,
      obtain âŸ¨n, hnâŸ© : âˆƒ (n : â„•), u n < r := ((tendsto_order.1 u_lim).2 r rpos).exists,
      refine âŸ¨n, ne_of_lt (lt_of_le_of_lt _ hr.lt_top)âŸ©,
      exact measure_mono (hm _ _ (u_pos n) hn.le) } },
  have B : (â‹‚ n, s (u n)) = (â‹‚ r > a, s r),
  { apply subset.antisymm,
    { simp only [subset_Inter_iff, gt_iff_lt],
      intros r rpos,
      obtain âŸ¨n, hnâŸ© : âˆƒ n, u n < r := ((tendsto_order.1 u_lim).2 _ rpos).exists,
      exact subset.trans (Inter_subset _ n) (hm (u n) r (u_pos n) hn.le) },
    { simp only [subset_Inter_iff, gt_iff_lt],
      intros n,
      apply bInter_subset_of_mem,
      exact u_pos n } },
  rw B at A,
  obtain âŸ¨n, hnâŸ© : âˆƒ n, Î¼ (s (u n)) < L := ((tendsto_order.1 A).2 _ hL).exists,
  have : Ioc a (u n) âˆˆ ğ“[>] a := Ioc_mem_nhds_within_Ioi âŸ¨le_rfl, u_pos nâŸ©,
  filter_upwards [this] with r hr using lt_of_le_of_lt (measure_mono (hm _ _ hr.1 hr.2)) hn,
end
lemma measure_limsup_eq_zero {s : â„• â†’ set Î±} (hs : âˆ‘' i, Î¼ (s i) â‰  âˆ) : Î¼ (limsup at_top s) = 0 :=
begin
def outer_measure.to_measure (m : outer_measure Î±) (h : ms â‰¤ m.caratheodory) : measure Î± :=
measure.of_measurable (Î» s _, m s) m.empty
  (Î» f hf hd, m.Union_eq_of_caratheodory (Î» i, h _ (hf i)) hd)
lemma le_to_outer_measure_caratheodory (Î¼ : measure Î±) : ms â‰¤ Î¼.to_outer_measure.caratheodory :=
Î» s hs t, (measure_inter_add_diff _ hs).symm
@[simp] lemma to_measure_to_outer_measure (m : outer_measure Î±) (h : ms â‰¤ m.caratheodory) :
  (m.to_measure h).to_outer_measure = m.trim := rfl
@[simp] lemma to_measure_apply (m : outer_measure Î±) (h : ms â‰¤ m.caratheodory)
  {s : set Î±} (hs : measurable_set s) : m.to_measure h s = m s :=
m.trim_eq hs
lemma le_to_measure_apply (m : outer_measure Î±) (h : ms â‰¤ m.caratheodory) (s : set Î±) :
  m s â‰¤ m.to_measure h s :=
m.le_trim s
lemma to_measure_applyâ‚€ (m : outer_measure Î±) (h : ms â‰¤ m.caratheodory)
  {s : set Î±} (hs : null_measurable_set s (m.to_measure h)) : m.to_measure h s = m s :=
begin
  refine le_antisymm _ (le_to_measure_apply _ _ _),
  rcases hs.exists_measurable_subset_ae_eq with âŸ¨t, hts, htm, heqâŸ©,
  calc m.to_measure h s = m.to_measure h t : measure_congr heq.symm
                    ... = m t              : to_measure_apply m h htm
                    ... â‰¤ m s              : m.mono hts
end
@[simp] lemma to_outer_measure_to_measure {Î¼ : measure Î±} :
  Î¼.to_outer_measure.to_measure (le_to_outer_measure_caratheodory _) = Î¼ :=
measure.ext $ Î» s, Î¼.to_outer_measure.trim_eq
@[simp] lemma bounded_by_measure (Î¼ : measure Î±) :
  outer_measure.bounded_by Î¼ = Î¼.to_outer_measure :=
Î¼.to_outer_measure.bounded_by_eq_self
end outer_measure
variables {m0 : measurable_space Î±} [measurable_space Î²] [measurable_space Î³]
variables {Î¼ Î¼â‚ Î¼â‚‚ Î¼â‚ƒ Î½ Î½' Î½â‚ Î½â‚‚ : measure Î±} {s s' t : set Î±}
namespace measure
lemma measure_inter_eq_of_measure_eq {s t u : set Î±} (hs : measurable_set s)
  (h : Î¼ t = Î¼ u) (htu : t âŠ† u) (ht_ne_top : Î¼ t â‰  âˆ) :
  Î¼ (t âˆ© s) = Î¼ (u âˆ© s) :=
begin
  rw h at ht_ne_top,
  refine le_antisymm (measure_mono (inter_subset_inter_left _ htu)) _,
  have A : Î¼ (u âˆ© s) + Î¼ (u \ s) â‰¤ Î¼ (t âˆ© s) + Î¼ (u \ s) := calc
    Î¼ (u âˆ© s) + Î¼ (u \ s) = Î¼ u : measure_inter_add_diff _ hs
    ... = Î¼ t : h.symm
    ... = Î¼ (t âˆ© s) + Î¼ (t \ s) : (measure_inter_add_diff _ hs).symm
    ... â‰¤ Î¼ (t âˆ© s) + Î¼ (u \ s) :
      add_le_add le_rfl (measure_mono (diff_subset_diff htu subset.rfl)),
  have B : Î¼ (u \ s) â‰  âˆ := (lt_of_le_of_lt (measure_mono (diff_subset _ _)) ht_ne_top.lt_top).ne,
  exact ennreal.le_of_add_le_add_right B A
end
lemma measure_to_measurable_inter {s t : set Î±} (hs : measurable_set s) (ht : Î¼ t â‰  âˆ) :
  Î¼ (to_measurable Î¼ t âˆ© s) = Î¼ (t âˆ© s) :=
(measure_inter_eq_of_measure_eq hs (measure_to_measurable t).symm
  (subset_to_measurable Î¼ t) ht).symm
instance [measurable_space Î±] : has_zero (measure Î±) :=
âŸ¨{ to_outer_measure := 0,
   m_Union := Î» f hf hd, tsum_zero.symm,
   trimmed := outer_measure.trim_zero }âŸ©
@[simp] theorem zero_to_outer_measure {m : measurable_space Î±} :
  (0 : measure Î±).to_outer_measure = 0 := rfl
@[simp, norm_cast] theorem coe_zero {m : measurable_space Î±} : â‡‘(0 : measure Î±) = 0 := rfl
lemma eq_zero_of_is_empty [is_empty Î±] {m : measurable_space Î±} (Î¼ : measure Î±) : Î¼ = 0 :=
ext $ Î» s hs, by simp only [eq_empty_of_is_empty s, measure_empty]
instance [measurable_space Î±] : inhabited (measure Î±) := âŸ¨0âŸ©
instance [measurable_space Î±] : has_add (measure Î±) :=
âŸ¨Î» Î¼â‚ Î¼â‚‚,
{ to_outer_measure := Î¼â‚.to_outer_measure + Î¼â‚‚.to_outer_measure,
  m_Union := Î» s hs hd,
    show Î¼â‚ (â‹ƒ i, s i) + Î¼â‚‚ (â‹ƒ i, s i) = âˆ‘' i, (Î¼â‚ (s i) + Î¼â‚‚ (s i)),
    by rw [ennreal.tsum_add, measure_Union hd hs, measure_Union hd hs],
  trimmed := by rw [outer_measure.trim_add, Î¼â‚.trimmed, Î¼â‚‚.trimmed] }âŸ©
@[simp] theorem add_to_outer_measure {m : measurable_space Î±} (Î¼â‚ Î¼â‚‚ : measure Î±) :
  (Î¼â‚ + Î¼â‚‚).to_outer_measure = Î¼â‚.to_outer_measure + Î¼â‚‚.to_outer_measure := rfl
@[simp, norm_cast] theorem coe_add {m : measurable_space Î±} (Î¼â‚ Î¼â‚‚ : measure Î±) :
  â‡‘(Î¼â‚ + Î¼â‚‚) = Î¼â‚ + Î¼â‚‚ := rfl
theorem add_apply {m : measurable_space Î±} (Î¼â‚ Î¼â‚‚ : measure Î±) (s : set Î±) :
  (Î¼â‚ + Î¼â‚‚) s = Î¼â‚ s + Î¼â‚‚ s := rfl
section has_smul
variables [has_smul R â„â‰¥0âˆ] [is_scalar_tower R â„â‰¥0âˆ â„â‰¥0âˆ]
variables [has_smul R' â„â‰¥0âˆ] [is_scalar_tower R' â„â‰¥0âˆ â„â‰¥0âˆ]
instance [measurable_space Î±] : has_smul R (measure Î±) :=
âŸ¨Î» c Î¼,
  { to_outer_measure := c â€¢ Î¼.to_outer_measure,
    m_Union := Î» s hs hd, begin
      rw â†smul_one_smul â„â‰¥0âˆ c (_ : outer_measure Î±),
      dsimp,
      simp_rw [measure_Union hd hs, ennreal.tsum_mul_left],
    end,
    trimmed := by rw [outer_measure.trim_smul, Î¼.trimmed] }âŸ©
@[simp] theorem smul_to_outer_measure {m : measurable_space Î±} (c : R) (Î¼ : measure Î±) :
  (c â€¢ Î¼).to_outer_measure = c â€¢ Î¼.to_outer_measure :=
rfl
@[simp, norm_cast] theorem coe_smul {m : measurable_space Î±} (c : R) (Î¼ : measure Î±) :
  â‡‘(c â€¢ Î¼) = c â€¢ Î¼ :=
rfl
@[simp] theorem smul_apply {m : measurable_space Î±} (c : R) (Î¼ : measure Î±) (s : set Î±) :
  (c â€¢ Î¼) s = c â€¢ Î¼ s :=
rfl
instance [smul_comm_class R R' â„â‰¥0âˆ] [measurable_space Î±] :
  smul_comm_class R R' (measure Î±) :=
âŸ¨Î» _ _ _, ext $ Î» _ _, smul_comm _ _ _âŸ©
instance [has_smul R R'] [is_scalar_tower R R' â„â‰¥0âˆ] [measurable_space Î±] :
  is_scalar_tower R R' (measure Î±) :=
âŸ¨Î» _ _ _, ext $ Î» _ _, smul_assoc _ _ _âŸ©
instance [has_smul Ráµáµ’áµ– â„â‰¥0âˆ] [is_central_scalar R â„â‰¥0âˆ] [measurable_space Î±] :
  is_central_scalar R (measure Î±) :=
âŸ¨Î» _ _, ext $ Î» _ _, op_smul_eq_smul _ _âŸ©
end has_smul
instance [monoid R] [mul_action R â„â‰¥0âˆ] [is_scalar_tower R â„â‰¥0âˆ â„â‰¥0âˆ] [measurable_space Î±] :
  mul_action R (measure Î±) :=
injective.mul_action _ to_outer_measure_injective smul_to_outer_measure
instance add_comm_monoid [measurable_space Î±] : add_comm_monoid (measure Î±) :=
to_outer_measure_injective.add_comm_monoid to_outer_measure zero_to_outer_measure
      add_to_outer_measure (Î» _ _, smul_to_outer_measure _ _)
def coe_add_hom {m : measurable_space Î±} : measure Î± â†’+ (set Î± â†’ â„â‰¥0âˆ) :=
âŸ¨coe_fn, coe_zero, coe_addâŸ©
@[simp] lemma coe_finset_sum {m : measurable_space Î±} (I : finset Î¹) (Î¼ : Î¹ â†’ measure Î±) :
  â‡‘(âˆ‘ i in I, Î¼ i) = âˆ‘ i in I, Î¼ i :=
(@coe_add_hom Î± m).map_sum _ _
theorem finset_sum_apply {m : measurable_space Î±} (I : finset Î¹) (Î¼ : Î¹ â†’ measure Î±) (s : set Î±) :
  (âˆ‘ i in I, Î¼ i) s = âˆ‘ i in I, Î¼ i s :=
by rw [coe_finset_sum, finset.sum_apply]
instance [monoid R] [distrib_mul_action R â„â‰¥0âˆ] [is_scalar_tower R â„â‰¥0âˆ â„â‰¥0âˆ]
  [measurable_space Î±] :
  distrib_mul_action R (measure Î±) :=
injective.distrib_mul_action âŸ¨to_outer_measure, zero_to_outer_measure, add_to_outer_measureâŸ©
  to_outer_measure_injective smul_to_outer_measure
instance [semiring R] [module R â„â‰¥0âˆ] [is_scalar_tower R â„â‰¥0âˆ â„â‰¥0âˆ] [measurable_space Î±] :
  module R (measure Î±) :=
injective.module R âŸ¨to_outer_measure, zero_to_outer_measure, add_to_outer_measureâŸ©
  to_outer_measure_injective smul_to_outer_measure
@[simp] theorem coe_nnreal_smul_apply {m : measurable_space Î±} (c : â„â‰¥0) (Î¼ : measure Î±)
  (s : set Î±) :
  (c â€¢ Î¼) s = c * Î¼ s :=
rfl
lemma ae_smul_measure_iff {p : Î± â†’ Prop} {c : â„â‰¥0âˆ} (hc : c â‰  0) :
  (âˆ€áµ x âˆ‚(c â€¢ Î¼), p x) â†” âˆ€áµ x âˆ‚Î¼, p x :=
by simp [ae_iff, hc]
lemma measure_eq_left_of_subset_of_measure_add_eq {s t : set Î±}
  (h : (Î¼ + Î½) t â‰  âˆ) (h' : s âŠ† t) (h'' : (Î¼ + Î½) s = (Î¼ + Î½) t) :
  Î¼ s = Î¼ t :=
begin
  refine le_antisymm (measure_mono h') _,
  have : Î¼ t + Î½ t â‰¤ Î¼ s + Î½ t := calc
    Î¼ t + Î½ t = Î¼ s + Î½ s : h''.symm
    ... â‰¤ Î¼ s + Î½ t : add_le_add le_rfl (measure_mono h'),
  apply ennreal.le_of_add_le_add_right _ this,
  simp only [not_or_distrib, ennreal.add_eq_top, pi.add_apply, ne.def, coe_add] at h,
  exact h.2
end
lemma measure_eq_right_of_subset_of_measure_add_eq {s t : set Î±}
  (h : (Î¼ + Î½) t â‰  âˆ) (h' : s âŠ† t) (h'' : (Î¼ + Î½) s = (Î¼ + Î½) t) :
  Î½ s = Î½ t :=
begin
  rw add_comm at h'' h,
  exact measure_eq_left_of_subset_of_measure_add_eq h h' h''
end
lemma measure_to_measurable_add_inter_left {s t : set Î±}
  (hs : measurable_set s) (ht : (Î¼ + Î½) t â‰  âˆ) :
  Î¼ (to_measurable (Î¼ + Î½) t âˆ© s) = Î¼ (t âˆ© s) :=
begin
  refine (measure_inter_eq_of_measure_eq hs _ (subset_to_measurable _ _) _).symm,
  { refine measure_eq_left_of_subset_of_measure_add_eq _ (subset_to_measurable _ _)
      (measure_to_measurable t).symm,
    rwa measure_to_measurable t, },
  { simp only [not_or_distrib, ennreal.add_eq_top, pi.add_apply, ne.def, coe_add] at ht,
    exact ht.1 }
end
lemma measure_to_measurable_add_inter_right {s t : set Î±}
  (hs : measurable_set s) (ht : (Î¼ + Î½) t â‰  âˆ) :
  Î½ (to_measurable (Î¼ + Î½) t âˆ© s) = Î½ (t âˆ© s) :=
begin
  rw add_comm at ht âŠ¢,
  exact measure_to_measurable_add_inter_left hs ht
end
instance [measurable_space Î±] : partial_order (measure Î±) :=
{ le          := Î» mâ‚ mâ‚‚, âˆ€ s, measurable_set s â†’ mâ‚ s â‰¤ mâ‚‚ s,
  le_refl     := Î» m s hs, le_rfl,
  le_trans    := Î» mâ‚ mâ‚‚ mâ‚ƒ hâ‚ hâ‚‚ s hs, le_trans (hâ‚ s hs) (hâ‚‚ s hs),
  le_antisymm := Î» mâ‚ mâ‚‚ hâ‚ hâ‚‚, ext $
    Î» s hs, le_antisymm (hâ‚ s hs) (hâ‚‚ s hs) }
theorem le_iff : Î¼â‚ â‰¤ Î¼â‚‚ â†” âˆ€ s, measurable_set s â†’ Î¼â‚ s â‰¤ Î¼â‚‚ s := iff.rfl
theorem to_outer_measure_le : Î¼â‚.to_outer_measure â‰¤ Î¼â‚‚.to_outer_measure â†” Î¼â‚ â‰¤ Î¼â‚‚ :=
by rw [â† Î¼â‚‚.trimmed, outer_measure.le_trim_iff]; refl
theorem le_iff' : Î¼â‚ â‰¤ Î¼â‚‚ â†” âˆ€ s, Î¼â‚ s â‰¤ Î¼â‚‚ s :=
to_outer_measure_le.symm
theorem lt_iff : Î¼ < Î½ â†” Î¼ â‰¤ Î½ âˆ§ âˆƒ s, measurable_set s âˆ§ Î¼ s < Î½ s :=
lt_iff_le_not_le.trans $ and_congr iff.rfl $ by simp only [le_iff, not_forall, not_le, exists_prop]
theorem lt_iff' : Î¼ < Î½ â†” Î¼ â‰¤ Î½ âˆ§ âˆƒ s, Î¼ s < Î½ s :=
lt_iff_le_not_le.trans $ and_congr iff.rfl $ by simp only [le_iff', not_forall, not_le]
instance covariant_add_le [measurable_space Î±] : covariant_class (measure Î±) (measure Î±) (+) (â‰¤) :=
âŸ¨Î» Î½ Î¼â‚ Î¼â‚‚ hÎ¼ s hs, add_le_add_left (hÎ¼ s hs) _âŸ©
protected lemma le_add_left (h : Î¼ â‰¤ Î½) : Î¼ â‰¤ Î½' + Î½ :=
Î» s hs, le_add_left (h s hs)
protected lemma le_add_right (h : Î¼ â‰¤ Î½) : Î¼ â‰¤ Î½ + Î½' :=
Î» s hs, le_add_right (h s hs)
section Inf
variables {m : set (measure Î±)}
lemma Inf_caratheodory (s : set Î±) (hs : measurable_set s) :
  measurable_set[(Inf (to_outer_measure '' m)).caratheodory] s :=
begin
  rw [outer_measure.Inf_eq_bounded_by_Inf_gen],
  refine outer_measure.bounded_by_caratheodory (Î» t, _),
  simp only [outer_measure.Inf_gen, le_infi_iff, ball_image_iff, coe_to_outer_measure,
    measure_eq_infi t],
  intros Î¼ hÎ¼ u htu hu,
  have hm : âˆ€ {s t}, s âŠ† t â†’ outer_measure.Inf_gen (to_outer_measure '' m) s â‰¤ Î¼ t,
  { intros s t hst,
    rw [outer_measure.Inf_gen_def],
    refine infi_le_of_le (Î¼.to_outer_measure) (infi_le_of_le (mem_image_of_mem _ hÎ¼) _),
    rw [to_outer_measure_apply],
    refine measure_mono hst },
  rw [â† measure_inter_add_diff u hs],
  refine add_le_add (hm $ inter_subset_inter_left _ htu) (hm $ diff_subset_diff_left htu)
end
instance [measurable_space Î±] : has_Inf (measure Î±) :=
âŸ¨Î» m, (Inf (to_outer_measure '' m)).to_measure $ Inf_caratheodoryâŸ©
lemma Inf_apply (hs : measurable_set s) : Inf m s = Inf (to_outer_measure '' m) s :=
to_measure_apply _ _ hs
private lemma measure_Inf_le (h : Î¼ âˆˆ m) : Inf m â‰¤ Î¼ :=
have Inf (to_outer_measure '' m) â‰¤ Î¼.to_outer_measure := Inf_le (mem_image_of_mem _ h),
Î» s hs, by rw [Inf_apply hs, â† to_outer_measure_apply]; exact this s
private lemma measure_le_Inf (h : âˆ€ Î¼' âˆˆ m, Î¼ â‰¤ Î¼') : Î¼ â‰¤ Inf m :=
have Î¼.to_outer_measure â‰¤ Inf (to_outer_measure '' m) :=
  le_Inf $ ball_image_of_ball $ Î» Î¼ hÎ¼, to_outer_measure_le.2 $ h _ hÎ¼,
Î» s hs, by rw [Inf_apply hs, â† to_outer_measure_apply]; exact this s
instance [measurable_space Î±] : complete_semilattice_Inf (measure Î±) :=
{ Inf_le := Î» s a, measure_Inf_le,
  le_Inf := Î» s a, measure_le_Inf,
  ..(by apply_instance : partial_order (measure Î±)),
  ..(by apply_instance : has_Inf (measure Î±)), }
instance [measurable_space Î±] : complete_lattice (measure Î±) :=
{ bot := 0,
  bot_le := Î» a s hs, by exact bot_le,
  .. complete_lattice_of_complete_semilattice_Inf (measure Î±) }
end Inf
@[simp] lemma top_add : âŠ¤ + Î¼ = âŠ¤ := top_unique $ measure.le_add_right le_rfl
@[simp] lemma add_top : Î¼ + âŠ¤ = âŠ¤ := top_unique $ measure.le_add_left le_rfl
protected lemma zero_le {m0 : measurable_space Î±} (Î¼ : measure Î±) : 0 â‰¤ Î¼ := bot_le
lemma nonpos_iff_eq_zero' : Î¼ â‰¤ 0 â†” Î¼ = 0 :=
Î¼.zero_le.le_iff_eq
@[simp] lemma measure_univ_eq_zero : Î¼ univ = 0 â†” Î¼ = 0 :=
âŸ¨Î» h, bot_unique $ Î» s hs, trans_rel_left (â‰¤) (measure_mono (subset_univ s)) h, Î» h, h.symm â–¸ rflâŸ©
def lift_linear {m0 : measurable_space Î±} (f : outer_measure Î± â†’â‚—[â„â‰¥0âˆ] outer_measure Î²)
  (hf : âˆ€ Î¼ : measure Î±, â€¹_â€º â‰¤ (f Î¼.to_outer_measure).caratheodory) :
  measure Î± â†’â‚—[â„â‰¥0âˆ] measure Î² :=
{ to_fun := Î» Î¼, (f Î¼.to_outer_measure).to_measure (hf Î¼),
  map_add' := Î» Î¼â‚ Î¼â‚‚, ext $ Î» s hs, by simp [hs],
  map_smul' := Î» c Î¼, ext $ Î» s hs, by simp [hs] }
@[simp] lemma lift_linear_apply {f : outer_measure Î± â†’â‚—[â„â‰¥0âˆ] outer_measure Î²} (hf)
  {s : set Î²} (hs : measurable_set s) : lift_linear f hf Î¼ s = f Î¼.to_outer_measure s :=
to_measure_apply _ _ hs
lemma le_lift_linear_apply {f : outer_measure Î± â†’â‚—[â„â‰¥0âˆ] outer_measure Î²} (hf) (s : set Î²) :
  f Î¼.to_outer_measure s â‰¤ lift_linear f hf Î¼ s :=
le_to_measure_apply _ _ s
def mapâ‚— [measurable_space Î±] (f : Î± â†’ Î²) : measure Î± â†’â‚—[â„â‰¥0âˆ] measure Î² :=
if hf : measurable f then
  lift_linear (outer_measure.map f) $ Î» Î¼ s hs t,
    le_to_outer_measure_caratheodory Î¼ _ (hf hs) (f â»Â¹' t)
else 0
lemma mapâ‚—_congr {f g : Î± â†’ Î²} (hf : measurable f) (hg : measurable g) (h : f =áµ[Î¼] g) :
  mapâ‚— f Î¼ = mapâ‚— g Î¼ :=
begin
  ext1 s hs,
  simpa only [mapâ‚—, hf, hg, hs, dif_pos, lift_linear_apply, outer_measure.map_apply,
    coe_to_outer_measure] using measure_congr (h.preimage s),
end
@[irreducible] def map [measurable_space Î±] (f : Î± â†’ Î²) (Î¼ : measure Î±) : measure Î² :=
if hf : ae_measurable f Î¼ then mapâ‚— (hf.mk f) Î¼ else 0
include m0
lemma mapâ‚—_mk_apply_of_ae_measurable {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) :
  mapâ‚— (hf.mk f) Î¼ = map f Î¼ :=
by simp [map, hf]
lemma mapâ‚—_apply_of_measurable {f : Î± â†’ Î²} (hf : measurable f) (Î¼ : measure Î±) :
  mapâ‚— f Î¼ = map f Î¼ :=
begin
  simp only [â† mapâ‚—_mk_apply_of_ae_measurable hf.ae_measurable],
  exact mapâ‚—_congr hf hf.ae_measurable.measurable_mk hf.ae_measurable.ae_eq_mk
end
@[simp] lemma map_add (Î¼ Î½ : measure Î±) {f : Î± â†’ Î²} (hf : measurable f) :
  (Î¼ + Î½).map f = Î¼.map f + Î½.map f :=
by simp [â† mapâ‚—_apply_of_measurable hf]
@[simp] lemma map_zero (f : Î± â†’ Î²) :
  (0 : measure Î±).map f = 0 :=
begin
  by_cases hf : ae_measurable f (0 : measure Î±);
  simp [map, hf],
end
theorem map_of_not_ae_measurable {f : Î± â†’ Î²} {Î¼ : measure Î±} (hf : Â¬ ae_measurable f Î¼) :
  Î¼.map f = 0 :=
by simp [map, hf]
lemma map_congr {f g : Î± â†’ Î²} (h : f =áµ[Î¼] g) : measure.map f Î¼ = measure.map g Î¼ :=
begin
  by_cases hf : ae_measurable f Î¼,
  { have hg : ae_measurable g Î¼ := hf.congr h,
    simp only [â† mapâ‚—_mk_apply_of_ae_measurable hf, â† mapâ‚—_mk_apply_of_ae_measurable hg],
    exact mapâ‚—_congr hf.measurable_mk hg.measurable_mk
      (hf.ae_eq_mk.symm.trans (h.trans hg.ae_eq_mk)) },
  { have hg : Â¬ (ae_measurable g Î¼), by simpa [â† ae_measurable_congr h] using hf,
    simp [map_of_not_ae_measurable, hf, hg] }
end
@[simp] protected lemma map_smul (c : â„â‰¥0âˆ) (Î¼ : measure Î±) (f : Î± â†’ Î²) :
  (c â€¢ Î¼).map f = c â€¢ Î¼.map f :=
begin
  rcases eq_or_ne c 0 with rfl|hc, { simp },
  by_cases hf : ae_measurable f Î¼,
  { have hfc : ae_measurable f (c â€¢ Î¼) :=
      âŸ¨hf.mk f, hf.measurable_mk, (ae_smul_measure_iff hc).2 hf.ae_eq_mkâŸ©,
    simp only [â†mapâ‚—_mk_apply_of_ae_measurable hf, â†mapâ‚—_mk_apply_of_ae_measurable hfc,
      linear_map.map_smulâ‚›â‚—, ring_hom.id_apply],
    congr' 1,
    apply mapâ‚—_congr hfc.measurable_mk hf.measurable_mk,
    exact eventually_eq.trans ((ae_smul_measure_iff hc).1 hfc.ae_eq_mk.symm) hf.ae_eq_mk },
  { have hfc : Â¬ (ae_measurable f (c â€¢ Î¼)),
    { assume hfc,
      exact hf âŸ¨hfc.mk f, hfc.measurable_mk, (ae_smul_measure_iff hc).1 hfc.ae_eq_mkâŸ© },
    simp [map_of_not_ae_measurable hf, map_of_not_ae_measurable hfc] }
end
@[simp] theorem map_apply_of_ae_measurable
  {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {s : set Î²} (hs : measurable_set s) :
  Î¼.map f s = Î¼ (f â»Â¹' s) :=
by simpa only [mapâ‚—, hf.measurable_mk, hs, dif_pos, lift_linear_apply, outer_measure.map_apply,
  coe_to_outer_measure, â† mapâ‚—_mk_apply_of_ae_measurable hf]
  using measure_congr (hf.ae_eq_mk.symm.preimage s)
@[simp] theorem map_apply
  {f : Î± â†’ Î²} (hf : measurable f) {s : set Î²} (hs : measurable_set s) :
  Î¼.map f s = Î¼ (f â»Â¹' s) :=
map_apply_of_ae_measurable hf.ae_measurable hs
lemma map_to_outer_measure {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) :
  (Î¼.map f).to_outer_measure = (outer_measure.map f Î¼.to_outer_measure).trim :=
begin
  rw [â† trimmed, outer_measure.trim_eq_trim_iff],
  intros s hs,
  rw [coe_to_outer_measure, map_apply_of_ae_measurable hf hs, outer_measure.map_apply,
    coe_to_outer_measure]
end
@[simp] lemma map_id : map id Î¼ = Î¼ :=
ext $ Î» s, map_apply measurable_id
@[simp] lemma map_id' : map (Î» x, x) Î¼ = Î¼ := map_id
lemma map_map {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : measurable g) (hf : measurable f) :
  (Î¼.map f).map g = Î¼.map (g âˆ˜ f) :=
ext $ Î» s hs, by simp [hf, hg, hs, hg hs, hg.comp hf, â† preimage_comp]
@[mono] lemma map_mono {f : Î± â†’ Î²} (h : Î¼ â‰¤ Î½) (hf : measurable f) : Î¼.map f â‰¤ Î½.map f :=
Î» s hs, by simp [hf.ae_measurable, hs, h _ (hf hs)]
theorem le_map_apply {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) (s : set Î²) : Î¼ (f â»Â¹' s) â‰¤ Î¼.map f s :=
calc Î¼ (f â»Â¹' s) â‰¤ Î¼ (f â»Â¹' (to_measurable (Î¼.map f) s)) :
  measure_mono $ preimage_mono $ subset_to_measurable _ _
... = Î¼.map f (to_measurable (Î¼.map f) s) :
  (map_apply_of_ae_measurable hf $ measurable_set_to_measurable _ _).symm
... = Î¼.map f s : measure_to_measurable _
lemma preimage_null_of_map_null {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {s : set Î²}
  (hs : Î¼.map f s = 0) : Î¼ (f â»Â¹' s) = 0 :=
nonpos_iff_eq_zero.mp $ (le_map_apply hf s).trans_eq hs
lemma tendsto_ae_map {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) : tendsto f Î¼.ae (Î¼.map f).ae :=
Î» s hs, preimage_null_of_map_null hf hs
omit m0
def comap [measurable_space Î±] (f : Î± â†’ Î²) : measure Î² â†’â‚—[â„â‰¥0âˆ] measure Î± :=
if hf : injective f âˆ§ âˆ€ s, measurable_set s â†’ measurable_set (f '' s) then
  lift_linear (outer_measure.comap f) $ Î» Î¼ s hs t,
  begin
    simp only [coe_to_outer_measure, outer_measure.comap_apply, â† image_inter hf.1,
      image_diff hf.1],
    apply le_to_outer_measure_caratheodory,
    exact hf.2 s hs
  end
else 0
lemma comap_apply {Î²} [measurable_space Î±] {mÎ² : measurable_space Î²} (f : Î± â†’ Î²) (hfi : injective f)
  (hf : âˆ€ s, measurable_set s â†’ measurable_set (f '' s)) (Î¼ : measure Î²) (hs : measurable_set s) :
  comap f Î¼ s = Î¼ (f '' s) :=
begin
  rw [comap, dif_pos, lift_linear_apply _ hs, outer_measure.comap_apply, coe_to_outer_measure],
  exact âŸ¨hfi, hfâŸ©
end
def restrictâ‚— {m0 : measurable_space Î±} (s : set Î±) : measure Î± â†’â‚—[â„â‰¥0âˆ] measure Î± :=
lift_linear (outer_measure.restrict s) $ Î» Î¼ s' hs' t,
begin
  suffices : Î¼ (s âˆ© t) = Î¼ (s âˆ© t âˆ© s') + Î¼ (s âˆ© t \ s'),
  { simpa [â† set.inter_assoc, set.inter_comm _ s, â† inter_diff_assoc] },
  exact le_to_outer_measure_caratheodory _ _ hs' _,
end
def restrict {m0 : measurable_space Î±} (Î¼ : measure Î±) (s : set Î±) : measure Î± := restrictâ‚— s Î¼
@[simp] lemma restrictâ‚—_apply {m0 : measurable_space Î±} (s : set Î±) (Î¼ : measure Î±) :
  restrictâ‚— s Î¼ = Î¼.restrict s :=
rfl
lemma restrict_to_outer_measure_eq_to_outer_measure_restrict (h : measurable_set s) :
    (Î¼.restrict s).to_outer_measure = outer_measure.restrict s Î¼.to_outer_measure :=
by simp_rw [restrict, restrictâ‚—, lift_linear, linear_map.coe_mk, to_measure_to_outer_measure,
  outer_measure.restrict_trim h, Î¼.trimmed]
lemma restrict_applyâ‚€ (ht : null_measurable_set t (Î¼.restrict s)) :
  Î¼.restrict s t = Î¼ (t âˆ© s) :=
(to_measure_applyâ‚€ _ _ ht).trans $ by simp only [coe_to_outer_measure, outer_measure.restrict_apply]
@[simp] lemma restrict_apply (ht : measurable_set t) : Î¼.restrict s t = Î¼ (t âˆ© s) :=
restrict_applyâ‚€ ht.null_measurable_set
lemma restrict_mono' {m0 : measurable_space Î±} â¦ƒs s' : set Î±â¦„ â¦ƒÎ¼ Î½ : measure Î±â¦„
  (hs : s â‰¤áµ[Î¼] s') (hÎ¼Î½ : Î¼ â‰¤ Î½) :
  Î¼.restrict s â‰¤ Î½.restrict s' :=
assume t ht,
calc Î¼.restrict s t = Î¼ (t âˆ© s) : restrict_apply ht
... â‰¤ Î¼ (t âˆ© s') : measure_mono_ae $ hs.mono $ Î» x hx âŸ¨hxt, hxsâŸ©, âŸ¨hxt, hx hxsâŸ©
... â‰¤ Î½ (t âˆ© s') : le_iff'.1 hÎ¼Î½ (t âˆ© s')
... = Î½.restrict s' t : (restrict_apply ht).symm
@[mono] lemma restrict_mono {m0 : measurable_space Î±} â¦ƒs s' : set Î±â¦„ (hs : s âŠ† s') â¦ƒÎ¼ Î½ : measure Î±â¦„
  (hÎ¼Î½ : Î¼ â‰¤ Î½) :
  Î¼.restrict s â‰¤ Î½.restrict s' :=
restrict_mono' (ae_of_all _ hs) hÎ¼Î½
lemma restrict_mono_ae (h : s â‰¤áµ[Î¼] t) : Î¼.restrict s â‰¤ Î¼.restrict t :=
restrict_mono' h (le_refl Î¼)
lemma restrict_congr_set (h : s =áµ[Î¼] t) : Î¼.restrict s = Î¼.restrict t :=
le_antisymm (restrict_mono_ae h.le) (restrict_mono_ae h.symm.le)
@[simp] lemma restrict_apply' (hs : measurable_set s) : Î¼.restrict s t = Î¼ (t âˆ© s) :=
by rw [â† coe_to_outer_measure, measure.restrict_to_outer_measure_eq_to_outer_measure_restrict hs,
      outer_measure.restrict_apply s t _, coe_to_outer_measure]
lemma restrict_applyâ‚€' (hs : null_measurable_set s Î¼) : Î¼.restrict s t = Î¼ (t âˆ© s) :=
by rw [â† restrict_congr_set hs.to_measurable_ae_eq,
  restrict_apply' (measurable_set_to_measurable _ _),
  measure_congr ((ae_eq_refl t).inter hs.to_measurable_ae_eq)]
lemma restrict_le_self : Î¼.restrict s â‰¤ Î¼ :=
Î» t ht,
calc Î¼.restrict s t = Î¼ (t âˆ© s) : restrict_apply ht
... â‰¤ Î¼ t : measure_mono $ inter_subset_left t s
variable (Î¼)
lemma restrict_eq_self (h : s âŠ† t) : Î¼.restrict t s = Î¼ s :=
(le_iff'.1 restrict_le_self s).antisymm $
calc Î¼ s â‰¤ Î¼ (to_measurable (Î¼.restrict t) s âˆ© t) :
  measure_mono (subset_inter (subset_to_measurable _ _) h)
... =  Î¼.restrict t s :
  by rw [â† restrict_apply (measurable_set_to_measurable _ _), measure_to_measurable]
@[simp] lemma restrict_apply_self (s : set Î±):
  (Î¼.restrict s) s = Î¼ s :=
restrict_eq_self Î¼ subset.rfl
variable {Î¼}
lemma restrict_apply_univ (s : set Î±) : Î¼.restrict s univ = Î¼ s :=
by rw [restrict_apply measurable_set.univ, set.univ_inter]
lemma le_restrict_apply (s t : set Î±) :
  Î¼ (t âˆ© s) â‰¤ Î¼.restrict s t :=
calc Î¼ (t âˆ© s) = Î¼.restrict s (t âˆ© s) : (restrict_eq_self Î¼ (inter_subset_right _ _)).symm
... â‰¤ Î¼.restrict s t : measure_mono (inter_subset_left _ _)
lemma restrict_apply_superset (h : s âŠ† t) : Î¼.restrict s t = Î¼ s :=
((measure_mono (subset_univ _)).trans_eq $ restrict_apply_univ _).antisymm
  ((restrict_apply_self Î¼ s).symm.trans_le $ measure_mono h)
@[simp] lemma restrict_add {m0 : measurable_space Î±} (Î¼ Î½ : measure Î±) (s : set Î±) :
  (Î¼ + Î½).restrict s = Î¼.restrict s + Î½.restrict s :=
(restrictâ‚— s).map_add Î¼ Î½
@[simp] lemma restrict_zero {m0 : measurable_space Î±} (s : set Î±) :
  (0 : measure Î±).restrict s = 0 :=
(restrictâ‚— s).map_zero
@[simp] lemma restrict_smul {m0 : measurable_space Î±} (c : â„â‰¥0âˆ) (Î¼ : measure Î±) (s : set Î±) :
  (c â€¢ Î¼).restrict s = c â€¢ Î¼.restrict s :=
(restrictâ‚— s).map_smul c Î¼
lemma restrict_restrictâ‚€ (hs : null_measurable_set s (Î¼.restrict t)) :
  (Î¼.restrict t).restrict s = Î¼.restrict (s âˆ© t) :=
ext $ Î» u hu, by simp only [set.inter_assoc, restrict_apply hu,
  restrict_applyâ‚€ (hu.null_measurable_set.inter hs)]
@[simp] lemma restrict_restrict (hs : measurable_set s) :
  (Î¼.restrict t).restrict s = Î¼.restrict (s âˆ© t) :=
restrict_restrictâ‚€ hs.null_measurable_set
lemma restrict_restrict_of_subset (h : s âŠ† t) :
  (Î¼.restrict t).restrict s = Î¼.restrict s :=
begin
  ext1 u hu,
  rw [restrict_apply hu, restrict_apply hu, restrict_eq_self],
  exact (inter_subset_right _ _).trans h
end
lemma restrict_restrictâ‚€' (ht : null_measurable_set t Î¼) :
  (Î¼.restrict t).restrict s = Î¼.restrict (s âˆ© t) :=
ext $ Î» u hu, by simp only [restrict_apply hu, restrict_applyâ‚€' ht, inter_assoc]
lemma restrict_restrict' (ht : measurable_set t) :
  (Î¼.restrict t).restrict s = Î¼.restrict (s âˆ© t) :=
restrict_restrictâ‚€' ht.null_measurable_set
lemma restrict_comm (hs : measurable_set s) :
  (Î¼.restrict t).restrict s = (Î¼.restrict s).restrict t :=
by rw [restrict_restrict hs, restrict_restrict' hs, inter_comm]
lemma restrict_apply_eq_zero (ht : measurable_set t) : Î¼.restrict s t = 0 â†” Î¼ (t âˆ© s) = 0 :=
by rw [restrict_apply ht]
lemma measure_inter_eq_zero_of_restrict (h : Î¼.restrict s t = 0) : Î¼ (t âˆ© s) = 0 :=
nonpos_iff_eq_zero.1 (h â–¸ le_restrict_apply _ _)
lemma restrict_apply_eq_zero' (hs : measurable_set s) : Î¼.restrict s t = 0 â†” Î¼ (t âˆ© s) = 0 :=
by rw [restrict_apply' hs]
@[simp] lemma restrict_eq_zero : Î¼.restrict s = 0 â†” Î¼ s = 0 :=
by rw [â† measure_univ_eq_zero, restrict_apply_univ]
lemma restrict_zero_set {s : set Î±} (h : Î¼ s = 0) :
  Î¼.restrict s = 0 :=
restrict_eq_zero.2 h
@[simp] lemma restrict_empty : Î¼.restrict âˆ… = 0 := restrict_zero_set measure_empty
@[simp] lemma restrict_univ : Î¼.restrict univ = Î¼ := ext $ Î» s hs, by simp [hs]
lemma restrict_inter_add_diffâ‚€ (s : set Î±) (ht : null_measurable_set t Î¼) :
  Î¼.restrict (s âˆ© t) + Î¼.restrict (s \ t) = Î¼.restrict s :=
begin
  ext1 u hu,
  simp only [add_apply, restrict_apply hu, â† inter_assoc, diff_eq],
  exact measure_inter_add_diffâ‚€ (u âˆ© s) ht
end
lemma restrict_inter_add_diff (s : set Î±) (ht : measurable_set t) :
  Î¼.restrict (s âˆ© t) + Î¼.restrict (s \ t) = Î¼.restrict s :=
restrict_inter_add_diffâ‚€ s ht.null_measurable_set
lemma restrict_union_add_interâ‚€ (s : set Î±) (ht : null_measurable_set t Î¼) :
  Î¼.restrict (s âˆª t) + Î¼.restrict (s âˆ© t) = Î¼.restrict s + Î¼.restrict t :=
by rw [â† restrict_inter_add_diffâ‚€ (s âˆª t) ht, union_inter_cancel_right, union_diff_right,
 â† restrict_inter_add_diffâ‚€ s ht, add_comm, â† add_assoc, add_right_comm]
lemma restrict_union_add_inter (s : set Î±) (ht : measurable_set t) :
  Î¼.restrict (s âˆª t) + Î¼.restrict (s âˆ© t) = Î¼.restrict s + Î¼.restrict t :=
restrict_union_add_interâ‚€ s ht.null_measurable_set
lemma restrict_union_add_inter' (hs : measurable_set s) (t : set Î±) :
  Î¼.restrict (s âˆª t) + Î¼.restrict (s âˆ© t) = Î¼.restrict s + Î¼.restrict t :=
by simpa only [union_comm, inter_comm, add_comm] using restrict_union_add_inter t hs
lemma restrict_unionâ‚€ (h : ae_disjoint Î¼ s t) (ht : null_measurable_set t Î¼) :
  Î¼.restrict (s âˆª t) = Î¼.restrict s + Î¼.restrict t :=
by simp [â† restrict_union_add_interâ‚€ s ht, restrict_zero_set h]
lemma restrict_union (h : disjoint s t) (ht : measurable_set t) :
  Î¼.restrict (s âˆª t) = Î¼.restrict s + Î¼.restrict t :=
restrict_unionâ‚€ h.ae_disjoint ht.null_measurable_set
lemma restrict_union' (h : disjoint s t) (hs : measurable_set s) :
  Î¼.restrict (s âˆª t) = Î¼.restrict s + Î¼.restrict t :=
by rw [union_comm, restrict_union h.symm hs, add_comm]
@[simp] lemma restrict_add_restrict_compl (hs : measurable_set s) :
  Î¼.restrict s + Î¼.restrict sá¶œ = Î¼ :=
by rw [â† restrict_union (@disjoint_compl_right (set Î±) _ _) hs.compl,
    union_compl_self, restrict_univ]
@[simp] lemma restrict_compl_add_restrict (hs : measurable_set s) :
  Î¼.restrict sá¶œ + Î¼.restrict s = Î¼ :=
by rw [add_comm, restrict_add_restrict_compl hs]
lemma restrict_union_le (s s' : set Î±) : Î¼.restrict (s âˆª s') â‰¤ Î¼.restrict s + Î¼.restrict s' :=
begin
  intros t ht,
  suffices : Î¼ (t âˆ© s âˆª t âˆ© s') â‰¤ Î¼ (t âˆ© s) + Î¼ (t âˆ© s'),
    by simpa [ht, inter_union_distrib_left],
  apply measure_union_le
end
lemma restrict_Union_apply_ae [encodable Î¹] {s : Î¹ â†’ set Î±}
  (hd : pairwise (ae_disjoint Î¼ on s))
  (hm : âˆ€ i, null_measurable_set (s i) Î¼) {t : set Î±} (ht : measurable_set t) :
  Î¼.restrict (â‹ƒ i, s i) t = âˆ‘' i, Î¼.restrict (s i) t :=
begin
  simp only [restrict_apply, ht, inter_Union],
  exact measure_Unionâ‚€ (hd.mono $ Î» i j h, h.mono (inter_subset_right _ _) (inter_subset_right _ _))
    (Î» i, (ht.null_measurable_set.inter (hm i)))
end
lemma restrict_Union_apply [encodable Î¹] {s : Î¹ â†’ set Î±} (hd : pairwise (disjoint on s))
  (hm : âˆ€ i, measurable_set (s i)) {t : set Î±} (ht : measurable_set t) :
  Î¼.restrict (â‹ƒ i, s i) t = âˆ‘' i, Î¼.restrict (s i) t :=
restrict_Union_apply_ae hd.ae_disjoint (Î» i, (hm i).null_measurable_set) ht
lemma restrict_Union_apply_eq_supr [encodable Î¹] {s : Î¹ â†’ set Î±}
  (hd : directed (âŠ†) s) {t : set Î±} (ht : measurable_set t) :
  Î¼.restrict (â‹ƒ i, s i) t = â¨† i, Î¼.restrict (s i) t :=
begin
  simp only [restrict_apply ht, inter_Union],
  rw [measure_Union_eq_supr],
  exacts [hd.mono_comp _ (Î» sâ‚ sâ‚‚, inter_subset_inter_right _)]
end
lemma restrict_map {f : Î± â†’ Î²} (hf : measurable f) {s : set Î²} (hs : measurable_set s) :
  (Î¼.map f).restrict s = (Î¼.restrict $ f â»Â¹' s).map f  :=
ext $ Î» t ht, by simp [*, hf ht]
lemma restrict_to_measurable (h : Î¼ s â‰  âˆ) : Î¼.restrict (to_measurable Î¼ s) = Î¼.restrict s :=
ext $ Î» t ht, by rw [restrict_apply ht, restrict_apply ht, inter_comm,
  measure_to_measurable_inter ht h, inter_comm]
lemma restrict_eq_self_of_ae_mem {m0 : measurable_space Î±} â¦ƒs : set Î±â¦„ â¦ƒÎ¼ : measure Î±â¦„
  (hs : âˆ€áµ x âˆ‚Î¼, x âˆˆ s) :
  Î¼.restrict s = Î¼ :=
calc Î¼.restrict s = Î¼.restrict univ : restrict_congr_set (eventually_eq_univ.mpr hs)
... = Î¼ : restrict_univ
lemma restrict_congr_meas (hs : measurable_set s) :
  Î¼.restrict s = Î½.restrict s â†” âˆ€ t âŠ† s, measurable_set t â†’ Î¼ t = Î½ t :=
âŸ¨Î» H t hts ht,
   by rw [â† inter_eq_self_of_subset_left hts, â† restrict_apply ht, H, restrict_apply ht],
 Î» H, ext $ Î» t ht,
   by rw [restrict_apply ht, restrict_apply ht, H _ (inter_subset_right _ _) (ht.inter hs)]âŸ©
lemma restrict_congr_mono (hs : s âŠ† t) (h : Î¼.restrict t = Î½.restrict t) :
  Î¼.restrict s = Î½.restrict s :=
by rw [â† restrict_restrict_of_subset hs, h, restrict_restrict_of_subset hs]
lemma restrict_union_congr :
  Î¼.restrict (s âˆª t) = Î½.restrict (s âˆª t) â†”
    Î¼.restrict s = Î½.restrict s âˆ§ Î¼.restrict t = Î½.restrict t :=
begin
  refine âŸ¨Î» h, âŸ¨restrict_congr_mono (subset_union_left _ _) h,
    restrict_congr_mono (subset_union_right _ _) hâŸ©, _âŸ©,
  rintro âŸ¨hs, htâŸ©,
  ext1 u hu,
  simp only [restrict_apply hu, inter_union_distrib_left],
  rcases exists_measurable_supersetâ‚‚ Î¼ Î½ (u âˆ© s) with âŸ¨US, hsub, hm, hÎ¼, hÎ½âŸ©,
  calc Î¼ (u âˆ© s âˆª u âˆ© t) = Î¼ (US âˆª u âˆ© t) :
    measure_union_congr_of_subset hsub hÎ¼.le subset.rfl le_rfl
  ... = Î¼ US + Î¼ (u âˆ© t \ US) : (measure_add_diff hm _).symm
  ... = restrict Î¼ s u + restrict Î¼ t (u \ US) :
    by simp only [restrict_apply, hu, hu.diff hm, hÎ¼, â† inter_comm t, inter_diff_assoc]
  ... = restrict Î½ s u + restrict Î½ t (u \ US) : by rw [hs, ht]
  ... = Î½ US + Î½ (u âˆ© t \ US) :
    by simp only [restrict_apply, hu, hu.diff hm, hÎ½, â† inter_comm t, inter_diff_assoc]
  ... = Î½ (US âˆª u âˆ© t) : measure_add_diff hm _
  ... = Î½ (u âˆ© s âˆª u âˆ© t) :
    eq.symm $ measure_union_congr_of_subset hsub hÎ½.le subset.rfl le_rfl
end
lemma restrict_finset_bUnion_congr {s : finset Î¹} {t : Î¹ â†’ set Î±} :
  Î¼.restrict (â‹ƒ i âˆˆ s, t i) = Î½.restrict (â‹ƒ i âˆˆ s, t i) â†”
    âˆ€ i âˆˆ s, Î¼.restrict (t i) = Î½.restrict (t i) :=
begin
  induction s using finset.induction_on with i s hi hs, { simp },
  simp only [forall_eq_or_imp, Union_Union_eq_or_left, finset.mem_insert],
  rw [restrict_union_congr, â† hs]
end
lemma restrict_Union_congr [encodable Î¹] {s : Î¹ â†’ set Î±} :
  Î¼.restrict (â‹ƒ i, s i) = Î½.restrict (â‹ƒ i, s i) â†”
    âˆ€ i, Î¼.restrict (s i) = Î½.restrict (s i) :=
begin
  refine âŸ¨Î» h i, restrict_congr_mono (subset_Union _ _) h, Î» h, _âŸ©,
  ext1 t ht,
  have D : directed (âŠ†) (Î» t : finset Î¹, â‹ƒ i âˆˆ t, s i) :=
    directed_of_sup (Î» tâ‚ tâ‚‚ ht, bUnion_subset_bUnion_left ht),
  rw [Union_eq_Union_finset],
  simp only [restrict_Union_apply_eq_supr D ht,
    restrict_finset_bUnion_congr.2 (Î» i hi, h i)],
end
lemma restrict_bUnion_congr {s : set Î¹} {t : Î¹ â†’ set Î±} (hc : s.countable) :
  Î¼.restrict (â‹ƒ i âˆˆ s, t i) = Î½.restrict (â‹ƒ i âˆˆ s, t i) â†”
    âˆ€ i âˆˆ s, Î¼.restrict (t i) = Î½.restrict (t i) :=
begin
  haveI := hc.to_encodable,
  simp only [bUnion_eq_Union, set_coe.forall', restrict_Union_congr]
end
lemma restrict_sUnion_congr {S : set (set Î±)} (hc : S.countable) :
  Î¼.restrict (â‹ƒâ‚€ S) = Î½.restrict (â‹ƒâ‚€ S) â†” âˆ€ s âˆˆ S, Î¼.restrict s = Î½.restrict s :=
by rw [sUnion_eq_bUnion, restrict_bUnion_congr hc]
lemma restrict_Inf_eq_Inf_restrict {m0 : measurable_space Î±} {m : set (measure Î±)}
  (hm : m.nonempty) (ht : measurable_set t) :
  (Inf m).restrict t = Inf ((Î» Î¼ : measure Î±, Î¼.restrict t) '' m) :=
begin
  ext1 s hs,
  simp_rw [Inf_apply hs, restrict_apply hs, Inf_apply (measurable_set.inter hs ht), set.image_image,
    restrict_to_outer_measure_eq_to_outer_measure_restrict ht, â† set.image_image _ to_outer_measure,
    â† outer_measure.restrict_Inf_eq_Inf_restrict _ (hm.image _),
    outer_measure.restrict_apply]
end
lemma ext_iff_of_Union_eq_univ [encodable Î¹] {s : Î¹ â†’ set Î±} (hs : (â‹ƒ i, s i) = univ) :
  Î¼ = Î½ â†” âˆ€ i, Î¼.restrict (s i) = Î½.restrict (s i) :=
by rw [â† restrict_Union_congr, hs, restrict_univ, restrict_univ]
alias ext_iff_of_Union_eq_univ â†” _ ext_of_Union_eq_univ
lemma ext_iff_of_bUnion_eq_univ {S : set Î¹} {s : Î¹ â†’ set Î±} (hc : S.countable)
  (hs : (â‹ƒ i âˆˆ S, s i) = univ) :
  Î¼ = Î½ â†” âˆ€ i âˆˆ S, Î¼.restrict (s i) = Î½.restrict (s i) :=
by rw [â† restrict_bUnion_congr hc, hs, restrict_univ, restrict_univ]
alias ext_iff_of_bUnion_eq_univ â†” _ ext_of_bUnion_eq_univ
lemma ext_iff_of_sUnion_eq_univ {S : set (set Î±)} (hc : S.countable) (hs : (â‹ƒâ‚€ S) = univ) :
  Î¼ = Î½ â†” âˆ€ s âˆˆ S, Î¼.restrict s = Î½.restrict s :=
ext_iff_of_bUnion_eq_univ hc $ by rwa â† sUnion_eq_bUnion
alias ext_iff_of_sUnion_eq_univ â†” _ ext_of_sUnion_eq_univ
lemma ext_of_generate_from_of_cover {S T : set (set Î±)}
  (h_gen : â€¹_â€º = generate_from S) (hc : T.countable)
  (h_inter : is_pi_system S) (hU : â‹ƒâ‚€ T = univ) (htop : âˆ€ t âˆˆ T, Î¼ t â‰  âˆ)
  (ST_eq : âˆ€ (t âˆˆ T) (s âˆˆ S), Î¼ (s âˆ© t) = Î½ (s âˆ© t)) (T_eq : âˆ€ t âˆˆ T, Î¼ t = Î½ t) :
  Î¼ = Î½ :=
begin
  refine ext_of_sUnion_eq_univ hc hU (Î» t ht, _),
  ext1 u hu,
  simp only [restrict_apply hu],
  refine induction_on_inter h_gen h_inter _ (ST_eq t ht) _ _ hu,
  { simp only [set.empty_inter, measure_empty] },
  { intros v hv hvt,
    have := T_eq t ht,
    rw [set.inter_comm] at hvt âŠ¢,
    rwa [â† measure_inter_add_diff t hv, â† measure_inter_add_diff t hv, â† hvt,
      ennreal.add_right_inj] at this,
    exact ne_top_of_le_ne_top (htop t ht) (measure_mono $ set.inter_subset_left _ _) },
  { intros f hfd hfm h_eq,
    simp only [â† restrict_apply (hfm _), â† restrict_apply (measurable_set.Union hfm)] at h_eq âŠ¢,
    simp only [measure_Union hfd hfm, h_eq] }
end
lemma ext_of_generate_from_of_cover_subset {S T : set (set Î±)}
  (h_gen : â€¹_â€º = generate_from S) (h_inter : is_pi_system S)
  (h_sub : T âŠ† S) (hc : T.countable) (hU : â‹ƒâ‚€ T = univ) (htop : âˆ€ s âˆˆ T, Î¼ s â‰  âˆ)
  (h_eq : âˆ€ s âˆˆ S, Î¼ s = Î½ s) :
  Î¼ = Î½ :=
begin
  refine ext_of_generate_from_of_cover h_gen hc h_inter hU htop _ (Î» t ht, h_eq t (h_sub ht)),
  intros t ht s hs, cases (s âˆ© t).eq_empty_or_nonempty with H H,
  { simp only [H, measure_empty] },
  { exact h_eq _ (h_inter _ hs _ (h_sub ht) H) }
end
lemma ext_of_generate_from_of_Union (C : set (set Î±)) (B : â„• â†’ set Î±)
  (hA : â€¹_â€º = generate_from C) (hC : is_pi_system C) (h1B : (â‹ƒ i, B i) = univ)
  (h2B : âˆ€ i, B i âˆˆ C) (hÎ¼B : âˆ€ i, Î¼ (B i) â‰  âˆ) (h_eq : âˆ€ s âˆˆ C, Î¼ s = Î½ s) : Î¼ = Î½ :=
begin
  refine ext_of_generate_from_of_cover_subset hA hC _ (countable_range B) h1B _ h_eq,
  { rintro _ âŸ¨i, rflâŸ©, apply h2B },
  { rintro _ âŸ¨i, rflâŸ©, apply hÎ¼B }
end
section dirac
variable [measurable_space Î±]
def dirac (a : Î±) : measure Î± :=
(outer_measure.dirac a).to_measure (by simp)
instance : measure_space punit := âŸ¨dirac punit.starâŸ©
lemma le_dirac_apply {a} : s.indicator 1 a â‰¤ dirac a s :=
outer_measure.dirac_apply a s â–¸ le_to_measure_apply _ _ _
@[simp] lemma dirac_apply' (a : Î±) (hs : measurable_set s) :
  dirac a s = s.indicator 1 a :=
to_measure_apply _ _ hs
@[simp] lemma dirac_apply_of_mem {a : Î±} (h : a âˆˆ s) :
  dirac a s = 1 :=
begin
  have : âˆ€ t : set Î±, a âˆˆ t â†’ t.indicator (1 : Î± â†’ â„â‰¥0âˆ) a = 1,
    from Î» t ht, indicator_of_mem ht 1,
  refine le_antisymm (this univ trivial â–¸ _) (this s h â–¸ le_dirac_apply),
  rw [â† dirac_apply' a measurable_set.univ],
  exact measure_mono (subset_univ s)
end
@[simp] lemma dirac_apply [measurable_singleton_class Î±] (a : Î±) (s : set Î±) :
  dirac a s = s.indicator 1 a :=
begin
  by_cases h : a âˆˆ s, by rw [dirac_apply_of_mem h, indicator_of_mem h, pi.one_apply],
  rw [indicator_of_not_mem h, â† nonpos_iff_eq_zero],
  calc dirac a s â‰¤ dirac a {a}á¶œ : measure_mono (subset_compl_comm.1 $ singleton_subset_iff.2 h)
             ... = 0            : by simp [dirac_apply' _ (measurable_set_singleton _).compl]
end
lemma map_dirac {f : Î± â†’ Î²} (hf : measurable f) (a : Î±) :
  (dirac a).map f  = dirac (f a) :=
ext $ Î» s hs, by simp [hs, map_apply hf hs, hf hs, indicator_apply]
@[simp] lemma restrict_singleton (Î¼ : measure Î±) (a : Î±) : Î¼.restrict {a} = Î¼ {a} â€¢ dirac a :=
begin
  ext1 s hs,
  by_cases ha : a âˆˆ s,
  { have : s âˆ© {a} = {a}, by simpa,
    simp * },
  { have : s âˆ© {a} = âˆ…, from inter_singleton_eq_empty.2 ha,
    simp * }
end
end dirac
section sum
include m0
def sum (f : Î¹ â†’ measure Î±) : measure Î± :=
(outer_measure.sum (Î» i, (f i).to_outer_measure)).to_measure $
le_trans
  (by exact le_infi (Î» i, le_to_outer_measure_caratheodory _))
  (outer_measure.le_sum_caratheodory _)
lemma le_sum_apply (f : Î¹ â†’ measure Î±) (s : set Î±) : (âˆ‘' i, f i s) â‰¤ sum f s :=
le_to_measure_apply _ _ _
@[simp] lemma sum_apply (f : Î¹ â†’ measure Î±) {s : set Î±} (hs : measurable_set s) :
  sum f s = âˆ‘' i, f i s :=
to_measure_apply _ _ hs
lemma le_sum (Î¼ : Î¹ â†’ measure Î±) (i : Î¹) : Î¼ i â‰¤ sum Î¼ :=
Î» s hs, by simp only [sum_apply Î¼ hs, ennreal.le_tsum i]
@[simp] lemma sum_apply_eq_zero [encodable Î¹] {Î¼ : Î¹ â†’ measure Î±} {s : set Î±} :
  sum Î¼ s = 0 â†” âˆ€ i, Î¼ i s = 0 :=
begin
  refine âŸ¨Î» h i, nonpos_iff_eq_zero.1 $ h â–¸ le_iff'.1 (le_sum Î¼ i) _, Î» h, nonpos_iff_eq_zero.1 _âŸ©,
  rcases exists_measurable_superset_forall_eq Î¼ s with âŸ¨t, hst, htm, htâŸ©,
  calc sum Î¼ s â‰¤ sum Î¼ t : measure_mono hst
           ... = 0       : by simp *
end
lemma sum_apply_eq_zero' {Î¼ : Î¹ â†’ measure Î±} {s : set Î±} (hs : measurable_set s) :
  sum Î¼ s = 0 â†” âˆ€ i, Î¼ i s = 0 :=
by simp [hs]
lemma ae_sum_iff [encodable Î¹] {Î¼ : Î¹ â†’ measure Î±} {p : Î± â†’ Prop} :
  (âˆ€áµ x âˆ‚(sum Î¼), p x) â†” âˆ€ i, âˆ€áµ x âˆ‚(Î¼ i), p x :=
sum_apply_eq_zero
lemma ae_sum_iff' {Î¼ : Î¹ â†’ measure Î±} {p : Î± â†’ Prop} (h : measurable_set {x | p x}) :
  (âˆ€áµ x âˆ‚(sum Î¼), p x) â†” âˆ€ i, âˆ€áµ x âˆ‚(Î¼ i), p x :=
sum_apply_eq_zero' h.compl
@[simp] lemma sum_fintype [fintype Î¹] (Î¼ : Î¹ â†’ measure Î±) : sum Î¼ = âˆ‘ i, Î¼ i :=
by { ext1 s hs, simp only [sum_apply, finset_sum_apply, hs, tsum_fintype] }
@[simp] lemma sum_coe_finset (s : finset Î¹) (Î¼ : Î¹ â†’ measure Î±) :
  sum (Î» i : s, Î¼ i) = âˆ‘ i in s, Î¼ i :=
by rw [sum_fintype, finset.sum_coe_sort s Î¼]
@[simp] lemma ae_sum_eq [encodable Î¹] (Î¼ : Î¹ â†’ measure Î±) : (sum Î¼).ae = â¨† i, (Î¼ i).ae :=
filter.ext $ Î» s, ae_sum_iff.trans mem_supr.symm
@[simp] lemma sum_bool (f : bool â†’ measure Î±) : sum f = f tt + f ff :=
by rw [sum_fintype, fintype.sum_bool]
@[simp] lemma sum_cond (Î¼ Î½ : measure Î±) : sum (Î» b, cond b Î¼ Î½) = Î¼ + Î½ := sum_bool _
@[simp] lemma restrict_sum (Î¼ : Î¹ â†’ measure Î±) {s : set Î±} (hs : measurable_set s) :
  (sum Î¼).restrict s = sum (Î» i, (Î¼ i).restrict s) :=
ext $ Î» t ht, by simp only [sum_apply, restrict_apply, ht, ht.inter hs]
@[simp] lemma sum_of_empty [is_empty Î¹] (Î¼ : Î¹ â†’ measure Î±) : sum Î¼ = 0 :=
by rw [â† measure_univ_eq_zero, sum_apply _ measurable_set.univ, tsum_empty]
lemma sum_add_sum_compl (s : set Î¹) (Î¼ : Î¹ â†’ measure Î±) :
  sum (Î» i : s, Î¼ i) + sum (Î» i : sá¶œ, Î¼ i) = sum Î¼ :=
begin
  ext1 t ht,
  simp only [add_apply, sum_apply _ ht],
  exact @tsum_add_tsum_compl â„â‰¥0âˆ Î¹ _ _ _ (Î» i, Î¼ i t) _ s ennreal.summable ennreal.summable
end
lemma sum_congr {Î¼ Î½ : â„• â†’ measure Î±} (h : âˆ€ n, Î¼ n = Î½ n) : sum Î¼ = sum Î½ :=
congr_arg sum (funext h)
lemma sum_add_sum (Î¼ Î½ : â„• â†’ measure Î±) : sum Î¼ + sum Î½ = sum (Î» n, Î¼ n + Î½ n) :=
begin
  ext1 s hs,
  simp only [add_apply, sum_apply _ hs, pi.add_apply, coe_add,
             tsum_add ennreal.summable ennreal.summable],
end
lemma map_eq_sum [encodable Î²] [measurable_singleton_class Î²]
  (Î¼ : measure Î±) (f : Î± â†’ Î²) (hf : measurable f) :
  Î¼.map f = sum (Î» b : Î², Î¼ (f â»Â¹' {b}) â€¢ dirac b) :=
begin
  ext1 s hs,
  have : âˆ€ y âˆˆ s, measurable_set (f â»Â¹' {y}), from Î» y _, hf (measurable_set_singleton _),
  simp [â† tsum_measure_preimage_singleton (countable_encodable s) this, *,
    tsum_subtype s (Î» b, Î¼ (f â»Â¹' {b})), â† indicator_mul_right s (Î» b, Î¼ (f â»Â¹' {b}))]
end
@[simp] lemma sum_smul_dirac [encodable Î±] [measurable_singleton_class Î±] (Î¼ : measure Î±) :
  sum (Î» a, Î¼ {a} â€¢ dirac a) = Î¼ :=
by simpa using (map_eq_sum Î¼ id measurable_id).symm
omit m0
end sum
lemma restrict_Union_ae [encodable Î¹] {s : Î¹ â†’ set Î±} (hd : pairwise (ae_disjoint Î¼ on s))
  (hm : âˆ€ i, null_measurable_set (s i) Î¼) :
  Î¼.restrict (â‹ƒ i, s i) = sum (Î» i, Î¼.restrict (s i)) :=
ext $ Î» t ht, by simp only [sum_apply _ ht, restrict_Union_apply_ae hd hm ht]
lemma restrict_Union [encodable Î¹] {s : Î¹ â†’ set Î±} (hd : pairwise (disjoint on s))
  (hm : âˆ€ i, measurable_set (s i)) :
  Î¼.restrict (â‹ƒ i, s i) = sum (Î» i, Î¼.restrict (s i)) :=
restrict_Union_ae hd.ae_disjoint (Î» i, (hm i).null_measurable_set)
lemma restrict_Union_le [encodable Î¹] {s : Î¹ â†’ set Î±} :
  Î¼.restrict (â‹ƒ i, s i) â‰¤ sum (Î» i, Î¼.restrict (s i)) :=
begin
  intros t ht,
  suffices : Î¼ (â‹ƒ i, t âˆ© s i) â‰¤ âˆ‘' i, Î¼ (t âˆ© s i), by simpa [ht, inter_Union],
  apply measure_Union_le
end
section count
variable [measurable_space Î±]
def count : measure Î± := sum dirac
lemma le_count_apply : (âˆ‘' i : s, 1 : â„â‰¥0âˆ) â‰¤ count s :=
calc (âˆ‘' i : s, 1 : â„â‰¥0âˆ) = âˆ‘' i, indicator s 1 i : tsum_subtype s 1
... â‰¤ âˆ‘' i, dirac i s : ennreal.tsum_le_tsum $ Î» x, le_dirac_apply
... â‰¤ count s : le_sum_apply _ _
lemma count_apply (hs : measurable_set s) : count s = âˆ‘' i : s, 1 :=
by simp only [count, sum_apply, hs, dirac_apply', â† tsum_subtype s 1, pi.one_apply]
@[simp] lemma count_empty : count (âˆ… : set Î±) = 0 :=
by rw [count_apply measurable_set.empty, tsum_empty]
@[simp] lemma count_apply_finset [measurable_singleton_class Î±] (s : finset Î±) :
  count (â†‘s : set Î±) = s.card :=
calc count (â†‘s : set Î±) = âˆ‘' i : (â†‘s : set Î±), 1 : count_apply s.measurable_set
                    ... = âˆ‘ i in s, 1 : s.tsum_subtype 1
                    ... = s.card : by simp
lemma count_apply_finite [measurable_singleton_class Î±] (s : set Î±) (hs : s.finite) :
  count s = hs.to_finset.card :=
by rw [â† count_apply_finset, finite.coe_to_finset]
lemma count_apply_infinite (hs : s.infinite) : count s = âˆ :=
begin
  refine top_unique (le_of_tendsto' ennreal.tendsto_nat_nhds_top $ Î» n, _),
  rcases hs.exists_subset_card_eq n with âŸ¨t, ht, rflâŸ©,
  calc (t.card : â„â‰¥0âˆ) = âˆ‘ i in t, 1 : by simp
  ... = âˆ‘' i : (t : set Î±), 1 : (t.tsum_subtype 1).symm
  ... â‰¤ count (t : set Î±) : le_count_apply
  ... â‰¤ count s : measure_mono ht
end
variable [measurable_singleton_class Î±]
@[simp] lemma count_apply_eq_top : count s = âˆ â†” s.infinite :=
begin
  by_cases hs : s.finite,
  { simp [set.infinite, hs, count_apply_finite] },
  { change s.infinite at hs,
    simp [hs, count_apply_infinite] }
end
@[simp] lemma count_apply_lt_top : count s < âˆ â†” s.finite :=
calc count s < âˆ â†” count s â‰  âˆ : lt_top_iff_ne_top
             ... â†” Â¬s.infinite : not_congr count_apply_eq_top
             ... â†” s.finite    : not_not
lemma empty_of_count_eq_zero (hsc : count s = 0) : s = âˆ… :=
begin
  have hs : s.finite,
  { rw [â† count_apply_lt_top, hsc],
    exact with_top.zero_lt_top },
  rw count_apply_finite _ hs at hsc,
  simpa using hsc,
end
@[simp] lemma count_eq_zero_iff : count s = 0 â†” s = âˆ… :=
âŸ¨empty_of_count_eq_zero, Î» h, h.symm â–¸ count_emptyâŸ©
lemma count_ne_zero (hs' : s.nonempty) : count s â‰  0 :=
begin
  rw [ne.def, count_eq_zero_iff],
  exact hs'.ne_empty,
end
@[simp] lemma count_singleton (a : Î±) : count ({a} : set Î±) = 1 :=
begin
  rw [count_apply_finite ({a} : set Î±) (set.finite_singleton _), set.finite.to_finset],
  simp,
end
lemma count_injective_image [measurable_singleton_class Î²]
  {f : Î² â†’ Î±} (hf : function.injective f) (s : set Î²) :
  count (f '' s) = count s :=
begin
  by_cases hs : s.finite,
  { lift s to finset Î² using hs,
    rw [â† finset.coe_image, count_apply_finset, count_apply_finset, s.card_image_of_injective hf] },
  rw count_apply_infinite hs,
  rw â† (finite_image_iff $ hf.inj_on _) at hs,
  rw count_apply_infinite hs,
end
end count
def absolutely_continuous {m0 : measurable_space Î±} (Î¼ Î½ : measure Î±) : Prop :=
âˆ€ â¦ƒs : set Î±â¦„, Î½ s = 0 â†’ Î¼ s = 0
localized "infix ` â‰ª `:50 := measure_theory.measure.absolutely_continuous" in measure_theory
lemma absolutely_continuous_of_le (h : Î¼ â‰¤ Î½) : Î¼ â‰ª Î½ :=
Î» s hs, nonpos_iff_eq_zero.1 $ hs â–¸ le_iff'.1 h s
alias absolutely_continuous_of_le â† _root_.has_le.le.absolutely_continuous
lemma absolutely_continuous_of_eq (h : Î¼ = Î½) : Î¼ â‰ª Î½ :=
h.le.absolutely_continuous
alias absolutely_continuous_of_eq â† _root_.eq.absolutely_continuous
namespace absolutely_continuous
lemma mk (h : âˆ€ â¦ƒs : set Î±â¦„, measurable_set s â†’ Î½ s = 0 â†’ Î¼ s = 0) : Î¼ â‰ª Î½ :=
begin
  intros s hs,
  rcases exists_measurable_superset_of_null hs with âŸ¨t, h1t, h2t, h3tâŸ©,
  exact measure_mono_null h1t (h h2t h3t),
end
@[refl] protected lemma refl {m0 : measurable_space Î±} (Î¼ : measure Î±) : Î¼ â‰ª Î¼ :=
rfl.absolutely_continuous
protected lemma rfl : Î¼ â‰ª Î¼ := Î» s hs, hs
instance [measurable_space Î±] : is_refl (measure Î±) (â‰ª) := âŸ¨Î» Î¼, absolutely_continuous.rflâŸ©
@[trans] protected lemma trans (h1 : Î¼â‚ â‰ª Î¼â‚‚) (h2 : Î¼â‚‚ â‰ª Î¼â‚ƒ) : Î¼â‚ â‰ª Î¼â‚ƒ :=
Î» s hs, h1 $ h2 hs
@[mono] protected lemma map (h : Î¼ â‰ª Î½) {f : Î± â†’ Î²} (hf : measurable f) : Î¼.map f â‰ª Î½.map f :=
absolutely_continuous.mk $ Î» s hs, by simpa [hf, hs] using @h _
protected lemma smul [monoid R] [distrib_mul_action R â„â‰¥0âˆ] [is_scalar_tower R â„â‰¥0âˆ â„â‰¥0âˆ]
  (h : Î¼ â‰ª Î½) (c : R) : c â€¢ Î¼ â‰ª Î½ :=
Î» s hÎ½s, by simp only [h hÎ½s, smul_eq_mul, smul_apply, smul_zero]
end absolutely_continuous
lemma absolutely_continuous_of_le_smul {Î¼' : measure Î±} {c : â„â‰¥0âˆ} (hÎ¼'_le : Î¼' â‰¤ c â€¢ Î¼) :
  Î¼' â‰ª Î¼ :=
(measure.absolutely_continuous_of_le hÎ¼'_le).trans (measure.absolutely_continuous.rfl.smul c)
lemma ae_le_iff_absolutely_continuous : Î¼.ae â‰¤ Î½.ae â†” Î¼ â‰ª Î½ :=
âŸ¨Î» h s, by { rw [measure_zero_iff_ae_nmem, measure_zero_iff_ae_nmem], exact Î» hs, h hs },
  Î» h s hs, h hsâŸ©
alias ae_le_iff_absolutely_continuous â†”
  _root_.has_le.le.absolutely_continuous_of_ae absolutely_continuous.ae_le
alias absolutely_continuous.ae_le â† ae_mono'
lemma absolutely_continuous.ae_eq (h : Î¼ â‰ª Î½) {f g : Î± â†’ Î´} (h' : f =áµ[Î½] g) : f =áµ[Î¼] g :=
h.ae_le h'
@[protect_proj]
structure quasi_measure_preserving {m0 : measurable_space Î±} (f : Î± â†’ Î²)
  (Î¼a : measure Î± . volume_tac) (Î¼b : measure Î² . volume_tac) : Prop :=
(measurable : measurable f)
(absolutely_continuous : Î¼a.map f â‰ª Î¼b)
namespace quasi_measure_preserving
protected lemma id {m0 : measurable_space Î±} (Î¼ : measure Î±) : quasi_measure_preserving id Î¼ Î¼ :=
âŸ¨measurable_id, map_id.absolutely_continuousâŸ©
variables {Î¼a Î¼a' : measure Î±} {Î¼b Î¼b' : measure Î²} {Î¼c : measure Î³} {f : Î± â†’ Î²}
protected lemma _root_.measurable.quasi_measure_preserving {m0 : measurable_space Î±}
  (hf : measurable f) (Î¼ : measure Î±) : quasi_measure_preserving f Î¼ (Î¼.map f) :=
âŸ¨hf, absolutely_continuous.rflâŸ©
lemma mono_left (h : quasi_measure_preserving f Î¼a Î¼b)
  (ha : Î¼a' â‰ª Î¼a) : quasi_measure_preserving f Î¼a' Î¼b :=
âŸ¨h.1, (ha.map h.1).trans h.2âŸ©
lemma mono_right (h : quasi_measure_preserving f Î¼a Î¼b)
  (ha : Î¼b â‰ª Î¼b') : quasi_measure_preserving f Î¼a Î¼b' :=
âŸ¨h.1, h.2.trans haâŸ©
@[mono] lemma mono (ha : Î¼a' â‰ª Î¼a) (hb : Î¼b â‰ª Î¼b') (h : quasi_measure_preserving f Î¼a Î¼b) :
  quasi_measure_preserving f Î¼a' Î¼b' :=
(h.mono_left ha).mono_right hb
protected lemma comp {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : quasi_measure_preserving g Î¼b Î¼c)
  (hf : quasi_measure_preserving f Î¼a Î¼b) :
  quasi_measure_preserving (g âˆ˜ f) Î¼a Î¼c :=
âŸ¨hg.measurable.comp hf.measurable, by { rw â† map_map hg.1 hf.1, exact (hf.2.map hg.1).trans hg.2 }âŸ©
protected lemma iterate {f : Î± â†’ Î±} (hf : quasi_measure_preserving f Î¼a Î¼a) :
  âˆ€ n, quasi_measure_preserving (f^[n]) Î¼a Î¼a
| 0 := quasi_measure_preserving.id Î¼a
| (n + 1) := (iterate n).comp hf
protected lemma ae_measurable (hf : quasi_measure_preserving f Î¼a Î¼b) : ae_measurable f Î¼a :=
hf.1.ae_measurable
lemma ae_map_le (h : quasi_measure_preserving f Î¼a Î¼b) : (Î¼a.map f).ae â‰¤ Î¼b.ae :=
h.2.ae_le
lemma tendsto_ae (h : quasi_measure_preserving f Î¼a Î¼b) : tendsto f Î¼a.ae Î¼b.ae :=
(tendsto_ae_map h.ae_measurable).mono_right h.ae_map_le
lemma ae (h : quasi_measure_preserving f Î¼a Î¼b) {p : Î² â†’ Prop} (hg : âˆ€áµ x âˆ‚Î¼b, p x) :
  âˆ€áµ x âˆ‚Î¼a, p (f x) :=
h.tendsto_ae hg
lemma ae_eq (h : quasi_measure_preserving f Î¼a Î¼b) {gâ‚ gâ‚‚ : Î² â†’ Î´} (hg : gâ‚ =áµ[Î¼b] gâ‚‚) :
  gâ‚ âˆ˜ f =áµ[Î¼a] gâ‚‚ âˆ˜ f :=
h.ae hg
lemma preimage_null (h : quasi_measure_preserving f Î¼a Î¼b) {s : set Î²} (hs : Î¼b s = 0) :
  Î¼a (f â»Â¹' s) = 0 :=
preimage_null_of_map_null h.ae_measurable (h.2 hs)
end quasi_measure_preserving
def cofinite {m0 : measurable_space Î±} (Î¼ : measure Î±) : filter Î± :=
{ sets := {s | Î¼ sá¶œ < âˆ},
  univ_sets := by simp,
  inter_sets := Î» s t hs ht, by { simp only [compl_inter, mem_set_of_eq],
    calc Î¼ (sá¶œ âˆª tá¶œ) â‰¤ Î¼ sá¶œ + Î¼ tá¶œ : measure_union_le _ _
                ... < âˆ : ennreal.add_lt_top.2 âŸ¨hs, htâŸ© },
  sets_of_superset := Î» s t hs hst, lt_of_le_of_lt (measure_mono $ compl_subset_compl.2 hst) hs }
lemma mem_cofinite : s âˆˆ Î¼.cofinite â†” Î¼ sá¶œ < âˆ := iff.rfl
lemma compl_mem_cofinite : sá¶œ âˆˆ Î¼.cofinite â†” Î¼ s < âˆ :=
by rw [mem_cofinite, compl_compl]
lemma eventually_cofinite {p : Î± â†’ Prop} : (âˆ€á¶  x in Î¼.cofinite, p x) â†” Î¼ {x | Â¬p x} < âˆ := iff.rfl
end measure
open measure
open_locale measure_theory
lemma null_measurable_set.preimage {Î½ : measure Î²} {f : Î± â†’ Î²} {t : set Î²}
  (ht : null_measurable_set t Î½) (hf : quasi_measure_preserving f Î¼ Î½) :
  null_measurable_set (f â»Â¹' t) Î¼ :=
âŸ¨f â»Â¹' (to_measurable Î½ t), hf.measurable (measurable_set_to_measurable _ _),
  hf.ae_eq ht.to_measurable_ae_eq.symmâŸ©
lemma null_measurable_set.mono_ac (h : null_measurable_set s Î¼) (hle : Î½ â‰ª Î¼) :
  null_measurable_set s Î½ :=
h.preimage $ (quasi_measure_preserving.id Î¼).mono_left hle
lemma null_measurable_set.mono (h : null_measurable_set s Î¼) (hle : Î½ â‰¤ Î¼) :
  null_measurable_set s Î½ :=
h.mono_ac hle.absolutely_continuous
lemma ae_disjoint.preimage {Î½ : measure Î²} {f : Î± â†’ Î²} {s t : set Î²}
  (ht : ae_disjoint Î½ s t) (hf : quasi_measure_preserving f Î¼ Î½) :
  ae_disjoint Î¼ (f â»Â¹' s) (f â»Â¹' t) :=
hf.preimage_null ht
@[simp] lemma ae_eq_bot : Î¼.ae = âŠ¥ â†” Î¼ = 0 :=
by rw [â† empty_mem_iff_bot, mem_ae_iff, compl_empty, measure_univ_eq_zero]
@[simp] lemma ae_ne_bot : Î¼.ae.ne_bot â†” Î¼ â‰  0 :=
ne_bot_iff.trans (not_congr ae_eq_bot)
@[simp] lemma ae_zero {m0 : measurable_space Î±} : (0 : measure Î±).ae = âŠ¥ := ae_eq_bot.2 rfl
@[mono] lemma ae_mono (h : Î¼ â‰¤ Î½) : Î¼.ae â‰¤ Î½.ae := h.absolutely_continuous.ae_le
lemma mem_ae_map_iff {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {s : set Î²} (hs : measurable_set s) :
  s âˆˆ (Î¼.map f).ae â†” (f â»Â¹' s) âˆˆ Î¼.ae :=
by simp only [mem_ae_iff, map_apply_of_ae_measurable hf hs.compl, preimage_compl]
lemma mem_ae_of_mem_ae_map
  {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {s : set Î²} (hs : s âˆˆ (Î¼.map f).ae) :
  f â»Â¹' s âˆˆ Î¼.ae :=
(tendsto_ae_map hf).eventually hs
lemma ae_map_iff
  {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {p : Î² â†’ Prop} (hp : measurable_set {x | p x}) :
  (âˆ€áµ y âˆ‚ (Î¼.map f), p y) â†” âˆ€áµ x âˆ‚ Î¼, p (f x) :=
mem_ae_map_iff hf hp
lemma ae_of_ae_map {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) {p : Î² â†’ Prop} (h : âˆ€áµ y âˆ‚ (Î¼.map f), p y) :
  âˆ€áµ x âˆ‚ Î¼, p (f x) :=
mem_ae_of_mem_ae_map hf h
lemma ae_map_mem_range {m0 : measurable_space Î±} (f : Î± â†’ Î²) (hf : measurable_set (range f))
  (Î¼ : measure Î±) :
  âˆ€áµ x âˆ‚(Î¼.map f), x âˆˆ range f :=
begin
  by_cases h : ae_measurable f Î¼,
  { change range f âˆˆ (Î¼.map f).ae,
    rw mem_ae_map_iff h hf,
    apply eventually_of_forall,
    exact mem_range_self },
  { simp [map_of_not_ae_measurable h] }
end
@[simp] lemma ae_restrict_Union_eq [encodable Î¹] (s : Î¹ â†’ set Î±) :
  (Î¼.restrict (â‹ƒ i, s i)).ae = â¨† i, (Î¼.restrict (s i)).ae :=
le_antisymm (ae_sum_eq (Î» i, Î¼.restrict (s i)) â–¸ ae_mono restrict_Union_le) $
  supr_le $ Î» i, ae_mono $ restrict_mono (subset_Union s i) le_rfl
@[simp] lemma ae_restrict_union_eq (s t : set Î±) :
  (Î¼.restrict (s âˆª t)).ae = (Î¼.restrict s).ae âŠ” (Î¼.restrict t).ae :=
by simp [union_eq_Union, supr_bool_eq]
lemma ae_restrict_interval_oc_eq [linear_order Î±] (a b : Î±) :
  (Î¼.restrict (Î™ a b)).ae = (Î¼.restrict (Ioc a b)).ae âŠ” (Î¼.restrict (Ioc b a)).ae :=
by simp only [interval_oc_eq_union, ae_restrict_union_eq]
lemma ae_restrict_interval_oc_iff [linear_order Î±] {a b : Î±} {P : Î± â†’ Prop} :
  (âˆ€áµ x âˆ‚Î¼.restrict (Î™ a b), P x) â†”
    (âˆ€áµ x âˆ‚Î¼.restrict (Ioc a b), P x) âˆ§ (âˆ€áµ x âˆ‚Î¼.restrict (Ioc b a), P x) :=
by rw [ae_restrict_interval_oc_eq, eventually_sup]
lemma ae_restrict_iff {p : Î± â†’ Prop} (hp : measurable_set {x | p x}) :
  (âˆ€áµ x âˆ‚(Î¼.restrict s), p x) â†” âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ p x :=
begin
  simp only [ae_iff, â† compl_set_of, restrict_apply hp.compl],
  congr' with x, simp [and_comm]
end
lemma ae_imp_of_ae_restrict {s : set Î±} {p : Î± â†’ Prop} (h : âˆ€áµ x âˆ‚(Î¼.restrict s), p x) :
  âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ p x :=
begin
  simp only [ae_iff] at h âŠ¢,
  simpa [set_of_and, inter_comm] using measure_inter_eq_zero_of_restrict h
end
lemma ae_restrict_iff' {p : Î± â†’ Prop} (hs : measurable_set s) :
  (âˆ€áµ x âˆ‚(Î¼.restrict s), p x) â†” âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ p x :=
begin
  simp only [ae_iff, â† compl_set_of, restrict_apply_eq_zero' hs],
  congr' with x, simp [and_comm]
end
lemma _root_.filter.eventually_eq.restrict {f g : Î± â†’ Î´} {s : set Î±} (hfg : f =áµ[Î¼] g) :
  f =áµ[Î¼.restrict s] g :=
lemma ae_restrict_of_ae_eq_of_ae_restrict {s t} (hst : s =áµ[Î¼] t) {p : Î± â†’ Prop} :
  (âˆ€áµ x âˆ‚Î¼.restrict s, p x) â†’ (âˆ€áµ x âˆ‚Î¼.restrict t, p x) :=
by simp [measure.restrict_congr_set hst]
lemma ae_restrict_congr_set {s t} (hst : s =áµ[Î¼] t) {p : Î± â†’ Prop} :
  (âˆ€áµ x âˆ‚Î¼.restrict s, p x) â†” (âˆ€áµ x âˆ‚Î¼.restrict t, p x) :=
âŸ¨ae_restrict_of_ae_eq_of_ae_restrict hst, ae_restrict_of_ae_eq_of_ae_restrict hst.symmâŸ©
lemma measure_set_of_frequently_eq_zero {p : â„• â†’ Î± â†’ Prop} (hp : âˆ‘' i, Î¼ {x | p i x} â‰  âˆ) :
  Î¼ {x | âˆƒá¶  n in at_top, p n x} = 0 :=
by simpa only [limsup_eq_infi_supr_of_nat, frequently_at_top, set_of_forall, set_of_exists]
  using measure_limsup_eq_zero hp
lemma ae_eventually_not_mem {s : â„• â†’ set Î±} (hs : âˆ‘' i, Î¼ (s i) â‰  âˆ) :
  âˆ€áµ x âˆ‚ Î¼, âˆ€á¶  n in at_top, x âˆ‰ s n :=
measure_set_of_frequently_eq_zero hs
section intervals
lemma bsupr_measure_Iic [preorder Î±] {s : set Î±} (hsc : s.countable)
  (hst : âˆ€ x : Î±, âˆƒ y âˆˆ s, x â‰¤ y) (hdir : directed_on (â‰¤) s) :
  (â¨† x âˆˆ s, Î¼ (Iic x)) = Î¼ univ :=
begin
  rw â† measure_bUnion_eq_supr hsc,
  { congr, exact Unionâ‚‚_eq_univ_iff.2 hst },
  { exact directed_on_iff_directed.2 (hdir.directed_coe.mono_comp _ $ Î» x y, Iic_subset_Iic.2) }
end
variables [partial_order Î±] {a b : Î±}
lemma Iio_ae_eq_Iic' (ha : Î¼ {a} = 0) : Iio a =áµ[Î¼] Iic a :=
by rw [â†Iic_diff_right, diff_ae_eq_self, measure_mono_null (set.inter_subset_right _ _) ha]
lemma Ioi_ae_eq_Ici' (ha : Î¼ {a} = 0) : Ioi a =áµ[Î¼] Ici a := @Iio_ae_eq_Iic' Î±áµ’áµˆ â€¹_â€º â€¹_â€º _ _ ha
lemma Ioo_ae_eq_Ioc' (hb : Î¼ {b} = 0) : Ioo a b =áµ[Î¼] Ioc a b :=
(ae_eq_refl _).inter (Iio_ae_eq_Iic' hb)
lemma Ioc_ae_eq_Icc' (ha : Î¼ {a} = 0) : Ioc a b =áµ[Î¼] Icc a b :=
(Ioi_ae_eq_Ici' ha).inter (ae_eq_refl _)
lemma Ioo_ae_eq_Ico' (ha : Î¼ {a} = 0) : Ioo a b =áµ[Î¼] Ico a b :=
(Ioi_ae_eq_Ici' ha).inter (ae_eq_refl _)
lemma Ioo_ae_eq_Icc' (ha : Î¼ {a} = 0) (hb : Î¼ {b} = 0) : Ioo a b =áµ[Î¼] Icc a b :=
(Ioi_ae_eq_Ici' ha).inter (Iio_ae_eq_Iic' hb)
lemma Ico_ae_eq_Icc' (hb : Î¼ {b} = 0) : Ico a b =áµ[Î¼] Icc a b :=
(ae_eq_refl _).inter (Iio_ae_eq_Iic' hb)
lemma Ico_ae_eq_Ioc' (ha : Î¼ {a} = 0) (hb : Î¼ {b} = 0) : Ico a b =áµ[Î¼] Ioc a b :=
(Ioo_ae_eq_Ico' ha).symm.trans (Ioo_ae_eq_Ioc' hb)
end intervals
section dirac
variable [measurable_space Î±]
lemma mem_ae_dirac_iff {a : Î±} (hs : measurable_set s) : s âˆˆ (dirac a).ae â†” a âˆˆ s :=
by by_cases a âˆˆ s; simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]
lemma ae_dirac_iff {a : Î±} {p : Î± â†’ Prop} (hp : measurable_set {x | p x}) :
  (âˆ€áµ x âˆ‚(dirac a), p x) â†” p a :=
mem_ae_dirac_iff hp
@[simp] lemma ae_dirac_eq [measurable_singleton_class Î±] (a : Î±) : (dirac a).ae = pure a :=
by { ext s, simp [mem_ae_iff, imp_false] }
lemma ae_eq_dirac' [measurable_singleton_class Î²] {a : Î±} {f : Î± â†’ Î²} (hf : measurable f) :
  f =áµ[dirac a] const Î± (f a) :=
(ae_dirac_iff $ show measurable_set (f â»Â¹' {f a}), from hf $ measurable_set_singleton _).2 rfl
lemma ae_eq_dirac [measurable_singleton_class Î±] {a : Î±} (f : Î± â†’ Î´) :
  f =áµ[dirac a] const Î± (f a) :=
by simp [filter.eventually_eq]
end dirac
section is_finite_measure
include m0
class is_finite_measure (Î¼ : measure Î±) : Prop := (measure_univ_lt_top : Î¼ univ < âˆ)
instance restrict.is_finite_measure (Î¼ : measure Î±) [hs : fact (Î¼ s < âˆ)] :
  is_finite_measure (Î¼.restrict s) :=
âŸ¨by simp [hs.elim]âŸ©
lemma measure_lt_top (Î¼ : measure Î±) [is_finite_measure Î¼] (s : set Î±) : Î¼ s < âˆ :=
(measure_mono (subset_univ s)).trans_lt is_finite_measure.measure_univ_lt_top
instance is_finite_measure_restrict (Î¼ : measure Î±) (s : set Î±) [h : is_finite_measure Î¼] :
  is_finite_measure (Î¼.restrict s) :=
âŸ¨by simp [measure_lt_top Î¼ s]âŸ©
lemma measure_ne_top (Î¼ : measure Î±) [is_finite_measure Î¼] (s : set Î±) : Î¼ s â‰  âˆ :=
ne_of_lt (measure_lt_top Î¼ s)
lemma measure_compl_le_add_of_le_add [is_finite_measure Î¼] (hs : measurable_set s)
  (ht : measurable_set t) {Îµ : â„â‰¥0âˆ} (h : Î¼ s â‰¤ Î¼ t + Îµ) :
  Î¼ tá¶œ â‰¤ Î¼ sá¶œ + Îµ :=
begin
  rw [measure_compl ht (measure_ne_top Î¼ _), measure_compl hs (measure_ne_top Î¼ _),
    tsub_le_iff_right],
  calc Î¼ univ = Î¼ univ - Î¼ s + Î¼ s :
    (tsub_add_cancel_of_le $ measure_mono s.subset_univ).symm
  ... â‰¤ Î¼ univ - Î¼ s + (Î¼ t + Îµ) : add_le_add_left h _
  ... = _ : by rw [add_right_comm, add_assoc]
end
lemma measure_compl_le_add_iff [is_finite_measure Î¼] (hs : measurable_set s)
  (ht : measurable_set t) {Îµ : â„â‰¥0âˆ} :
  Î¼ sá¶œ â‰¤ Î¼ tá¶œ + Îµ â†” Î¼ t â‰¤ Î¼ s + Îµ :=
âŸ¨Î» h, compl_compl s â–¸ compl_compl t â–¸ measure_compl_le_add_of_le_add hs.compl ht.compl h,
  measure_compl_le_add_of_le_add ht hsâŸ©
def measure_univ_nnreal (Î¼ : measure Î±) : â„â‰¥0 := (Î¼ univ).to_nnreal
@[simp] lemma coe_measure_univ_nnreal (Î¼ : measure Î±) [is_finite_measure Î¼] :
  â†‘(measure_univ_nnreal Î¼) = Î¼ univ :=
ennreal.coe_to_nnreal (measure_ne_top Î¼ univ)
instance is_finite_measure_zero : is_finite_measure (0 : measure Î±) := âŸ¨by simpâŸ©
@[priority 100]
instance is_finite_measure_of_is_empty [is_empty Î±] : is_finite_measure Î¼ :=
by { rw eq_zero_of_is_empty Î¼, apply_instance }
@[simp] lemma measure_univ_nnreal_zero : measure_univ_nnreal (0 : measure Î±) = 0 := rfl
omit m0
instance is_finite_measure_add [is_finite_measure Î¼] [is_finite_measure Î½] :
  is_finite_measure (Î¼ + Î½) :=
{ measure_univ_lt_top :=
  begin
    rw [measure.coe_add, pi.add_apply, ennreal.add_lt_top],
    exact âŸ¨measure_lt_top _ _, measure_lt_top _ _âŸ©,
  end }
instance is_finite_measure_smul_nnreal [is_finite_measure Î¼] {r : â„â‰¥0} :
  is_finite_measure (r â€¢ Î¼) :=
{ measure_univ_lt_top := ennreal.mul_lt_top ennreal.coe_ne_top (measure_ne_top _ _) }
instance is_finite_measure_smul_of_nnreal_tower
  {R} [has_smul R â„â‰¥0] [has_smul R â„â‰¥0âˆ] [is_scalar_tower R â„â‰¥0 â„â‰¥0âˆ]
  [is_scalar_tower R â„â‰¥0âˆ â„â‰¥0âˆ]
  [is_finite_measure Î¼] {r : R} :
  is_finite_measure (r â€¢ Î¼) :=
begin
  rw â†smul_one_smul â„â‰¥0 r Î¼,
  apply_instance,
end
lemma is_finite_measure_of_le (Î¼ : measure Î±) [is_finite_measure Î¼] (h : Î½ â‰¤ Î¼) :
  is_finite_measure Î½ :=
{ measure_univ_lt_top := lt_of_le_of_lt (h set.univ measurable_set.univ) (measure_lt_top _ _) }
@[instance] lemma measure.is_finite_measure_map {m : measurable_space Î±}
  (Î¼ : measure Î±) [is_finite_measure Î¼] (f : Î± â†’ Î²) :
  is_finite_measure (Î¼.map f) :=
begin
  by_cases hf : ae_measurable f Î¼,
  { constructor, rw map_apply_of_ae_measurable hf measurable_set.univ, exact measure_lt_top Î¼ _ },
  { rw map_of_not_ae_measurable hf, exact measure_theory.is_finite_measure_zero }
end
@[simp] lemma measure_univ_nnreal_eq_zero [is_finite_measure Î¼] :
  measure_univ_nnreal Î¼ = 0 â†” Î¼ = 0 :=
begin
  rw [â† measure_theory.measure.measure_univ_eq_zero, â† coe_measure_univ_nnreal],
  norm_cast
end
lemma measure_univ_nnreal_pos [is_finite_measure Î¼] (hÎ¼ : Î¼ â‰  0) : 0 < measure_univ_nnreal Î¼ :=
begin
  contrapose! hÎ¼,
  simpa [measure_univ_nnreal_eq_zero, le_zero_iff] using hÎ¼
end
lemma measure.le_of_add_le_add_left [is_finite_measure Î¼] (A2 : Î¼ + Î½â‚ â‰¤ Î¼ + Î½â‚‚) : Î½â‚ â‰¤ Î½â‚‚ :=
Î» S B1, ennreal.le_of_add_le_add_left (measure_theory.measure_ne_top Î¼ S) (A2 S B1)
lemma summable_measure_to_real [hÎ¼ : is_finite_measure Î¼]
  {f : â„• â†’ set Î±} (hfâ‚ : âˆ€ (i : â„•), measurable_set (f i)) (hfâ‚‚ : pairwise (disjoint on f)) :
  summable (Î» x, (Î¼ (f x)).to_real) :=
begin
  apply ennreal.summable_to_real,
  rw â† measure_theory.measure_Union hfâ‚‚ hfâ‚,
  exact ne_of_lt (measure_lt_top _ _)
end
end is_finite_measure
section is_probability_measure
include m0
class is_probability_measure (Î¼ : measure Î±) : Prop := (measure_univ : Î¼ univ = 1)
export is_probability_measure (measure_univ)
attribute [simp] is_probability_measure.measure_univ
@[priority 100]
instance is_probability_measure.to_is_finite_measure (Î¼ : measure Î±) [is_probability_measure Î¼] :
  is_finite_measure Î¼ :=
âŸ¨by simp only [measure_univ, ennreal.one_lt_top]âŸ©
lemma is_probability_measure.ne_zero (Î¼ : measure Î±) [is_probability_measure Î¼] : Î¼ â‰  0 :=
mt measure_univ_eq_zero.2 $ by simp [measure_univ]
@[priority 200]
instance is_probability_measure.ae_ne_bot [is_probability_measure Î¼] : ne_bot Î¼.ae :=
ae_ne_bot.2 (is_probability_measure.ne_zero Î¼)
omit m0
instance measure.dirac.is_probability_measure [measurable_space Î±] {x : Î±} :
  is_probability_measure (dirac x) :=
âŸ¨dirac_apply_of_mem $ mem_univ xâŸ©
lemma prob_add_prob_compl [is_probability_measure Î¼]
  (h : measurable_set s) : Î¼ s + Î¼ sá¶œ = 1 :=
(measure_add_measure_compl h).trans measure_univ
lemma prob_le_one [is_probability_measure Î¼] : Î¼ s â‰¤ 1 :=
(measure_mono $ set.subset_univ _).trans_eq measure_univ
lemma is_probability_measure_smul [is_finite_measure Î¼] (h : Î¼ â‰  0) :
  is_probability_measure ((Î¼ univ)â»Â¹ â€¢ Î¼) :=
begin
  constructor,
  rw [smul_apply, smul_eq_mul, ennreal.inv_mul_cancel],
  { rwa [ne, measure_univ_eq_zero] },
  { exact measure_ne_top _ _ }
end
lemma is_probability_measure_map [is_probability_measure Î¼] {f : Î± â†’ Î²} (hf : ae_measurable f Î¼) :
  is_probability_measure (map f Î¼) :=
âŸ¨by simp [map_apply_of_ae_measurable, hf]âŸ©
end is_probability_measure
section no_atoms
class has_no_atoms {m0 : measurable_space Î±} (Î¼ : measure Î±) : Prop :=
(measure_singleton : âˆ€ x, Î¼ {x} = 0)
export has_no_atoms (measure_singleton)
attribute [simp] measure_singleton
variables [has_no_atoms Î¼]
lemma _root_.set.subsingleton.measure_zero {Î± : Type*} {m : measurable_space Î±} {s : set Î±}
  (hs : s.subsingleton) (Î¼ : measure Î±) [has_no_atoms Î¼] :
  Î¼ s = 0 :=
hs.induction_on measure_empty measure_singleton
lemma measure.restrict_singleton' {a : Î±} :
  Î¼.restrict {a} = 0 :=
by simp only [measure_singleton, measure.restrict_eq_zero]
instance (s : set Î±) : has_no_atoms (Î¼.restrict s) :=
begin
  refine âŸ¨Î» x, _âŸ©,
  obtain âŸ¨t, hxt, ht1, ht2âŸ© := exists_measurable_superset_of_null (measure_singleton x : Î¼ {x} = 0),
  apply measure_mono_null hxt,
  rw measure.restrict_apply ht1,
  apply measure_mono_null (inter_subset_left t s) ht2
end
lemma _root_.set.countable.measure_zero {Î± : Type*} {m : measurable_space Î±} {s : set Î±}
  (h : s.countable) (Î¼ : measure Î±) [has_no_atoms Î¼] :
  Î¼ s = 0 :=
begin
  rw [â† bUnion_of_singleton s, â† nonpos_iff_eq_zero],
  refine le_trans (measure_bUnion_le h _) _,
  simp
end
lemma _root_.set.countable.ae_not_mem {Î± : Type*} {m : measurable_space Î±} {s : set Î±}
  (h : s.countable) (Î¼ : measure Î±) [has_no_atoms Î¼] :
  âˆ€áµ x âˆ‚Î¼, x âˆ‰ s :=
by simpa only [ae_iff, not_not] using h.measure_zero Î¼
lemma _root_.set.finite.measure_zero {Î± : Type*} {m : measurable_space Î±} {s : set Î±}
  (h : s.finite) (Î¼ : measure Î±) [has_no_atoms Î¼] : Î¼ s = 0 :=
h.countable.measure_zero Î¼
lemma _root_.finset.measure_zero {Î± : Type*} {m : measurable_space Î±}
  (s : finset Î±) (Î¼ : measure Î±) [has_no_atoms Î¼] : Î¼ s = 0 :=
s.finite_to_set.measure_zero Î¼
lemma insert_ae_eq_self (a : Î±) (s : set Î±) :
  (insert a s : set Î±) =áµ[Î¼] s :=
union_ae_eq_right.2 $ measure_mono_null (diff_subset _ _) (measure_singleton _)
section
variables [partial_order Î±] {a b : Î±}
lemma Iio_ae_eq_Iic : Iio a =áµ[Î¼] Iic a :=
Iio_ae_eq_Iic' (measure_singleton a)
lemma Ioi_ae_eq_Ici : Ioi a =áµ[Î¼] Ici a :=
Ioi_ae_eq_Ici' (measure_singleton a)
lemma Ioo_ae_eq_Ioc : Ioo a b =áµ[Î¼] Ioc a b :=
Ioo_ae_eq_Ioc' (measure_singleton b)
lemma Ioc_ae_eq_Icc : Ioc a b =áµ[Î¼] Icc a b :=
Ioc_ae_eq_Icc' (measure_singleton a)
lemma Ioo_ae_eq_Ico : Ioo a b =áµ[Î¼] Ico a b :=
Ioo_ae_eq_Ico' (measure_singleton a)
lemma Ioo_ae_eq_Icc : Ioo a b =áµ[Î¼] Icc a b :=
Ioo_ae_eq_Icc' (measure_singleton a) (measure_singleton b)
lemma Ico_ae_eq_Icc : Ico a b =áµ[Î¼] Icc a b :=
Ico_ae_eq_Icc' (measure_singleton b)
lemma Ico_ae_eq_Ioc : Ico a b =áµ[Î¼] Ioc a b :=
Ico_ae_eq_Ioc' (measure_singleton a) (measure_singleton b)
end
open_locale interval
lemma interval_oc_ae_eq_interval [linear_order Î±] {a b : Î±} : Î™ a b =áµ[Î¼] [a, b] := Ioc_ae_eq_Icc
end no_atoms
lemma ite_ae_eq_of_measure_zero {Î³} (f : Î± â†’ Î³) (g : Î± â†’ Î³) (s : set Î±) (hs_zero : Î¼ s = 0) :
  (Î» x, ite (x âˆˆ s) (f x) (g x)) =áµ[Î¼] g :=
begin
  have h_ss : sá¶œ âŠ† {a : Î± | ite (a âˆˆ s) (f a) (g a) = g a},
    from Î» x hx, by simp [(set.mem_compl_iff _ _).mp hx],
  refine measure_mono_null _ hs_zero,
  nth_rewrite 0 â†compl_compl s,
  rwa set.compl_subset_compl,
end
lemma ite_ae_eq_of_measure_compl_zero {Î³} (f : Î± â†’ Î³) (g : Î± â†’ Î³) (s : set Î±) (hs_zero : Î¼ sá¶œ = 0) :
  (Î» x, ite (x âˆˆ s) (f x) (g x)) =áµ[Î¼] f :=
by { filter_upwards [hs_zero], intros, split_ifs, refl }
namespace measure
def finite_at_filter {m0 : measurable_space Î±} (Î¼ : measure Î±) (f : filter Î±) : Prop :=
âˆƒ s âˆˆ f, Î¼ s < âˆ
lemma finite_at_filter_of_finite {m0 : measurable_space Î±} (Î¼ : measure Î±) [is_finite_measure Î¼]
  (f : filter Î±) :
  Î¼.finite_at_filter f :=
âŸ¨univ, univ_mem, measure_lt_top Î¼ univâŸ©
lemma finite_at_filter.exists_mem_basis {f : filter Î±} (hÎ¼ : finite_at_filter Î¼ f)
  {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (hf : f.has_basis p s) :
  âˆƒ i (hi : p i), Î¼ (s i) < âˆ :=
(hf.exists_iff (Î» s t hst ht, (measure_mono hst).trans_lt ht)).1 hÎ¼
lemma finite_at_bot {m0 : measurable_space Î±} (Î¼ : measure Î±) : Î¼.finite_at_filter âŠ¥ :=
âŸ¨âˆ…, mem_bot, by simp only [measure_empty, with_top.zero_lt_top]âŸ©
@[protect_proj, nolint has_inhabited_instance]
structure finite_spanning_sets_in {m0 : measurable_space Î±} (Î¼ : measure Î±) (C : set (set Î±)) :=
(set : â„• â†’ set Î±)
(set_mem : âˆ€ i, set i âˆˆ C)
(finite : âˆ€ i, Î¼ (set i) < âˆ)
(spanning : (â‹ƒ i, set i) = univ)
end measure
open measure
class sigma_finite {m0 : measurable_space Î±} (Î¼ : measure Î±) : Prop :=
(out' : nonempty (Î¼.finite_spanning_sets_in univ))
theorem sigma_finite_iff :
  sigma_finite Î¼ â†” nonempty (Î¼.finite_spanning_sets_in univ) :=
âŸ¨Î» h, h.1, Î» h, âŸ¨hâŸ©âŸ©
theorem sigma_finite.out (h : sigma_finite Î¼) :
  nonempty (Î¼.finite_spanning_sets_in univ) := h.1
include m0
def measure.to_finite_spanning_sets_in (Î¼ : measure Î±) [h : sigma_finite Î¼] :
  Î¼.finite_spanning_sets_in {s | measurable_set s} :=
{ set := Î» n, to_measurable Î¼ (h.out.some.set n),
  set_mem := Î» n, measurable_set_to_measurable _ _,
  finite := Î» n, by { rw measure_to_measurable, exact h.out.some.finite n },
  spanning := eq_univ_of_subset (Union_mono $ Î» n, subset_to_measurable _ _)
    h.out.some.spanning }
def spanning_sets (Î¼ : measure Î±) [sigma_finite Î¼] (i : â„•) : set Î± :=
accumulate Î¼.to_finite_spanning_sets_in.set i
lemma monotone_spanning_sets (Î¼ : measure Î±) [sigma_finite Î¼] :
  monotone (spanning_sets Î¼) :=
monotone_accumulate
lemma measurable_spanning_sets (Î¼ : measure Î±) [sigma_finite Î¼] (i : â„•) :
  measurable_set (spanning_sets Î¼ i) :=
measurable_set.Union $ Î» j, measurable_set.Union_Prop $
  Î» hij, Î¼.to_finite_spanning_sets_in.set_mem j
lemma measure_spanning_sets_lt_top (Î¼ : measure Î±) [sigma_finite Î¼] (i : â„•) :
  Î¼ (spanning_sets Î¼ i) < âˆ :=
measure_bUnion_lt_top (finite_le_nat i) $ Î» j _, (Î¼.to_finite_spanning_sets_in.finite j).ne
lemma Union_spanning_sets (Î¼ : measure Î±) [sigma_finite Î¼] :
  (â‹ƒ i : â„•, spanning_sets Î¼ i) = univ :=
by simp_rw [spanning_sets, Union_accumulate, Î¼.to_finite_spanning_sets_in.spanning]
lemma is_countably_spanning_spanning_sets (Î¼ : measure Î±) [sigma_finite Î¼] :
  is_countably_spanning (range (spanning_sets Î¼)) :=
âŸ¨spanning_sets Î¼, mem_range_self, Union_spanning_sets Î¼âŸ©
def spanning_sets_index (Î¼ : measure Î±) [sigma_finite Î¼] (x : Î±) : â„• :=
nat.find $ Union_eq_univ_iff.1 (Union_spanning_sets Î¼) x
lemma measurable_spanning_sets_index (Î¼ : measure Î±) [sigma_finite Î¼] :
  measurable (spanning_sets_index Î¼) :=
measurable_find _ $ measurable_spanning_sets Î¼
lemma preimage_spanning_sets_index_singleton (Î¼ : measure Î±) [sigma_finite Î¼] (n : â„•) :
  spanning_sets_index Î¼ â»Â¹' {n} = disjointed (spanning_sets Î¼) n :=
preimage_find_eq_disjointed _ _ _
lemma spanning_sets_index_eq_iff (Î¼ : measure Î±) [sigma_finite Î¼] {x : Î±} {n : â„•} :
  spanning_sets_index Î¼ x = n â†” x âˆˆ disjointed (spanning_sets Î¼) n :=
by convert set.ext_iff.1 (preimage_spanning_sets_index_singleton Î¼ n) x
lemma mem_disjointed_spanning_sets_index (Î¼ : measure Î±) [sigma_finite Î¼] (x : Î±) :
  x âˆˆ disjointed (spanning_sets Î¼) (spanning_sets_index Î¼ x) :=
(spanning_sets_index_eq_iff Î¼).1 rfl
lemma mem_spanning_sets_index (Î¼ : measure Î±) [sigma_finite Î¼] (x : Î±) :
  x âˆˆ spanning_sets Î¼ (spanning_sets_index Î¼ x) :=
disjointed_subset _ _ (mem_disjointed_spanning_sets_index Î¼ x)
lemma mem_spanning_sets_of_index_le (Î¼ : measure Î±) [sigma_finite Î¼] (x : Î±)
  {n : â„•} (hn : spanning_sets_index Î¼ x â‰¤ n) :
  x âˆˆ spanning_sets Î¼ n :=
monotone_spanning_sets Î¼ hn (mem_spanning_sets_index Î¼ x)
lemma eventually_mem_spanning_sets (Î¼ : measure Î±) [sigma_finite Î¼] (x : Î±) :
  âˆ€á¶  n in at_top, x âˆˆ spanning_sets Î¼ n :=
eventually_at_top.2 âŸ¨spanning_sets_index Î¼ x, Î» b, mem_spanning_sets_of_index_le Î¼ xâŸ©
omit m0
namespace measure
lemma supr_restrict_spanning_sets [sigma_finite Î¼] (hs : measurable_set s) :
  (â¨† i, Î¼.restrict (spanning_sets Î¼ i) s) = Î¼ s :=
calc (â¨† i, Î¼.restrict (spanning_sets Î¼ i) s) = Î¼.restrict (â‹ƒ i, spanning_sets Î¼ i) s :
  (restrict_Union_apply_eq_supr (directed_of_sup (monotone_spanning_sets Î¼)) hs).symm
... = Î¼ s : by rw [Union_spanning_sets, restrict_univ]
lemma exists_subset_measure_lt_top [sigma_finite Î¼]
  {r : â„â‰¥0âˆ} (hs : measurable_set s) (h's : r < Î¼ s) :
  âˆƒ t, measurable_set t âˆ§ t âŠ† s âˆ§ r < Î¼ t âˆ§ Î¼ t < âˆ :=
begin
  rw [â† supr_restrict_spanning_sets hs,
      @lt_supr_iff _ _ _ r (Î» (i : â„•), Î¼.restrict (spanning_sets Î¼ i) s)] at h's,
  rcases h's with âŸ¨n, hnâŸ©,
  simp only [restrict_apply hs] at hn,
  refine âŸ¨s âˆ© spanning_sets Î¼ n, hs.inter (measurable_spanning_sets _ _), inter_subset_left _ _,
    hn, _âŸ©,
  exact (measure_mono (inter_subset_right _ _)).trans_lt (measure_spanning_sets_lt_top _ _),
end
lemma measure_to_measurable_inter_of_sigma_finite
  [sigma_finite Î¼] {s : set Î±} (hs : measurable_set s) (t : set Î±) :
  Î¼ (to_measurable Î¼ t âˆ© s) = Î¼ (t âˆ© s) :=
begin
protected def mono' (h : Î¼.finite_spanning_sets_in C) (hC : C âˆ© {s | Î¼ s < âˆ} âŠ† D) :
  Î¼.finite_spanning_sets_in D :=
âŸ¨h.set, Î» i, hC âŸ¨h.set_mem i, h.finite iâŸ©, h.finite, h.spanningâŸ©
protected def mono (h : Î¼.finite_spanning_sets_in C) (hC : C âŠ† D) : Î¼.finite_spanning_sets_in D :=
h.mono' (Î» s hs, hC hs.1)
protected lemma sigma_finite (h : Î¼.finite_spanning_sets_in C) :
  sigma_finite Î¼ :=
âŸ¨âŸ¨h.mono $ subset_univ CâŸ©âŸ©
protected lemma ext {Î½ : measure Î±} {C : set (set Î±)} (hA : â€¹_â€º = generate_from C)
  (hC : is_pi_system C) (h : Î¼.finite_spanning_sets_in C) (h_eq : âˆ€ s âˆˆ C, Î¼ s = Î½ s) : Î¼ = Î½ :=
ext_of_generate_from_of_Union C _ hA hC h.spanning h.set_mem (Î» i, (h.finite i).ne) h_eq
protected lemma is_countably_spanning (h : Î¼.finite_spanning_sets_in C) : is_countably_spanning C :=
âŸ¨h.set, h.set_mem, h.spanningâŸ©
end finite_spanning_sets_in
lemma sigma_finite_of_countable {S : set (set Î±)} (hc : S.countable)
  (hÎ¼ : âˆ€ s âˆˆ S, Î¼ s < âˆ) (hU : â‹ƒâ‚€ S = univ) :
  sigma_finite Î¼ :=
begin
  obtain âŸ¨s, hÎ¼, hsâŸ© : âˆƒ s : â„• â†’ set Î±, (âˆ€ n, Î¼ (s n) < âˆ) âˆ§ (â‹ƒ n, s n) = univ,
    from (@exists_seq_cover_iff_countable _ (Î» x, Î¼ x < âŠ¤) âŸ¨âˆ…, by simpâŸ©).2 âŸ¨S, hc, hÎ¼, hUâŸ©,
  exact âŸ¨âŸ¨âŸ¨Î» n, s n, Î» n, trivial, hÎ¼, hsâŸ©âŸ©âŸ©,
end
def finite_spanning_sets_in.of_le (h : Î½ â‰¤ Î¼) {C : set (set Î±)}
  (S : Î¼.finite_spanning_sets_in C) : Î½.finite_spanning_sets_in C :=
{ set := S.set,
  set_mem := S.set_mem,
  finite := Î» n, lt_of_le_of_lt (le_iff'.1 h _) (S.finite n),
  spanning := S.spanning }
lemma sigma_finite_of_le (Î¼ : measure Î±) [hs : sigma_finite Î¼]
  (h : Î½ â‰¤ Î¼) : sigma_finite Î½ :=
âŸ¨hs.out.map $ finite_spanning_sets_in.of_le hâŸ©
end measure
include m0
@[priority 100]
instance is_finite_measure.to_sigma_finite (Î¼ : measure Î±) [is_finite_measure Î¼] :
  sigma_finite Î¼ :=
âŸ¨âŸ¨âŸ¨Î» _, univ, Î» _, trivial, Î» _, measure_lt_top Î¼ _, Union_const _âŸ©âŸ©âŸ©
instance restrict.sigma_finite (Î¼ : measure Î±) [sigma_finite Î¼] (s : set Î±) :
  sigma_finite (Î¼.restrict s) :=
begin
  refine âŸ¨âŸ¨âŸ¨spanning_sets Î¼, Î» _, trivial, Î» i, _, Union_spanning_sets Î¼âŸ©âŸ©âŸ©,
  rw [restrict_apply (measurable_spanning_sets Î¼ i)],
  exact (measure_mono $ inter_subset_left _ _).trans_lt (measure_spanning_sets_lt_top Î¼ i)
end
instance sum.sigma_finite {Î¹} [fintype Î¹] (Î¼ : Î¹ â†’ measure Î±) [âˆ€ i, sigma_finite (Î¼ i)] :
  sigma_finite (sum Î¼) :=
begin
  haveI : encodable Î¹ := fintype.to_encodable Î¹,
  have : âˆ€ n, measurable_set (â‹‚ (i : Î¹), spanning_sets (Î¼ i) n) :=
    Î» n, measurable_set.Inter (Î» i, measurable_spanning_sets (Î¼ i) n),
  refine âŸ¨âŸ¨âŸ¨Î» n, â‹‚ i, spanning_sets (Î¼ i) n, Î» _, trivial, Î» n, _, _âŸ©âŸ©âŸ©,
  { rw [sum_apply _ (this n), tsum_fintype, ennreal.sum_lt_top_iff],
    rintro i -,
    exact (measure_mono $ Inter_subset _ i).trans_lt (measure_spanning_sets_lt_top (Î¼ i) n) },
  { rw [Union_Inter_of_monotone], simp_rw [Union_spanning_sets, Inter_univ],
    exact Î» i, monotone_spanning_sets (Î¼ i), }
end
instance add.sigma_finite (Î¼ Î½ : measure Î±) [sigma_finite Î¼] [sigma_finite Î½] :
  sigma_finite (Î¼ + Î½) :=
by { rw [â† sum_cond], refine @sum.sigma_finite _ _ _ _ _ (bool.rec _ _); simpa }
lemma sigma_finite.of_map (Î¼ : measure Î±) {f : Î± â†’ Î²} (hf : ae_measurable f Î¼)
  (h : sigma_finite (Î¼.map f)) :
  sigma_finite Î¼ :=
âŸ¨âŸ¨âŸ¨Î» n, f â»Â¹' (spanning_sets (Î¼.map f) n),
   Î» n, trivial,
   Î» n, by simp only [â† map_apply_of_ae_measurable hf, measurable_spanning_sets,
     measure_spanning_sets_lt_top],
   by rw [â† preimage_Union, Union_spanning_sets, preimage_univ]âŸ©âŸ©âŸ©
lemma _root_.measurable_equiv.sigma_finite_map {Î¼ : measure Î±} (f : Î± â‰ƒáµ Î²) (h : sigma_finite Î¼) :
  sigma_finite (Î¼.map f) :=
by { refine sigma_finite.of_map _ f.symm.measurable.ae_measurable _,
     rwa [map_map f.symm.measurable f.measurable, f.symm_comp_self, measure.map_id] }
lemma ae_of_forall_measure_lt_top_ae_restrict' {Î¼ : measure Î±} (Î½ : measure Î±) [sigma_finite Î¼]
  [sigma_finite Î½] (P : Î± â†’ Prop)
  (h : âˆ€ s, measurable_set s â†’ Î¼ s < âˆ â†’ Î½ s < âˆ â†’ âˆ€áµ x âˆ‚(Î¼.restrict s), P x) :
  âˆ€áµ x âˆ‚Î¼, P x :=
begin
  have : âˆ€ n, âˆ€áµ x âˆ‚Î¼, x âˆˆ spanning_sets (Î¼ + Î½) n â†’ P x,
  { intro n,
    have := h (spanning_sets (Î¼ + Î½) n) (measurable_spanning_sets _ _) _ _,
    exacts [(ae_restrict_iff' (measurable_spanning_sets _ _)).mp this,
      (self_le_add_right _ _).trans_lt (measure_spanning_sets_lt_top (Î¼ + Î½) _),
      (self_le_add_left _ _).trans_lt (measure_spanning_sets_lt_top (Î¼ + Î½) _)] },
  filter_upwards [ae_all_iff.2 this] with _ hx using hx _ (mem_spanning_sets_index _ _)
end
lemma ae_of_forall_measure_lt_top_ae_restrict {Î¼ : measure Î±} [sigma_finite Î¼] (P : Î± â†’ Prop)
  (h : âˆ€ s, measurable_set s â†’ Î¼ s < âˆ â†’ âˆ€áµ x âˆ‚(Î¼.restrict s), P x) :
  âˆ€áµ x âˆ‚Î¼, P x :=
ae_of_forall_measure_lt_top_ae_restrict' Î¼ P $ Î» s hs h2s _, h s hs h2s
class is_locally_finite_measure [topological_space Î±] (Î¼ : measure Î±) : Prop :=
(finite_at_nhds : âˆ€ x, Î¼.finite_at_filter (ğ“ x))
@[protect_proj] class is_finite_measure_on_compacts [topological_space Î±] (Î¼ : measure Î±) : Prop :=
(lt_top_of_is_compact : âˆ€ â¦ƒK : set Î±â¦„, is_compact K â†’ Î¼ K < âˆ)
lemma _root_.is_compact.measure_lt_top
  [topological_space Î±] {Î¼ : measure Î±} [is_finite_measure_on_compacts Î¼]
  â¦ƒK : set Î±â¦„ (hK : is_compact K) : Î¼ K < âˆ :=
is_finite_measure_on_compacts.lt_top_of_is_compact hK
lemma _root_.metric.bounded.measure_lt_top [pseudo_metric_space Î±] [proper_space Î±]
  {Î¼ : measure Î±} [is_finite_measure_on_compacts Î¼] â¦ƒs : set Î±â¦„ (hs : metric.bounded s) :
  Î¼ s < âˆ :=
calc Î¼ s â‰¤ Î¼ (closure s) : measure_mono subset_closure
... < âˆ : (metric.is_compact_of_is_closed_bounded is_closed_closure hs.closure).measure_lt_top
lemma measure_closed_ball_lt_top [pseudo_metric_space Î±] [proper_space Î±]
  {Î¼ : measure Î±} [is_finite_measure_on_compacts Î¼] {x : Î±} {r : â„} :
  Î¼ (metric.closed_ball x r) < âˆ :=
metric.bounded_closed_ball.measure_lt_top
lemma measure_ball_lt_top [pseudo_metric_space Î±] [proper_space Î±]
  {Î¼ : measure Î±} [is_finite_measure_on_compacts Î¼] {x : Î±} {r : â„} :
  Î¼ (metric.ball x r) < âˆ :=
metric.bounded_ball.measure_lt_top
protected lemma is_finite_measure_on_compacts.smul [topological_space Î±] (Î¼ : measure Î±)
  [is_finite_measure_on_compacts Î¼] {c : â„â‰¥0âˆ} (hc : c â‰  âˆ) :
  is_finite_measure_on_compacts (c â€¢ Î¼) :=
âŸ¨Î» K hK, ennreal.mul_lt_top hc (hK.measure_lt_top).neâŸ©
omit m0
lemma is_locally_finite_measure_of_is_finite_measure_on_compacts [topological_space Î±]
  [locally_compact_space Î±] [is_finite_measure_on_compacts Î¼] :
  is_locally_finite_measure Î¼ :=
âŸ¨begin
  intro x,
  rcases exists_compact_mem_nhds x with âŸ¨K, K_compact, K_memâŸ©,
  exact âŸ¨K, K_mem, K_compact.measure_lt_topâŸ©,
endâŸ©
lemma exists_pos_measure_of_cover [encodable Î¹] {U : Î¹ â†’ set Î±} (hU : (â‹ƒ i, U i) = univ)
  (hÎ¼ : Î¼ â‰  0) : âˆƒ i, 0 < Î¼ (U i) :=
begin
  contrapose! hÎ¼ with H,
  rw [â† measure_univ_eq_zero, â† hU],
  exact measure_Union_null (Î» i, nonpos_iff_eq_zero.1 (H i))
end
lemma exists_pos_preimage_ball [pseudo_metric_space Î´] (f : Î± â†’ Î´) (x : Î´) (hÎ¼ : Î¼ â‰  0) :
  âˆƒ n : â„•, 0 < Î¼ (f â»Â¹' metric.ball x n) :=
exists_pos_measure_of_cover (by rw [â† preimage_Union, metric.Union_ball_nat, preimage_univ]) hÎ¼
lemma exists_pos_ball [pseudo_metric_space Î±] (x : Î±) (hÎ¼ : Î¼ â‰  0) :
  âˆƒ n : â„•, 0 < Î¼ (metric.ball x n) :=
exists_pos_preimage_ball id x hÎ¼
lemma null_of_locally_null [topological_space Î±] [second_countable_topology Î±]
  (s : set Î±) (hs : âˆ€ x âˆˆ s, âˆƒ u âˆˆ ğ“[s] x, Î¼ u = 0) :
  Î¼ s = 0 :=
Î¼.to_outer_measure.null_of_locally_null s hs
lemma exists_mem_forall_mem_nhds_within_pos_measure [topological_space Î±]
  [second_countable_topology Î±] {s : set Î±} (hs : Î¼ s â‰  0) :
  âˆƒ x âˆˆ s, âˆ€ t âˆˆ ğ“[s] x, 0 < Î¼ t :=
Î¼.to_outer_measure.exists_mem_forall_mem_nhds_within_pos hs
lemma exists_ne_forall_mem_nhds_pos_measure_preimage {Î²} [topological_space Î²] [t1_space Î²]
  [second_countable_topology Î²] [nonempty Î²] {f : Î± â†’ Î²} (h : âˆ€ b, âˆƒáµ x âˆ‚Î¼, f x â‰  b) :
  âˆƒ a b : Î², a â‰  b âˆ§ (âˆ€ s âˆˆ ğ“ a, 0 < Î¼ (f â»Â¹' s)) âˆ§ (âˆ€ t âˆˆ ğ“ b, 0 < Î¼ (f â»Â¹' t)) :=
begin
lemma ext_on_measurable_space_of_generate_finite {Î±} (mâ‚€ : measurable_space Î±)
  {Î¼ Î½ : measure Î±} [is_finite_measure Î¼]
  (C : set (set Î±)) (hÎ¼Î½ : âˆ€ s âˆˆ C, Î¼ s = Î½ s) {m : measurable_space Î±}
  (h : m â‰¤ mâ‚€) (hA : m = measurable_space.generate_from C) (hC : is_pi_system C)
  (h_univ : Î¼ set.univ = Î½ set.univ) {s : set Î±} (hs : measurable_set[m] s) :
  Î¼ s = Î½ s :=
begin
  haveI : is_finite_measure Î½ := begin
     constructor,
     rw â† h_univ,
     apply is_finite_measure.measure_univ_lt_top,
  end,
  refine induction_on_inter hA hC (by simp) hÎ¼Î½ _ _ hs,
  { intros t h1t h2t,
    have h1t_ : @measurable_set Î± mâ‚€ t, from h _ h1t,
    rw [@measure_compl Î± mâ‚€ Î¼ t h1t_ (@measure_ne_top Î± mâ‚€ Î¼ _ t),
      @measure_compl Î± mâ‚€ Î½ t h1t_ (@measure_ne_top Î± mâ‚€ Î½ _ t), h_univ, h2t], },
  { intros f h1f h2f h3f,
    have h2f_ : âˆ€ (i : â„•), @measurable_set Î± mâ‚€ (f i), from (Î» i, h _ (h2f i)),
    have h_Union : @measurable_set Î± mâ‚€ (â‹ƒ (i : â„•), f i),from @measurable_set.Union Î± â„• mâ‚€ _ f h2f_,
    simp [measure_Union, h_Union, h1f, h3f, h2f_], },
end
lemma ext_of_generate_finite (C : set (set Î±)) (hA : m0 = generate_from C) (hC : is_pi_system C)
  [is_finite_measure Î¼] (hÎ¼Î½ : âˆ€ s âˆˆ C, Î¼ s = Î½ s) (h_univ : Î¼ univ = Î½ univ) :
  Î¼ = Î½ :=
measure.ext (Î» s hs, ext_on_measurable_space_of_generate_finite m0 C hÎ¼Î½ le_rfl hA hC h_univ hs)
namespace measure
section disjointed
include m0
protected def finite_spanning_sets_in.disjointed {Î¼ : measure Î±}
  (S : Î¼.finite_spanning_sets_in {s | measurable_set s}) :
   Î¼.finite_spanning_sets_in {s | measurable_set s} :=
âŸ¨disjointed S.set, measurable_set.disjointed S.set_mem,
  Î» n, lt_of_le_of_lt (measure_mono (disjointed_subset S.set n)) (S.finite _),
  S.spanning â–¸ Union_disjointedâŸ©
lemma finite_spanning_sets_in.disjointed_set_eq {Î¼ : measure Î±}
  (S : Î¼.finite_spanning_sets_in {s | measurable_set s}) :
  S.disjointed.set = disjointed S.set :=
rfl
lemma exists_eq_disjoint_finite_spanning_sets_in
  (Î¼ Î½ : measure Î±) [sigma_finite Î¼] [sigma_finite Î½] :
  âˆƒ (S : Î¼.finite_spanning_sets_in {s | measurable_set s})
    (T : Î½.finite_spanning_sets_in {s | measurable_set s}),
    S.set = T.set âˆ§ pairwise (disjoint on S.set) :=
let S := (Î¼ + Î½).to_finite_spanning_sets_in.disjointed in
âŸ¨S.of_le (measure.le_add_right le_rfl), S.of_le (measure.le_add_left le_rfl),
  rfl, disjoint_disjointed _âŸ©
end disjointed
namespace finite_at_filter
variables {f g : filter Î±}
lemma filter_mono (h : f â‰¤ g) : Î¼.finite_at_filter g â†’ Î¼.finite_at_filter f :=
Î» âŸ¨s, hs, hÎ¼âŸ©, âŸ¨s, h hs, hÎ¼âŸ©
lemma inf_of_left (h : Î¼.finite_at_filter f) : Î¼.finite_at_filter (f âŠ“ g) :=
h.filter_mono inf_le_left
lemma inf_of_right (h : Î¼.finite_at_filter g) : Î¼.finite_at_filter (f âŠ“ g) :=
h.filter_mono inf_le_right
@[simp] lemma inf_ae_iff : Î¼.finite_at_filter (f âŠ“ Î¼.ae) â†” Î¼.finite_at_filter f :=
begin
  refine âŸ¨_, Î» h, h.filter_mono inf_le_leftâŸ©,
  rintros âŸ¨s, âŸ¨t, ht, u, hu, rflâŸ©, hÎ¼âŸ©,
  suffices : Î¼ t â‰¤ Î¼ (t âˆ© u), from âŸ¨t, ht, this.trans_lt hÎ¼âŸ©,
  exact measure_mono_ae (mem_of_superset hu (Î» x hu ht, âŸ¨ht, huâŸ©))
end
alias inf_ae_iff â†” of_inf_ae _
lemma filter_mono_ae (h : f âŠ“ Î¼.ae â‰¤ g) (hg : Î¼.finite_at_filter g) : Î¼.finite_at_filter f :=
inf_ae_iff.1 (hg.filter_mono h)
protected lemma measure_mono (h : Î¼ â‰¤ Î½) : Î½.finite_at_filter f â†’ Î¼.finite_at_filter f :=
Î» âŸ¨s, hs, hÎ½âŸ©, âŸ¨s, hs, (measure.le_iff'.1 h s).trans_lt hÎ½âŸ©
@[mono] protected lemma mono (hf : f â‰¤ g) (hÎ¼ : Î¼ â‰¤ Î½) :
  Î½.finite_at_filter g â†’ Î¼.finite_at_filter f :=
Î» h, (h.filter_mono hf).measure_mono hÎ¼
protected lemma eventually (h : Î¼.finite_at_filter f) : âˆ€á¶  s in f.small_sets, Î¼ s < âˆ :=
(eventually_small_sets' $ Î» s t hst ht, (measure_mono hst).trans_lt ht).2 h
lemma filter_sup : Î¼.finite_at_filter f â†’ Î¼.finite_at_filter g â†’ Î¼.finite_at_filter (f âŠ” g) :=
Î» âŸ¨s, hsf, hsÎ¼âŸ© âŸ¨t, htg, htÎ¼âŸ©,
 âŸ¨s âˆª t, union_mem_sup hsf htg, (measure_union_le s t).trans_lt (ennreal.add_lt_top.2 âŸ¨hsÎ¼, htÎ¼âŸ©)âŸ©
end finite_at_filter
lemma finite_at_nhds_within [topological_space Î±] {m0 : measurable_space Î±} (Î¼ : measure Î±)
  [is_locally_finite_measure Î¼] (x : Î±) (s : set Î±) :
  Î¼.finite_at_filter (ğ“[s] x) :=
(finite_at_nhds Î¼ x).inf_of_left
@[simp] lemma finite_at_principal : Î¼.finite_at_filter (ğ“Ÿ s) â†” Î¼ s < âˆ :=
âŸ¨Î» âŸ¨t, ht, hÎ¼âŸ©, (measure_mono ht).trans_lt hÎ¼, Î» h, âŸ¨s, mem_principal_self s, hâŸ©âŸ©
lemma is_locally_finite_measure_of_le [topological_space Î±] {m : measurable_space Î±}
  {Î¼ Î½ : measure Î±} [H : is_locally_finite_measure Î¼] (h : Î½ â‰¤ Î¼) :
  is_locally_finite_measure Î½ :=
let F := H.finite_at_nhds in âŸ¨Î» x, (F x).measure_mono hâŸ©
end measure
end measure_theory
open measure_theory measure_theory.measure
namespace measurable_embedding
variables {m0 : measurable_space Î±} {m1 : measurable_space Î²} {f : Î± â†’ Î²}
  (hf : measurable_embedding f)
include hf
theorem map_apply (Î¼ : measure Î±) (s : set Î²) : Î¼.map f s = Î¼ (f â»Â¹' s) :=
begin
  refine le_antisymm _ (le_map_apply hf.measurable.ae_measurable s),
  set t := f '' (to_measurable Î¼ (f â»Â¹' s)) âˆª (range f)á¶œ,
  have htm : measurable_set t,
    from (hf.measurable_set_image.2 $ measurable_set_to_measurable _ _).union
      hf.measurable_set_range.compl,
  have hst : s âŠ† t,
  { rw [subset_union_compl_iff_inter_subset, â† image_preimage_eq_inter_range],
    exact image_subset _ (subset_to_measurable _ _) },
  have hft : f â»Â¹' t = to_measurable Î¼ (f â»Â¹' s),
    by rw [preimage_union, preimage_compl, preimage_range, compl_univ, union_empty,
      hf.injective.preimage_image],
  calc Î¼.map f s â‰¤ Î¼.map f t : measure_mono hst
            ... = Î¼ (f â»Â¹' s) :
    by rw [map_apply hf.measurable htm, hft, measure_to_measurable]
end
lemma map_comap (Î¼ : measure Î²) : (comap f Î¼).map f  = Î¼.restrict (range f) :=
begin
  ext1 t ht,
  rw [hf.map_apply, comap_apply f hf.injective hf.measurable_set_image' _ (hf.measurable ht),
    image_preimage_eq_inter_range, restrict_apply ht]
end
lemma comap_apply (Î¼ : measure Î²) (s : set Î±) : comap f Î¼ s = Î¼ (f '' s) :=
calc comap f Î¼ s = comap f Î¼ (f â»Â¹' (f '' s)) : by rw hf.injective.preimage_image
... = (comap f Î¼).map f (f '' s) : (hf.map_apply _ _).symm
... = Î¼ (f '' s) : by rw [hf.map_comap, restrict_apply' hf.measurable_set_range,
  inter_eq_self_of_subset_left (image_subset_range _ _)]
lemma ae_map_iff {p : Î² â†’ Prop} {Î¼ : measure Î±} : (âˆ€áµ x âˆ‚(Î¼.map f), p x) â†” âˆ€áµ x âˆ‚Î¼, p (f x) :=
by simp only [ae_iff, hf.map_apply, preimage_set_of_eq]
lemma restrict_map (Î¼ : measure Î±) (s : set Î²) :
  (Î¼.map f).restrict s = (Î¼.restrict $ f â»Â¹' s).map f :=
measure.ext $ Î» t ht, by simp [hf.map_apply, ht, hf.measurable ht]
end measurable_embedding
section subtype
lemma comap_subtype_coe_apply {m0 : measurable_space Î±} {s : set Î±} (hs : measurable_set s)
  (Î¼ : measure Î±) (t : set s) :
  comap coe Î¼ t = Î¼ (coe '' t) :=
(measurable_embedding.subtype_coe hs).comap_apply _ _
lemma map_comap_subtype_coe {m0 : measurable_space Î±} {s : set Î±} (hs : measurable_set s)
  (Î¼ : measure Î±) : (comap coe Î¼).map (coe : s â†’ Î±) = Î¼.restrict s :=
by rw [(measurable_embedding.subtype_coe hs).map_comap, subtype.range_coe]
lemma ae_restrict_iff_subtype {m0 : measurable_space Î±} {Î¼ : measure Î±} {s : set Î±}
  (hs : measurable_set s) {p : Î± â†’ Prop} :
  (âˆ€áµ x âˆ‚(Î¼.restrict s), p x) â†” âˆ€áµ x âˆ‚(comap (coe : s â†’ Î±) Î¼), p â†‘x :=
by rw [â† map_comap_subtype_coe hs, (measurable_embedding.subtype_coe hs).ae_map_iff]
variables [measure_space Î±]
instance _root_.set_coe.measure_space (s : set Î±) : measure_space s :=
âŸ¨comap (coe : s â†’ Î±) volumeâŸ©
lemma volume_set_coe_def (s : set Î±) : (volume : measure s) = comap (coe : s â†’ Î±) volume := rfl
lemma measurable_set.map_coe_volume {s : set Î±} (hs : measurable_set s) :
  volume.map (coe : s â†’ Î±)= restrict volume s :=
by rw [volume_set_coe_def, (measurable_embedding.subtype_coe hs).map_comap volume,
  subtype.range_coe]
lemma volume_image_subtype_coe {s : set Î±} (hs : measurable_set s) (t : set s) :
  volume (coe '' t : set Î±) = volume t :=
(comap_subtype_coe_apply hs volume t).symm
end subtype
namespace measurable_equiv
open equiv measure_theory.measure
variables [measurable_space Î±] [measurable_space Î²] {Î¼ : measure Î±} {Î½ : measure Î²}
protected theorem map_apply (f : Î± â‰ƒáµ Î²) (s : set Î²) : Î¼.map f s = Î¼ (f â»Â¹' s) :=
f.measurable_embedding.map_apply _ _
@[simp] lemma map_symm_map (e : Î± â‰ƒáµ Î²) : (Î¼.map e).map e.symm  = Î¼ :=
by simp [map_map e.symm.measurable e.measurable]
@[simp] lemma map_map_symm (e : Î± â‰ƒáµ Î²) : (Î½.map e.symm).map e  = Î½ :=
by simp [map_map e.measurable e.symm.measurable]
lemma map_measurable_equiv_injective (e : Î± â‰ƒáµ Î²) : injective (map e) :=
by { intros Î¼â‚ Î¼â‚‚ hÎ¼, apply_fun map e.symm at hÎ¼, simpa [map_symm_map e] using hÎ¼ }
lemma map_apply_eq_iff_map_symm_apply_eq (e : Î± â‰ƒáµ Î²) : Î¼.map e = Î½ â†” Î½.map e.symm = Î¼ :=
by rw [â† (map_measurable_equiv_injective e).eq_iff, map_map_symm, eq_comm]
lemma restrict_map (e : Î± â‰ƒáµ Î²) (s : set Î²) : (Î¼.map e).restrict s = (Î¼.restrict $ e â»Â¹' s).map e :=
e.measurable_embedding.restrict_map _ _
lemma map_ae (f : Î± â‰ƒáµ Î²) (Î¼ : measure Î±) : filter.map f Î¼.ae = (map f Î¼).ae :=
by { ext s, simp_rw [mem_map, mem_ae_iff, â† preimage_compl, f.map_apply] }
end measurable_equiv
namespace measure_theory
lemma outer_measure.to_measure_zero [measurable_space Î±] : (0 : outer_measure Î±).to_measure
  ((le_top).trans outer_measure.zero_caratheodory.symm.le) = 0 :=
by rw [â† measure.measure_univ_eq_zero, to_measure_apply _ _ measurable_set.univ,
  outer_measure.coe_zero, pi.zero_apply]
section trim
def measure.trim {m m0 : measurable_space Î±} (Î¼ : @measure Î± m0) (hm : m â‰¤ m0) : @measure Î± m :=
@outer_measure.to_measure Î± m Î¼.to_outer_measure (hm.trans (le_to_outer_measure_caratheodory Î¼))
@[simp] lemma trim_eq_self [measurable_space Î±] {Î¼ : measure Î±} : Î¼.trim le_rfl = Î¼ :=
by simp [measure.trim]
variables {m m0 : measurable_space Î±} {Î¼ : measure Î±} {s : set Î±}
lemma to_outer_measure_trim_eq_trim_to_outer_measure (Î¼ : measure Î±) (hm : m â‰¤ m0) :
  @measure.to_outer_measure _ m (Î¼.trim hm) = @outer_measure.trim _ m Î¼.to_outer_measure :=
by rw [measure.trim, to_measure_to_outer_measure]
@[simp] lemma zero_trim (hm : m â‰¤ m0) : (0 : measure Î±).trim hm = (0 : @measure Î± m) :=
by simp [measure.trim, outer_measure.to_measure_zero]
lemma trim_measurable_set_eq (hm : m â‰¤ m0) (hs : @measurable_set Î± m s) : Î¼.trim hm s = Î¼ s :=
by simp [measure.trim, hs]
lemma le_trim (hm : m â‰¤ m0) : Î¼ s â‰¤ Î¼.trim hm s :=
by { simp_rw [measure.trim], exact (@le_to_measure_apply _ m _ _ _), }
lemma measure_eq_zero_of_trim_eq_zero (hm : m â‰¤ m0) (h : Î¼.trim hm s = 0) : Î¼ s = 0 :=
le_antisymm ((le_trim hm).trans (le_of_eq h)) (zero_le _)
lemma measure_trim_to_measurable_eq_zero {hm : m â‰¤ m0} (hs : Î¼.trim hm s = 0) :
  Î¼ (@to_measurable Î± m (Î¼.trim hm) s) = 0 :=
measure_eq_zero_of_trim_eq_zero hm (by rwa measure_to_measurable)
lemma ae_of_ae_trim (hm : m â‰¤ m0) {Î¼ : measure Î±} {P : Î± â†’ Prop} (h : âˆ€áµ x âˆ‚(Î¼.trim hm), P x) :
  âˆ€áµ x âˆ‚Î¼, P x :=
measure_eq_zero_of_trim_eq_zero hm h
lemma ae_eq_of_ae_eq_trim {E} {hm : m â‰¤ m0} {fâ‚ fâ‚‚ : Î± â†’ E}
  (h12 : fâ‚ =á¶ [@measure.ae Î± m (Î¼.trim hm)] fâ‚‚) :
  fâ‚ =áµ[Î¼] fâ‚‚ :=
measure_eq_zero_of_trim_eq_zero hm h12
lemma ae_le_of_ae_le_trim {E} [has_le E] {hm : m â‰¤ m0} {fâ‚ fâ‚‚ : Î± â†’ E}
  (h12 : fâ‚ â‰¤á¶ [@measure.ae Î± m (Î¼.trim hm)] fâ‚‚) :
  fâ‚ â‰¤áµ[Î¼] fâ‚‚ :=
measure_eq_zero_of_trim_eq_zero hm h12
lemma trim_trim {mâ‚ mâ‚‚ : measurable_space Î±} {hmâ‚â‚‚ : mâ‚ â‰¤ mâ‚‚} {hmâ‚‚ : mâ‚‚ â‰¤ m0} :
  (Î¼.trim hmâ‚‚).trim hmâ‚â‚‚ = Î¼.trim (hmâ‚â‚‚.trans hmâ‚‚) :=
begin
  ext1 t ht,
  rw [trim_measurable_set_eq hmâ‚â‚‚ ht, trim_measurable_set_eq (hmâ‚â‚‚.trans hmâ‚‚) ht,
    trim_measurable_set_eq hmâ‚‚ (hmâ‚â‚‚ t ht)],
end
lemma restrict_trim (hm : m â‰¤ m0) (Î¼ : measure Î±) (hs : @measurable_set Î± m s) :
  @measure.restrict Î± m (Î¼.trim hm) s = (Î¼.restrict s).trim hm :=
begin
  ext1 t ht,
  rw [@measure.restrict_apply Î± m _ _ _ ht, trim_measurable_set_eq hm ht,
    measure.restrict_apply (hm t ht),
    trim_measurable_set_eq hm (@measurable_set.inter Î± m t s ht hs)],
end
instance is_finite_measure_trim (hm : m â‰¤ m0) [is_finite_measure Î¼] :
  is_finite_measure (Î¼.trim hm) :=
{ measure_univ_lt_top :=
    by { rw trim_measurable_set_eq hm (@measurable_set.univ _ m), exact measure_lt_top _ _, } }
lemma sigma_finite_trim_mono {m mâ‚‚ m0 : measurable_space Î±} {Î¼ : measure Î±} (hm : m â‰¤ m0)
  (hmâ‚‚ : mâ‚‚ â‰¤ m) [sigma_finite (Î¼.trim (hmâ‚‚.trans hm))] :
  sigma_finite (Î¼.trim hm) :=
begin
  have h := measure.finite_spanning_sets_in (Î¼.trim (hmâ‚‚.trans hm)) set.univ,
  refine measure.finite_spanning_sets_in.sigma_finite _,
  { use set.univ, },
  { refine
    { set := spanning_sets (Î¼.trim (hmâ‚‚.trans hm)),
      set_mem := Î» _, set.mem_univ _,
lemma exists_open_superset_measure_lt_top' (h : is_compact s)
  (hÎ¼ : âˆ€ x âˆˆ s, Î¼.finite_at_filter (ğ“ x)) :
  âˆƒ U âŠ‡ s, is_open U âˆ§ Î¼ U < âˆ :=
begin
  refine is_compact.induction_on h _ _ _ _,
  { use âˆ…, simp [superset] },
  { rintro s t hst âŸ¨U, htU, hUo, hUâŸ©, exact âŸ¨U, hst.trans htU, hUo, hUâŸ© },
  { rintro s t âŸ¨U, hsU, hUo, hUâŸ© âŸ¨V, htV, hVo, hVâŸ©,
    refine âŸ¨U âˆª V, union_subset_union hsU htV, hUo.union hVo,
      (measure_union_le _ _).trans_lt $ ennreal.add_lt_top.2 âŸ¨hU, hVâŸ©âŸ© },
  { intros x hx,
    rcases (hÎ¼ x hx).exists_mem_basis (nhds_basis_opens _) with âŸ¨U, âŸ¨hx, hUoâŸ©, hUâŸ©,
    exact âŸ¨U, nhds_within_le_nhds (hUo.mem_nhds hx), U, subset.rfl, hUo, hUâŸ© }
end
lemma exists_open_superset_measure_lt_top (h : is_compact s)
  (Î¼ : measure Î±) [is_locally_finite_measure Î¼] :
  âˆƒ U âŠ‡ s, is_open U âˆ§ Î¼ U < âˆ :=
h.exists_open_superset_measure_lt_top' $ Î» x hx, Î¼.finite_at_nhds x
lemma measure_lt_top_of_nhds_within (h : is_compact s) (hÎ¼ : âˆ€ x âˆˆ s, Î¼.finite_at_filter (ğ“[s] x)) :
  Î¼ s < âˆ :=
is_compact.induction_on h (by simp) (Î» s t hst ht, (measure_mono hst).trans_lt ht)
  (Î» s t hs ht, (measure_union_le s t).trans_lt (ennreal.add_lt_top.2 âŸ¨hs, htâŸ©)) hÎ¼
lemma measure_zero_of_nhds_within (hs : is_compact s) :
  (âˆ€ a âˆˆ s, âˆƒ t âˆˆ ğ“[s] a, Î¼ t = 0) â†’ Î¼ s = 0 :=
by simpa only [â† compl_mem_ae_iff] using hs.compl_mem_sets_of_nhds_within
end is_compact
def measure_theory.measure.finite_spanning_sets_in_compact [topological_space Î±]
  [sigma_compact_space Î±] {m : measurable_space Î±} (Î¼ : measure Î±) [is_locally_finite_measure Î¼] :
  Î¼.finite_spanning_sets_in {K | is_compact K} :=
{ set := compact_covering Î±,
  set_mem := is_compact_compact_covering Î±,
  finite := Î» n, (is_compact_compact_covering Î± n).measure_lt_top,
  spanning := Union_compact_covering Î± }
def measure_theory.measure.finite_spanning_sets_in_open [topological_space Î±]
  [sigma_compact_space Î±] {m : measurable_space Î±} (Î¼ : measure Î±) [is_locally_finite_measure Î¼] :
  Î¼.finite_spanning_sets_in {K | is_open K} :=
{ set := Î» n, ((is_compact_compact_covering Î± n).exists_open_superset_measure_lt_top Î¼).some,
  set_mem := Î» n,
    ((is_compact_compact_covering Î± n).exists_open_superset_measure_lt_top Î¼).some_spec.snd.1,
  finite := Î» n,
    ((is_compact_compact_covering Î± n).exists_open_superset_measure_lt_top Î¼).some_spec.snd.2,
  spanning := eq_univ_of_subset (Union_mono $ Î» n,
    ((is_compact_compact_covering Î± n).exists_open_superset_measure_lt_top Î¼).some_spec.fst)
    (Union_compact_covering Î±) }
section measure_Ixx
variables [preorder Î±] [topological_space Î±] [compact_Icc_space Î±]
  {m : measurable_space Î±} {Î¼ : measure Î±} [is_locally_finite_measure Î¼] {a b : Î±}
lemma measure_Icc_lt_top : Î¼ (Icc a b) < âˆ := is_compact_Icc.measure_lt_top
lemma measure_Ico_lt_top : Î¼ (Ico a b) < âˆ :=
(measure_mono Ico_subset_Icc_self).trans_lt measure_Icc_lt_top
lemma measure_Ioc_lt_top : Î¼ (Ioc a b) < âˆ :=
(measure_mono Ioc_subset_Icc_self).trans_lt measure_Icc_lt_top
lemma measure_Ioo_lt_top : Î¼ (Ioo a b) < âˆ :=
(measure_mono Ioo_subset_Icc_self).trans_lt measure_Icc_lt_top
end measure_Ixx
section piecewise
variables [measurable_space Î±] {Î¼ : measure Î±} {s t : set Î±} {f g : Î± â†’ Î²}
lemma piecewise_ae_eq_restrict (hs : measurable_set s) : piecewise s f g =áµ[Î¼.restrict s] f :=
begin
  rw [ae_restrict_eq hs],
  exact (piecewise_eq_on s f g).eventually_eq.filter_mono inf_le_right
end
lemma piecewise_ae_eq_restrict_compl (hs : measurable_set s) :
  piecewise s f g =áµ[Î¼.restrict sá¶œ] g :=
begin
  rw [ae_restrict_eq hs.compl],
  exact (piecewise_eq_on_compl s f g).eventually_eq.filter_mono inf_le_right
end
lemma piecewise_ae_eq_of_ae_eq_set (hst : s =áµ[Î¼] t) : s.piecewise f g =áµ[Î¼] t.piecewise f g :=
hst.mem_iff.mono $ Î» x hx, by simp [piecewise, hx]
end piecewise
section indicator_function
variables [measurable_space Î±] {Î¼ : measure Î±} {s t : set Î±} {f : Î± â†’ Î²}
lemma mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem [has_zero Î²] {t : set Î²}
  (ht : (0 : Î²) âˆˆ t) (hs : measurable_set s) :
  t âˆˆ filter.map (s.indicator f) Î¼.ae â†” t âˆˆ filter.map f (Î¼.restrict s).ae :=
begin
  simp_rw [mem_map, mem_ae_iff],
  rw [measure.restrict_apply' hs, set.indicator_preimage, set.ite],
  simp_rw [set.compl_union, set.compl_inter],
  change Î¼ (((f â»Â¹' t)á¶œ âˆª sá¶œ) âˆ© ((Î» x, (0 : Î²)) â»Â¹' t \ s)á¶œ) = 0 â†” Î¼ ((f â»Â¹' t)á¶œ âˆ© s) = 0,
  simp only [ht, â† set.compl_eq_univ_diff, compl_compl, set.compl_union, if_true,
    set.preimage_const],
  simp_rw [set.union_inter_distrib_right, set.compl_inter_self s, set.union_empty],
end
lemma mem_map_indicator_ae_iff_of_zero_nmem [has_zero Î²] {t : set Î²} (ht : (0 : Î²) âˆ‰ t)  :
  t âˆˆ filter.map (s.indicator f) Î¼.ae â†” Î¼ ((f â»Â¹' t)á¶œ âˆª sá¶œ) = 0 :=
begin
  rw [mem_map, mem_ae_iff, set.indicator_preimage, set.ite, set.compl_union, set.compl_inter],
  change Î¼ (((f â»Â¹' t)á¶œ âˆª sá¶œ) âˆ© ((Î» x, (0 : Î²)) â»Â¹' t \ s)á¶œ) = 0 â†” Î¼ ((f â»Â¹' t)á¶œ âˆª sá¶œ) = 0,
  simp only [ht, if_false, set.compl_empty, set.empty_diff, set.inter_univ, set.preimage_const],
end
lemma map_restrict_ae_le_map_indicator_ae [has_zero Î²] (hs : measurable_set s) :
  filter.map f (Î¼.restrict s).ae â‰¤ filter.map (s.indicator f) Î¼.ae :=
begin
  intro t,
  by_cases ht : (0 : Î²) âˆˆ t,
  { rw mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem ht hs, exact id, },
  rw [mem_map_indicator_ae_iff_of_zero_nmem ht, mem_map_restrict_ae_iff hs],
  exact Î» h, measure_mono_null ((set.inter_subset_left _ _).trans (set.subset_union_left _ _)) h,
end
variables [has_zero Î²]
lemma indicator_ae_eq_restrict (hs : measurable_set s) : indicator s f =áµ[Î¼.restrict s] f :=
piecewise_ae_eq_restrict hs
lemma indicator_ae_eq_restrict_compl (hs : measurable_set s) : indicator s f =áµ[Î¼.restrict sá¶œ] 0 :=
piecewise_ae_eq_restrict_compl hs
lemma indicator_ae_eq_of_restrict_compl_ae_eq_zero (hs : measurable_set s)
  (hf : f =áµ[Î¼.restrict sá¶œ] 0) :
  s.indicator f =áµ[Î¼] f :=
begin
  rw [filter.eventually_eq, ae_restrict_iff' hs.compl] at hf,
  filter_upwards [hf] with x hx,
  by_cases hxs : x âˆˆ s,
  { simp only [hxs, set.indicator_of_mem], },
  { simp only [hx hxs, pi.zero_apply, set.indicator_apply_eq_zero, eq_self_iff_true,
      implies_true_iff], },
end
lemma indicator_ae_eq_zero_of_restrict_ae_eq_zero (hs : measurable_set s)
  (hf : f =áµ[Î¼.restrict s] 0) :
  s.indicator f =áµ[Î¼] 0 :=
begin
  rw [filter.eventually_eq, ae_restrict_iff' hs] at hf,
  filter_upwards [hf] with x hx,
  by_cases hxs : x âˆˆ s,
  { simp only [hxs, hx hxs, set.indicator_of_mem], },
  { simp [hx, hxs], },
end
lemma indicator_ae_eq_of_ae_eq_set (hst : s =áµ[Î¼] t) : s.indicator f =áµ[Î¼] t.indicator f :=
piecewise_ae_eq_of_ae_eq_set hst
lemma indicator_meas_zero (hs : Î¼ s = 0) : indicator s f =áµ[Î¼] 0 :=
(indicator_empty' f) â–¸ indicator_ae_eq_of_ae_eq_set (ae_eq_empty.2 hs)
lemma ae_eq_restrict_iff_indicator_ae_eq {g : Î± â†’ Î²} (hs : measurable_set s) :
  f =áµ[Î¼.restrict s] g â†” s.indicator f =áµ[Î¼] s.indicator g :=
begin
  rw [filter.eventually_eq, ae_restrict_iff' hs],
  refine âŸ¨Î» h, _, Î» h, _âŸ©; filter_upwards [h] with x hx,
  { by_cases hxs : x âˆˆ s,
    { simp [hxs, hx hxs], },
    { simp [hxs], }, },
  { intros hxs,
    simpa [hxs] using hx, },
end
end indicator_function
