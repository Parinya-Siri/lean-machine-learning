import category_theory.monad.basic
import category_theory.monoidal.End
import category_theory.monoidal.Mon_
import category_theory.category.Cat
namespace category_theory
open category
@[simps]
def to_Mon : monad C â†’ Mon_ (C â¥¤ C) := Î» M,
{ X := (M : C â¥¤ C),
  one := M.Î·,
  mul := M.Î¼,
@[simps]
def Monad_to_Mon : monad C â¥¤ Mon_ (C â¥¤ C) :=
{ obj := to_Mon,
  map := Î» _ _ f, { hom := f.to_nat_trans },
@[simps]
def of_Mon : Mon_ (C â¥¤ C) â†’ monad C := Î» M,
{ to_functor := M.X,
  Î·' := M.one,
  Î¼' := M.mul,
  left_unit' := Î» X, by { rw [â†M.one.id_hcomp_app, â†nat_trans.comp_app, M.mul_one], refl },
  right_unit' := Î» X, by { rw [â†M.one.hcomp_id_app, â†nat_trans.comp_app, M.one_mul], refl },
  assoc' := Î» X, by { rw [â†nat_trans.hcomp_id_app, â†nat_trans.comp_app], simp } }
variable (C)
@[simps]
def Mon_to_Monad : Mon_ (C â¥¤ C) â¥¤ monad C :=
{ obj := of_Mon,
  map := Î» _ _ f,
  { app_Î·' := begin
      intro X,
      erw [â†nat_trans.comp_app, f.one_hom],
      refl,
    end,
    app_Î¼' := begin
      intro X,
@[simps {rhs_md := semireducible}]
def counit_iso : Mon_to_Monad C â‹™ Monad_to_Mon C â‰… ğŸ­ _ :=
{ hom := { app := Î» _, { hom := ğŸ™ _ } },
  inv := { app := Î» _, { hom := ğŸ™ _ } },
@[simps]
def unit_iso_hom : ğŸ­ _ âŸ¶ Monad_to_Mon C â‹™ Mon_to_Monad C :=
{ app := Î» _, { app := Î» _, ğŸ™ _ } }
@[simps]
def unit_iso_inv : Monad_to_Mon C â‹™ Mon_to_Monad C âŸ¶ ğŸ­ _ :=
{ app := Î» _, { app := Î» _, ğŸ™ _ } }
@[simps]
def unit_iso : ğŸ­ _ â‰… Monad_to_Mon C â‹™ Mon_to_Monad C :=
{ hom := unit_iso_hom,
  inv := unit_iso_inv,
@[simps]
def Monad_Mon_equiv : (monad C) â‰Œ (Mon_ (C â¥¤ C)) :=
{ functor := Monad_to_Mon _,
  inverse := Mon_to_Monad _,
  unit_iso := unit_iso,
  counit_iso := counit_iso,
