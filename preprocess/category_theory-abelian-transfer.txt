import category_theory.preadditive.additive_functor
import category_theory.abelian.basic
import category_theory.limits.preserves.shapes.kernels
import category_theory.adjunction.limits
noncomputable theory
namespace category_theory
open category_theory.limits
universes v uâ‚ uâ‚‚
namespace abelian_of_adjunction
variables {C : Type uâ‚} [category.{v} C] [preadditive C]
variables {D : Type uâ‚‚} [category.{v} D] [abelian D]
variables (F : C â¥¤ D)
variables (G : D â¥¤ C) [functor.preserves_zero_morphisms G]
variables (i : F â‹™ G â‰… ğŸ­ C) (adj : G âŠ£ F)
include i
lemma has_kernels [preserves_finite_limits G] : has_kernels C :=
{ has_limit := Î» X Y f, begin
    have := nat_iso.naturality_1 i f,
    simp at this,
    rw â†this,
    haveI : has_kernel (G.map (F.map f) â‰« i.hom.app _) := limits.has_kernel_comp_mono _ _,
    apply limits.has_kernel_iso_comp,
  end }
include adj
lemma has_cokernels : has_cokernels C :=
{ has_colimit := Î» X Y f, begin
    haveI : preserves_colimits G := adj.left_adjoint_preserves_colimits,
    have := nat_iso.naturality_1 i f,
    simp at this,
    rw â†this,
    haveI : has_cokernel (G.map (F.map f) â‰« i.hom.app _) := limits.has_cokernel_comp_iso _ _,
    apply limits.has_cokernel_epi_comp,
  end }
variables [limits.has_cokernels C]
def cokernel_iso {X Y : C} (f : X âŸ¶ Y) : G.obj (cokernel (F.map f)) â‰… cokernel f :=
begin
def coimage_iso_image_aux {X Y : C} (f : X âŸ¶ Y) :
  kernel (G.map (cokernel.Ï€ (F.map f))) â‰… kernel (cokernel.Ï€ f) :=
begin
  haveI : preserves_colimits G := adj.left_adjoint_preserves_colimits,
  calc kernel (G.map (cokernel.Ï€ (F.map f)))
      â‰… kernel (cokernel.Ï€ (G.map (F.map f)) â‰« cokernel_comparison (F.map f) G)
          : kernel_iso_of_eq (Ï€_comp_cokernel_comparison _ _).symm
  ... â‰… kernel (cokernel.Ï€ (G.map (F.map f))) : kernel_comp_mono _ _
  ... â‰… kernel (cokernel.Ï€ (_ â‰« f â‰« _) â‰« (cokernel_iso_of_eq _).hom)
          : kernel_iso_of_eq (Ï€_comp_cokernel_iso_of_eq_hom (nat_iso.naturality_2 i f)).symm
  ... â‰… kernel (cokernel.Ï€ (_ â‰« f â‰« _))       : kernel_comp_mono _ _
  ... â‰… kernel (cokernel.Ï€ (f â‰« i.inv.app Y) â‰« (cokernel_epi_comp (i.hom.app X) _).inv)
          : kernel_iso_of_eq (by simp only [cokernel.Ï€_desc, cokernel_epi_comp_inv])
  ... â‰… kernel (cokernel.Ï€ (f â‰« _))           : kernel_comp_mono _ _
  ... â‰… kernel (inv (i.inv.app Y) â‰« cokernel.Ï€ f â‰« (cokernel_comp_is_iso f (i.inv.app Y)).inv)
          : kernel_iso_of_eq (by simp only [cokernel.Ï€_desc, cokernel_comp_is_iso_inv,
              iso.hom_inv_id_app_assoc, nat_iso.inv_inv_app])
  ... â‰… kernel (cokernel.Ï€ f â‰« _)             : kernel_is_iso_comp _ _
  ... â‰… kernel (cokernel.Ï€ f)                 : kernel_comp_mono _ _
end
variables [functor.preserves_zero_morphisms F]
def coimage_iso_image {X Y : C} (f : X âŸ¶ Y) : abelian.coimage f â‰… abelian.image f :=
begin
  haveI : preserves_limits F := adj.right_adjoint_preserves_limits,
  haveI : preserves_colimits G := adj.left_adjoint_preserves_colimits,
  calc abelian.coimage f
      â‰… cokernel (kernel.Î¹ f)                 : iso.refl _
  ... â‰… G.obj (cokernel (F.map (kernel.Î¹ f))) : (cokernel_iso _ _ i adj _).symm
  ... â‰… G.obj (cokernel (kernel_comparison f F â‰« (kernel.Î¹ (F.map f))))
                                              : G.map_iso (cokernel_iso_of_eq (by simp))
  ... â‰… G.obj (cokernel (kernel.Î¹ (F.map f))) : G.map_iso (cokernel_epi_comp _ _)
  ... â‰… G.obj (abelian.coimage (F.map f))     : iso.refl _
  ... â‰… G.obj (abelian.image (F.map f))       : G.map_iso (abelian.coimage_iso_image _)
  ... â‰… G.obj (kernel (cokernel.Ï€ (F.map f))) : iso.refl _
  ... â‰… kernel (G.map (cokernel.Ï€ (F.map f))) : preserves_kernel.iso _ _
  ... â‰… kernel (cokernel.Ï€ f)                 : coimage_iso_image_aux F G i adj f
  ... â‰… abelian.image f                       : iso.refl _,
end
local attribute [simp] cokernel_iso coimage_iso_image coimage_iso_image_aux
def abelian_of_adjunction
  {C : Type uâ‚} [category.{v} C] [preadditive C] [has_finite_products C]
  {D : Type uâ‚‚} [category.{v} D] [abelian D]
  (F : C â¥¤ D) [functor.preserves_zero_morphisms F]
  (G : D â¥¤ C) [functor.preserves_zero_morphisms G] [preserves_finite_limits G]
  (i : F â‹™ G â‰… ğŸ­ C) (adj : G âŠ£ F) : abelian C :=
begin
  haveI := has_kernels F G i, haveI := has_cokernels F G i adj,
  haveI : âˆ€ {X Y : C} (f : X âŸ¶ Y), is_iso (abelian.coimage_image_comparison f),
  { intros X Y f, rw â†coimage_iso_image_hom F G i adj f, apply_instance, },
  apply abelian.of_coimage_image_comparison_is_iso,
end
def abelian_of_equivalence
  {C : Type uâ‚} [category.{v} C] [preadditive C] [has_finite_products C]
  {D : Type uâ‚‚} [category.{v} D] [abelian D]
  (F : C â¥¤ D) [functor.preserves_zero_morphisms F] [is_equivalence F] : abelian C :=
abelian_of_adjunction F F.inv F.as_equivalence.unit_iso.symm F.as_equivalence.symm.to_adjunction
end category_theory
