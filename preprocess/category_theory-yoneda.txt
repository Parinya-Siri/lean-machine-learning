import category_theory.functor.hom
import category_theory.functor.currying
import category_theory.products.basic
namespace category_theory
open opposite
@[simps]
def yoneda : C â¥¤ (Cáµ’áµ– â¥¤ Type vâ‚) :=
{ obj := Î» X,
  { obj := Î» Y, unop Y âŸ¶ X,
    map := Î» Y Y' f g, f.unop â‰« g,
    map_comp' := Î» _ _ _ f g, begin ext, dsimp, erw [category.assoc] end,
    map_id' := Î» Y, begin ext, dsimp, erw [category.id_comp] end },
  map := Î» X X' f, { app := Î» Y g, g â‰« f } }
@[simps] def coyoneda : Cáµ’áµ– â¥¤ (C â¥¤ Type vâ‚) :=
{ obj := Î» X,
  { obj := Î» Y, unop X âŸ¶ Y,
    map := Î» Y Y' f g, g â‰« f },
  map := Î» X X' f, { app := Î» Y g, f.unop â‰« g } }
namespace yoneda
lemma obj_map_id {X Y : C} (f : op X âŸ¶ op Y) :
  (yoneda.obj X).map f (ğŸ™ X) = (yoneda.map f.unop).app (op Y) (ğŸ™ Y) :=
by { dsimp, simp }
@[simp] lemma naturality {X Y : C} (Î± : yoneda.obj X âŸ¶ yoneda.obj Y)
  {Z Z' : C} (f : Z âŸ¶ Z') (h : Z' âŸ¶ X) : f â‰« Î±.app (op Z') h = Î±.app (op Z) (f â‰« h) :=
(functor_to_types.naturality _ _ Î± f.op h).symm
instance yoneda_full : full (yoneda : C â¥¤ Cáµ’áµ– â¥¤ Type vâ‚) :=
{ preimage := Î» X Y f, f.app (op X) (ğŸ™ X) }
instance yoneda_faithful : faithful (yoneda : C â¥¤ Cáµ’áµ– â¥¤ Type vâ‚) :=
{ map_injective' := Î» X Y f g p, by convert (congr_fun (congr_app p (op X)) (ğŸ™ X)); dsimp; simp }
def ext (X Y : C)
  (p : Î  {Z : C}, (Z âŸ¶ X) â†’ (Z âŸ¶ Y)) (q : Î  {Z : C}, (Z âŸ¶ Y) â†’ (Z âŸ¶ X))
  (hâ‚ : Î  {Z : C} (f : Z âŸ¶ X), q (p f) = f) (hâ‚‚ : Î  {Z : C} (f : Z âŸ¶ Y), p (q f) = f)
  (n : Î  {Z Z' : C} (f : Z' âŸ¶ Z) (g : Z âŸ¶ X), p (f â‰« g) = f â‰« p g) : X â‰… Y :=
yoneda.preimage_iso (nat_iso.of_components (Î» Z, { hom := p, inv := q, }) (by tidy))
lemma is_iso {X Y : C} (f : X âŸ¶ Y) [is_iso (yoneda.map f)] : is_iso f :=
is_iso_of_fully_faithful yoneda f
end yoneda
namespace coyoneda
@[simp] lemma naturality {X Y : Cáµ’áµ–} (Î± : coyoneda.obj X âŸ¶ coyoneda.obj Y)
  {Z Z' : C} (f : Z' âŸ¶ Z) (h : unop X âŸ¶ Z') : (Î±.app Z' h) â‰« f = Î±.app Z (h â‰« f) :=
(functor_to_types.naturality _ _ Î± f h).symm
instance coyoneda_full : full (coyoneda : Cáµ’áµ– â¥¤ C â¥¤ Type vâ‚) :=
{ preimage := Î» X Y f, (f.app _ (ğŸ™ X.unop)).op }
instance coyoneda_faithful : faithful (coyoneda : Cáµ’áµ– â¥¤ C â¥¤ Type vâ‚) :=
{ map_injective' := Î» X Y f g p,
  begin
    have t := congr_fun (congr_app p X.unop) (ğŸ™ _),
    simpa using congr_arg quiver.hom.op t,
  end }
lemma is_iso {X Y : Cáµ’áµ–} (f : X âŸ¶ Y) [is_iso (coyoneda.map f)] : is_iso f :=
is_iso_of_fully_faithful coyoneda f
def punit_iso : coyoneda.obj (opposite.op punit) â‰… ğŸ­ (Type vâ‚) :=
nat_iso.of_components
  (Î» X, { hom := Î» f, f âŸ¨âŸ©, inv := Î» x _, x })
  (by tidy)
end coyoneda
namespace functor
class representable (F : Cáµ’áµ– â¥¤ Type vâ‚) : Prop :=
(has_representation : âˆƒ X (f : yoneda.obj X âŸ¶ F), is_iso f)
instance {X : C} : representable (yoneda.obj X) :=
{ has_representation := âŸ¨X, ğŸ™ _, infer_instanceâŸ© }
class corepresentable (F : C â¥¤ Type vâ‚) : Prop :=
(has_corepresentation : âˆƒ X (f : coyoneda.obj X âŸ¶ F), is_iso f)
instance {X : Cáµ’áµ–} : corepresentable (coyoneda.obj X) :=
{ has_corepresentation := âŸ¨X, ğŸ™ _, infer_instanceâŸ© }
noncomputable def repr_X : C :=
(representable.has_representation : âˆƒ X (f : _ âŸ¶ F), _).some
noncomputable def repr_f : yoneda.obj F.repr_X âŸ¶ F :=
representable.has_representation.some_spec.some
noncomputable def repr_x : F.obj (op F.repr_X) :=
F.repr_f.app (op F.repr_X) (ğŸ™ F.repr_X)
instance : is_iso F.repr_f :=
representable.has_representation.some_spec.some_spec
noncomputable def repr_w : yoneda.obj F.repr_X â‰… F := as_iso F.repr_f
@[simp] lemma repr_w_hom : F.repr_w.hom = F.repr_f := rfl
lemma repr_w_app_hom (X : Cáµ’áµ–) (f : unop X âŸ¶ F.repr_X) :
  (F.repr_w.app X).hom f = F.map f.op F.repr_x :=
begin
  change F.repr_f.app X f = (F.repr_f.app (op F.repr_X) â‰« F.map f.op) (ğŸ™ F.repr_X),
  rw â†F.repr_f.naturality,
  dsimp,
  simp
end
end representable
section corepresentable
variables (F : C â¥¤ Type vâ‚)
variable [F.corepresentable]
noncomputable def corepr_X : C :=
(corepresentable.has_corepresentation : âˆƒ X (f : _ âŸ¶ F), _).some.unop
noncomputable def corepr_f : coyoneda.obj (op F.corepr_X) âŸ¶ F :=
corepresentable.has_corepresentation.some_spec.some
noncomputable def corepr_x : F.obj F.corepr_X :=
F.corepr_f.app F.corepr_X (ğŸ™ F.corepr_X)
instance : is_iso F.corepr_f :=
corepresentable.has_corepresentation.some_spec.some_spec
noncomputable def corepr_w : coyoneda.obj (op F.corepr_X) â‰… F := as_iso F.corepr_f
lemma corepr_w_app_hom (X : C) (f : F.corepr_X âŸ¶ X) :
  (F.corepr_w.app X).hom f = F.map f F.corepr_x :=
begin
  change F.corepr_f.app X f = (F.corepr_f.app F.corepr_X â‰« F.map f) (ğŸ™ F.corepr_X),
  rw â†F.corepr_f.naturality,
  dsimp,
  simp
end
end corepresentable
end functor
lemma representable_of_nat_iso (F : Cáµ’áµ– â¥¤ Type vâ‚) {G} (i : F â‰… G) [F.representable] :
  G.representable :=
{ has_representation := âŸ¨F.repr_X, F.repr_f â‰« i.hom, infer_instanceâŸ© }
lemma corepresentable_of_nat_iso (F : C â¥¤ Type vâ‚) {G} (i : F â‰… G) [F.corepresentable] :
  G.corepresentable :=
{ has_corepresentation := âŸ¨op F.corepr_X, F.corepr_f â‰« i.hom, infer_instanceâŸ© }
instance : functor.corepresentable (ğŸ­ (Type vâ‚)) :=
corepresentable_of_nat_iso (coyoneda.obj (op punit)) coyoneda.punit_iso
open opposite
variables (C)
def yoneda_evaluation : Cáµ’áµ– Ã— (Cáµ’áµ– â¥¤ Type vâ‚) â¥¤ Type (max uâ‚ vâ‚) :=
evaluation_uncurried Cáµ’áµ– (Type vâ‚) â‹™ ulift_functor.{uâ‚}
@[simp] lemma yoneda_evaluation_map_down
  (P Q : Cáµ’áµ– Ã— (Cáµ’áµ– â¥¤ Type vâ‚)) (Î± : P âŸ¶ Q) (x : (yoneda_evaluation C).obj P) :
  ((yoneda_evaluation C).map Î± x).down = Î±.2.app Q.1 (P.2.map Î±.1 x.down) := rfl
def yoneda_pairing : Cáµ’áµ– Ã— (Cáµ’áµ– â¥¤ Type vâ‚) â¥¤ Type (max uâ‚ vâ‚) :=
functor.prod yoneda.op (ğŸ­ (Cáµ’áµ– â¥¤ Type vâ‚)) â‹™ functor.hom (Cáµ’áµ– â¥¤ Type vâ‚)
@[simp] lemma yoneda_pairing_map
  (P Q : Cáµ’áµ– Ã— (Cáµ’áµ– â¥¤ Type vâ‚)) (Î± : P âŸ¶ Q) (Î² : (yoneda_pairing C).obj P) :
  (yoneda_pairing C).map Î± Î² = yoneda.map Î±.1.unop â‰« Î² â‰« Î±.2 := rfl
def yoneda_lemma : yoneda_pairing C â‰… yoneda_evaluation C :=
{ hom :=
  { app := Î» F x, ulift.up ((x.app F.1) (ğŸ™ (unop F.1))),
    naturality' :=
    begin
      intros X Y f, ext, dsimp,
      erw [category.id_comp, â†functor_to_types.naturality],
      simp only [category.comp_id, yoneda_obj_map],
    end },
  inv :=
  { app := Î» F x,
    { app := Î» X a, (F.2.map a.op) x.down,
      naturality' :=
      begin
        intros X Y f, ext, dsimp,
        rw [functor_to_types.map_comp_apply]
      end },
    naturality' :=
    begin
      intros X Y f, ext, dsimp,
      rw [â†functor_to_types.naturality, functor_to_types.map_comp_apply]
    end },
  hom_inv_id' :=
  begin
    ext, dsimp,
    erw [â†functor_to_types.naturality,
         obj_map_id],
    simp only [yoneda_map_app, quiver.hom.unop_op],
    erw [category.id_comp],
  end,
  inv_hom_id' :=
  begin
    ext, dsimp,
    rw [functor_to_types.map_id_apply]
  end }.
variables {C}
@[simps] def yoneda_sections (X : C) (F : Cáµ’áµ– â¥¤ Type vâ‚) :
  (yoneda.obj X âŸ¶ F) â‰… ulift.{uâ‚} (F.obj (op X)) :=
(yoneda_lemma C).app (op X, F)
def yoneda_equiv {X : C} {F : Cáµ’áµ– â¥¤ Type vâ‚} : (yoneda.obj X âŸ¶ F) â‰ƒ F.obj (op X) :=
(yoneda_sections X F).to_equiv.trans equiv.ulift
@[simp]
lemma yoneda_equiv_apply {X : C} {F : Cáµ’áµ– â¥¤ Type vâ‚} (f : yoneda.obj X âŸ¶ F) :
  yoneda_equiv f = f.app (op X) (ğŸ™ X) :=
rfl
@[simp]
lemma yoneda_equiv_symm_app_apply {X : C} {F : Cáµ’áµ– â¥¤ Type vâ‚} (x : F.obj (op X))
  (Y : Cáµ’áµ–) (f : Y.unop âŸ¶ X) :
  (yoneda_equiv.symm x).app Y f = F.map f.op x :=
rfl
lemma yoneda_equiv_naturality {X Y : C} {F : Cáµ’áµ– â¥¤ Type vâ‚} (f : yoneda.obj X âŸ¶ F) (g : Y âŸ¶ X) :
  F.map g.op (yoneda_equiv f) = yoneda_equiv (yoneda.map g â‰« f) :=
begin
  change (f.app (op X) â‰« F.map g.op) (ğŸ™ X) = f.app (op Y) (ğŸ™ Y â‰« g),
  rw â†f.naturality,
  dsimp,
  simp,
end
def yoneda_sections_small {C : Type uâ‚} [small_category C] (X : C)
  (F : Cáµ’áµ– â¥¤ Type uâ‚) :
  (yoneda.obj X âŸ¶ F) â‰… F.obj (op X) :=
yoneda_sections X F â‰ªâ‰« ulift_trivial _
@[simp]
lemma yoneda_sections_small_hom {C : Type uâ‚} [small_category C] (X : C)
  (F : Cáµ’áµ– â¥¤ Type uâ‚) (f : yoneda.obj X âŸ¶ F) :
  (yoneda_sections_small X F).hom f = f.app _ (ğŸ™ _) :=
rfl
@[simp]
lemma yoneda_sections_small_inv_app_apply {C : Type uâ‚} [small_category C] (X : C)
  (F : Cáµ’áµ– â¥¤ Type uâ‚) (t : F.obj (op X)) (Y : Cáµ’áµ–) (f : Y.unop âŸ¶ X) :
  ((yoneda_sections_small X F).inv t).app Y f = F.map f.op t :=
rfl
local attribute [ext] functor.ext
def curried_yoneda_lemma {C : Type uâ‚} [small_category C] :
  (yoneda.op â‹™ coyoneda : Cáµ’áµ– â¥¤ (Cáµ’áµ– â¥¤ Type uâ‚) â¥¤ Type uâ‚) â‰… evaluation Cáµ’áµ– (Type uâ‚) :=
eq_to_iso (by tidy) â‰ªâ‰« curry.map_iso (yoneda_lemma C â‰ªâ‰«
  iso_whisker_left (evaluation_uncurried Cáµ’áµ– (Type uâ‚)) ulift_functor_trivial) â‰ªâ‰«
    eq_to_iso (by tidy)
def curried_yoneda_lemma' {C : Type uâ‚} [small_category C] :
  yoneda â‹™ (whiskering_left Cáµ’áµ– (Cáµ’áµ– â¥¤ Type uâ‚)áµ’áµ– (Type uâ‚)).obj yoneda.op â‰… ğŸ­ (Cáµ’áµ– â¥¤ Type uâ‚) :=
eq_to_iso (by tidy) â‰ªâ‰« curry.map_iso (iso_whisker_left (prod.swap _ _)
  (yoneda_lemma C â‰ªâ‰« iso_whisker_left
    (evaluation_uncurried Cáµ’áµ– (Type uâ‚)) ulift_functor_trivial : _)) â‰ªâ‰« eq_to_iso (by tidy)
end category_theory
