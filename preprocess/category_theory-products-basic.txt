import category_theory.eq_to_hom
namespace category_theory
@[simp] lemma prod_id (X : C) (Y : D) : ùüô (X, Y) = (ùüô X, ùüô Y) := rfl
@[simp] lemma prod_comp {P Q R : C} {S T U : D} (f : (P, S) ‚ü∂ (Q, T)) (g : (Q, T) ‚ü∂ (R, U)) :
  f ‚â´ g = (f.1 ‚â´ g.1, f.2 ‚â´ g.2) := rfl
lemma is_iso_prod_iff {P Q : C} {S T : D} {f : (P, S) ‚ü∂ (Q, T)} :
  is_iso f ‚Üî is_iso f.1 ‚àß is_iso f.2 :=
begin
  split,
  { rintros ‚ü®g, hfg, hgf‚ü©,
    simp at hfg hgf,
    rcases hfg with ‚ü®hfg‚ÇÅ, hfg‚ÇÇ‚ü©,
    rcases hgf with ‚ü®hgf‚ÇÅ, hgf‚ÇÇ‚ü©,
    exact ‚ü®‚ü®‚ü®g.1, hfg‚ÇÅ, hgf‚ÇÅ‚ü©‚ü©, ‚ü®‚ü®g.2, hfg‚ÇÇ, hgf‚ÇÇ‚ü©‚ü©‚ü© },
  { rintros ‚ü®‚ü®g‚ÇÅ, hfg‚ÇÅ, hgf‚ÇÅ‚ü©, ‚ü®g‚ÇÇ, hfg‚ÇÇ, hgf‚ÇÇ‚ü©‚ü©,
    dsimp at hfg‚ÇÅ hgf‚ÇÅ hfg‚ÇÇ hgf‚ÇÇ,
    refine ‚ü®‚ü®(g‚ÇÅ, g‚ÇÇ), _, _‚ü©‚ü©; { simp; split; assumption } }
end
section
variables {C D}
@[simps]
def iso.prod {P Q : C} {S T : D} (f : P ‚âÖ Q) (g : S ‚âÖ T) : (P, S) ‚âÖ (Q, T) :=
{ hom := (f.hom, g.hom),
  inv := (f.inv, g.inv), }
end
end
section
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÅ) [category.{v‚ÇÅ} D]
instance uniform_prod : category (C √ó D) := category_theory.prod C D
end
@[simps] def sectl
  (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] (Z : D) : C ‚•§ C √ó D :=
{ obj := Œª X, (X, Z),
  map := Œª X Y f, (f, ùüô Z) }
@[simps] def sectr
  {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] (Z : C) (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D] : D ‚•§ C √ó D :=
{ obj := Œª X, (Z, X),
  map := Œª X Y f, (ùüô Z, f) }
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D]
@[simps] def fst : C √ó D ‚•§ C :=
{ obj := Œª X, X.1,
  map := Œª X Y f, f.1 }
@[simps] def snd : C √ó D ‚•§ D :=
{ obj := Œª X, X.2,
  map := Œª X Y f, f.2 }
@[simps] def swap : C √ó D ‚•§ D √ó C :=
{ obj := Œª X, (X.2, X.1),
  map := Œª _ _ f, (f.2, f.1) }
@[simps] def symmetry : swap C D ‚ãô swap D C ‚âÖ ùü≠ (C √ó D) :=
{ hom := { app := Œª X, ùüô X },
  inv := { app := Œª X, ùüô X } }
@[simps]
def braiding : C √ó D ‚âå D √ó C :=
equivalence.mk (swap C D) (swap D C)
  (nat_iso.of_components (Œª X, eq_to_iso (by simp)) (by tidy))
  (nat_iso.of_components (Œª X, eq_to_iso (by simp)) (by tidy))
instance swap_is_equivalence : is_equivalence (swap C D) :=
(by apply_instance : is_equivalence (braiding C D).functor)
end prod
section
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D]
@[simps] def evaluation : C ‚•§ (C ‚•§ D) ‚•§ D :=
{ obj := Œª X,
  { obj := Œª F, F.obj X,
    map := Œª F G Œ±, Œ±.app X, },
  map := Œª X Y f,
  { app := Œª F, F.map f,
    naturality' := Œª F G Œ±, eq.symm (Œ±.naturality f) } }
@[simps] def evaluation_uncurried : C √ó (C ‚•§ D) ‚•§ D :=
{ obj := Œª p, p.2.obj p.1,
  map := Œª x y f, (x.2.map f.1) ‚â´ (f.2.app y.1),
  map_comp' := Œª X Y Z f g,
  begin
    cases g, cases f, cases Z, cases Y, cases X,
    simp only [prod_comp, nat_trans.comp_app, functor.map_comp, category.assoc],
    rw [‚Üênat_trans.comp_app, nat_trans.naturality, nat_trans.comp_app,
        category.assoc, nat_trans.naturality],
  end }
end
variables {A : Type u‚ÇÅ} [category.{v‚ÇÅ} A]
          {B : Type u‚ÇÇ} [category.{v‚ÇÇ} B]
          {C : Type u‚ÇÉ} [category.{v‚ÇÉ} C]
          {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D]
namespace functor
@[simps] def prod (F : A ‚•§ B) (G : C ‚•§ D) : A √ó C ‚•§ B √ó D :=
{ obj := Œª X, (F.obj X.1, G.obj X.2),
  map := Œª _ _ f, (F.map f.1, G.map f.2) }
@[simps] def prod' (F : A ‚•§ B) (G : A ‚•§ C) : A ‚•§ (B √ó C) :=
{ obj := Œª a, (F.obj a, G.obj a),
  map := Œª x y f, (F.map f, G.map f), }
section
variable (C)
def diag : C ‚•§ C √ó C := (ùü≠ C).prod' (ùü≠ C)
@[simp] lemma diag_obj (X : C) : (diag C).obj X = (X, X) := rfl
@[simp] lemma diag_map {X Y : C} (f : X ‚ü∂ Y) : (diag C).map f = (f, f) := rfl
end
end functor
namespace nat_trans
@[simps] def prod {F G : A ‚•§ B} {H I : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : H ‚ü∂ I) :
  F.prod H ‚ü∂ G.prod I :=
{ app         := Œª X, (Œ±.app X.1, Œ≤.app X.2),
  naturality' := Œª X Y f,
  begin
    cases X, cases Y,
    simp only [functor.prod_map, prod.mk.inj_iff, prod_comp],
    split; rw naturality
  end }
end nat_trans
@[simps]
def flip_comp_evaluation (F : A ‚•§ B ‚•§ C) (a) :
  F.flip ‚ãô (evaluation _ _).obj a ‚âÖ F.obj a :=
nat_iso.of_components (Œª b, eq_to_iso rfl) $ by tidy
end category_theory
