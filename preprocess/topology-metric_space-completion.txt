import topology.uniform_space.completion
import topology.metric_space.isometry
import topology.instances.real
open set filter uniform_space metric
open_locale filter topological_space uniformity
noncomputable theory
universes u v
variables {Î± : Type u} {Î² : Type v} [pseudo_metric_space Î±]
namespace uniform_space.completion
instance : has_dist (completion Î±) :=
âŸ¨completion.extensionâ‚‚ distâŸ©
protected lemma uniform_continuous_dist :
  uniform_continuous (Î»p:completion Î± Ã— completion Î±, dist p.1 p.2) :=
uniform_continuous_extensionâ‚‚ dist
protected lemma continuous_dist [topological_space Î²] {f g : Î² â†’ completion Î±} (hf : continuous f)
  (hg : continuous g) :
  continuous (Î» x, dist (f x) (g x)) :=
completion.uniform_continuous_dist.continuous.comp (hf.prod_mk hg : _)
@[simp] protected lemma dist_eq (x y : Î±) : dist (x : completion Î±) y = dist x y :=
completion.extensionâ‚‚_coe_coe uniform_continuous_dist _ _
protected lemma dist_self (x : completion Î±) : dist x x = 0 :=
begin
  apply induction_on x,
  { refine is_closed_eq _ continuous_const,
    exact completion.continuous_dist continuous_id continuous_id },
  { assume a,
    rw [completion.dist_eq, dist_self] }
end
protected lemma dist_comm (x y : completion Î±) : dist x y = dist y x :=
begin
  apply induction_onâ‚‚ x y,
  { exact is_closed_eq (completion.continuous_dist continuous_fst continuous_snd)
      (completion.continuous_dist continuous_snd continuous_fst) },
  { assume a b,
    rw [completion.dist_eq, completion.dist_eq, dist_comm] }
end
protected lemma dist_triangle (x y z : completion Î±) : dist x z â‰¤ dist x y + dist y z :=
begin
  apply induction_onâ‚ƒ x y z,
  { refine is_closed_le _ (continuous.add _ _);
      apply_rules [completion.continuous_dist, continuous.fst, continuous.snd, continuous_id] },
  { assume a b c,
    rw [completion.dist_eq, completion.dist_eq, completion.dist_eq],
    exact dist_triangle a b c }
end
protected lemma mem_uniformity_dist (s : set (completion Î± Ã— completion Î±)) :
  s âˆˆ ğ“¤ (completion Î±) â†” (âˆƒÎµ>0, âˆ€{a b}, dist a b < Îµ â†’ (a, b) âˆˆ s) :=
begin
  split,
    assume hs,
    rcases mem_uniformity_is_closed hs with âŸ¨t, ht, âŸ¨tclosed, tsâŸ©âŸ©,
    have A : {x : Î± Ã— Î± | (coe (x.1), coe (x.2)) âˆˆ t} âˆˆ uniformity Î± :=
      uniform_continuous_def.1 (uniform_continuous_coe Î±) t ht,
    rcases mem_uniformity_dist.1 A with âŸ¨Îµ, Îµpos, hÎµâŸ©,
    refine âŸ¨Îµ, Îµpos, Î»x y hxy, _âŸ©,
    have : Îµ â‰¤ dist x y âˆ¨ (x, y) âˆˆ t,
    { apply induction_onâ‚‚ x y,
      { have : {x : completion Î± Ã— completion Î± | Îµ â‰¤ dist (x.fst) (x.snd) âˆ¨ (x.fst, x.snd) âˆˆ t}
               = {p : completion Î± Ã— completion Î± | Îµ â‰¤ dist p.1 p.2} âˆª t, by ext; simp,
        rw this,
        apply is_closed.union _ tclosed,
        exact is_closed_le continuous_const completion.uniform_continuous_dist.continuous },
      { assume x y,
        rw completion.dist_eq,
        by_cases h : Îµ â‰¤ dist x y,
        { exact or.inl h },
        { have Z := hÎµ (not_le.1 h),
          simp only [set.mem_set_of_eq] at Z,
          exact or.inr Z }}},
    simp only [not_le.mpr hxy, false_or, not_le] at this,
    exact ts this },
    rintros âŸ¨Îµ, Îµpos, hÎµâŸ©,
    let r : set (â„ Ã— â„) := {p | dist p.1 p.2 < Îµ},
    have : r âˆˆ uniformity â„ := metric.dist_mem_uniformity Îµpos,
    have T := uniform_continuous_def.1 (@completion.uniform_continuous_dist Î± _) r this,
    simp only [uniformity_prod_eq_prod, mem_prod_iff, exists_prop,
               filter.mem_map, set.mem_set_of_eq] at T,
    rcases T with âŸ¨t1, ht1, t2, ht2, htâŸ©,
    refine mem_of_superset ht1 _,
    have A : âˆ€a b : completion Î±, (a, b) âˆˆ t1 â†’ dist a b < Îµ,
    { assume a b hab,
      have : ((a, b), (a, a)) âˆˆ t1 Ã—Ë¢ t2 := âŸ¨hab, refl_mem_uniformity ht2âŸ©,
      have I := ht this,
      simp [completion.dist_self, real.dist_eq, completion.dist_comm] at I,
      exact lt_of_le_of_lt (le_abs_self _) I },
    show t1 âŠ† s,
    { rintros âŸ¨a, bâŸ© hp,
      have : dist a b < Îµ := A a b hp,
      exact hÎµ this }}
end
protected lemma eq_of_dist_eq_zero (x y : completion Î±) (h : dist x y = 0) : x = y :=
begin
  have : separated_space (completion Î±) := by apply_instance,
  refine separated_def.1 this x y (Î»s hs, _),
  rcases (completion.mem_uniformity_dist s).1 hs with âŸ¨Îµ, Îµpos, hÎµâŸ©,
  rw â† h at Îµpos,
  exact hÎµ Îµpos
end
protected lemma uniformity_dist' :
  ğ“¤ (completion Î±) = (â¨…Îµ:{Îµ : â„ // 0 < Îµ}, ğ“Ÿ {p | dist p.1 p.2 < Îµ.val}) :=
begin
  ext s, rw mem_infi_of_directed,
  { simp [completion.mem_uniformity_dist, subset_def] },
  { rintro âŸ¨r, hrâŸ© âŸ¨p, hpâŸ©, use âŸ¨min r p, lt_min hr hpâŸ©,
    simp [lt_min_iff, (â‰¥)] {contextual := tt} }
end
protected lemma uniformity_dist :
  ğ“¤ (completion Î±) = (â¨… Îµ>0, ğ“Ÿ {p | dist p.1 p.2 < Îµ}) :=
by simpa [infi_subtype] using @completion.uniformity_dist' Î± _
instance : metric_space (completion Î±) :=
{ dist_self          := completion.dist_self,
  eq_of_dist_eq_zero := completion.eq_of_dist_eq_zero,
  dist_comm          := completion.dist_comm,
  dist_triangle      := completion.dist_triangle,
  dist               := dist,
  to_uniform_space   := by apply_instance,
  uniformity_dist    := completion.uniformity_dist }
lemma coe_isometry : isometry (coe : Î± â†’ completion Î±) :=
isometry_emetric_iff_metric.2 completion.dist_eq
@[simp] protected lemma edist_eq (x y : Î±) : edist (x : completion Î±) y = edist x y :=
coe_isometry x y
end uniform_space.completion
