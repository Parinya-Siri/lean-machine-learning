import algebra.ring.ulift
import ring_theory.witt_vector.basic
import data.mv_polynomial.funext
mk_simp_attribute ghost_simps
"Simplification rules for ghost equations"
namespace tactic
namespace interactive
setup_tactic_parser
meta def ghost_simp (lems : parse simp_arg_list) : tactic unit :=
do tactic.try tactic.intro1,
   simp none none tt
     (lems ++ [simp_arg_type.symm_expr ``(sub_eq_add_neg)])
     [`ghost_simps] (loc.ns [none])
meta def ghost_calc (ids' : parse ident_*) : tactic unit :=
do ids ‚Üê ids'.mmap $ Œª n, get_local n <|> tactic.intro n,
   `(@eq (witt_vector _ %%R) _ _) ‚Üê target,
   match ids with
   | [x] := refine ```(is_poly.ext _ _ _ _ %%x)
   | [x, y] := refine ```(is_poly‚ÇÇ.ext _ _ _ _ %%x %%y)
   | _ := fail "ghost_calc takes one or two arguments"
   end,
   nm ‚Üê match R with
   | expr.local_const _ nm _ _ := return nm
   | _ := get_unused_name `R
   end,
   iterate_exactly 2 apply_instance,
   unfreezingI (tactic.clear' tt [R]),
   introsI $ [nm, nm<.>"_inst"] ++ ids',
   skip
end interactive
end tactic
namespace witt_vector
universe u
variables {p : ‚Ñï} {R S : Type u} {œÉ idx : Type*} [hp : fact p.prime] [comm_ring R] [comm_ring S]
lemma poly_eq_of_witt_polynomial_bind_eq' (f g : ‚Ñï ‚Üí mv_polynomial (idx √ó ‚Ñï) ‚Ñ§)
  (h : ‚àÄ n, bind‚ÇÅ f (witt_polynomial p _ n) = bind‚ÇÅ g (witt_polynomial p _ n)) :
  f = g :=
begin
  ext1 n,
  apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective,
  rw ‚Üê function.funext_iff at h,
  replace h := congr_arg
    (Œª fam, bind‚ÇÅ (mv_polynomial.map (int.cast_ring_hom ‚Ñö) ‚àò fam)
    (X_in_terms_of_W p ‚Ñö n)) h,
  simpa only [function.comp, map_bind‚ÇÅ, map_witt_polynomial,
    ‚Üê bind‚ÇÅ_bind‚ÇÅ, bind‚ÇÅ_witt_polynomial_X_in_terms_of_W, bind‚ÇÅ_X_right] using h
end
lemma poly_eq_of_witt_polynomial_bind_eq (f g : ‚Ñï ‚Üí mv_polynomial ‚Ñï ‚Ñ§)
  (h : ‚àÄ n, bind‚ÇÅ f (witt_polynomial p _ n) = bind‚ÇÅ g (witt_polynomial p _ n)) :
  f = g :=
begin
  ext1 n,
  apply mv_polynomial.map_injective (int.cast_ring_hom ‚Ñö) int.cast_injective,
  rw ‚Üê function.funext_iff at h,
  replace h := congr_arg
    (Œª fam, bind‚ÇÅ (mv_polynomial.map (int.cast_ring_hom ‚Ñö) ‚àò fam)
    (X_in_terms_of_W p ‚Ñö n)) h,
  simpa only [function.comp, map_bind‚ÇÅ, map_witt_polynomial,
    ‚Üê bind‚ÇÅ_bind‚ÇÅ, bind‚ÇÅ_witt_polynomial_X_in_terms_of_W, bind‚ÇÅ_X_right] using h
end
omit hp
class is_poly (f : Œ† ‚¶ÉR‚¶Ñ [comm_ring R], witt_vector p R ‚Üí ùïé R) : Prop :=
mk' :: (poly : ‚àÉ œÜ : ‚Ñï ‚Üí mv_polynomial ‚Ñï ‚Ñ§, ‚àÄ ‚¶ÉR‚¶Ñ [comm_ring R] (x : ùïé R),
  by exactI (f x).coeff = Œª n, aeval x.coeff (œÜ n))
instance id_is_poly : is_poly p (Œª _ _, id) :=
‚ü®‚ü®X, by { introsI, simp only [aeval_X, id] }‚ü©‚ü©
instance id_is_poly_i' : is_poly p (Œª _ _ a, a) :=
witt_vector.id_is_poly _
namespace is_poly
instance : inhabited (is_poly p (Œª _ _, id)) :=
‚ü®witt_vector.id_is_poly p‚ü©
variables {p}
include hp
lemma ext {f g} (hf : is_poly p f) (hg : is_poly p g)
  (h : ‚àÄ (R : Type u) [_Rcr : comm_ring R] (x : ùïé R) (n : ‚Ñï),
    by exactI ghost_component n (f x) = ghost_component n (g x)) :
  ‚àÄ (R : Type u) [_Rcr : comm_ring R] (x : ùïé R), by exactI f x = g x :=
begin
  unfreezingI
  { obtain ‚ü®œÜ, hf‚ü© := hf,
    obtain ‚ü®œà, hg‚ü© := hg },
  intros,
  ext n,
  rw [hf, hg, poly_eq_of_witt_polynomial_bind_eq p œÜ œà],
  intro k,
  apply mv_polynomial.funext,
  intro x,
  simp only [hom_bind‚ÇÅ],
  specialize h (ulift ‚Ñ§) (mk p $ Œª i, ‚ü®x i‚ü©) k,
  simp only [ghost_component_apply, aeval_eq_eval‚ÇÇ_hom] at h,
  apply (ulift.ring_equiv.symm : ‚Ñ§ ‚âÉ+* _).injective,
  simp only [‚Üêring_equiv.coe_to_ring_hom, map_eval‚ÇÇ_hom],
  convert h using 1,
  all_goals
  { funext i,
    simp only [hf, hg, mv_polynomial.eval, map_eval‚ÇÇ_hom],
    apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) _ rfl,
    ext1,
    apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) _ rfl,
    simp only [coeff_mk], refl }
end
omit hp
lemma comp {g f} (hg : is_poly p g) (hf : is_poly p f) :
  is_poly p (Œª R _Rcr, @g R _Rcr ‚àò @f R _Rcr) :=
begin
  unfreezingI
  { obtain ‚ü®œÜ, hf‚ü© := hf,
    obtain ‚ü®œà, hg‚ü© := hg },
  use (Œª n, bind‚ÇÅ œÜ (œà n)),
  intros,
  simp only [aeval_bind‚ÇÅ, function.comp, hg, hf]
end
end is_poly
class is_poly‚ÇÇ (f : Œ† ‚¶ÉR‚¶Ñ [comm_ring R], witt_vector p R ‚Üí ùïé R ‚Üí ùïé R) : Prop :=
mk' :: (poly : ‚àÉ œÜ : ‚Ñï ‚Üí mv_polynomial (fin 2 √ó ‚Ñï) ‚Ñ§, ‚àÄ ‚¶ÉR‚¶Ñ [comm_ring R] (x y : ùïé R),
  by exactI (f x y).coeff = Œª n, peval (œÜ n) ![x.coeff, y.coeff])
variable {p}
lemma is_poly‚ÇÇ.comp {h f g} (hh : is_poly‚ÇÇ p h) (hf : is_poly p f) (hg : is_poly p g) :
  is_poly‚ÇÇ p (Œª R _Rcr x y, by exactI h (f x) (g y)) :=
begin
  unfreezingI
  { obtain ‚ü®œÜ, hf‚ü© := hf,
    obtain ‚ü®œà, hg‚ü© := hg,
    obtain ‚ü®œá, hh‚ü© := hh },
  refine ‚ü®‚ü®(Œª n, bind‚ÇÅ (uncurry $
          ![Œª k, rename (prod.mk (0 : fin 2)) (œÜ k),
            Œª k, rename (prod.mk (1 : fin 2)) (œà k)]) (œá n)), _‚ü©‚ü©,
  intros,
  funext n,
  simp only [peval, aeval_bind‚ÇÅ, function.comp, hh, hf, hg, uncurry],
  apply eval‚ÇÇ_hom_congr rfl _ rfl,
  ext ‚ü®i, n‚ü©,
  fin_cases i;
  simp only [aeval_eq_eval‚ÇÇ_hom, eval‚ÇÇ_hom_rename, function.comp, matrix.cons_val_zero,
    matrix.head_cons, matrix.cons_val_one],
end
lemma is_poly.comp‚ÇÇ {g f} (hg : is_poly p g) (hf : is_poly‚ÇÇ p f) :
  is_poly‚ÇÇ p (Œª R _Rcr x y, by exactI g (f x y)) :=
begin
  unfreezingI
  { obtain ‚ü®œÜ, hf‚ü© := hf,
    obtain ‚ü®œà, hg‚ü© := hg },
  use (Œª n, bind‚ÇÅ œÜ (œà n)),
  intros,
  simp only [peval, aeval_bind‚ÇÅ, function.comp, hg, hf]
end
lemma is_poly‚ÇÇ.diag {f} (hf : is_poly‚ÇÇ p f) :
  is_poly p (Œª R _Rcr x, by exactI f x x) :=
begin
  unfreezingI {obtain ‚ü®œÜ, hf‚ü© := hf},
  refine ‚ü®‚ü®Œª n, bind‚ÇÅ (uncurry ![X, X]) (œÜ n), _‚ü©‚ü©,
  intros, funext n,
  simp only [hf, peval, uncurry, aeval_bind‚ÇÅ],
  apply eval‚ÇÇ_hom_congr rfl _ rfl,
  ext ‚ü®i, k‚ü©, fin_cases i;
  simp only [matrix.head_cons, aeval_X, matrix.cons_val_zero, matrix.cons_val_one],
end
open tactic
namespace tactic
meta def mk_poly_comp_lemmas (n : name) (vars : list expr) (p : expr) : tactic unit :=
do c ‚Üê mk_const n,
   let appd := vars.foldl expr.app c,
   tgt_bod ‚Üê to_expr ``(Œª f [hf : is_poly %%p f], is_poly.comp %%appd hf) >>=
     replace_univ_metas_with_univ_params,
   tgt_bod ‚Üê lambdas vars tgt_bod,
   tgt_tp ‚Üê infer_type tgt_bod,
   let nm := n <.> "comp_i",
   add_decl $ mk_definition nm tgt_tp.collect_univ_params tgt_tp tgt_bod,
   set_attribute `instance nm,
   tgt_bod ‚Üê to_expr ``(Œª f [hf : is_poly‚ÇÇ %%p f], is_poly.comp‚ÇÇ %%appd hf) >>=
     replace_univ_metas_with_univ_params,
   tgt_bod ‚Üê lambdas vars tgt_bod,
   tgt_tp ‚Üê infer_type tgt_bod,
   let nm := n <.> "comp‚ÇÇ_i",
   add_decl $ mk_definition nm tgt_tp.collect_univ_params tgt_tp tgt_bod,
   set_attribute `instance nm
meta def mk_poly‚ÇÇ_comp_lemmas (n : name) (vars : list expr) (p : expr) : tactic unit :=
do c ‚Üê mk_const n,
   let appd := vars.foldl expr.app c,
   tgt_bod ‚Üê to_expr ``(Œª {f g} [hf : is_poly %%p f] [hg : is_poly %%p g],
     is_poly‚ÇÇ.comp %%appd hf hg) >>= replace_univ_metas_with_univ_params,
   tgt_bod ‚Üê lambdas vars tgt_bod,
   tgt_tp ‚Üê infer_type tgt_bod >>= simp_lemmas.mk.dsimplify,
   let nm := n <.> "comp‚ÇÇ_i",
   add_decl $ mk_definition nm tgt_tp.collect_univ_params tgt_tp tgt_bod,
   set_attribute `instance nm,
   tgt_bod ‚Üê to_expr ``(Œª {f g} [hf : is_poly %%p f] [hg : is_poly %%p g],
     (is_poly‚ÇÇ.comp %%appd hf hg).diag) >>= replace_univ_metas_with_univ_params,
   tgt_bod ‚Üê lambdas vars tgt_bod,
   tgt_tp ‚Üê infer_type tgt_bod >>= simp_lemmas.mk.dsimplify,
   let nm := n <.> "comp_diag",
   add_decl $ mk_definition nm tgt_tp.collect_univ_params tgt_tp tgt_bod,
   set_attribute `instance nm
meta def mk_comp_lemmas (n : name) : tactic unit :=
do d ‚Üê get_decl n,
   (vars, tp) ‚Üê open_pis d.type,
   match tp with
   | `(is_poly %%p _) := mk_poly_comp_lemmas n vars p
   | `(is_poly‚ÇÇ %%p _) := mk_poly‚ÇÇ_comp_lemmas n vars p
   | _ := fail "@[is_poly] should only be applied to terms of type `is_poly _ _` or `is_poly‚ÇÇ _ _`"
   end
@[user_attribute] meta def is_poly_attr : user_attribute :=
{ name := `is_poly,
  descr := "Lemmas with this attribute describe the polynomial structure of functions",
  after_set := some $ Œª n _ _, mk_comp_lemmas n }
end tactic
include hp
@[is_poly]
lemma neg_is_poly : is_poly p (Œª R _, by exactI @has_neg.neg (ùïé R) _) :=
‚ü®‚ü®Œª n, rename prod.snd (witt_neg p n),
begin
  introsI, funext n,
  rw [neg_coeff, aeval_eq_eval‚ÇÇ_hom, eval‚ÇÇ_hom_rename],
  apply eval‚ÇÇ_hom_congr rfl _ rfl,
  ext ‚ü®i, k‚ü©, fin_cases i, refl,
end‚ü©‚ü©
section zero_one
instance zero_is_poly : is_poly p (Œª _ _ _, by exactI 0) :=
‚ü®‚ü®0, by { introsI, funext n, simp only [pi.zero_apply, alg_hom.map_zero, zero_coeff] }‚ü©‚ü©
@[simp] lemma bind‚ÇÅ_zero_witt_polynomial (n : ‚Ñï) :
  bind‚ÇÅ (0 : ‚Ñï ‚Üí mv_polynomial ‚Ñï R) (witt_polynomial p R n) = 0 :=
by rw [‚Üê aeval_eq_bind‚ÇÅ, aeval_zero, constant_coeff_witt_polynomial, ring_hom.map_zero]
omit hp
def one_poly (n : ‚Ñï) : mv_polynomial ‚Ñï ‚Ñ§ := if n = 0 then 1 else 0
include hp
@[simp] lemma bind‚ÇÅ_one_poly_witt_polynomial (n : ‚Ñï) :
  bind‚ÇÅ one_poly (witt_polynomial p ‚Ñ§ n) = 1 :=
begin
  rw [witt_polynomial_eq_sum_C_mul_X_pow, alg_hom.map_sum, finset.sum_eq_single 0],
  { simp only [one_poly, one_pow, one_mul, alg_hom.map_pow, C_1, pow_zero, bind‚ÇÅ_X_right,
      if_true, eq_self_iff_true], },
  { intros i hi hi0,
    simp only [one_poly, if_neg hi0, zero_pow (pow_pos hp.1.pos _), mul_zero,
      alg_hom.map_pow, bind‚ÇÅ_X_right, alg_hom.map_mul], },
  { rw finset.mem_range, dec_trivial }
end
instance one_is_poly : is_poly p (Œª _ _ _, by exactI 1) :=
‚ü®‚ü®one_poly,
begin
  introsI, funext n, cases n,
  { simp only [one_poly, if_true, eq_self_iff_true, one_coeff_zero, alg_hom.map_one], },
  { simp only [one_poly, nat.succ_pos', one_coeff_eq_of_pos,
      if_neg n.succ_ne_zero, alg_hom.map_zero] }
end‚ü©‚ü©
end zero_one
omit hp
@[is_poly] lemma add_is_poly‚ÇÇ [fact p.prime] : is_poly‚ÇÇ p (Œª _ _, by exactI (+)) :=
‚ü®‚ü®witt_add p, by { introsI, dunfold witt_vector.has_add, simp [eval] }‚ü©‚ü©
@[is_poly] lemma mul_is_poly‚ÇÇ [fact p.prime] : is_poly‚ÇÇ p (Œª _ _, by exactI (*)) :=
‚ü®‚ü®witt_mul p, by { introsI, dunfold witt_vector.has_mul, simp [eval] }‚ü©‚ü©
include hp
lemma comp_left {g f} (hg : is_poly‚ÇÇ p g) (hf : is_poly p f) :
  is_poly‚ÇÇ p (Œª R _Rcr x y, by exactI g (f x) y) :=
hg.comp hf (witt_vector.id_is_poly _)
lemma comp_right {g f} (hg : is_poly‚ÇÇ p g) (hf : is_poly p f) :
  is_poly‚ÇÇ p (Œª R _Rcr x y, by exactI g x (f y)) :=
hg.comp (witt_vector.id_is_poly p) hf
include hp
lemma ext {f g} (hf : is_poly‚ÇÇ p f) (hg : is_poly‚ÇÇ p g)
  (h : ‚àÄ (R : Type u) [_Rcr : comm_ring R] (x y : ùïé R) (n : ‚Ñï),
    by exactI ghost_component n (f x y) = ghost_component n (g x y)) :
  ‚àÄ (R) [_Rcr : comm_ring R] (x y : ùïé R), by exactI f x y = g x y :=
begin
  unfreezingI
  { obtain ‚ü®œÜ, hf‚ü© := hf,
    obtain ‚ü®œà, hg‚ü© := hg },
  intros,
  ext n,
  rw [hf, hg, poly_eq_of_witt_polynomial_bind_eq' p œÜ œà],
  clear x y,
  intro k,
  apply mv_polynomial.funext,
  intro x,
  simp only [hom_bind‚ÇÅ],
  specialize h (ulift ‚Ñ§) (mk p $ Œª i, ‚ü®x (0, i)‚ü©) (mk p $ Œª i, ‚ü®x (1, i)‚ü©) k,
  simp only [ghost_component_apply, aeval_eq_eval‚ÇÇ_hom] at h,
  apply (ulift.ring_equiv.symm : ‚Ñ§ ‚âÉ+* _).injective,
  simp only [‚Üêring_equiv.coe_to_ring_hom, map_eval‚ÇÇ_hom],
  convert h using 1,
  all_goals
  { funext i,
    simp only [hf, hg, mv_polynomial.eval, map_eval‚ÇÇ_hom],
    apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) _ rfl,
    ext1,
    apply eval‚ÇÇ_hom_congr (ring_hom.ext_int _ _) _ rfl,
    ext ‚ü®b, _‚ü©,
    fin_cases b; simp only [coeff_mk, uncurry]; refl }
end
