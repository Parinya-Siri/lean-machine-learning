import category_theory.preadditive.additive_functor
import category_theory.shift
import category_theory.triangulated.rotate
noncomputable theory
open category_theory
open category_theory.preadditive
open category_theory.limits
universes v vâ‚€ vâ‚ vâ‚‚ u uâ‚€ uâ‚ uâ‚‚
namespace category_theory.triangulated
open category_theory.category
variables (C : Type u) [category.{v} C] [has_zero_object C] [has_shift C â„¤] [preadditive C]
  [âˆ€ n : â„¤, functor.additive (shift_functor C n)]
class pretriangulated :=
(distinguished_triangles [] : set (triangle C))
(isomorphic_distinguished : Î  (Tâ‚ âˆˆ distinguished_triangles) (Tâ‚‚ â‰… Tâ‚),
  Tâ‚‚ âˆˆ distinguished_triangles)
(contractible_distinguished : Î  (X : C), (contractible_triangle C X) âˆˆ distinguished_triangles)
(distinguished_cocone_triangle : Î  (X Y : C) (f : X âŸ¶ Y), (âˆƒ (Z : C) (g : Y âŸ¶ Z)
  (h : Z âŸ¶ XâŸ¦(1:â„¤)âŸ§),
  triangle.mk _ f g h âˆˆ distinguished_triangles))
(rotate_distinguished_triangle : Î  (T : triangle C),
  T âˆˆ distinguished_triangles â†” T.rotate âˆˆ distinguished_triangles)
(complete_distinguished_triangle_morphism : Î  (Tâ‚ Tâ‚‚ : triangle C)
  (hâ‚ : Tâ‚ âˆˆ distinguished_triangles) (hâ‚‚ : Tâ‚‚ âˆˆ distinguished_triangles) (a : Tâ‚.objâ‚ âŸ¶ Tâ‚‚.objâ‚)
  (b : Tâ‚.objâ‚‚ âŸ¶ Tâ‚‚.objâ‚‚) (commâ‚ : Tâ‚.morâ‚ â‰« b = a â‰« Tâ‚‚.morâ‚),
  (âˆƒ (c : Tâ‚.objâ‚ƒ âŸ¶ Tâ‚‚.objâ‚ƒ), (Tâ‚.morâ‚‚ â‰« c = b â‰« Tâ‚‚.morâ‚‚) âˆ§ (Tâ‚.morâ‚ƒ â‰« aâŸ¦1âŸ§' = c â‰« Tâ‚‚.morâ‚ƒ) ))
namespace pretriangulated
variables [pretriangulated C]
notation `dist_triang `:20 C := distinguished_triangles C
lemma rot_of_dist_triangle (T âˆˆ dist_triang C) : (T.rotate âˆˆ dist_triang C) :=
(rotate_distinguished_triangle T).mp H
lemma inv_rot_of_dist_triangle (T âˆˆ dist_triang C) : (T.inv_rotate âˆˆ dist_triang C) :=
(rotate_distinguished_triangle (T.inv_rotate)).mpr
  (isomorphic_distinguished T H T.inv_rotate.rotate (inv_rot_comp_rot.app T))
lemma comp_dist_triangle_mor_zeroâ‚â‚‚ (T âˆˆ dist_triang C) : T.morâ‚ â‰« T.morâ‚‚ = 0 :=
begin
  have h := contractible_distinguished T.objâ‚,
  have f := complete_distinguished_triangle_morphism,
  specialize f (contractible_triangle C T.objâ‚) T h H (ğŸ™ T.objâ‚) T.morâ‚,
  have t : (contractible_triangle C T.objâ‚).morâ‚ â‰« T.morâ‚ = ğŸ™ T.objâ‚ â‰« T.morâ‚,
    by refl,
  specialize f t,
  cases f with c f,
  rw â† f.left,
  simp only [limits.zero_comp, contractible_triangle_morâ‚‚],
lemma comp_dist_triangle_mor_zeroâ‚‚â‚ƒ  (T âˆˆ dist_triang C) : T.morâ‚‚ â‰« T.morâ‚ƒ = 0 :=
comp_dist_triangle_mor_zeroâ‚â‚‚ C T.rotate (rot_of_dist_triangle C T H)
lemma comp_dist_triangle_mor_zeroâ‚ƒâ‚ (T âˆˆ dist_triang C) :
  T.morâ‚ƒ â‰« ((shift_equiv C 1).functor.map T.morâ‚) = 0 :=
have Hâ‚‚ : _ := rot_of_dist_triangle C T.rotate (rot_of_dist_triangle C T H),
by simpa using comp_dist_triangle_mor_zeroâ‚â‚‚ C (T.rotate.rotate) Hâ‚‚
end pretriangulated
end category_theory.triangulated
namespace category_theory.triangulated
namespace pretriangulated
variables (C : Type uâ‚) [category.{vâ‚} C] [has_zero_object C] [has_shift C â„¤] [preadditive C]
  [âˆ€ n : â„¤, functor.additive (shift_functor C n)]
variables (D : Type uâ‚‚) [category.{vâ‚‚} D] [has_zero_object D] [has_shift D â„¤] [preadditive D]
  [âˆ€ n : â„¤, functor.additive (shift_functor D n)]
structure triangulated_functor_struct extends (C â¥¤ D) :=
(comm_shift : shift_functor C (1 : â„¤) â‹™ to_functor â‰… to_functor â‹™ shift_functor D (1 : â„¤))
namespace triangulated_functor_struct
def id : triangulated_functor_struct C C :=
{ obj := Î» X, X,
  map := Î» _ _ f, f,
  comm_shift := by refl }
instance : inhabited (triangulated_functor_struct C C) := âŸ¨id CâŸ©
variables {C D}
@[simps]
def map_triangle (F : triangulated_functor_struct C D) : triangle C â¥¤ triangle D :=
{ obj := Î» T, triangle.mk _ (F.map T.morâ‚) (F.map T.morâ‚‚)
    (F.map T.morâ‚ƒ â‰« F.comm_shift.hom.app T.objâ‚),
  map := Î» S T f,
  { homâ‚ := F.map f.homâ‚,
    homâ‚‚ := F.map f.homâ‚‚,
    homâ‚ƒ := F.map f.homâ‚ƒ,
    commâ‚' := by { dsimp, simp only [â†F.to_functor.map_comp, f.commâ‚], },
    commâ‚‚' := by { dsimp, simp only [â†F.to_functor.map_comp, f.commâ‚‚], },
    commâ‚ƒ' := begin
      dsimp,
      erw [category.assoc, â†F.comm_shift.hom.naturality],
      simp only [functor.comp_map, â†F.to_functor.map_comp_assoc, f.commâ‚ƒ],
    end, }, }
end triangulated_functor_struct
variables (C D)
structure triangulated_functor [pretriangulated C] [pretriangulated D] extends
  triangulated_functor_struct C D :=
(map_distinguished' : Î  (T : triangle C), (T âˆˆ dist_triang C) â†’
  (to_triangulated_functor_struct.map_triangle.obj T âˆˆ dist_triang D) )
instance [pretriangulated C] : inhabited (triangulated_functor C C) :=
âŸ¨{obj := Î» X, X,
  map := Î» _ _ f, f,
  comm_shift := by refl ,
  map_distinguished' := begin
    rintros âŸ¨_,_,_,_âŸ© Tdt,
    dsimp at *,
    rwa category.comp_id,
  end }âŸ©
variables {C D} [pretriangulated C] [pretriangulated D]
@[simps]
def triangulated_functor.map_triangle (F : triangulated_functor C D) :
  triangle C â¥¤ triangle D :=
F.to_triangulated_functor_struct.map_triangle
lemma triangulated_functor.map_distinguished (F : triangulated_functor C D) (T : triangle C)
  (h : T âˆˆ dist_triang C) : (F.map_triangle.obj T) âˆˆ dist_triang D := F.map_distinguished' T h
end pretriangulated
end category_theory.triangulated
