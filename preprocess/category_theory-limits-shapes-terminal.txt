import category_theory.pempty
import category_theory.limits.has_limits
import category_theory.epi_mono
import category_theory.category.preorder
noncomputable theory
universes w w' v v‚ÇÅ v‚ÇÇ u u‚ÇÅ u‚ÇÇ
open category_theory
namespace category_theory.limits
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C]
local attribute [tidy] tactic.discrete_cases
@[simps] def as_empty_cone (X : C) : cone (functor.empty.{0} C) := { X := X, œÄ := by tidy }
@[simps] def as_empty_cocone (X : C) : cocone (functor.empty.{0} C) := { X := X, Œπ := by tidy }
abbreviation is_terminal (X : C) := is_limit (as_empty_cone X)
abbreviation is_initial (X : C) := is_colimit (as_empty_cocone X)
def is_terminal_equiv_unique (F : discrete.{0} pempty.{1} ‚•§ C) (Y : C) :
  is_limit (‚ü®Y, by tidy‚ü© : cone F) ‚âÉ ‚àÄ X : C, unique (X ‚ü∂ Y) :=
{ to_fun := Œª t X, { default := t.lift ‚ü®X, by tidy‚ü©,
    uniq := Œª f, t.uniq ‚ü®X, by tidy‚ü© f (by tidy) },
  inv_fun := Œª u, { lift := Œª s, (u s.X).default, uniq' := Œª s _ _, (u s.X).2 _ },
  left_inv := by tidy,
  right_inv := by tidy }
def is_terminal.of_unique (Y : C) [h : Œ† X : C, unique (X ‚ü∂ Y)] : is_terminal Y :=
{ lift := Œª s, (h s.X).default }
def is_terminal_top {Œ± : Type*} [preorder Œ±] [order_top Œ±] : is_terminal (‚ä§ : Œ±) :=
is_terminal.of_unique _
def is_terminal.of_iso {Y Z : C} (hY : is_terminal Y) (i : Y ‚âÖ Z) : is_terminal Z :=
is_limit.of_iso_limit hY
{ hom := { hom := i.hom },
  inv := { hom := i.inv } }
def is_initial_equiv_unique (F : discrete.{0} pempty.{1} ‚•§ C) (X : C) :
  is_colimit (‚ü®X, by tidy‚ü© : cocone F) ‚âÉ ‚àÄ Y : C, unique (X ‚ü∂ Y) :=
{ to_fun := Œª t X, { default := t.desc ‚ü®X, by tidy‚ü©,
    uniq := Œª f, t.uniq ‚ü®X, by tidy‚ü© f (by tidy) },
  inv_fun := Œª u, { desc := Œª s, (u s.X).default, uniq' := Œª s _ _, (u s.X).2 _ },
  left_inv := by tidy,
  right_inv := by tidy }
def is_initial.of_unique (X : C) [h : Œ† Y : C, unique (X ‚ü∂ Y)] : is_initial X :=
{ desc := Œª s, (h s.X).default }
def is_initial_bot {Œ± : Type*} [preorder Œ±] [order_bot Œ±] : is_initial (‚ä• : Œ±) :=
is_initial.of_unique _
def is_initial.of_iso {X Y : C} (hX : is_initial X) (i : X ‚âÖ Y) : is_initial Y :=
is_colimit.of_iso_colimit hX
{ hom := { hom := i.hom },
  inv := { hom := i.inv } }
def is_terminal.from {X : C} (t : is_terminal X) (Y : C) : Y ‚ü∂ X :=
t.lift (as_empty_cone Y)
lemma is_terminal.hom_ext {X Y : C} (t : is_terminal X) (f g : Y ‚ü∂ X) : f = g :=
t.hom_ext (by tidy)
@[simp] lemma is_terminal.comp_from {Z : C} (t : is_terminal Z) {X Y : C} (f : X ‚ü∂ Y) :
  f ‚â´ t.from Y = t.from X :=
t.hom_ext _ _
@[simp] lemma is_terminal.from_self {X : C} (t : is_terminal X) : t.from X = ùüô X :=
t.hom_ext _ _
def is_initial.to {X : C} (t : is_initial X) (Y : C) : X ‚ü∂ Y :=
t.desc (as_empty_cocone Y)
lemma is_initial.hom_ext {X Y : C} (t : is_initial X) (f g : X ‚ü∂ Y) : f = g :=
t.hom_ext (by tidy)
@[simp] lemma is_initial.to_comp {X : C} (t : is_initial X) {Y Z : C} (f : Y ‚ü∂ Z) :
  t.to Y ‚â´ f = t.to Z :=
t.hom_ext _ _
@[simp] lemma is_initial.to_self {X : C} (t : is_initial X) : t.to X = ùüô X :=
t.hom_ext _ _
def is_terminal.split_mono_from {X Y : C} (t : is_terminal X) (f : X ‚ü∂ Y) : split_mono f :=
‚ü®t.from _, t.hom_ext _ _‚ü©
def is_initial.split_epi_to {X Y : C} (t : is_initial X) (f : Y ‚ü∂ X) : split_epi f :=
‚ü®t.to _, t.hom_ext _ _‚ü©
lemma is_terminal.mono_from {X Y : C} (t : is_terminal X) (f : X ‚ü∂ Y) : mono f :=
by haveI := t.split_mono_from f; apply_instance
lemma is_initial.epi_to {X Y : C} (t : is_initial X) (f : Y ‚ü∂ X) : epi f :=
by haveI := t.split_epi_to f; apply_instance
@[simps]
def is_terminal.unique_up_to_iso {T T' : C} (hT : is_terminal T) (hT' : is_terminal T') : T ‚âÖ T' :=
{ hom := hT'.from _,
  inv := hT.from _ }
@[simps]
def is_initial.unique_up_to_iso {I I' : C} (hI : is_initial I) (hI' : is_initial I') : I ‚âÖ I' :=
{ hom := hI.to _,
  inv := hI'.to _ }
variable (C)
abbreviation has_terminal := has_limits_of_shape (discrete.{0} pempty) C
abbreviation has_initial := has_colimits_of_shape (discrete.{0} pempty) C
section univ
variables (X : C) {F‚ÇÅ : discrete.{w} pempty ‚•§ C} {F‚ÇÇ : discrete.{w'} pempty ‚•§ C}
def is_limit_change_empty_cone {c‚ÇÅ : cone F‚ÇÅ} (hl : is_limit c‚ÇÅ)
  (c‚ÇÇ : cone F‚ÇÇ) (hi : c‚ÇÅ.X ‚âÖ c‚ÇÇ.X) : is_limit c‚ÇÇ :=
{ lift := Œª c, hl.lift ‚ü®c.X, by tidy‚ü© ‚â´ hi.hom,
  fac' := Œª _ j, j.as.elim,
  uniq' := Œª c f _, by { erw ‚Üê hl.uniq ‚ü®c.X, by tidy‚ü© (f ‚â´ hi.inv) (Œª j, j.as.elim), simp } }
def is_limit_empty_cone_equiv (c‚ÇÅ : cone F‚ÇÅ) (c‚ÇÇ : cone F‚ÇÇ) (h : c‚ÇÅ.X ‚âÖ c‚ÇÇ.X) :
  is_limit c‚ÇÅ ‚âÉ is_limit c‚ÇÇ :=
{ to_fun := Œª hl, is_limit_change_empty_cone C hl c‚ÇÇ h,
  inv_fun := Œª hl, is_limit_change_empty_cone C hl c‚ÇÅ h.symm,
  left_inv := by tidy,
  right_inv := by tidy }
lemma has_terminal_change_diagram (h : has_limit F‚ÇÅ) : has_limit F‚ÇÇ :=
‚ü®‚ü®‚ü®‚ü®limit F‚ÇÅ, by tidy‚ü©, is_limit_change_empty_cone C (limit.is_limit F‚ÇÅ) _ (eq_to_iso rfl)‚ü©‚ü©‚ü©
lemma has_terminal_change_universe [h : has_limits_of_shape (discrete.{w} pempty) C] :
  has_limits_of_shape (discrete.{w'} pempty) C :=
{ has_limit := Œª J, has_terminal_change_diagram C (let f := h.1 in f (functor.empty C)) }
def is_colimit_change_empty_cocone {c‚ÇÅ : cocone F‚ÇÅ} (hl : is_colimit c‚ÇÅ)
  (c‚ÇÇ : cocone F‚ÇÇ) (hi : c‚ÇÅ.X ‚âÖ c‚ÇÇ.X) : is_colimit c‚ÇÇ :=
{ desc := Œª c, hi.inv ‚â´ hl.desc ‚ü®c.X, by tidy‚ü©,
  fac' := Œª _ j, j.as.elim,
  uniq' := Œª c f _, by { erw ‚Üê hl.uniq ‚ü®c.X, by tidy‚ü© (hi.hom ‚â´ f) (Œª j, j.as.elim), simp } }
def is_colimit_empty_cocone_equiv (c‚ÇÅ : cocone F‚ÇÅ) (c‚ÇÇ : cocone F‚ÇÇ) (h : c‚ÇÅ.X ‚âÖ c‚ÇÇ.X) :
  is_colimit c‚ÇÅ ‚âÉ is_colimit c‚ÇÇ :=
{ to_fun := Œª hl, is_colimit_change_empty_cocone C hl c‚ÇÇ h,
  inv_fun := Œª hl, is_colimit_change_empty_cocone C hl c‚ÇÅ h.symm,
  left_inv := by tidy,
  right_inv := by tidy }
lemma has_initial_change_diagram (h : has_colimit F‚ÇÅ) : has_colimit F‚ÇÇ :=
‚ü®‚ü®‚ü®‚ü®colimit F‚ÇÅ, by tidy‚ü©,
   is_colimit_change_empty_cocone C (colimit.is_colimit F‚ÇÅ) _ (eq_to_iso rfl)‚ü©‚ü©‚ü©
lemma has_initial_change_universe [h : has_colimits_of_shape (discrete.{w} pempty) C] :
  has_colimits_of_shape (discrete.{w'} pempty) C :=
{ has_colimit := Œª J, has_initial_change_diagram C (let f := h.1 in f (functor.empty C)) }
end univ
abbreviation terminal [has_terminal C] : C := limit (functor.empty.{0} C)
abbreviation initial [has_initial C] : C := colimit (functor.empty.{0} C)
notation `‚ä§_ ` C:20 := terminal C
notation `‚ä•_ ` C:20 := initial C
section
variables {C}
lemma has_terminal_of_unique (X : C) [h : Œ† Y : C, unique (Y ‚ü∂ X)] : has_terminal C :=
{ has_limit := Œª F, has_limit.mk ‚ü®_, (is_terminal_equiv_unique F X).inv_fun h‚ü© }
lemma has_initial_of_unique (X : C) [h : Œ† Y : C, unique (X ‚ü∂ Y)] : has_initial C :=
{ has_colimit := Œª F, has_colimit.mk ‚ü®_, (is_initial_equiv_unique F X).inv_fun h‚ü© }
abbreviation terminal.from [has_terminal C] (P : C) : P ‚ü∂ ‚ä§_ C :=
limit.lift (functor.empty C) (as_empty_cone P)
abbreviation initial.to [has_initial C] (P : C) : ‚ä•_ C ‚ü∂ P :=
colimit.desc (functor.empty C) (as_empty_cocone P)
def terminal_is_terminal [has_terminal C] : is_terminal (‚ä§_ C) :=
{ lift := Œª s, terminal.from _ }
def initial_is_initial [has_initial C] : is_initial (‚ä•_ C) :=
{ desc := Œª s, initial.to _ }
instance unique_to_terminal [has_terminal C] (P : C) : unique (P ‚ü∂ ‚ä§_ C) :=
is_terminal_equiv_unique _ (‚ä§_ C) terminal_is_terminal P
instance unique_from_initial [has_initial C] (P : C) : unique (‚ä•_ C ‚ü∂ P) :=
is_initial_equiv_unique _ (‚ä•_ C) initial_is_initial P
@[simp] lemma terminal.comp_from [has_terminal C] {P Q : C} (f : P ‚ü∂ Q) :
  f ‚â´ terminal.from Q = terminal.from P :=
by tidy
@[simp] lemma initial.to_comp [has_initial C] {P Q : C} (f : P ‚ü∂ Q) :
  initial.to P ‚â´ f = initial.to Q :=
by tidy
@[simp] def initial_iso_is_initial [has_initial C] {P : C} (t : is_initial P) : ‚ä•_ C ‚âÖ P :=
initial_is_initial.unique_up_to_iso t
@[simp] def terminal_iso_is_terminal [has_terminal C] {P : C}  (t : is_terminal P) : ‚ä§_ C ‚âÖ P :=
terminal_is_terminal.unique_up_to_iso t
instance terminal.split_mono_from {Y : C} [has_terminal C] (f : ‚ä§_ C ‚ü∂ Y) : split_mono f :=
is_terminal.split_mono_from terminal_is_terminal _
instance initial.split_epi_to {Y : C} [has_initial C] (f : Y ‚ü∂ ‚ä•_ C) : split_epi f :=
is_initial.split_epi_to initial_is_initial _
def terminal_op_of_initial {X : C} (t : is_initial X) : is_terminal (opposite.op X) :=
{ lift := Œª s, (t.to s.X.unop).op,
  uniq' := Œª s m w, quiver.hom.unop_inj (t.hom_ext _ _) }
def terminal_unop_of_initial {X : C·µí·µñ} (t : is_initial X) : is_terminal X.unop :=
{ lift := Œª s, (t.to (opposite.op s.X)).unop,
  uniq' := Œª s m w, quiver.hom.op_inj (t.hom_ext _ _) }
def initial_op_of_terminal {X : C} (t : is_terminal X) : is_initial (opposite.op X) :=
{ desc := Œª s, (t.from s.X.unop).op,
  uniq' := Œª s m w, quiver.hom.unop_inj (t.hom_ext _ _) }
def initial_unop_of_terminal {X : C·µí·µñ} (t : is_terminal X) : is_initial X.unop :=
{ desc := Œª s, (t.from (opposite.op s.X)).unop,
  uniq' := Œª s m w, quiver.hom.op_inj (t.hom_ext _ _) }
instance {J : Type*} [category J] {C : Type*} [category C] [has_terminal C] :
  has_limit ((category_theory.functor.const J).obj (‚ä§_ C)) :=
has_limit.mk
{ cone :=
  { X := ‚ä§_ C,
    œÄ := { app := Œª _, terminal.from _, }, },
  is_limit :=
  { lift := Œª s, terminal.from _, }, }
@[simps hom]
def limit_const_terminal {J : Type*} [category J] {C : Type*} [category C] [has_terminal C] :
  limit ((category_theory.functor.const J).obj (‚ä§_ C)) ‚âÖ ‚ä§_ C :=
{ hom := terminal.from _,
  inv := limit.lift ((category_theory.functor.const J).obj (‚ä§_ C))
    { X := ‚ä§_ C, œÄ := { app := Œª j, terminal.from _, }}, }
@[simp, reassoc] lemma limit_const_terminal_inv_œÄ
  {J : Type*} [category J] {C : Type*} [category C] [has_terminal C] {j : J} :
  limit_const_terminal.inv ‚â´ limit.œÄ ((category_theory.functor.const J).obj (‚ä§_ C)) j =
    terminal.from _ :=
by ext ‚ü®‚ü®‚ü©‚ü©
instance {J : Type*} [category J] {C : Type*} [category C] [has_initial C] :
  has_colimit ((category_theory.functor.const J).obj (‚ä•_ C)) :=
has_colimit.mk
{ cocone :=
  { X := ‚ä•_ C,
    Œπ := { app := Œª _, initial.to _, }, },
  is_colimit :=
  { desc := Œª s, initial.to _, }, }
@[simps inv]
def colimit_const_initial {J : Type*} [category J] {C : Type*} [category C] [has_initial C] :
  colimit ((category_theory.functor.const J).obj (‚ä•_ C)) ‚âÖ ‚ä•_ C :=
{ hom := colimit.desc ((category_theory.functor.const J).obj (‚ä•_ C))
    { X := ‚ä•_ C, Œπ := { app := Œª j, initial.to _, }, },
  inv := initial.to _, }
@[simp, reassoc] lemma Œπ_colimit_const_initial_hom
  {J : Type*} [category J] {C : Type*} [category C] [has_initial C] {j : J} :
  colimit.Œπ ((category_theory.functor.const J).obj (‚ä•_ C)) j ‚â´ colimit_const_initial.hom =
    initial.to _ :=
by ext ‚ü®‚ü®‚ü©‚ü©
class initial_mono_class (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] : Prop :=
(is_initial_mono_from : ‚àÄ {I} (X : C) (hI : is_initial I), mono (hI.to X))
lemma is_initial.mono_from [initial_mono_class C] {I} {X : C} (hI : is_initial I) (f : I ‚ü∂ X) :
  mono f :=
begin
  rw hI.hom_ext f (hI.to X),
  apply initial_mono_class.is_initial_mono_from,
end
@[priority 100]
instance initial.mono_from [has_initial C] [initial_mono_class C] (X : C) (f : ‚ä•_ C ‚ü∂ X) :
  mono f :=
initial_is_initial.mono_from f
lemma initial_mono_class.of_is_initial {I : C} (hI : is_initial I) (h : ‚àÄ X, mono (hI.to X)) :
  initial_mono_class C :=
{ is_initial_mono_from := Œª I' X hI',
  begin
    rw hI'.hom_ext (hI'.to X) ((hI'.unique_up_to_iso hI).hom ‚â´ hI.to X),
    apply mono_comp,
  end }
lemma initial_mono_class.of_initial [has_initial C] (h : ‚àÄ X : C, mono (initial.to X)) :
  initial_mono_class C :=
initial_mono_class.of_is_initial initial_is_initial h
lemma initial_mono_class.of_is_terminal {I T : C} (hI : is_initial I) (hT : is_terminal T)
  (f : mono (hI.to T)) :
  initial_mono_class C :=
initial_mono_class.of_is_initial hI (Œª X, mono_of_mono_fac (hI.hom_ext (_ ‚â´ hT.from X) (hI.to T)))
lemma initial_mono_class.of_terminal [has_initial C] [has_terminal C]
  (h : mono (initial.to (‚ä§_ C))) :
  initial_mono_class C :=
initial_mono_class.of_is_terminal initial_is_initial terminal_is_terminal h
section comparison
variables {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] (G : C ‚•§ D)
def terminal_comparison [has_terminal C] [has_terminal D] :
  G.obj (‚ä§_ C) ‚ü∂ ‚ä§_ D :=
terminal.from _
@[simps]
def cone_of_diagram_initial
  {X : J} (tX : is_initial X) (F : J ‚•§ C) : cone F :=
{ X := F.obj X,
  œÄ :=
  { app := Œª j, F.map (tX.to j),
    naturality' := Œª j j' k,
    begin
      dsimp,
      rw [‚Üê F.map_comp, category.id_comp, tX.hom_ext (tX.to j ‚â´ k) (tX.to j')],
    end } }
def limit_of_diagram_initial
  {X : J} (tX : is_initial X) (F : J ‚•§ C) :
is_limit (cone_of_diagram_initial tX F) :=
{ lift := Œª s, s.œÄ.app X,
  uniq' := Œª s m w,
    begin
      rw [‚Üê w X, cone_of_diagram_initial_œÄ_app, tX.hom_ext (tX.to X) (ùüô _)],
@[reducible]
def limit_of_initial (F : J ‚•§ C)
  [has_initial J] [has_limit F] :
limit F ‚âÖ F.obj (‚ä•_ J) :=
is_limit.cone_point_unique_up_to_iso
  (limit.is_limit _)
  (limit_of_diagram_initial initial_is_initial F)
@[simps]
def cone_of_diagram_terminal {X : J} (hX : is_terminal X)
  (F : J ‚•§ C) [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] : cone F :=
{ X := F.obj X,
  œÄ :=
  { app := Œª i, inv (F.map (hX.from _)),
    naturality' := begin
      intros i j f,
      dsimp,
      simp only [is_iso.eq_inv_comp, is_iso.comp_inv_eq, category.id_comp,
        ‚Üê F.map_comp, hX.hom_ext (hX.from i) (f ‚â´ hX.from j)],
    end } }
def limit_of_diagram_terminal {X : J} (hX : is_terminal X)
  (F : J ‚•§ C) [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] :
  is_limit (cone_of_diagram_terminal hX F) :=
{ lift := Œª S, S.œÄ.app _ }
@[reducible]
def limit_of_terminal (F : J ‚•§ C)
  [has_terminal J] [has_limit F] [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] :
limit F ‚âÖ F.obj (‚ä§_ J) :=
is_limit.cone_point_unique_up_to_iso
  (limit.is_limit _)
  (limit_of_diagram_terminal terminal_is_terminal F)
@[simps]
def cocone_of_diagram_terminal
  {X : J} (tX : is_terminal X) (F : J ‚•§ C) : cocone F :=
{ X := F.obj X,
  Œπ :=
  { app := Œª j, F.map (tX.from j),
    naturality' := Œª j j' k,
    begin
      dsimp,
      rw [‚Üê F.map_comp, category.comp_id, tX.hom_ext (k ‚â´ tX.from j') (tX.from j)],
    end } }
def colimit_of_diagram_terminal
  {X : J} (tX : is_terminal X) (F : J ‚•§ C) :
is_colimit (cocone_of_diagram_terminal tX F) :=
{ desc := Œª s, s.Œπ.app X,
  uniq' := Œª s m w,
    by { rw [‚Üê w X, cocone_of_diagram_terminal_Œπ_app, tX.hom_ext (tX.from X) (ùüô _)], simp } }
@[reducible]
def colimit_of_terminal (F : J ‚•§ C)
  [has_terminal J] [has_colimit F] :
colimit F ‚âÖ F.obj (‚ä§_ J) :=
is_colimit.cocone_point_unique_up_to_iso
  (colimit.is_colimit _)
  (colimit_of_diagram_terminal terminal_is_terminal F)
@[simps]
def cocone_of_diagram_initial {X : J} (hX : is_initial X) (F : J ‚•§ C)
  [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] : cocone F :=
{ X := F.obj X,
  Œπ :=
  { app := Œª i, inv (F.map (hX.to _)),
    naturality' := begin
      intros i j f,
      dsimp,
      simp only [is_iso.eq_inv_comp, is_iso.comp_inv_eq, category.comp_id,
        ‚Üê F.map_comp, hX.hom_ext (hX.to i ‚â´ f) (hX.to j)],
    end } }
def colimit_of_diagram_initial {X : J} (hX : is_initial X) (F : J ‚•§ C)
  [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] : is_colimit (cocone_of_diagram_initial hX F) :=
{ desc := Œª S, S.Œπ.app _ }
@[reducible]
def colimit_of_initial (F : J ‚•§ C)
  [has_initial J] [has_colimit F] [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] :
colimit F ‚âÖ F.obj (‚ä•_ J) :=
is_colimit.cocone_point_unique_up_to_iso
  (colimit.is_colimit _)
  (colimit_of_diagram_initial initial_is_initial _)
lemma is_iso_œÄ_of_is_initial {j : J} (I : is_initial j) (F : J ‚•§ C) [has_limit F] :
  is_iso (limit.œÄ F j) :=
‚ü®‚ü®limit.lift _ (cone_of_diagram_initial I F), ‚ü®by { ext, simp }, by simp‚ü©‚ü©‚ü©
instance is_iso_œÄ_initial [has_initial J] (F : J ‚•§ C) [has_limit F] :
  is_iso (limit.œÄ F (‚ä•_ J)) :=
is_iso_œÄ_of_is_initial (initial_is_initial) F
lemma is_iso_œÄ_of_is_terminal {j : J} (I : is_terminal j) (F : J ‚•§ C)
  [has_limit F] [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] : is_iso (limit.œÄ F j) :=
‚ü®‚ü®limit.lift _ (cone_of_diagram_terminal I F), by { ext, simp }, by simp ‚ü©‚ü©
instance is_iso_œÄ_terminal [has_terminal J] (F : J ‚•§ C) [has_limit F]
  [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] : is_iso (limit.œÄ F (‚ä§_ J)) :=
is_iso_œÄ_of_is_terminal terminal_is_terminal F
lemma is_iso_Œπ_of_is_terminal {j : J} (I : is_terminal j) (F : J ‚•§ C) [has_colimit F] :
  is_iso (colimit.Œπ F j) :=
‚ü®‚ü®colimit.desc _ (cocone_of_diagram_terminal I F), ‚ü®by simp, by { ext, simp }‚ü©‚ü©‚ü©
instance is_iso_Œπ_terminal [has_terminal J] (F : J ‚•§ C) [has_colimit F] :
  is_iso (colimit.Œπ F (‚ä§_ J)) :=
is_iso_Œπ_of_is_terminal (terminal_is_terminal) F
lemma is_iso_Œπ_of_is_initial {j : J} (I : is_initial j) (F : J ‚•§ C)
  [has_colimit F] [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] : is_iso (colimit.Œπ F j) :=
‚ü®‚ü®colimit.desc _ (cocone_of_diagram_initial I F), ‚ü®by tidy, by { ext, simp }‚ü©‚ü©‚ü©
instance is_iso_Œπ_initial [has_initial J] (F : J ‚•§ C) [has_colimit F]
  [‚àÄ (i j : J) (f : i ‚ü∂ j), is_iso (F.map f)] : is_iso (colimit.Œπ F (‚ä•_ J)) :=
is_iso_Œπ_of_is_initial initial_is_initial F
end
end category_theory.limits
