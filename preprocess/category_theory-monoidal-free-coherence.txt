import category_theory.monoidal.free.basic
import category_theory.groupoid
import category_theory.discrete_category
universe u
namespace category_theory
open monoidal_category
namespace free_monoidal_category
variables {C : Type u}
section
variables (C)
@[nolint has_inhabited_instance]
inductive normal_monoidal_object : Type u
| unit : normal_monoidal_object
| tensor : normal_monoidal_object ‚Üí C ‚Üí normal_monoidal_object
end
local notation `F` := free_monoidal_category
local notation `N` := discrete ‚àò normal_monoidal_object
local infixr ` ‚ü∂·µê `:10 := hom
@[simp] def inclusion_obj : normal_monoidal_object C ‚Üí F C
| normal_monoidal_object.unit := unit
| (normal_monoidal_object.tensor n a) := tensor (inclusion_obj n) (of a)
@[simp] def inclusion : N C ‚•§ F C :=
discrete.functor inclusion_obj
@[simp] def normalize_obj : F C ‚Üí normal_monoidal_object C ‚Üí N C
| unit n := ‚ü®n‚ü©
| (of X) n := ‚ü®normal_monoidal_object.tensor n X‚ü©
| (tensor X Y) n := normalize_obj Y (normalize_obj X n).as
@[simp] lemma normalize_obj_unitor (n : normal_monoidal_object C) :
  normalize_obj (ùüô_ (F C)) n = ‚ü®n‚ü© :=
rfl
@[simp] lemma normalize_obj_tensor (X Y : F C) (n : normal_monoidal_object C) :
  normalize_obj (X ‚äó Y) n = normalize_obj Y (normalize_obj X n).as :=
rfl
section
open hom
local attribute [tidy] tactic.discrete_cases
@[simp] def normalize_map_aux : Œ† {X Y : F C},
  (X ‚ü∂·µê Y) ‚Üí
    ((discrete.functor (normalize_obj X) : _ ‚•§ N C) ‚ü∂ discrete.functor (normalize_obj Y))
| _ _ (id _) := ùüô _
| _ _ (Œ±_hom _ _ _) := ‚ü®Œª X, ùüô _, by { rintros ‚ü®X‚ü© ‚ü®Y‚ü© f, simp }‚ü©
| _ _ (Œ±_inv _ _ _) := ‚ü®Œª X, ùüô _, by { rintros ‚ü®X‚ü© ‚ü®Y‚ü© f, simp }‚ü©
| _ _ (l_hom _) := ‚ü®Œª X, ùüô _, by { rintros ‚ü®X‚ü© ‚ü®Y‚ü© f, simp }‚ü©
| _ _ (l_inv _) := ‚ü®Œª X, ùüô _, by { rintros ‚ü®X‚ü© ‚ü®Y‚ü© f, simp }‚ü©
| _ _ (œÅ_hom _) := ‚ü®Œª ‚ü®X‚ü©, ‚ü®‚ü®by simp‚ü©‚ü©, by { rintros ‚ü®X‚ü© ‚ü®Y‚ü© f, simp }‚ü©
| _ _ (œÅ_inv _) := ‚ü®Œª ‚ü®X‚ü©, ‚ü®‚ü®by simp‚ü©‚ü©, by { rintros ‚ü®X‚ü© ‚ü®Y‚ü© f, simp }‚ü©
| X Y (@comp _ U V W f g) := normalize_map_aux f ‚â´ normalize_map_aux g
| X Y (@hom.tensor _ T U V W f g) :=
    ‚ü®Œª X, (normalize_map_aux g).app (normalize_obj T X.as) ‚â´
      (discrete.functor (normalize_obj W) : _ ‚•§ N C).map ((normalize_map_aux f).app X), by tidy‚ü©
end
section
variables (C)
@[simp] def normalize : F C ‚•§ N C ‚•§ N C :=
{ obj := Œª X, discrete.functor (normalize_obj X),
  map := Œª X Y, quotient.lift normalize_map_aux (by tidy) }
@[simp] def normalize' : F C ‚•§ N C ‚•§ F C :=
normalize C ‚ãô (whiskering_right _ _ _).obj inclusion
def full_normalize : F C ‚•§ N C :=
{ obj := Œª X, ((normalize C).obj X).obj ‚ü®normal_monoidal_object.unit‚ü©,
  map := Œª X Y f, ((normalize C).map f).app ‚ü®normal_monoidal_object.unit‚ü© }
@[simp] def tensor_func : F C ‚•§ N C ‚•§ F C :=
{ obj := Œª X, discrete.functor (Œª n, (inclusion.obj ‚ü®n‚ü©) ‚äó X),
  map := Œª X Y f, ‚ü®Œª n, ùüô _ ‚äó f, by { rintro ‚ü®X‚ü© ‚ü®Y‚ü©, tidy }‚ü© }
lemma tensor_func_map_app {X Y : F C} (f : X ‚ü∂ Y) (n) : ((tensor_func C).map f).app n =
  ùüô _ ‚äó f :=
rfl
lemma tensor_func_obj_map (Z : F C) {n n' : N C} (f : n ‚ü∂ n') :
  ((tensor_func C).obj Z).map f = inclusion.map f ‚äó ùüô Z :=
by { cases n, cases n', tidy }
@[simp] def normalize_iso_app :
  Œ† (X : F C) (n : N C), ((tensor_func C).obj X).obj n ‚âÖ ((normalize' C).obj X).obj n
| (of X) n := iso.refl _
| unit n := œÅ_ _
| (tensor X Y) n :=
    (Œ±_ _ _ _).symm ‚â™‚â´ tensor_iso (normalize_iso_app X n) (iso.refl _) ‚â™‚â´ normalize_iso_app _ _
@[simp] lemma normalize_iso_app_tensor (X Y : F C) (n : N C) :
  normalize_iso_app C (X ‚äó Y) n =
  (Œ±_ _ _ _).symm ‚â™‚â´ tensor_iso (normalize_iso_app C X n) (iso.refl _) ‚â™‚â´
    normalize_iso_app _ _ _ :=
rfl
@[simp] lemma normalize_iso_app_unitor (n : N C) : normalize_iso_app C (ùüô_ (F C)) n = œÅ_ _ :=
rfl
@[simp] def normalize_iso_aux (X : F C) : (tensor_func C).obj X ‚âÖ (normalize' C).obj X :=
nat_iso.of_components (normalize_iso_app C X) (by { rintros ‚ü®X‚ü© ‚ü®Y‚ü©, tidy })
section
variables {D : Type u} [category.{u} D] {I : Type u} (f : I ‚Üí D) (X : discrete I)
def normalize_iso : tensor_func C ‚âÖ normalize' C :=
nat_iso.of_components (normalize_iso_aux C)
begin
  rintros X Y f,
  apply quotient.induction_on f,
  intro f,
  ext n,
  induction f generalizing n,
  { simp only [mk_id, functor.map_id, category.id_comp, category.comp_id] },
  { dsimp,
    simp only [id_tensor_associator_inv_naturality_assoc, ‚Üêpentagon_inv_assoc,
      tensor_hom_inv_id_assoc, tensor_id, category.id_comp, discrete.functor_map_id, comp_tensor_id,
      iso.cancel_iso_inv_left, category.assoc],
    dsimp, simp only [category.comp_id], },
  { dsimp,
    simp only [discrete.functor_map_id, comp_tensor_id, category.assoc, pentagon_inv_assoc,
      ‚Üêassociator_inv_naturality_assoc, tensor_id, iso.cancel_iso_inv_left],
    dsimp, simp only [category.comp_id],},
  { dsimp,
    rw triangle_assoc_comp_right_assoc,
    simp only [discrete.functor_map_id, category.assoc],
    cases n,
    dsimp, simp only [category.comp_id] },
  { dsimp,
    simp only [triangle_assoc_comp_left_inv_assoc, inv_hom_id_tensor_assoc, tensor_id,
      category.id_comp, discrete.functor_map_id],
    dsimp, simp only [category.comp_id],
    cases n, simp },
  { dsimp,
    rw [‚Üê(iso.inv_comp_eq _).2 (right_unitor_tensor _ _), category.assoc, ‚Üêright_unitor_naturality],
    simp only [iso.cancel_iso_inv_left, category.assoc],
    congr' 1,
    convert (category.comp_id _).symm,
    convert discrete_functor_map_eq_id inclusion_obj _ _,
    ext,
    refl },
  { dsimp,
    simp only [‚Üê(iso.eq_comp_inv _).1 (right_unitor_tensor_inv _ _), right_unitor_conjugation,
      category.assoc, iso.hom_inv_id, iso.hom_inv_id_assoc, iso.inv_hom_id, iso.inv_hom_id_assoc],
    congr,
    convert (discrete_functor_map_eq_id inclusion_obj _ _).symm,
    ext, refl, },
  { dsimp at *,
    rw [id_tensor_comp, category.assoc, f_ih_g ‚ü¶f_g‚üß, ‚Üêcategory.assoc, f_ih_f ‚ü¶f_f‚üß, category.assoc,
      ‚Üêfunctor.map_comp],
    congr' 2 },
  { dsimp at *,
    rw associator_inv_naturality_assoc,
    slice_lhs 2 3 { rw [‚Üêtensor_comp, f_ih_f ‚ü¶f_f‚üß] },
    conv_lhs { rw [‚Üê@category.id_comp (F C) _ _ _ ‚ü¶f_g‚üß] },
    simp only [category.comp_id, tensor_comp, category.assoc],
    congr' 2,
    rw [‚Üêmk_tensor, quotient.lift_mk],
    dsimp,
    rw [functor.map_comp, ‚Üêcategory.assoc, ‚Üêf_ih_g ‚ü¶f_g‚üß, ‚Üê@category.comp_id (F C) _ _ _ ‚ü¶f_g‚üß,
      ‚Üêcategory.id_comp ((discrete.functor inclusion_obj).map _), tensor_comp],
    dsimp,
    simp only [category.assoc, category.comp_id],
    congr' 1,
    convert (normalize_iso_aux C f_Z).hom.naturality ((normalize_map_aux f_f).app n),
    exact (tensor_func_obj_map _ _ _).symm }
end
def full_normalize_iso : ùü≠ (F C) ‚âÖ full_normalize C ‚ãô inclusion :=
nat_iso.of_components
  (Œª X, (Œª_ X).symm ‚â™‚â´ ((normalize_iso C).app X).app ‚ü®normal_monoidal_object.unit‚ü©)
  begin
    intros X Y f,
    dsimp,
    rw [left_unitor_inv_naturality_assoc, category.assoc, iso.cancel_iso_inv_left],
    exact congr_arg (Œª f, nat_trans.app f (discrete.mk normal_monoidal_object.unit))
      ((normalize_iso.{u} C).hom.naturality f)
  end
end
instance subsingleton_hom {X Y : F C} : subsingleton (X ‚ü∂ Y) :=
‚ü®Œª f g, have (full_normalize C).map f = (full_normalize C).map g, from subsingleton.elim _ _,
 begin
  rw [‚Üêfunctor.id_map f, ‚Üêfunctor.id_map g],
  simp [‚Üênat_iso.naturality_2 (full_normalize_iso.{u} C), this]
 end‚ü©
section groupoid
section
open hom
def inverse_aux : Œ† {X Y : F C}, (X ‚ü∂·µê Y) ‚Üí (Y ‚ü∂·µê X)
| _ _ (id X) := id X
| _ _ (Œ±_hom _ _ _) := Œ±_inv _ _ _
| _ _ (Œ±_inv _ _ _) := Œ±_hom _ _ _
| _ _ (œÅ_hom _) := œÅ_inv _
| _ _ (œÅ_inv _) := œÅ_hom _
| _ _ (l_hom _) := l_inv _
| _ _ (l_inv _) := l_hom _
| _ _ (comp f g) := (inverse_aux g).comp (inverse_aux f)
| _ _ (hom.tensor f g) := (inverse_aux f).tensor (inverse_aux g)
end
instance : groupoid.{u} (F C) :=
{ inv := Œª X Y, quotient.lift (Œª f, ‚ü¶inverse_aux f‚üß) (by tidy),
  ..(infer_instance : category (F C)) }
end groupoid
end free_monoidal_category
end category_theory
