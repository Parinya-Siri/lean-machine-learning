import algebraic_geometry.ringed_space
import algebraic_geometry.stalks
import logic.equiv.transfer_instance
universes v u
open category_theory
open Top
open topological_space
open opposite
open category_theory.category category_theory.functor
namespace algebraic_geometry
@[nolint has_inhabited_instance]
structure LocallyRingedSpace extends SheafedSpace CommRing :=
(local_ring : ‚àÄ x, local_ring (presheaf.stalk x))
attribute [instance] LocallyRingedSpace.local_ring
namespace LocallyRingedSpace
variables (X : LocallyRingedSpace)
def to_RingedSpace : RingedSpace := X.to_SheafedSpace
def to_Top : Top := X.1.carrier
instance : has_coe_to_sort LocallyRingedSpace (Type u) :=
‚ü®Œª X : LocallyRingedSpace, (X.to_Top : Type u)‚ü©
instance (x : X) : _root_.local_ring (X.to_PresheafedSpace.stalk x) := X.local_ring x
def ùí™ : sheaf CommRing X.to_Top := X.to_SheafedSpace.sheaf
def hom (X Y : LocallyRingedSpace) : Type* :=
{ f : X.to_SheafedSpace ‚ü∂ Y.to_SheafedSpace //
    ‚àÄ x, is_local_ring_hom (PresheafedSpace.stalk_map f x) }
instance : quiver LocallyRingedSpace := ‚ü®hom‚ü©
@[ext] lemma hom_ext {X Y : LocallyRingedSpace} (f g : hom X Y) (w : f.1 = g.1) : f = g :=
subtype.eq w
noncomputable
def stalk_map {X Y : LocallyRingedSpace} (f : X ‚ü∂ Y) (x : X) :
  Y.stalk (f.1.1 x) ‚ü∂ X.stalk x :=
PresheafedSpace.stalk_map f.1 x
instance {X Y : LocallyRingedSpace} (f : X ‚ü∂ Y) (x : X) :
  is_local_ring_hom (stalk_map f x) := f.2 x
instance {X Y : LocallyRingedSpace} (f : X ‚ü∂ Y) (x : X) :
   is_local_ring_hom (PresheafedSpace.stalk_map f.1 x) := f.2 x
@[simps]
def id (X : LocallyRingedSpace) : hom X X :=
‚ü®ùüô _, Œª x, by { erw PresheafedSpace.stalk_map.id, apply is_local_ring_hom_id, }‚ü©
instance (X : LocallyRingedSpace) : inhabited (hom X X) := ‚ü®id X‚ü©
@[simps]
def comp {X Y Z : LocallyRingedSpace} (f : hom X Y) (g : hom Y Z) : hom X Z :=
‚ü®f.val ‚â´ g.val, Œª x,
begin
  erw PresheafedSpace.stalk_map.comp,
  exact @is_local_ring_hom_comp _ _ _ _ _ _ _ _ (f.2 _) (g.2 _),
end‚ü©
instance : category LocallyRingedSpace :=
{ hom := hom,
  id := id,
  comp := Œª X Y Z f g, comp f g,
  comp_id' := by { intros, ext1, simp, },
  id_comp' := by { intros, ext1, simp, },
  assoc' := by { intros, ext1, simp, }, }.
@[simps] def forget_to_SheafedSpace : LocallyRingedSpace ‚•§ SheafedSpace CommRing :=
{ obj := Œª X, X.to_SheafedSpace,
  map := Œª X Y f, f.1, }
instance : faithful forget_to_SheafedSpace := {}
@[simps]
def forget_to_Top : LocallyRingedSpace ‚•§ Top :=
forget_to_SheafedSpace ‚ãô SheafedSpace.forget _
@[simp] lemma comp_val {X Y Z : LocallyRingedSpace} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  (f ‚â´ g).val = f.val ‚â´ g.val := rfl
@[simp] lemma comp_val_c {X Y Z : LocallyRingedSpace} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  (f ‚â´ g).val.c = g.val.c ‚â´ (presheaf.pushforward _ g.val.base).map f.val.c := rfl
lemma comp_val_c_app {X Y Z : LocallyRingedSpace} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (U : (opens Z)·µí·µñ) :
  (f ‚â´ g).val.c.app U = g.val.c.app U ‚â´ f.val.c.app (op $ (opens.map g.val.base).obj U.unop) :=
rfl
@[simps]
def hom_of_SheafedSpace_hom_of_is_iso {X Y : LocallyRingedSpace}
  (f : X.to_SheafedSpace ‚ü∂ Y.to_SheafedSpace) [is_iso f] : X ‚ü∂ Y :=
subtype.mk f $ Œª x,
def iso_of_SheafedSpace_iso {X Y : LocallyRingedSpace}
  (f : X.to_SheafedSpace ‚âÖ Y.to_SheafedSpace) : X ‚âÖ Y :=
{ hom := hom_of_SheafedSpace_hom_of_is_iso f.hom,
  inv := hom_of_SheafedSpace_hom_of_is_iso f.inv,
  hom_inv_id' := hom_ext _ _ f.hom_inv_id,
  inv_hom_id' := hom_ext _ _ f.inv_hom_id }
instance : reflects_isomorphisms forget_to_SheafedSpace :=
{ reflects := Œª X Y f i,
  { out := by exactI
    ‚ü®hom_of_SheafedSpace_hom_of_is_iso (category_theory.inv (forget_to_SheafedSpace.map f)),
      hom_ext _ _ (is_iso.hom_inv_id _), hom_ext _ _ (is_iso.inv_hom_id _)‚ü© } }
instance is_SheafedSpace_iso {X Y : LocallyRingedSpace} (f : X ‚ü∂ Y) [is_iso f] :
  is_iso f.1 :=
LocallyRingedSpace.forget_to_SheafedSpace.map_is_iso f
@[simps]
def restrict {U : Top} (X : LocallyRingedSpace) {f : U ‚ü∂ X.to_Top}
  (h : open_embedding f) : LocallyRingedSpace :=
{ local_ring :=
  begin
    intro x,
    dsimp at *,
def of_restrict {U : Top} (X : LocallyRingedSpace) {f : U ‚ü∂ X.to_Top}
  (h : open_embedding f) : X.restrict h ‚ü∂ X :=
‚ü®X.to_PresheafedSpace.of_restrict h, Œª x, infer_instance‚ü©
def restrict_top_iso (X : LocallyRingedSpace) :
  X.restrict (opens.open_embedding ‚ä§) ‚âÖ X :=
@iso_of_SheafedSpace_iso (X.restrict (opens.open_embedding ‚ä§)) X
  X.to_SheafedSpace.restrict_top_iso
def Œì : LocallyRingedSpace·µí·µñ ‚•§ CommRing :=
forget_to_SheafedSpace.op ‚ãô SheafedSpace.Œì
lemma Œì_def : Œì = forget_to_SheafedSpace.op ‚ãô SheafedSpace.Œì := rfl
@[simp] lemma Œì_obj (X : LocallyRingedSpace·µí·µñ) : Œì.obj X = (unop X).presheaf.obj (op ‚ä§) := rfl
lemma Œì_obj_op (X : LocallyRingedSpace) : Œì.obj (op X) = X.presheaf.obj (op ‚ä§) := rfl
@[simp] lemma Œì_map {X Y : LocallyRingedSpace·µí·µñ} (f : X ‚ü∂ Y) :
  Œì.map f = f.unop.1.c.app (op ‚ä§) := rfl
lemma Œì_map_op {X Y : LocallyRingedSpace} (f : X ‚ü∂ Y) :
  Œì.map f.op = f.1.c.app (op ‚ä§) := rfl
lemma preimage_basic_open {X Y : LocallyRingedSpace} (f : X ‚ü∂ Y) {U : opens Y}
  (s : Y.presheaf.obj (op U)) :
  (opens.map f.1.base).obj (Y.to_RingedSpace.basic_open s) =
    @RingedSpace.basic_open X.to_RingedSpace ((opens.map f.1.base).obj U) (f.1.c.app _ s) :=
begin
  ext,
  split,
  { rintros ‚ü®‚ü®y, hyU‚ü©, (hy : is_unit _), (rfl : y = _)‚ü©,
    erw RingedSpace.mem_basic_open _ _ ‚ü®x, show x ‚àà (opens.map f.1.base).obj U, from hyU‚ü©,
    rw ‚Üê PresheafedSpace.stalk_map_germ_apply,
    exact (PresheafedSpace.stalk_map f.1 _).is_unit_map hy },
  { rintros ‚ü®y, (hy : is_unit _), rfl‚ü©,
    erw RingedSpace.mem_basic_open _ _ ‚ü®f.1.base y.1, y.2‚ü©,
    rw ‚Üê PresheafedSpace.stalk_map_germ_apply at hy,
    exact (is_unit_map_iff (PresheafedSpace.stalk_map f.1 _) _).mp hy }
end
