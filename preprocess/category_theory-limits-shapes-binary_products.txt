import category_theory.limits.shapes.terminal
import category_theory.discrete_category
import category_theory.epi_mono
import category_theory.over
noncomputable theory
universes v u uâ‚‚
open category_theory
namespace category_theory.limits
@[derive decidable_eq, derive inhabited]
inductive walking_pair : Type
| left | right
open walking_pair
def walking_pair.swap : walking_pair â‰ƒ walking_pair :=
{ to_fun := Î» j, walking_pair.rec_on j right left,
  inv_fun := Î» j, walking_pair.rec_on j right left,
  left_inv := Î» j, by { cases j; refl, },
  right_inv := Î» j, by { cases j; refl, }, }
@[simp] lemma walking_pair.swap_apply_left : walking_pair.swap left = right := rfl
@[simp] lemma walking_pair.swap_apply_right : walking_pair.swap right = left := rfl
@[simp] lemma walking_pair.swap_symm_apply_tt : walking_pair.swap.symm left = right := rfl
@[simp] lemma walking_pair.swap_symm_apply_ff : walking_pair.swap.symm right = left := rfl
def walking_pair.equiv_bool : walking_pair â‰ƒ bool :=
def pair_function (X Y : C) : walking_pair â†’ C := Î» j, walking_pair.cases_on j X Y
@[simp] lemma pair_function_left (X Y : C) : pair_function X Y left = X := rfl
@[simp] lemma pair_function_right (X Y : C) : pair_function X Y right = Y := rfl
variables [category.{v} C]
def pair (X Y : C) : discrete walking_pair â¥¤ C :=
discrete.functor (Î» j, walking_pair.cases_on j X Y)
@[simp] lemma pair_obj_left (X Y : C) : (pair X Y).obj âŸ¨leftâŸ© = X := rfl
@[simp] lemma pair_obj_right (X Y : C) : (pair X Y).obj âŸ¨rightâŸ© = Y := rfl
section
variables {F G : discrete walking_pair â¥¤ C} (f : F.obj âŸ¨leftâŸ© âŸ¶ G.obj âŸ¨leftâŸ©)
  (g : F.obj âŸ¨rightâŸ© âŸ¶ G.obj âŸ¨rightâŸ©)
local attribute [tidy] tactic.discrete_cases
def map_pair : F âŸ¶ G := { app := Î» j, discrete.rec_on j (Î» j, walking_pair.cases_on j f g) }
@[simp] lemma map_pair_left : (map_pair f g).app âŸ¨leftâŸ© = f := rfl
@[simp] lemma map_pair_right : (map_pair f g).app âŸ¨rightâŸ© = g := rfl
@[simps]
def map_pair_iso (f : F.obj âŸ¨leftâŸ© â‰… G.obj âŸ¨leftâŸ©) (g : F.obj âŸ¨rightâŸ© â‰… G.obj âŸ¨rightâŸ©) : F â‰… G :=
nat_iso.of_components (Î» j, discrete.rec_on j (Î» j, walking_pair.cases_on j f g)) (by tidy)
end
@[simps]
def diagram_iso_pair (F : discrete walking_pair â¥¤ C) :
  F â‰… pair (F.obj âŸ¨walking_pair.leftâŸ©) (F.obj âŸ¨walking_pair.rightâŸ©) :=
map_pair_iso (iso.refl _) (iso.refl _)
section
variables {D : Type u} [category.{v} D]
def pair_comp (X Y : C) (F : C â¥¤ D) : pair X Y â‹™ F â‰… pair (F.obj X) (F.obj Y) :=
diagram_iso_pair _
end
abbreviation binary_fan (X Y : C) := cone (pair X Y)
abbreviation binary_fan.fst {X Y : C} (s : binary_fan X Y) := s.Ï€.app âŸ¨walking_pair.leftâŸ©
abbreviation binary_fan.snd {X Y : C} (s : binary_fan X Y) := s.Ï€.app âŸ¨walking_pair.rightâŸ©
@[simp] lemma binary_fan.Ï€_app_left {X Y : C} (s : binary_fan X Y) :
  s.Ï€.app âŸ¨walking_pair.leftâŸ© = s.fst := rfl
@[simp] lemma binary_fan.Ï€_app_right {X Y : C} (s : binary_fan X Y) :
  s.Ï€.app âŸ¨walking_pair.rightâŸ© = s.snd := rfl
def binary_fan.is_limit.mk {X Y : C} (s : binary_fan X Y)
  (lift : Î  {T : C} (f : T âŸ¶ X) (g : T âŸ¶ Y), T âŸ¶ s.X)
  (hlâ‚ : âˆ€ {T : C} (f : T âŸ¶ X) (g : T âŸ¶ Y), lift f g â‰« s.fst = f)
  (hlâ‚‚ : âˆ€ {T : C} (f : T âŸ¶ X) (g : T âŸ¶ Y), lift f g â‰« s.snd = g)
  (uniq : âˆ€ {T : C} (f : T âŸ¶ X) (g : T âŸ¶ Y) (m : T âŸ¶ s.X) (hâ‚ : m â‰« s.fst = f)
    (hâ‚‚ : m â‰« s.snd = g), m = lift f g) : is_limit s := is_limit.mk
  (Î» t, lift (binary_fan.fst t) (binary_fan.snd t))
  (by { rintros t (rfl|rfl), { exact hlâ‚ _ _ }, { exact hlâ‚‚ _ _ } })
  (Î» t m h, uniq _ _ _ (h âŸ¨walking_pair.leftâŸ©) (h âŸ¨walking_pair.rightâŸ©))
lemma binary_fan.is_limit.hom_ext {W X Y : C} {s : binary_fan X Y} (h : is_limit s)
  {f g : W âŸ¶ s.X} (hâ‚ : f â‰« s.fst = g â‰« s.fst) (hâ‚‚ : f â‰« s.snd = g â‰« s.snd) : f = g :=
h.hom_ext $ Î» j, discrete.rec_on j (Î» j, walking_pair.cases_on j hâ‚ hâ‚‚)
abbreviation binary_cofan (X Y : C) := cocone (pair X Y)
abbreviation binary_cofan.inl {X Y : C} (s : binary_cofan X Y) := s.Î¹.app âŸ¨walking_pair.leftâŸ©
abbreviation binary_cofan.inr {X Y : C} (s : binary_cofan X Y) := s.Î¹.app âŸ¨walking_pair.rightâŸ©
@[simp] lemma binary_cofan.Î¹_app_left {X Y : C} (s : binary_cofan X Y) :
  s.Î¹.app âŸ¨walking_pair.leftâŸ© = s.inl := rfl
@[simp] lemma binary_cofan.Î¹_app_right {X Y : C} (s : binary_cofan X Y) :
  s.Î¹.app âŸ¨walking_pair.rightâŸ© = s.inr := rfl
def binary_cofan.is_colimit.mk {X Y : C} (s : binary_cofan X Y)
  (desc : Î  {T : C} (f : X âŸ¶ T) (g : Y âŸ¶ T), s.X âŸ¶ T)
  (hdâ‚ : âˆ€ {T : C} (f : X âŸ¶ T) (g : Y âŸ¶ T), s.inl â‰« desc f g = f)
  (hdâ‚‚ : âˆ€ {T : C} (f : X âŸ¶ T) (g : Y âŸ¶ T), s.inr â‰« desc f g = g)
  (uniq : âˆ€ {T : C} (f : X âŸ¶ T) (g : Y âŸ¶ T) (m : s.X âŸ¶ T) (hâ‚ : s.inl â‰« m = f)
    (hâ‚‚ : s.inr â‰« m = g), m = desc f g) : is_colimit s := is_colimit.mk
    (Î» t, desc (binary_cofan.inl t) (binary_cofan.inr t))
    (by { rintros t (rfl|rfl), { exact hdâ‚ _ _ }, { exact hdâ‚‚ _ _ }})
    (Î» t m h, uniq _ _ _ (h âŸ¨walking_pair.leftâŸ©) (h âŸ¨walking_pair.rightâŸ©))
lemma binary_cofan.is_colimit.hom_ext {W X Y : C} {s : binary_cofan X Y} (h : is_colimit s)
  {f g : s.X âŸ¶ W} (hâ‚ : s.inl â‰« f = s.inl â‰« g) (hâ‚‚ : s.inr â‰« f = s.inr â‰« g) : f = g :=
h.hom_ext $ Î» j, discrete.rec_on j (Î» j, walking_pair.cases_on j hâ‚ hâ‚‚)
variables {X Y : C}
section
local attribute [tidy] tactic.discrete_cases
@[simps X]
def binary_fan.mk {P : C} (Ï€â‚ : P âŸ¶ X) (Ï€â‚‚ : P âŸ¶ Y) : binary_fan X Y :=
{ X := P,
  Ï€ := { app := Î» j, discrete.rec_on j (Î» j, walking_pair.cases_on j Ï€â‚ Ï€â‚‚) }}
@[simps X]
def binary_cofan.mk {P : C} (Î¹â‚ : X âŸ¶ P) (Î¹â‚‚ : Y âŸ¶ P) : binary_cofan X Y :=
{ X := P,
  Î¹ := { app := Î» j, discrete.rec_on j (Î» j, walking_pair.cases_on j Î¹â‚ Î¹â‚‚) }}
end
@[simp] lemma binary_fan.mk_Ï€_app_left {P : C} (Ï€â‚ : P âŸ¶ X) (Ï€â‚‚ : P âŸ¶ Y) :
  (binary_fan.mk Ï€â‚ Ï€â‚‚).Ï€.app âŸ¨walking_pair.leftâŸ© = Ï€â‚ := rfl
@[simp] lemma binary_fan.mk_Ï€_app_right {P : C} (Ï€â‚ : P âŸ¶ X) (Ï€â‚‚ : P âŸ¶ Y) :
  (binary_fan.mk Ï€â‚ Ï€â‚‚).Ï€.app âŸ¨walking_pair.rightâŸ© = Ï€â‚‚ := rfl
@[simp] lemma binary_cofan.mk_Î¹_app_left {P : C} (Î¹â‚ : X âŸ¶ P) (Î¹â‚‚ : Y âŸ¶ P) :
  (binary_cofan.mk Î¹â‚ Î¹â‚‚).Î¹.app âŸ¨walking_pair.leftâŸ© = Î¹â‚ := rfl
@[simp] lemma binary_cofan.mk_Î¹_app_right {P : C} (Î¹â‚ : X âŸ¶ P) (Î¹â‚‚ : Y âŸ¶ P) :
  (binary_cofan.mk Î¹â‚ Î¹â‚‚).Î¹.app âŸ¨walking_pair.rightâŸ© = Î¹â‚‚ := rfl
@[simps]
def binary_fan.is_limit.lift' {W X Y : C} {s : binary_fan X Y} (h : is_limit s) (f : W âŸ¶ X)
  (g : W âŸ¶ Y) : {l : W âŸ¶ s.X // l â‰« s.fst = f âˆ§ l â‰« s.snd = g} :=
âŸ¨h.lift $ binary_fan.mk f g, h.fac _ _, h.fac _ _âŸ©
@[simps]
def binary_cofan.is_colimit.desc' {W X Y : C} {s : binary_cofan X Y} (h : is_colimit s) (f : X âŸ¶ W)
  (g : Y âŸ¶ W) : {l : s.X âŸ¶ W // s.inl â‰« l = f âˆ§ s.inr â‰« l = g} :=
âŸ¨h.desc $ binary_cofan.mk f g, h.fac _ _, h.fac _ _âŸ©
abbreviation has_binary_product (X Y : C) := has_limit (pair X Y)
abbreviation has_binary_coproduct (X Y : C) := has_colimit (pair X Y)
abbreviation prod (X Y : C) [has_binary_product X Y] := limit (pair X Y)
abbreviation coprod (X Y : C) [has_binary_coproduct X Y] := colimit (pair X Y)
notation X ` â¨¯ `:20 Y:20 := prod X Y
notation X ` â¨¿ `:20 Y:20 := coprod X Y
abbreviation prod.fst {X Y : C} [has_binary_product X Y] : X â¨¯ Y âŸ¶ X :=
limit.Ï€ (pair X Y) âŸ¨walking_pair.leftâŸ©
abbreviation prod.snd {X Y : C} [has_binary_product X Y] : X â¨¯ Y âŸ¶ Y :=
limit.Ï€ (pair X Y) âŸ¨walking_pair.rightâŸ©
abbreviation coprod.inl {X Y : C} [has_binary_coproduct X Y] : X âŸ¶ X â¨¿ Y :=
colimit.Î¹ (pair X Y) âŸ¨walking_pair.leftâŸ©
abbreviation coprod.inr {X Y : C} [has_binary_coproduct X Y] : Y âŸ¶ X â¨¿ Y :=
colimit.Î¹ (pair X Y) âŸ¨walking_pair.rightâŸ©
def prod_is_prod (X Y : C) [has_binary_product X Y] :
  is_limit (binary_fan.mk (prod.fst : X â¨¯ Y âŸ¶ X) prod.snd) :=
(limit.is_limit _).of_iso_limit (cones.ext (iso.refl _) (by { rintro (_ | _), tidy }))
def coprod_is_coprod (X Y : C) [has_binary_coproduct X Y] :
  is_colimit (binary_cofan.mk (coprod.inl : X âŸ¶ X â¨¿ Y) coprod.inr) :=
(colimit.is_colimit _).of_iso_colimit (cocones.ext (iso.refl _) (by { rintro (_ | _), tidy }))
@[ext] lemma prod.hom_ext {W X Y : C} [has_binary_product X Y] {f g : W âŸ¶ X â¨¯ Y}
  (hâ‚ : f â‰« prod.fst = g â‰« prod.fst) (hâ‚‚ : f â‰« prod.snd = g â‰« prod.snd) : f = g :=
binary_fan.is_limit.hom_ext (limit.is_limit _) hâ‚ hâ‚‚
@[ext] lemma coprod.hom_ext {W X Y : C} [has_binary_coproduct X Y] {f g : X â¨¿ Y âŸ¶ W}
  (hâ‚ : coprod.inl â‰« f = coprod.inl â‰« g) (hâ‚‚ : coprod.inr â‰« f = coprod.inr â‰« g) : f = g :=
binary_cofan.is_colimit.hom_ext (colimit.is_colimit _) hâ‚ hâ‚‚
abbreviation prod.lift {W X Y : C} [has_binary_product X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) : W âŸ¶ X â¨¯ Y :=
limit.lift _ (binary_fan.mk f g)
abbreviation diag (X : C) [has_binary_product X X] : X âŸ¶ X â¨¯ X :=
prod.lift (ğŸ™ _) (ğŸ™ _)
abbreviation coprod.desc {W X Y : C} [has_binary_coproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) :
  X â¨¿ Y âŸ¶ W :=
colimit.desc _ (binary_cofan.mk f g)
abbreviation codiag (X : C) [has_binary_coproduct X X] : X â¨¿ X âŸ¶ X :=
coprod.desc (ğŸ™ _) (ğŸ™ _)
@[simp, reassoc]
lemma prod.lift_fst {W X Y : C} [has_binary_product X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :
  prod.lift f g â‰« prod.fst = f :=
limit.lift_Ï€ _ _
@[simp, reassoc]
lemma prod.lift_snd {W X Y : C} [has_binary_product X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :
  prod.lift f g â‰« prod.snd = g :=
limit.lift_Ï€ _ _
def prod.lift' {W X Y : C} [has_binary_product X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :
  {l : W âŸ¶ X â¨¯ Y // l â‰« prod.fst = f âˆ§ l â‰« prod.snd = g} :=
âŸ¨prod.lift f g, prod.lift_fst _ _, prod.lift_snd _ _âŸ©
def coprod.desc' {W X Y : C} [has_binary_coproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) :
  {l : X â¨¿ Y âŸ¶ W // coprod.inl â‰« l = f âˆ§ coprod.inr â‰« l = g} :=
âŸ¨coprod.desc f g, coprod.inl_desc _ _, coprod.inr_desc _ _âŸ©
def prod.map {W X Y Z : C} [has_binary_product W X] [has_binary_product Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) : W â¨¯ X âŸ¶ Y â¨¯ Z :=
lim_map (map_pair f g)
def coprod.map {W X Y Z : C} [has_binary_coproduct W X] [has_binary_coproduct Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) : W â¨¿ X âŸ¶ Y â¨¿ Z :=
colim_map (map_pair f g)
section prod_lemmas
@[simps]
def prod.map_iso {W X Y Z : C} [has_binary_product W X] [has_binary_product Y Z]
  (f : W â‰… Y) (g : X â‰… Z) : W â¨¯ X â‰… Y â¨¯ Z :=
{ hom := prod.map f.hom g.hom,
  inv := prod.map f.inv g.inv }
instance is_iso_prod {W X Y Z : C} [has_binary_product W X] [has_binary_product Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) [is_iso f] [is_iso g] : is_iso (prod.map f g) :=
is_iso.of_iso (prod.map_iso (as_iso f) (as_iso g))
instance prod.map_mono {C : Type*} [category C] {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [mono f]
  [mono g] [has_binary_product W X] [has_binary_product Y Z] : mono (prod.map f g) :=
âŸ¨Î» A iâ‚ iâ‚‚ h, begin
  ext,
  { rw â† cancel_mono f, simpa using congr_arg (Î» f, f â‰« prod.fst) h },
  { rw â† cancel_mono g, simpa using congr_arg (Î» f, f â‰« prod.snd) h }
endâŸ©
@[simp, reassoc]
lemma prod.diag_map {X Y : C} (f : X âŸ¶ Y) [has_binary_product X X] [has_binary_product Y Y] :
  diag X â‰« prod.map f f = f â‰« diag Y :=
by simp
@[simp, reassoc]
lemma prod.diag_map_fst_snd {X Y : C} [has_binary_product X Y]
  [has_binary_product (X â¨¯ Y) (X â¨¯ Y)] :
  diag (X â¨¯ Y) â‰« prod.map prod.fst prod.snd = ğŸ™ (X â¨¯ Y) :=
by simp
@[simp, reassoc]
lemma prod.diag_map_fst_snd_comp  [has_limits_of_shape (discrete walking_pair) C]
  {X X' Y Y' : C} (g : X âŸ¶ Y) (g' : X' âŸ¶ Y') :
  diag (X â¨¯ X') â‰« prod.map (prod.fst â‰« g) (prod.snd â‰« g') = prod.map g g' :=
by simp
instance {X : C} [has_binary_product X X] : split_mono (diag X) :=
{ retraction := prod.fst }
end prod_lemmas
section coprod_lemmas
@[simp, reassoc]
lemma coprod.desc_comp {V W X Y : C} [has_binary_coproduct X Y] (f : V âŸ¶ W) (g : X âŸ¶ V)
  (h : Y âŸ¶ V) :
  coprod.desc g h â‰« f = coprod.desc (g â‰« f) (h â‰« f) :=
by { ext; simp }
lemma coprod.diag_comp {X Y : C} [has_binary_coproduct X X] (f : X âŸ¶ Y) :
  codiag X â‰« f = coprod.desc f f :=
by simp
@[simp, reassoc]
lemma coprod.inl_map {W X Y Z : C} [has_binary_coproduct W X] [has_binary_coproduct Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) : coprod.inl â‰« coprod.map f g = f â‰« coprod.inl :=
Î¹_colim_map _ _
@[simp, reassoc]
lemma coprod.inr_map {W X Y Z : C} [has_binary_coproduct W X] [has_binary_coproduct Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) : coprod.inr â‰« coprod.map f g = g â‰« coprod.inr :=
Î¹_colim_map _ _
@[simp]
lemma coprod.map_id_id {X Y : C} [has_binary_coproduct X Y] :
  coprod.map (ğŸ™ X) (ğŸ™ Y) = ğŸ™ _ :=
by { ext; simp }
@[simp]
lemma coprod.desc_inl_inr {X Y : C} [has_binary_coproduct X Y] :
  coprod.desc coprod.inl coprod.inr = ğŸ™ (X â¨¿ Y) :=
by { ext; simp }
@[simps]
def coprod.map_iso {W X Y Z : C} [has_binary_coproduct W X] [has_binary_coproduct Y Z]
  (f : W â‰… Y) (g : X â‰… Z) : W â¨¿ X â‰… Y â¨¿ Z :=
{ hom := coprod.map f.hom g.hom,
  inv := coprod.map f.inv g.inv }
instance is_iso_coprod {W X Y Z : C} [has_binary_coproduct W X] [has_binary_coproduct Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) [is_iso f] [is_iso g] : is_iso (coprod.map f g) :=
is_iso.of_iso (coprod.map_iso (as_iso f) (as_iso g))
instance coprod.map_epi {C : Type*} [category C] {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [epi f]
  [epi g] [has_binary_coproduct W X] [has_binary_coproduct Y Z] : epi (coprod.map f g) :=
âŸ¨Î» A iâ‚ iâ‚‚ h, begin
  ext,
  { rw â† cancel_epi f, simpa using congr_arg (Î» f, coprod.inl â‰« f) h },
  { rw â† cancel_epi g, simpa using congr_arg (Î» f, coprod.inr â‰« f) h }
endâŸ©
abbreviation has_binary_products := has_limits_of_shape (discrete walking_pair) C
abbreviation has_binary_coproducts := has_colimits_of_shape (discrete walking_pair) C
lemma has_binary_products_of_has_limit_pair [Î  {X Y : C}, has_limit (pair X Y)] :
  has_binary_products C :=
{ has_limit := Î» F, has_limit_of_iso (diagram_iso_pair F).symm }
lemma has_binary_coproducts_of_has_colimit_pair [Î  {X Y : C}, has_colimit (pair X Y)] :
  has_binary_coproducts C :=
{ has_colimit := Î» F, has_colimit_of_iso (diagram_iso_pair F) }
section
variables {C}
@[simps] def prod.braiding (P Q : C) [has_binary_product P Q] [has_binary_product Q P] :
  P â¨¯ Q â‰… Q â¨¯ P :=
{ hom := prod.lift prod.snd prod.fst,
  inv := prod.lift prod.snd prod.fst }
@[reassoc] lemma braid_natural [has_binary_products C] {W X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ W) :
  prod.map f g â‰« (prod.braiding _ _).hom = (prod.braiding _ _).hom â‰« prod.map g f :=
by simp
@[reassoc] lemma prod.symmetry' (P Q : C) [has_binary_product P Q] [has_binary_product Q P] :
  prod.lift prod.snd prod.fst â‰« prod.lift prod.snd prod.fst = ğŸ™ (P â¨¯ Q) :=
(prod.braiding _ _).hom_inv_id
@[reassoc] lemma prod.symmetry (P Q : C) [has_binary_product P Q] [has_binary_product Q P] :
  (prod.braiding P Q).hom â‰« (prod.braiding Q P).hom = ğŸ™ _ :=
(prod.braiding _ _).hom_inv_id
@[simps] def prod.associator [has_binary_products C] (P Q R : C) :
  (P â¨¯ Q) â¨¯ R â‰… P â¨¯ (Q â¨¯ R) :=
{ hom :=
  prod.lift
    (prod.fst â‰« prod.fst)
    (prod.lift (prod.fst â‰« prod.snd) prod.snd),
  inv :=
  prod.lift
    (prod.lift prod.fst (prod.snd â‰« prod.fst))
    (prod.snd â‰« prod.snd) }
@[reassoc]
lemma prod.pentagon [has_binary_products C] (W X Y Z : C) :
  prod.map ((prod.associator W X Y).hom) (ğŸ™ Z) â‰«
      (prod.associator W (X â¨¯ Y) Z).hom â‰« prod.map (ğŸ™ W) ((prod.associator X Y Z).hom) =
    (prod.associator (W â¨¯ X) Y Z).hom â‰« (prod.associator W X (Y â¨¯ Z)).hom :=
by simp
@[reassoc]
lemma prod.associator_naturality [has_binary_products C] {Xâ‚ Xâ‚‚ Xâ‚ƒ Yâ‚ Yâ‚‚ Yâ‚ƒ : C}
  (fâ‚ : Xâ‚ âŸ¶ Yâ‚) (fâ‚‚ : Xâ‚‚ âŸ¶ Yâ‚‚) (fâ‚ƒ : Xâ‚ƒ âŸ¶ Yâ‚ƒ) :
  prod.map (prod.map fâ‚ fâ‚‚) fâ‚ƒ â‰« (prod.associator Yâ‚ Yâ‚‚ Yâ‚ƒ).hom =
    (prod.associator Xâ‚ Xâ‚‚ Xâ‚ƒ).hom â‰« prod.map fâ‚ (prod.map fâ‚‚ fâ‚ƒ) :=
by simp
variables [has_terminal C]
@[simps] def prod.left_unitor (P : C) [has_binary_product (âŠ¤_ C) P] :
  âŠ¤_ C â¨¯ P â‰… P :=
{ hom := prod.snd,
  inv := prod.lift (terminal.from P) (ğŸ™ _) }
@[simps] def prod.right_unitor (P : C) [has_binary_product P (âŠ¤_ C)] :
  P â¨¯ âŠ¤_ C â‰… P :=
{ hom := prod.fst,
  inv := prod.lift (ğŸ™ _) (terminal.from P) }
@[reassoc]
lemma prod.left_unitor_hom_naturality [has_binary_products C] (f : X âŸ¶ Y) :
  prod.map (ğŸ™ _) f â‰« (prod.left_unitor Y).hom = (prod.left_unitor X).hom â‰« f :=
prod.map_snd _ _
@[reassoc]
lemma prod.left_unitor_inv_naturality [has_binary_products C] (f : X âŸ¶ Y) :
  (prod.left_unitor X).inv â‰« prod.map (ğŸ™ _) f = f â‰« (prod.left_unitor Y).inv :=
by rw [iso.inv_comp_eq, â† category.assoc, iso.eq_comp_inv, prod.left_unitor_hom_naturality]
@[reassoc]
lemma prod.right_unitor_hom_naturality [has_binary_products C] (f : X âŸ¶ Y) :
  prod.map f (ğŸ™ _) â‰« (prod.right_unitor Y).hom = (prod.right_unitor X).hom â‰« f :=
prod.map_fst _ _
@[reassoc]
lemma prod_right_unitor_inv_naturality [has_binary_products C] (f : X âŸ¶ Y) :
  (prod.right_unitor X).inv â‰« prod.map f (ğŸ™ _) = f â‰« (prod.right_unitor Y).inv :=
by rw [iso.inv_comp_eq, â† category.assoc, iso.eq_comp_inv, prod.right_unitor_hom_naturality]
lemma prod.triangle [has_binary_products C] (X Y : C) :
  (prod.associator X (âŠ¤_ C) Y).hom â‰« prod.map (ğŸ™ X) ((prod.left_unitor Y).hom) =
    prod.map ((prod.right_unitor X).hom) (ğŸ™ Y) :=
by tidy
end
section
variables {C} [has_binary_coproducts C]
@[simps] def coprod.braiding (P Q : C) : P â¨¿ Q â‰… Q â¨¿ P :=
{ hom := coprod.desc coprod.inr coprod.inl,
  inv := coprod.desc coprod.inr coprod.inl }
@[reassoc] lemma coprod.symmetry' (P Q : C) :
  coprod.desc coprod.inr coprod.inl â‰« coprod.desc coprod.inr coprod.inl = ğŸ™ (P â¨¿ Q) :=
(coprod.braiding _ _).hom_inv_id
lemma coprod.symmetry (P Q : C) :
  (coprod.braiding P Q).hom â‰« (coprod.braiding Q P).hom = ğŸ™ _ :=
coprod.symmetry' _ _
@[simps] def coprod.associator
  (P Q R : C) : (P â¨¿ Q) â¨¿ R â‰… P â¨¿ (Q â¨¿ R) :=
{ hom :=
  coprod.desc
    (coprod.desc coprod.inl (coprod.inl â‰« coprod.inr))
    (coprod.inr â‰« coprod.inr),
  inv :=
  coprod.desc
    (coprod.inl â‰« coprod.inl)
    (coprod.desc (coprod.inr â‰« coprod.inl) coprod.inr) }
lemma coprod.pentagon (W X Y Z : C) :
  coprod.map ((coprod.associator W X Y).hom) (ğŸ™ Z) â‰«
      (coprod.associator W (X â¨¿ Y) Z).hom â‰« coprod.map (ğŸ™ W) ((coprod.associator X Y Z).hom) =
    (coprod.associator (W â¨¿ X) Y Z).hom â‰« (coprod.associator W X (Y â¨¿ Z)).hom :=
by simp
lemma coprod.associator_naturality {Xâ‚ Xâ‚‚ Xâ‚ƒ Yâ‚ Yâ‚‚ Yâ‚ƒ : C} (fâ‚ : Xâ‚ âŸ¶ Yâ‚) (fâ‚‚ : Xâ‚‚ âŸ¶ Yâ‚‚)
  (fâ‚ƒ : Xâ‚ƒ âŸ¶ Yâ‚ƒ) :
  coprod.map (coprod.map fâ‚ fâ‚‚) fâ‚ƒ â‰« (coprod.associator Yâ‚ Yâ‚‚ Yâ‚ƒ).hom =
    (coprod.associator Xâ‚ Xâ‚‚ Xâ‚ƒ).hom â‰« coprod.map fâ‚ (coprod.map fâ‚‚ fâ‚ƒ) :=
by simp
variables [has_initial C]
@[simps] def coprod.left_unitor
  (P : C) : âŠ¥_ C â¨¿ P â‰… P :=
{ hom := coprod.desc (initial.to P) (ğŸ™ _),
  inv := coprod.inr }
@[simps] def coprod.right_unitor
  (P : C) : P â¨¿ âŠ¥_ C â‰… P :=
{ hom := coprod.desc (ğŸ™ _) (initial.to P),
  inv := coprod.inl }
lemma coprod.triangle (X Y : C) :
  (coprod.associator X (âŠ¥_ C) Y).hom â‰« coprod.map (ğŸ™ X) ((coprod.left_unitor Y).hom) =
    coprod.map ((coprod.right_unitor X).hom) (ğŸ™ Y) :=
by tidy
end
section prod_functor
variables {C} [has_binary_products C]
@[simps]
def prod.functor : C â¥¤ C â¥¤ C :=
{ obj := Î» X, { obj := Î» Y, X â¨¯ Y, map := Î» Y Z, prod.map (ğŸ™ X) },
  map := Î» Y Z f, { app := Î» T, prod.map f (ğŸ™ T) }}
def prod.functor_left_comp (X Y : C) :
  prod.functor.obj (X â¨¯ Y) â‰… prod.functor.obj Y â‹™ prod.functor.obj X :=
nat_iso.of_components (prod.associator _ _) (by tidy)
end prod_functor
section coprod_functor
variables {C} [has_binary_coproducts C]
@[simps]
def coprod.functor : C â¥¤ C â¥¤ C :=
{ obj := Î» X, { obj := Î» Y, X â¨¿ Y, map := Î» Y Z, coprod.map (ğŸ™ X) },
  map := Î» Y Z f, { app := Î» T, coprod.map f (ğŸ™ T) }}
def coprod.functor_left_comp (X Y : C) :
  coprod.functor.obj (X â¨¿ Y) â‰… coprod.functor.obj Y â‹™ coprod.functor.obj X :=
nat_iso.of_components (coprod.associator _ _) (by tidy)
end coprod_functor
section prod_comparison
universe w
variables {C} {D : Type uâ‚‚} [category.{w} D]
variables (F : C â¥¤ D) {A A' B B' : C}
variables [has_binary_product A B] [has_binary_product A' B']
variables [has_binary_product (F.obj A) (F.obj B)] [has_binary_product (F.obj A') (F.obj B')]
def prod_comparison (F : C â¥¤ D) (A B : C)
  [has_binary_product A B] [has_binary_product (F.obj A) (F.obj B)] :
  F.obj (A â¨¯ B) âŸ¶ F.obj A â¨¯ F.obj B :=
prod.lift (F.map prod.fst) (F.map prod.snd)
@[simp, reassoc]
lemma prod_comparison_fst :
  prod_comparison F A B â‰« prod.fst = F.map prod.fst :=
prod.lift_fst _ _
@[simp, reassoc]
lemma prod_comparison_snd :
  prod_comparison F A B â‰« prod.snd = F.map prod.snd :=
prod.lift_snd _ _
@[reassoc] lemma prod_comparison_natural (f : A âŸ¶ A') (g : B âŸ¶ B') :
  F.map (prod.map f g) â‰« prod_comparison F A' B' =
    prod_comparison F A B â‰« prod.map (F.map f) (F.map g) :=
begin
  rw [prod_comparison, prod_comparison, prod.lift_map, â† F.map_comp, â† F.map_comp,
      prod.comp_lift, â† F.map_comp, prod.map_fst, â† F.map_comp, prod.map_snd]
end
@[simps]
def prod_comparison_nat_trans [has_binary_products C] [has_binary_products D]
  (F : C â¥¤ D) (A : C) :
  prod.functor.obj A â‹™ F âŸ¶ F â‹™ prod.functor.obj (F.obj A) :=
{ app := Î» B, prod_comparison F A B,
  naturality' := Î» B B' f, by simp [prod_comparison_natural] }
@[reassoc]
lemma inv_prod_comparison_map_fst [is_iso (prod_comparison F A B)] :
  inv (prod_comparison F A B) â‰« F.map prod.fst = prod.fst :=
by simp [is_iso.inv_comp_eq]
@[reassoc]
lemma inv_prod_comparison_map_snd [is_iso (prod_comparison F A B)] :
  inv (prod_comparison F A B) â‰« F.map prod.snd = prod.snd :=
by simp [is_iso.inv_comp_eq]
@[reassoc]
lemma prod_comparison_inv_natural (f : A âŸ¶ A') (g : B âŸ¶ B')
  [is_iso (prod_comparison F A B)] [is_iso (prod_comparison F A' B')] :
  inv (prod_comparison F A B) â‰« F.map (prod.map f g) =
    prod.map (F.map f) (F.map g) â‰« inv (prod_comparison F A' B') :=
by rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, prod_comparison_natural]
@[simps {rhs_md := semireducible}]
def prod_comparison_nat_iso [has_binary_products C] [has_binary_products D]
  (A : C) [âˆ€ B, is_iso (prod_comparison F A B)] :
  prod.functor.obj A â‹™ F â‰… F â‹™ prod.functor.obj (F.obj A) :=
{ hom := prod_comparison_nat_trans F A
  ..(@as_iso _ _ _ _ _ (nat_iso.is_iso_of_is_iso_app âŸ¨_, _âŸ©)) }
end prod_comparison
section coprod_comparison
universe w
variables {C} {D : Type uâ‚‚} [category.{w} D]
variables (F : C â¥¤ D) {A A' B B' : C}
variables [has_binary_coproduct A B] [has_binary_coproduct A' B']
variables [has_binary_coproduct (F.obj A) (F.obj B)] [has_binary_coproduct (F.obj A') (F.obj B')]
def coprod_comparison (F : C â¥¤ D) (A B : C)
  [has_binary_coproduct A B] [has_binary_coproduct (F.obj A) (F.obj B)] :
  F.obj A â¨¿ F.obj B âŸ¶ F.obj (A â¨¿ B) :=
coprod.desc (F.map coprod.inl) (F.map coprod.inr)
@[simp, reassoc]
lemma coprod_comparison_inl :
  coprod.inl â‰« coprod_comparison F A B  = F.map coprod.inl :=
coprod.inl_desc _ _
@[simp, reassoc]
lemma coprod_comparison_inr :
  coprod.inr â‰« coprod_comparison F A B = F.map coprod.inr :=
coprod.inr_desc _ _
@[reassoc] lemma coprod_comparison_natural (f : A âŸ¶ A') (g : B âŸ¶ B') :
  coprod_comparison F A B â‰« F.map (coprod.map f g) =
    coprod.map (F.map f) (F.map g) â‰« coprod_comparison F A' B' :=
begin
  rw [coprod_comparison, coprod_comparison, coprod.map_desc, â† F.map_comp, â† F.map_comp,
      coprod.desc_comp, â† F.map_comp, coprod.inl_map, â† F.map_comp, coprod.inr_map]
end
@[simps]
def coprod_comparison_nat_trans [has_binary_coproducts C] [has_binary_coproducts D]
  (F : C â¥¤ D) (A : C) :
  F â‹™ coprod.functor.obj (F.obj A) âŸ¶ coprod.functor.obj A â‹™ F :=
{ app := Î» B, coprod_comparison F A B,
  naturality' := Î» B B' f, by simp [coprod_comparison_natural] }
@[reassoc]
lemma map_inl_inv_coprod_comparison [is_iso (coprod_comparison F A B)] :
  F.map coprod.inl â‰« inv (coprod_comparison F A B) = coprod.inl :=
by simp [is_iso.inv_comp_eq]
@[reassoc]
lemma map_inr_inv_coprod_comparison [is_iso (coprod_comparison F A B)] :
  F.map coprod.inr â‰« inv (coprod_comparison F A B) = coprod.inr :=
by simp [is_iso.inv_comp_eq]
@[reassoc]
lemma coprod_comparison_inv_natural (f : A âŸ¶ A') (g : B âŸ¶ B')
  [is_iso (coprod_comparison F A B)] [is_iso (coprod_comparison F A' B')] :
  inv (coprod_comparison F A B) â‰« coprod.map (F.map f) (F.map g) =
    F.map (coprod.map f g) â‰« inv (coprod_comparison F A' B') :=
by rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, coprod_comparison_natural]
@[simps {rhs_md := semireducible}]
def coprod_comparison_nat_iso [has_binary_coproducts C] [has_binary_coproducts D]
  (A : C) [âˆ€ B, is_iso (coprod_comparison F A B)] :
  F â‹™ coprod.functor.obj (F.obj A) â‰… coprod.functor.obj A â‹™ F :=
{ hom := coprod_comparison_nat_trans F A
  ..(@as_iso _ _ _ _ _ (nat_iso.is_iso_of_is_iso_app âŸ¨_, _âŸ©)) }
end coprod_comparison
end category_theory.limits
open category_theory.limits
namespace category_theory
variables {C : Type u} [category.{v} C]
@[simps]
def over.coprod_obj [has_binary_coproducts C] {A : C} : over A â†’ over A â¥¤ over A := Î» f,
{ obj := Î» g, over.mk (coprod.desc f.hom g.hom),
  map := Î» gâ‚ gâ‚‚ k, over.hom_mk (coprod.map (ğŸ™ _) k.left) }
@[simps]
def over.coprod [has_binary_coproducts C] {A : C} : over A â¥¤ over A â¥¤ over A :=
{ obj := Î» f, over.coprod_obj f,
  map := Î» fâ‚ fâ‚‚ k,
  { app := Î» g, over.hom_mk (coprod.map k.left (ğŸ™ _))
      (by { dsimp, rw [coprod.map_desc, category.id_comp, over.w k] }),
    naturality' := Î» f g k, by ext; { dsimp, simp, }, },
  map_id' := Î» X, by ext; { dsimp, simp, },
  map_comp' := Î» X Y Z f g, by ext; { dsimp, simp, }, }.
end category_theory
