import algebra.indicator_function
import data.prod.tprod
import group_theory.coset
import logic.equiv.fin
import measure_theory.measurable_space_def
import measure_theory.tactic
import order.filter.lift
open set encodable function equiv
open_locale filter measure_theory
variables {Î± Î² Î³ Î´ Î´' : Type*} {Î¹ : Sort*} {s t u : set Î±}
namespace measurable_space
section functors
variables {m mâ‚ mâ‚‚ : measurable_space Î±} {m' : measurable_space Î²} {f : Î± â†’ Î²} {g : Î² â†’ Î±}
protected def map (f : Î± â†’ Î²) (m : measurable_space Î±) : measurable_space Î² :=
{ measurable_set'      := Î» s, measurable_set[m] $ f â»Â¹' s,
  measurable_set_empty := m.measurable_set_empty,
  measurable_set_compl := assume s hs, m.measurable_set_compl _ hs,
  measurable_set_Union := assume f hf, by { rw preimage_Union, exact m.measurable_set_Union _ hf }}
@[simp] lemma map_id : m.map id = m :=
measurable_space.ext $ assume s, iff.rfl
@[simp] lemma map_comp {f : Î± â†’ Î²} {g : Î² â†’ Î³} : (m.map f).map g = m.map (g âˆ˜ f) :=
measurable_space.ext $ assume s, iff.rfl
protected def comap (f : Î± â†’ Î²) (m : measurable_space Î²) : measurable_space Î± :=
{ measurable_set'      := Î» s, âˆƒs', measurable_set[m] s' âˆ§ f â»Â¹' s' = s,
  measurable_set_empty := âŸ¨âˆ…, m.measurable_set_empty, rflâŸ©,
  measurable_set_compl := assume s âŸ¨s', hâ‚, hâ‚‚âŸ©, âŸ¨s'á¶œ, m.measurable_set_compl _ hâ‚, hâ‚‚ â–¸ rflâŸ©,
  measurable_set_Union := assume s hs,
    let âŸ¨s', hs'âŸ© := classical.axiom_of_choice hs in
    âŸ¨â‹ƒ i, s' i, m.measurable_set_Union _ (Î» i, (hs' i).left), by simp [hs'] âŸ© }
lemma comap_eq_generate_from (m : measurable_space Î²) (f : Î± â†’ Î²) :
  m.comap f = generate_from {t | âˆƒ s, measurable_set s âˆ§ f â»Â¹' s = t} :=
by convert generate_from_measurable_set.symm
@[simp] lemma comap_id : m.comap id = m :=
measurable_space.ext $ assume s, âŸ¨assume âŸ¨s', hs', hâŸ©, h â–¸ hs', assume h, âŸ¨s, h, rflâŸ©âŸ©
@[simp] lemma comap_comp {f : Î² â†’ Î±} {g : Î³ â†’ Î²} : (m.comap f).comap g = m.comap (f âˆ˜ g) :=
measurable_space.ext $ assume s,
  âŸ¨assume âŸ¨t, âŸ¨u, h, huâŸ©, htâŸ©, âŸ¨u, h, ht â–¸ hu â–¸ rflâŸ©, assume âŸ¨t, h, htâŸ©, âŸ¨f â»Â¹' t, âŸ¨_, h, rflâŸ©, htâŸ©âŸ©
lemma comap_le_iff_le_map {f : Î± â†’ Î²} : m'.comap f â‰¤ m â†” m' â‰¤ m.map f :=
âŸ¨assume h s hs, h _ âŸ¨_, hs, rflâŸ©, assume h s âŸ¨t, ht, heqâŸ©, heq â–¸ h _ htâŸ©
lemma gc_comap_map (f : Î± â†’ Î²) :
  galois_connection (measurable_space.comap f) (measurable_space.map f) :=
assume f g, comap_le_iff_le_map
lemma map_mono (h : mâ‚ â‰¤ mâ‚‚) : mâ‚.map f â‰¤ mâ‚‚.map f := (gc_comap_map f).monotone_u h
lemma monotone_map : monotone (measurable_space.map f) := assume a b h, map_mono h
lemma comap_mono (h : mâ‚ â‰¤ mâ‚‚) : mâ‚.comap g â‰¤ mâ‚‚.comap g := (gc_comap_map g).monotone_l h
lemma monotone_comap : monotone (measurable_space.comap g) := assume a b h, comap_mono h
@[simp] lemma comap_bot : (âŠ¥ : measurable_space Î±).comap g = âŠ¥ := (gc_comap_map g).l_bot
@[simp] lemma comap_sup : (mâ‚ âŠ” mâ‚‚).comap g = mâ‚.comap g âŠ” mâ‚‚.comap g := (gc_comap_map g).l_sup
@[simp] lemma comap_supr {m : Î¹ â†’ measurable_space Î±} : (â¨†i, m i).comap g = (â¨†i, (m i).comap g) :=
(gc_comap_map g).l_supr
@[simp] lemma map_top : (âŠ¤ : measurable_space Î±).map f = âŠ¤ := (gc_comap_map f).u_top
@[simp] lemma map_inf : (mâ‚ âŠ“ mâ‚‚).map f = mâ‚.map f âŠ“ mâ‚‚.map f := (gc_comap_map f).u_inf
@[simp] lemma map_infi {m : Î¹ â†’ measurable_space Î±} : (â¨…i, m i).map f = (â¨…i, (m i).map f) :=
(gc_comap_map f).u_infi
lemma comap_map_le : (m.map f).comap f â‰¤ m := (gc_comap_map f).l_u_le _
lemma le_map_comap : m â‰¤ (m.comap g).map g := (gc_comap_map g).le_u_l _
end functors
lemma comap_generate_from {f : Î± â†’ Î²} {s : set (set Î²)} :
  (generate_from s).comap f = generate_from (preimage f '' s) :=
le_antisymm
  (comap_le_iff_le_map.2 $ generate_from_le $ assume t hts,
    generate_measurable.basic _ $ mem_image_of_mem _ $ hts)
  (generate_from_le $ assume t âŸ¨u, hu, eqâŸ©, eq â–¸ âŸ¨u, generate_measurable.basic _ hu, rflâŸ©)
end measurable_space
section measurable_functions
open measurable_space
lemma measurable_iff_le_map {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} :
  measurable f â†” mâ‚‚ â‰¤ mâ‚.map f :=
iff.rfl
alias measurable_iff_le_map â†” measurable.le_map measurable.of_le_map
lemma measurable_iff_comap_le {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} :
  measurable f â†” mâ‚‚.comap f â‰¤ mâ‚ :=
comap_le_iff_le_map.symm
alias measurable_iff_comap_le â†” measurable.comap_le measurable.of_comap_le
lemma measurable.mono {ma ma' : measurable_space Î±} {mb mb' : measurable_space Î²} {f : Î± â†’ Î²}
  (hf : @measurable Î± Î² ma mb f) (ha : ma â‰¤ ma') (hb : mb' â‰¤ mb) :
  @measurable Î± Î² ma' mb' f :=
Î» t ht, ha _ $ hf $ hb _ ht
@[measurability]
lemma measurable_from_top [measurable_space Î²] {f : Î± â†’ Î²} : measurable[âŠ¤] f :=
Î» s hs, trivial
lemma measurable_generate_from [measurable_space Î±] {s : set (set Î²)} {f : Î± â†’ Î²}
  (h : âˆ€ t âˆˆ s, measurable_set (f â»Â¹' t)) : @measurable _ _ _ (generate_from s) f :=
measurable.of_le_map $ generate_from_le h
variables {f g : Î± â†’ Î²}
section typeclass_measurable_space
variables [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]
@[nontriviality, measurability]
lemma subsingleton.measurable [subsingleton Î±] : measurable f :=
Î» s hs, @subsingleton.measurable_set Î± _ _ _
@[nontriviality, measurability]
lemma measurable_of_subsingleton_codomain [subsingleton Î²] (f : Î± â†’ Î²) :
  measurable f :=
Î» s hs, subsingleton.set_cases measurable_set.empty measurable_set.univ s
@[to_additive]
lemma measurable_one [has_one Î±] : measurable (1 : Î² â†’ Î±) := @measurable_const _ _ _ _ 1
lemma measurable_of_empty [is_empty Î±] (f : Î± â†’ Î²) : measurable f :=
subsingleton.measurable
lemma measurable_of_empty_codomain [is_empty Î²] (f : Î± â†’ Î²) : measurable f :=
by { haveI := function.is_empty f, exact measurable_of_empty f }
lemma measurable_const' {f : Î² â†’ Î±} (hf : âˆ€ x y, f x = f y) : measurable f :=
begin
  casesI is_empty_or_nonempty Î²,
  { exact measurable_of_empty f },
  { convert measurable_const, exact funext (Î» x, hf x h.some) }
end
lemma measurable_of_fintype [fintype Î±] [measurable_singleton_class Î±] (f : Î± â†’ Î²) :
  measurable f :=
Î» s hs, (set.finite.of_fintype (f â»Â¹' s)).measurable_set
end typeclass_measurable_space
variables {m : measurable_space Î±}
include m
@[measurability] lemma measurable.iterate {f : Î± â†’ Î±} (hf : measurable f) : âˆ€ n, measurable (f^[n])
| 0 := measurable_id
| (n+1) := (measurable.iterate n).comp hf
variables {mÎ² : measurable_space Î²}
include mÎ²
@[measurability]
lemma measurable_set_preimage {t : set Î²} (hf : measurable f) (ht : measurable_set t) :
  measurable_set (f â»Â¹' t) :=
hf ht
@[measurability]
lemma measurable.piecewise {_ : decidable_pred (âˆˆ s)} (hs : measurable_set s)
  (hf : measurable f) (hg : measurable g) :
  measurable (piecewise s f g) :=
begin
  intros t ht,
  rw piecewise_preimage,
  exact hs.ite (hf ht) (hg ht)
end
lemma measurable.ite {p : Î± â†’ Prop} {_ : decidable_pred p}
  (hp : measurable_set {a : Î± | p a}) (hf : measurable f) (hg : measurable g) :
  measurable (Î» x, ite (p x) (f x) (g x)) :=
measurable.piecewise hp hf hg
@[measurability]
lemma measurable.indicator [has_zero Î²] (hf : measurable f) (hs : measurable_set s) :
  measurable (s.indicator f) :=
hf.piecewise hs measurable_const
@[measurability, to_additive] lemma measurable_set_mul_support [has_one Î²]
  [measurable_singleton_class Î²] (hf : measurable f) :
  measurable_set (mul_support f) :=
hf (measurable_set_singleton 1).compl
lemma measurable.measurable_of_countable_ne [measurable_singleton_class Î±]
  (hf : measurable f) (h : set.countable {x | f x â‰  g x}) : measurable g :=
begin
  assume t ht,
  have : g â»Â¹' t = (g â»Â¹' t âˆ© {x | f x = g x}á¶œ) âˆª (g â»Â¹' t âˆ© {x | f x = g x}),
    by simp [â† inter_union_distrib_left],
  rw this,
  apply measurable_set.union (h.mono (inter_subset_right _ _)).measurable_set,
  have : g â»Â¹' t âˆ© {x : Î± | f x = g x} = f â»Â¹' t âˆ© {x : Î± | f x = g x},
    by { ext x, simp {contextual := tt} },
  rw this,
  exact (hf ht).inter h.measurable_set.of_compl,
end
end measurable_functions
section constructions
instance : measurable_space empty := âŠ¤
def measurable_space.prod {Î± Î²} (mâ‚ : measurable_space Î±) (mâ‚‚ : measurable_space Î²) :
  measurable_space (Î± Ã— Î²) :=
mâ‚.comap prod.fst âŠ” mâ‚‚.comap prod.snd
instance {Î± Î²} [mâ‚ : measurable_space Î±] [mâ‚‚ : measurable_space Î²] : measurable_space (Î± Ã— Î²) :=
mâ‚.prod mâ‚‚
@[measurability] lemma measurable_fst {ma : measurable_space Î±} {mb : measurable_space Î²} :
  measurable (prod.fst : Î± Ã— Î² â†’ Î±) :=
measurable.of_comap_le le_sup_left
@[measurability] lemma measurable_snd {ma : measurable_space Î±} {mb : measurable_space Î²} :
  measurable (prod.snd : Î± Ã— Î² â†’ Î²) :=
measurable.of_comap_le le_sup_right
variables {m : measurable_space Î±} {mÎ² : measurable_space Î²} {mÎ³ : measurable_space Î³}
include m mÎ² mÎ³
lemma measurable.fst {f : Î± â†’ Î² Ã— Î³} (hf : measurable f) :
  measurable (Î» a : Î±, (f a).1) :=
measurable_fst.comp hf
lemma measurable.snd {f : Î± â†’ Î² Ã— Î³} (hf : measurable f) :
  measurable (Î» a : Î±, (f a).2) :=
measurable_snd.comp hf
@[measurability] lemma measurable.prod {f : Î± â†’ Î² Ã— Î³}
  (hfâ‚ : measurable (Î» a, (f a).1)) (hfâ‚‚ : measurable (Î» a, (f a).2)) : measurable f :=
measurable.of_le_map $ sup_le
  (by { rw [measurable_space.comap_le_iff_le_map, measurable_space.map_comp], exact hfâ‚ })
  (by { rw [measurable_space.comap_le_iff_le_map, measurable_space.map_comp], exact hfâ‚‚ })
lemma measurable.prod_mk {Î² Î³} {mÎ² : measurable_space Î²}
  {mÎ³ : measurable_space Î³} {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hf : measurable f) (hg : measurable g) :
  measurable (Î» a : Î±, (f a, g a)) :=
measurable.prod hf hg
lemma measurable.prod_map [measurable_space Î´] {f : Î± â†’ Î²} {g : Î³ â†’ Î´} (hf : measurable f)
  (hg : measurable g) : measurable (prod.map f g) :=
(hf.comp measurable_fst).prod_mk (hg.comp measurable_snd)
omit mÎ³
lemma measurable_prod_mk_left {x : Î±} : measurable (@prod.mk _ Î² x) :=
measurable_const.prod_mk measurable_id
lemma measurable_prod_mk_right {y : Î²} : measurable (Î» x : Î±, (x, y)) :=
measurable_id.prod_mk measurable_const
include mÎ³
lemma measurable.of_uncurry_left {f : Î± â†’ Î² â†’ Î³} (hf : measurable (uncurry f)) {x : Î±} :
  measurable (f x) :=
hf.comp measurable_prod_mk_left
lemma measurable.of_uncurry_right {f : Î± â†’ Î² â†’ Î³} (hf : measurable (uncurry f)) {y : Î²} :
  measurable (Î» x, f x y) :=
hf.comp measurable_prod_mk_right
lemma measurable_prod {f : Î± â†’ Î² Ã— Î³} : measurable f â†”
  measurable (Î» a, (f a).1) âˆ§ measurable (Î» a, (f a).2) :=
âŸ¨Î» hf, âŸ¨measurable_fst.comp hf, measurable_snd.comp hfâŸ©, Î» h, measurable.prod h.1 h.2âŸ©
omit mÎ³
@[measurability] lemma measurable_swap :
  measurable (prod.swap : Î± Ã— Î² â†’ Î² Ã— Î±) :=
measurable.prod measurable_snd measurable_fst
lemma measurable_swap_iff {mÎ³ : measurable_space Î³} {f : Î± Ã— Î² â†’ Î³} :
  measurable (f âˆ˜ prod.swap) â†” measurable f :=
âŸ¨Î» hf, by { convert hf.comp measurable_swap, ext âŸ¨x, yâŸ©, refl }, Î» hf, hf.comp measurable_swapâŸ©
@[measurability]
lemma measurable_set.prod {s : set Î±} {t : set Î²} (hs : measurable_set s) (ht : measurable_set t) :
  measurable_set (s Ã—Ë¢ t) :=
measurable_set.inter (measurable_fst hs) (measurable_snd ht)
lemma measurable_set_prod_of_nonempty {s : set Î±} {t : set Î²} (h : (s Ã—Ë¢ t : set _).nonempty) :
  measurable_set (s Ã—Ë¢ t) â†” measurable_set s âˆ§ measurable_set t :=
begin
  rcases h with âŸ¨âŸ¨x, yâŸ©, hx, hyâŸ©,
  refine âŸ¨Î» hst, _, Î» h, h.1.prod h.2âŸ©,
  have : measurable_set ((Î» x, (x, y)) â»Â¹' s Ã—Ë¢ t) := measurable_prod_mk_right hst,
  have : measurable_set (prod.mk x â»Â¹' s Ã—Ë¢ t) := measurable_prod_mk_left hst,
  simp * at *
end
lemma measurable_set_prod {s : set Î±} {t : set Î²} :
  measurable_set (s Ã—Ë¢ t) â†” (measurable_set s âˆ§ measurable_set t) âˆ¨ s = âˆ… âˆ¨ t = âˆ… :=
begin
  cases (s Ã—Ë¢ t : set _).eq_empty_or_nonempty with h h,
  { simp [h, prod_eq_empty_iff.mp h] },
  { simp [â†not_nonempty_iff_eq_empty, prod_nonempty_iff.mp h, measurable_set_prod_of_nonempty h] }
end
lemma measurable_set_swap_iff {s : set (Î± Ã— Î²)} :
  measurable_set (prod.swap â»Â¹' s) â†” measurable_set s :=
âŸ¨Î» hs, by { convert measurable_swap hs, ext âŸ¨x, yâŸ©, refl }, Î» hs, measurable_swap hsâŸ©
lemma measurable_from_prod_encodable [encodable Î²] [measurable_singleton_class Î²]
  {mÎ³ : measurable_space Î³} {f : Î± Ã— Î² â†’ Î³} (hf : âˆ€ y, measurable (Î» x, f (x, y))) :
  measurable f :=
begin
  intros s hs,
  have : f â»Â¹' s = â‹ƒ y, ((Î» x, f (x, y)) â»Â¹' s) Ã—Ë¢ ({y} : set Î²),
  { ext1 âŸ¨x, yâŸ©,
    simp [and_assoc, and.left_comm] },
  rw this,
  exact measurable_set.Union (Î» y, (hf y hs).prod (measurable_set_singleton y))
end
@[measurability]
lemma measurable.find {m : measurable_space Î±}
  {f : â„• â†’ Î± â†’ Î²} {p : â„• â†’ Î± â†’ Prop} [âˆ€ n, decidable_pred (p n)]
  (hf : âˆ€ n, measurable (f n)) (hp : âˆ€ n, measurable_set {x | p n x}) (h : âˆ€ x, âˆƒ n, p n x) :
  measurable (Î» x, f (nat.find (h x)) x) :=
begin
  have : measurable (Î» (p : Î± Ã— â„•), f p.2 p.1) := measurable_from_prod_encodable (Î» n, hf n),
  exact this.comp (measurable.prod_mk measurable_id (measurable_find h hp)),
end
lemma exists_measurable_piecewise_nat {m : measurable_space Î±} (t : â„• â†’ set Î²)
  (t_meas : âˆ€ n, measurable_set (t n)) (t_disj : pairwise (disjoint on t))
  (g : â„• â†’ Î² â†’ Î±) (hg : âˆ€ n, measurable (g n)) :
  âˆƒ f : Î² â†’ Î±, measurable f âˆ§ (âˆ€ n x, x âˆˆ t n â†’ f x = g n x) :=
begin
  classical,
  let p : â„• â†’ Î² â†’ Prop := Î» n x, x âˆˆ t n âˆª (â‹ƒ k, t k)á¶œ,
  have M : âˆ€ n, measurable_set {x | p n x} :=
    Î» n, (t_meas n).union (measurable_set.compl (measurable_set.Union t_meas)),
  have P : âˆ€ x, âˆƒ n, p n x,
  { assume x,
    by_cases H : âˆ€ (i : â„•), x âˆ‰ t i,
    { exact âŸ¨0, or.inr (by simpa only [mem_Inter, compl_Union] using H)âŸ© },
    { simp only [not_forall, not_not_mem] at H,
      rcases H with âŸ¨n, hnâŸ©,
      exact âŸ¨n, or.inl hnâŸ© } },
  refine âŸ¨Î» x, g (nat.find (P x)) x, measurable.find hg M P, _âŸ©,
  assume n x hx,
  have : x âˆˆ t (nat.find (P x)),
  { have B : x âˆˆ t (nat.find (P x)) âˆª (â‹ƒ k, t k)á¶œ := nat.find_spec (P x),
    have B' : (âˆ€ (i : â„•), x âˆ‰ t i) â†” false,
    { simp only [iff_false, not_forall, not_not_mem], exact âŸ¨n, hxâŸ© },
    simpa only [B', mem_union_eq, mem_Inter, or_false, compl_Union, mem_compl_eq] using B },
  congr,
  by_contra h,
  exact t_disj n (nat.find (P x)) (ne.symm h) âŸ¨hx, thisâŸ©
end
end prod
section pi
variables {Ï€ : Î´ â†’ Type*} [measurable_space Î±]
instance measurable_space.pi [m : Î  a, measurable_space (Ï€ a)] : measurable_space (Î  a, Ï€ a) :=
â¨† a, (m a).comap (Î» b, b a)
variables [Î  a, measurable_space (Ï€ a)] [measurable_space Î³]
lemma measurable_pi_iff {g : Î± â†’ Î  a, Ï€ a} :
  measurable g â†” âˆ€ a, measurable (Î» x, g x a) :=
by simp_rw [measurable_iff_comap_le, measurable_space.pi, measurable_space.comap_supr,
    measurable_space.comap_comp, function.comp, supr_le_iff]
@[measurability]
lemma measurable_pi_apply (a : Î´) : measurable (Î» f : Î  a, Ï€ a, f a) :=
measurable.of_comap_le $ le_supr _ a
@[measurability]
lemma measurable.eval {a : Î´} {g : Î± â†’ Î  a, Ï€ a}
  (hg : measurable g) : measurable (Î» x, g x a) :=
(measurable_pi_apply a).comp hg
@[measurability]
lemma measurable_pi_lambda (f : Î± â†’ Î  a, Ï€ a) (hf : âˆ€ a, measurable (Î» c, f c a)) :
  measurable f :=
measurable_pi_iff.mpr hf
@[measurability]
lemma measurable_update (f : Î  (a : Î´), Ï€ a) {a : Î´} [decidable_eq Î´] : measurable (update f a) :=
begin
  apply measurable_pi_lambda,
  intro x, by_cases hx : x = a,
  { cases hx, convert measurable_id, ext, simp },
  simp_rw [update_noteq hx], apply measurable_const,
end
@[measurability]
lemma measurable_set.pi {s : set Î´} {t : Î  i : Î´, set (Ï€ i)} (hs : s.countable)
  (ht : âˆ€ i âˆˆ s, measurable_set (t i)) :
  measurable_set (s.pi t) :=
by { rw [pi_def], exact measurable_set.bInter hs (Î» i hi, measurable_pi_apply _ (ht i hi)) }
lemma measurable_set.univ_pi [encodable Î´] {t : Î  i : Î´, set (Ï€ i)}
  (ht : âˆ€ i, measurable_set (t i)) : measurable_set (pi univ t) :=
measurable_set.pi (countable_encodable _) (Î» i _, ht i)
lemma measurable_set_pi_of_nonempty
  {s : set Î´} {t : Î  i, set (Ï€ i)} (hs : s.countable)
  (h : (pi s t).nonempty) : measurable_set (pi s t) â†” âˆ€ i âˆˆ s, measurable_set (t i) :=
begin
  classical,
  rcases h with âŸ¨f, hfâŸ©, refine âŸ¨Î» hst i hi, _, measurable_set.pi hsâŸ©,
  convert measurable_update f hst, rw [update_preimage_pi hi], exact Î» j hj _, hf j hj
end
lemma measurable_set_pi {s : set Î´} {t : Î  i, set (Ï€ i)} (hs : s.countable) :
  measurable_set (pi s t) â†” (âˆ€ i âˆˆ s, measurable_set (t i)) âˆ¨ pi s t = âˆ… :=
begin
  cases (pi s t).eq_empty_or_nonempty with h h,
  { simp [h] },
  { simp [measurable_set_pi_of_nonempty hs, h, â† not_nonempty_iff_eq_empty] }
end
section
variable (Ï€)
@[measurability]
lemma measurable_pi_equiv_pi_subtype_prod_symm (p : Î´ â†’ Prop) [decidable_pred p] :
  measurable (equiv.pi_equiv_pi_subtype_prod p Ï€).symm :=
begin
  apply measurable_pi_iff.2 (Î» j, _),
  by_cases hj : p j,
  { simp only [hj, dif_pos, equiv.pi_equiv_pi_subtype_prod_symm_apply],
    have : measurable (Î» (f : (Î  (i : {x // p x}), Ï€ â†‘i)), f âŸ¨j, hjâŸ©) :=
      measurable_pi_apply âŸ¨j, hjâŸ©,
    exact measurable.comp this measurable_fst },
  { simp only [hj, equiv.pi_equiv_pi_subtype_prod_symm_apply, dif_neg, not_false_iff],
    have : measurable (Î» (f : (Î  (i : {x // Â¬ p x}), Ï€ â†‘i)), f âŸ¨j, hjâŸ©) :=
      measurable_pi_apply âŸ¨j, hjâŸ©,
    exact measurable.comp this measurable_snd }
end
@[measurability]
lemma measurable_pi_equiv_pi_subtype_prod (p : Î´ â†’ Prop) [decidable_pred p] :
  measurable (equiv.pi_equiv_pi_subtype_prod p Ï€) :=
begin
  refine measurable_prod.2 _,
  split;
  { apply measurable_pi_iff.2 (Î» j, _),
    simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply] }
end
end
section fintype
local attribute [instance] fintype.to_encodable
lemma measurable_set.pi_fintype [fintype Î´] {s : set Î´} {t : Î  i, set (Ï€ i)}
  (ht : âˆ€ i âˆˆ s, measurable_set (t i)) : measurable_set (pi s t) :=
measurable_set.pi (countable_encodable _) ht
lemma measurable_set.univ_pi_fintype [fintype Î´] {t : Î  i, set (Ï€ i)}
  (ht : âˆ€ i, measurable_set (t i)) : measurable_set (pi univ t) :=
measurable_set.pi_fintype (Î» i _, ht i)
end fintype
end pi
instance tprod.measurable_space (Ï€ : Î´ â†’ Type*) [âˆ€ x, measurable_space (Ï€ x)] :
  âˆ€ (l : list Î´), measurable_space (list.tprod Ï€ l)
| []        := punit.measurable_space
| (i :: is) := @prod.measurable_space _ _ _ (tprod.measurable_space is)
section tprod
open list
variables {Ï€ : Î´ â†’ Type*} [âˆ€ x, measurable_space (Ï€ x)]
lemma measurable_tprod_mk (l : list Î´) : measurable (@tprod.mk Î´ Ï€ l) :=
begin
  induction l with i l ih,
  { exact measurable_const },
  { exact (measurable_pi_apply i).prod_mk ih }
end
lemma measurable_tprod_elim [decidable_eq Î´] : âˆ€ {l : list Î´} {i : Î´} (hi : i âˆˆ l),
  measurable (Î» (v : tprod Ï€ l), v.elim hi)
| (i :: is) j hj := begin
  by_cases hji : j = i,
  { subst hji, simp [measurable_fst] },
  { rw [funext $ tprod.elim_of_ne _ hji],
    exact (measurable_tprod_elim (hj.resolve_left hji)).comp measurable_snd }
end
lemma measurable_tprod_elim' [decidable_eq Î´] {l : list Î´} (h : âˆ€ i, i âˆˆ l) :
  measurable (tprod.elim' h : tprod Ï€ l â†’ Î  i, Ï€ i) :=
measurable_pi_lambda _ (Î» i, measurable_tprod_elim (h i))
lemma measurable_set.tprod (l : list Î´) {s : âˆ€ i, set (Ï€ i)} (hs : âˆ€ i, measurable_set (s i)) :
  measurable_set (set.tprod l s) :=
by { induction l with i l ih, exact measurable_set.univ, exact (hs i).prod ih }
end tprod
instance {Î± Î²} [mâ‚ : measurable_space Î±] [mâ‚‚ : measurable_space Î²] : measurable_space (Î± âŠ• Î²) :=
mâ‚.map sum.inl âŠ“ mâ‚‚.map sum.inr
section sum
@[measurability] lemma measurable_inl [measurable_space Î±] [measurable_space Î²] :
  measurable (@sum.inl Î± Î²) :=
measurable.of_le_map inf_le_left
@[measurability] lemma measurable_inr [measurable_space Î±] [measurable_space Î²] :
  measurable (@sum.inr Î± Î²) :=
measurable.of_le_map inf_le_right
variables {m : measurable_space Î±} {mÎ² : measurable_space Î²}
include m mÎ²
lemma measurable_sum {mÎ³ : measurable_space Î³} {f : Î± âŠ• Î² â†’ Î³}
  (hl : measurable (f âˆ˜ sum.inl)) (hr : measurable (f âˆ˜ sum.inr)) : measurable f :=
measurable.of_comap_le $ le_inf
  (measurable_space.comap_le_iff_le_map.2 $ hl)
  (measurable_space.comap_le_iff_le_map.2 $ hr)
@[measurability]
lemma measurable.sum_elim {mÎ³ : measurable_space Î³} {f : Î± â†’ Î³} {g : Î² â†’ Î³}
  (hf : measurable f) (hg : measurable g) :
  measurable (sum.elim f g) :=
measurable_sum hf hg
lemma measurable_set.inl_image {s : set Î±} (hs : measurable_set s) :
  measurable_set (sum.inl '' s : set (Î± âŠ• Î²)) :=
âŸ¨show measurable_set (sum.inl â»Â¹' _), by { rwa [preimage_image_eq], exact (Î» a b, sum.inl.inj) },
  have sum.inr â»Â¹' (sum.inl '' s : set (Î± âŠ• Î²)) = âˆ… :=
    eq_empty_of_subset_empty $ assume x âŸ¨y, hy, eqâŸ©, by contradiction,
  show measurable_set (sum.inr â»Â¹' _), by { rw [this], exact measurable_set.empty }âŸ©
lemma measurable_set_inr_image {s : set Î²} (hs : measurable_set s) :
  measurable_set (sum.inr '' s : set (Î± âŠ• Î²)) :=
âŸ¨ have sum.inl â»Â¹' (sum.inr '' s : set (Î± âŠ• Î²)) = âˆ… :=
    eq_empty_of_subset_empty $ assume x âŸ¨y, hy, eqâŸ©, by contradiction,
  show measurable_set (sum.inl â»Â¹' _), by { rw [this], exact measurable_set.empty },
  show measurable_set (sum.inr â»Â¹' _), by { rwa [preimage_image_eq], exact Î» a b, sum.inr.inj }âŸ©
omit m
lemma measurable_set_range_inl [measurable_space Î±] :
  measurable_set (range sum.inl : set (Î± âŠ• Î²)) :=
by { rw [â† image_univ], exact measurable_set.univ.inl_image }
lemma measurable_set_range_inr [measurable_space Î±] :
  measurable_set (range sum.inr : set (Î± âŠ• Î²)) :=
by { rw [â† image_univ], exact measurable_set_inr_image measurable_set.univ }
end sum
instance {Î±} {Î² : Î± â†’ Type*} [m : Î a, measurable_space (Î² a)] : measurable_space (sigma Î²) :=
â¨…a, (m a).map (sigma.mk a)
end constructions
@[protect_proj]
structure measurable_embedding {Î± Î² : Type*} [measurable_space Î±] [measurable_space Î²] (f : Î± â†’ Î²) :
  Prop :=
(injective : injective f)
(measurable : measurable f)
(measurable_set_image' : âˆ€ â¦ƒsâ¦„, measurable_set s â†’ measurable_set (f '' s))
namespace measurable_embedding
variables {mÎ± : measurable_space Î±} [measurable_space Î²] [measurable_space Î³]
  {f : Î± â†’ Î²} {g : Î² â†’ Î³}
include mÎ±
lemma measurable_set_image (hf : measurable_embedding f) {s : set Î±} :
  measurable_set (f '' s) â†” measurable_set s :=
âŸ¨Î» h, by simpa only [hf.injective.preimage_image] using hf.measurable h,
  Î» h, hf.measurable_set_image' hâŸ©
lemma id : measurable_embedding (id : Î± â†’ Î±) :=
âŸ¨injective_id, measurable_id, Î» s hs, by rwa image_idâŸ©
lemma comp (hg : measurable_embedding g) (hf : measurable_embedding f) :
  measurable_embedding (g âˆ˜ f) :=
âŸ¨hg.injective.comp hf.injective, hg.measurable.comp hf.measurable,
  Î» s hs, by rwa [â† image_image, hg.measurable_set_image, hf.measurable_set_image]âŸ©
lemma subtype_coe {s : set Î±} (hs : measurable_set s) : measurable_embedding (coe : s â†’ Î±) :=
{ injective := subtype.coe_injective,
  measurable := measurable_subtype_coe,
  measurable_set_image' := Î» _, measurable_set.subtype_image hs }
lemma measurable_set_range (hf : measurable_embedding f) : measurable_set (range f) :=
by { rw â† image_univ, exact hf.measurable_set_image' measurable_set.univ }
lemma measurable_set_preimage (hf : measurable_embedding f) {s : set Î²} :
  measurable_set (f â»Â¹' s) â†” measurable_set (s âˆ© range f) :=
by rw [â† image_preimage_eq_inter_range, hf.measurable_set_image]
lemma measurable_range_splitting (hf : measurable_embedding f) :
  measurable (range_splitting f) :=
Î» s hs, by rwa [preimage_range_splitting hf.injective,
  â† (subtype_coe hf.measurable_set_range).measurable_set_image, â† image_comp,
  coe_comp_range_factorization, hf.measurable_set_image]
lemma measurable_extend (hf : measurable_embedding f) {g : Î± â†’ Î³} {g' : Î² â†’ Î³}
  (hg : measurable g) (hg' : measurable g') :
  measurable (extend f g g') :=
begin
  refine measurable_of_restrict_of_restrict_compl hf.measurable_set_range _ _,
  { rw restrict_extend_range,
    simpa only [range_splitting] using hg.comp hf.measurable_range_splitting },
  { rw restrict_extend_compl_range, exact hg'.comp measurable_subtype_coe }
end
lemma exists_measurable_extend (hf : measurable_embedding f) {g : Î± â†’ Î³} (hg : measurable g)
  (hne : Î² â†’ nonempty Î³) :
  âˆƒ g' : Î² â†’ Î³, measurable g' âˆ§ g' âˆ˜ f = g :=
âŸ¨extend f g (Î» x, classical.choice (hne x)),
  hf.measurable_extend hg (measurable_const' $ Î» _ _, rfl),
  funext $ Î» x, extend_apply hf.injective _ _ _âŸ©
lemma measurable_comp_iff (hg : measurable_embedding g) : measurable (g âˆ˜ f) â†” measurable f :=
begin
  refine âŸ¨Î» H, _, hg.measurable.compâŸ©,
  suffices : measurable ((range_splitting g âˆ˜ range_factorization g) âˆ˜ f),
    by rwa [(right_inverse_range_splitting hg.injective).comp_eq_id] at this,
  exact hg.measurable_range_splitting.comp H.subtype_mk
end
end measurable_embedding
lemma measurable_set.exists_measurable_proj {m : measurable_space Î±} {s : set Î±}
  (hs : measurable_set s) (hne : s.nonempty) : âˆƒ f : Î± â†’ s, measurable f âˆ§ âˆ€ x : s, f x = x :=
let âŸ¨f, hfm, hfâŸ© := (measurable_embedding.subtype_coe hs).exists_measurable_extend
  measurable_id (Î» _, hne.to_subtype)
in âŸ¨f, hfm, congr_fun hfâŸ©
structure measurable_equiv (Î± Î² : Type*) [measurable_space Î±] [measurable_space Î²] extends Î± â‰ƒ Î² :=
(measurable_to_fun : measurable to_equiv)
(measurable_inv_fun : measurable to_equiv.symm)
infix ` â‰ƒáµ `:25 := measurable_equiv
namespace measurable_equiv
variables (Î± Î²) [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] [measurable_space Î´]
instance : has_coe_to_fun (Î± â‰ƒáµ Î²) (Î» _, Î± â†’ Î²) := âŸ¨Î» e, e.to_funâŸ©
variables {Î± Î²}
@[simp] lemma coe_to_equiv (e : Î± â‰ƒáµ Î²) : (e.to_equiv : Î± â†’ Î²) = e := rfl
@[measurability]
protected lemma measurable (e : Î± â‰ƒáµ Î²) : measurable (e : Î± â†’ Î²) :=
e.measurable_to_fun
@[simp] lemma coe_mk (e : Î± â‰ƒ Î²) (h1 : measurable e) (h2 : measurable e.symm) :
  ((âŸ¨e, h1, h2âŸ© : Î± â‰ƒáµ Î²) : Î± â†’ Î²) = e := rfl
def refl (Î± : Type*) [measurable_space Î±] : Î± â‰ƒáµ Î± :=
{ to_equiv := equiv.refl Î±,
  measurable_to_fun := measurable_id, measurable_inv_fun := measurable_id }
instance : inhabited (Î± â‰ƒáµ Î±) := âŸ¨refl Î±âŸ©
def trans (ab : Î± â‰ƒáµ Î²) (bc : Î² â‰ƒáµ Î³) :
  Î± â‰ƒáµ Î³ :=
{ to_equiv := ab.to_equiv.trans bc.to_equiv,
  measurable_to_fun := bc.measurable_to_fun.comp ab.measurable_to_fun,
  measurable_inv_fun := ab.measurable_inv_fun.comp bc.measurable_inv_fun }
def symm (ab : Î± â‰ƒáµ Î²) : Î² â‰ƒáµ Î± :=
{ to_equiv := ab.to_equiv.symm,
  measurable_to_fun := ab.measurable_inv_fun,
  measurable_inv_fun := ab.measurable_to_fun }
@[simp] lemma coe_to_equiv_symm (e : Î± â‰ƒáµ Î²) : (e.to_equiv.symm : Î² â†’ Î±) = e.symm := rfl
def simps.apply (h : Î± â‰ƒáµ Î²) : Î± â†’ Î² := h
def simps.symm_apply (h : Î± â‰ƒáµ Î²) : Î² â†’ Î± := h.symm
initialize_simps_projections measurable_equiv
  (to_equiv_to_fun â†’ apply, to_equiv_inv_fun â†’ symm_apply)
lemma to_equiv_injective : injective (to_equiv : (Î± â‰ƒáµ Î²) â†’ (Î± â‰ƒ Î²)) :=
by { rintro âŸ¨eâ‚, _, _âŸ© âŸ¨eâ‚‚, _, _âŸ© (rfl : eâ‚ = eâ‚‚), refl }
@[ext] lemma ext {eâ‚ eâ‚‚ : Î± â‰ƒáµ Î²} (h : (eâ‚ : Î± â†’ Î²) = eâ‚‚) : eâ‚ = eâ‚‚ :=
to_equiv_injective $ equiv.coe_fn_injective h
@[simp] lemma symm_mk (e : Î± â‰ƒ Î²) (h1 : measurable e) (h2 : measurable e.symm) :
  (âŸ¨e, h1, h2âŸ© : Î± â‰ƒáµ Î²).symm = âŸ¨e.symm, h2, h1âŸ© := rfl
attribute [simps apply to_equiv] trans refl
@[simp] lemma symm_refl (Î± : Type*) [measurable_space Î±] : (refl Î±).symm = refl Î± := rfl
@[simp] theorem symm_comp_self (e : Î± â‰ƒáµ Î²) : e.symm âˆ˜ e = id := funext e.left_inv
@[simp] theorem self_comp_symm (e : Î± â‰ƒáµ Î²) : e âˆ˜ e.symm = id := funext e.right_inv
@[simp] theorem apply_symm_apply (e : Î± â‰ƒáµ Î²) (y : Î²) : e (e.symm y) = y := e.right_inv y
@[simp] theorem symm_apply_apply (e : Î± â‰ƒáµ Î²) (x : Î±) : e.symm (e x) = x := e.left_inv x
@[simp] theorem symm_trans_self (e : Î± â‰ƒáµ Î²) : e.symm.trans e = refl Î² :=
ext e.self_comp_symm
@[simp] theorem self_trans_symm (e : Î± â‰ƒáµ Î²) : e.trans e.symm = refl Î± :=
ext e.symm_comp_self
protected theorem surjective (e : Î± â‰ƒáµ Î²) : surjective e := e.to_equiv.surjective
protected theorem bijective (e : Î± â‰ƒáµ Î²) : bijective e := e.to_equiv.bijective
protected theorem injective (e : Î± â‰ƒáµ Î²) : injective e := e.to_equiv.injective
@[simp] theorem symm_preimage_preimage (e : Î± â‰ƒáµ Î²) (s : set Î²) : e.symm â»Â¹' (e â»Â¹' s) = s :=
e.to_equiv.symm_preimage_preimage s
theorem image_eq_preimage (e : Î± â‰ƒáµ Î²) (s : set Î±) : e '' s = e.symm â»Â¹' s :=
e.to_equiv.image_eq_preimage s
@[simp] theorem measurable_set_preimage (e : Î± â‰ƒáµ Î²) {s : set Î²} :
  measurable_set (e â»Â¹' s) â†” measurable_set s :=
âŸ¨Î» h, by simpa only [symm_preimage_preimage] using e.symm.measurable h, Î» h, e.measurable hâŸ©
@[simp] theorem measurable_set_image (e : Î± â‰ƒáµ Î²) {s : set Î±} :
  measurable_set (e '' s) â†” measurable_set s :=
by rw [image_eq_preimage, measurable_set_preimage]
protected lemma measurable_embedding (e : Î± â‰ƒáµ Î²) : measurable_embedding e :=
{ injective := e.injective,
  measurable := e.measurable,
  measurable_set_image' := Î» s, e.measurable_set_image.2 }
protected def cast {Î± Î²} [iâ‚ : measurable_space Î±] [iâ‚‚ : measurable_space Î²]
  (h : Î± = Î²) (hi : iâ‚ == iâ‚‚) : Î± â‰ƒáµ Î² :=
{ to_equiv := equiv.cast h,
  measurable_to_fun  := by { substI h, substI hi, exact measurable_id },
  measurable_inv_fun := by { substI h, substI hi, exact measurable_id }}
protected lemma measurable_comp_iff {f : Î² â†’ Î³} (e : Î± â‰ƒáµ Î²) :
  measurable (f âˆ˜ e) â†” measurable f :=
iff.intro
  (assume hfe,
    have measurable (f âˆ˜ (e.symm.trans e).to_equiv) := hfe.comp e.symm.measurable,
    by rwa [coe_to_equiv, symm_trans_self] at this)
  (Î» h, h.comp e.measurable)
def of_unique_of_unique (Î± Î² : Type*) [measurable_space Î±] [measurable_space Î²]
  [unique Î±] [unique Î²] : Î± â‰ƒáµ Î² :=
{ to_equiv := equiv_of_unique Î± Î²,
  measurable_to_fun := subsingleton.measurable,
  measurable_inv_fun := subsingleton.measurable }
def prod_congr (ab : Î± â‰ƒáµ Î²) (cd : Î³ â‰ƒáµ Î´) : Î± Ã— Î³ â‰ƒáµ Î² Ã— Î´ :=
{ to_equiv := prod_congr ab.to_equiv cd.to_equiv,
  measurable_to_fun := (ab.measurable_to_fun.comp measurable_id.fst).prod_mk
    (cd.measurable_to_fun.comp measurable_id.snd),
  measurable_inv_fun := (ab.measurable_inv_fun.comp measurable_id.fst).prod_mk
    (cd.measurable_inv_fun.comp measurable_id.snd) }
def prod_comm : Î± Ã— Î² â‰ƒáµ Î² Ã— Î± :=
{ to_equiv := prod_comm Î± Î²,
  measurable_to_fun  := measurable_id.snd.prod_mk measurable_id.fst,
  measurable_inv_fun := measurable_id.snd.prod_mk measurable_id.fst }
def prod_assoc : (Î± Ã— Î²) Ã— Î³ â‰ƒáµ Î± Ã— (Î² Ã— Î³) :=
{ to_equiv := prod_assoc Î± Î² Î³,
  measurable_to_fun  := measurable_fst.fst.prod_mk $ measurable_fst.snd.prod_mk measurable_snd,
  measurable_inv_fun := (measurable_fst.prod_mk measurable_snd.fst).prod_mk measurable_snd.snd }
def sum_congr (ab : Î± â‰ƒáµ Î²) (cd : Î³ â‰ƒáµ Î´) : Î± âŠ• Î³ â‰ƒáµ Î² âŠ• Î´ :=
{ to_equiv := sum_congr ab.to_equiv cd.to_equiv,
  measurable_to_fun :=
    begin
      cases ab with ab' abm, cases ab', cases cd with cd' cdm, cases cd',
      refine measurable_sum (measurable_inl.comp abm) (measurable_inr.comp cdm)
    end,
  measurable_inv_fun :=
    begin
      cases ab with ab' _ abm, cases ab', cases cd with cd' _ cdm, cases cd',
      refine measurable_sum (measurable_inl.comp abm) (measurable_inr.comp cdm)
    end }
def set.prod (s : set Î±) (t : set Î²) : â†¥(s Ã—Ë¢ t) â‰ƒáµ s Ã— t :=
{ to_equiv := equiv.set.prod s t,
  measurable_to_fun := measurable_id.subtype_coe.fst.subtype_mk.prod_mk
    measurable_id.subtype_coe.snd.subtype_mk,
  measurable_inv_fun := measurable.subtype_mk $ measurable_id.fst.subtype_coe.prod_mk
    measurable_id.snd.subtype_coe }
def set.univ (Î± : Type*) [measurable_space Î±] : (univ : set Î±) â‰ƒáµ Î± :=
{ to_equiv := equiv.set.univ Î±,
  measurable_to_fun := measurable_id.subtype_coe,
  measurable_inv_fun := measurable_id.subtype_mk }
def set.singleton (a : Î±) : ({a} : set Î±) â‰ƒáµ unit :=
{ to_equiv := equiv.set.singleton a,
  measurable_to_fun := measurable_const,
  measurable_inv_fun := measurable_const }
noncomputable def set.image (f : Î± â†’ Î²) (s : set Î±) (hf : injective f)
  (hfm : measurable f) (hfi : âˆ€ s, measurable_set s â†’ measurable_set (f '' s)) : s â‰ƒáµ (f '' s) :=
{ to_equiv := equiv.set.image f s hf,
  measurable_to_fun  := (hfm.comp measurable_id.subtype_coe).subtype_mk,
  measurable_inv_fun :=
    begin
      rintro t âŸ¨u, hu, rflâŸ©, simp [preimage_preimage, set.image_symm_preimage hf],
      exact measurable_subtype_coe (hfi u hu)
    end }
noncomputable def set.range (f : Î± â†’ Î²) (hf : injective f) (hfm : measurable f)
  (hfi : âˆ€ s, measurable_set s â†’ measurable_set (f '' s)) :
  Î± â‰ƒáµ (range f) :=
(measurable_equiv.set.univ _).symm.trans $
  (measurable_equiv.set.image f univ hf hfm hfi).trans $
  measurable_equiv.cast (by rw image_univ) (by rw image_univ)
def set.range_inl : (range sum.inl : set (Î± âŠ• Î²)) â‰ƒáµ Î± :=
{ to_fun    := Î» ab, match ab with
    | âŸ¨sum.inl a, _âŸ© := a
    | âŸ¨sum.inr b, pâŸ© := have false, by { cases p, contradiction }, this.elim
    end,
  inv_fun   := Î» a, âŸ¨sum.inl a, a, rflâŸ©,
  left_inv  := by { rintro âŸ¨ab, a, rflâŸ©, refl },
  right_inv := assume a, rfl,
  measurable_to_fun  := assume s (hs : measurable_set s),
    begin
      refine âŸ¨_, hs.inl_image, set.ext _âŸ©,
      rintros âŸ¨ab, a, rflâŸ©,
      simp [set.range_inl._match_1]
    end,
  measurable_inv_fun := measurable.subtype_mk measurable_inl }
def set.range_inr : (range sum.inr : set (Î± âŠ• Î²)) â‰ƒáµ Î² :=
{ to_fun    := Î» ab, match ab with
    | âŸ¨sum.inr b, _âŸ© := b
    | âŸ¨sum.inl a, pâŸ© := have false, by { cases p, contradiction }, this.elim
    end,
  inv_fun   := Î» b, âŸ¨sum.inr b, b, rflâŸ©,
  left_inv  := by { rintro âŸ¨ab, b, rflâŸ©, refl },
  right_inv := assume b, rfl,
  measurable_to_fun  := assume s (hs : measurable_set s),
    begin
      refine âŸ¨_, measurable_set_inr_image hs, set.ext _âŸ©,
      rintros âŸ¨ab, b, rflâŸ©,
      simp [set.range_inr._match_1]
    end,
  measurable_inv_fun := measurable.subtype_mk measurable_inr }
def sum_prod_distrib (Î± Î² Î³) [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] :
  (Î± âŠ• Î²) Ã— Î³ â‰ƒáµ (Î± Ã— Î³) âŠ• (Î² Ã— Î³) :=
{ to_equiv := sum_prod_distrib Î± Î² Î³,
  measurable_to_fun  :=
  begin
    refine measurable_of_measurable_union_cover
      (range sum.inl Ã—Ë¢ (univ : set Î³))
      (range sum.inr Ã—Ë¢ (univ : set Î³))
      (measurable_set_range_inl.prod measurable_set.univ)
      (measurable_set_range_inr.prod measurable_set.univ)
      (by { rintro âŸ¨a|b, câŸ©; simp [set.prod_eq] })
      _
      _,
    { refine (set.prod (range sum.inl) univ).symm.measurable_comp_iff.1 _,
      refine (prod_congr set.range_inl (set.univ _)).symm.measurable_comp_iff.1 _,
      dsimp [(âˆ˜)],
      convert measurable_inl,
      ext âŸ¨a, câŸ©, refl },
    { refine (set.prod (range sum.inr) univ).symm.measurable_comp_iff.1 _,
      refine (prod_congr set.range_inr (set.univ _)).symm.measurable_comp_iff.1 _,
      dsimp [(âˆ˜)],
      convert measurable_inr,
      ext âŸ¨b, câŸ©, refl }
  end,
  measurable_inv_fun :=
    measurable_sum
      ((measurable_inl.comp measurable_fst).prod_mk measurable_snd)
      ((measurable_inr.comp measurable_fst).prod_mk measurable_snd) }
def prod_sum_distrib (Î± Î² Î³) [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] :
  Î± Ã— (Î² âŠ• Î³) â‰ƒáµ (Î± Ã— Î²) âŠ• (Î± Ã— Î³) :=
prod_comm.trans $ (sum_prod_distrib _ _ _).trans $ sum_congr prod_comm prod_comm
def sum_prod_sum (Î± Î² Î³ Î´)
  [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] [measurable_space Î´] :
  (Î± âŠ• Î²) Ã— (Î³ âŠ• Î´) â‰ƒáµ ((Î± Ã— Î³) âŠ• (Î± Ã— Î´)) âŠ• ((Î² Ã— Î³) âŠ• (Î² Ã— Î´)) :=
(sum_prod_distrib _ _ _).trans $ sum_congr (prod_sum_distrib _ _ _) (prod_sum_distrib _ _ _)
variables {Ï€ Ï€' : Î´' â†’ Type*} [âˆ€ x, measurable_space (Ï€ x)] [âˆ€ x, measurable_space (Ï€' x)]
def Pi_congr_right (e : Î  a, Ï€ a â‰ƒáµ Ï€' a) : (Î  a, Ï€ a) â‰ƒáµ (Î  a, Ï€' a) :=
{ to_equiv := Pi_congr_right (Î» a, (e a).to_equiv),
  measurable_to_fun :=
    measurable_pi_lambda _ (Î» i, (e i).measurable_to_fun.comp (measurable_pi_apply i)),
  measurable_inv_fun :=
    measurable_pi_lambda _ (Î» i, (e i).measurable_inv_fun.comp (measurable_pi_apply i)) }
@[simps {fully_applied := ff}]
def pi_measurable_equiv_tprod [decidable_eq Î´']
  {l : list Î´'} (hnd : l.nodup) (h : âˆ€ i, i âˆˆ l) :
  (Î  i, Ï€ i) â‰ƒáµ list.tprod Ï€ l :=
{ to_equiv := list.tprod.pi_equiv_tprod hnd h,
  measurable_to_fun := measurable_tprod_mk l,
  measurable_inv_fun := measurable_tprod_elim' h }
@[simps {fully_applied := ff}] def fun_unique (Î± Î² : Type*) [unique Î±] [measurable_space Î²] :
  (Î± â†’ Î²) â‰ƒáµ Î² :=
{ to_equiv := equiv.fun_unique Î± Î²,
  measurable_to_fun := measurable_pi_apply _,
  measurable_inv_fun := measurable_pi_iff.2 $ Î» b, measurable_id }
@[simps {fully_applied := ff}] def pi_fin_two (Î± : fin 2 â†’ Type*) [âˆ€ i, measurable_space (Î± i)] :
  (Î  i, Î± i) â‰ƒáµ Î± 0 Ã— Î± 1 :=
{ to_equiv := pi_fin_two_equiv Î±,
  measurable_to_fun := measurable.prod (measurable_pi_apply _) (measurable_pi_apply _),
  measurable_inv_fun := measurable_pi_iff.2 $
    fin.forall_fin_two.2 âŸ¨measurable_fst, measurable_sndâŸ© }
@[simps {fully_applied := ff}] def fin_two_arrow : (fin 2 â†’ Î±) â‰ƒáµ Î± Ã— Î± := pi_fin_two (Î» _, Î±)
@[simps {fully_applied := ff}]
def pi_fin_succ_above_equiv {n : â„•} (Î± : fin (n + 1) â†’ Type*) [Î  i, measurable_space (Î± i)]
  (i : fin (n + 1)) :
  (Î  j, Î± j) â‰ƒáµ Î± i Ã— (Î  j, Î± (i.succ_above j)) :=
{ to_equiv := pi_fin_succ_above_equiv Î± i,
  measurable_to_fun := (measurable_pi_apply i).prod_mk $ measurable_pi_iff.2 $
    Î» j, measurable_pi_apply _,
  measurable_inv_fun := by simp [measurable_pi_iff, i.forall_iff_succ_above, measurable_fst,
    (measurable_pi_apply _).comp measurable_snd]  }
variable (Ï€)
@[simps {fully_applied := ff}]
def pi_equiv_pi_subtype_prod (p : Î´' â†’ Prop) [decidable_pred p] :
  (Î  i, Ï€ i) â‰ƒáµ ((Î  i : subtype p, Ï€ i) Ã— (Î  i : {i // Â¬p i}, Ï€ i)) :=
{ to_equiv := pi_equiv_pi_subtype_prod p Ï€,
  measurable_to_fun := measurable_pi_equiv_pi_subtype_prod Ï€ p,
  measurable_inv_fun := measurable_pi_equiv_pi_subtype_prod_symm Ï€ p }
end measurable_equiv
namespace measurable_embedding
variables [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] {f : Î± â†’ Î²}
noncomputable def equiv_range (f : Î± â†’ Î²) (hf : measurable_embedding f) :
  Î± â‰ƒáµ range f :=
{ to_equiv := equiv.of_injective f hf.injective,
  measurable_to_fun := hf.measurable.subtype_mk,
  measurable_inv_fun :=
    by { rw coe_of_injective_symm, exact hf.measurable_range_splitting } }
lemma of_measurable_inverse_on_range {g : range f â†’ Î±} (hfâ‚ : measurable f)
  (hfâ‚‚ : measurable_set (range f)) (hg : measurable g)
  (H : left_inverse g (range_factorization f)) : measurable_embedding f :=
begin
  set e : Î± â‰ƒáµ range f :=
    âŸ¨âŸ¨range_factorization f, g, H, H.right_inverse_of_surjective surjective_onto_rangeâŸ©,
      hfâ‚.subtype_mk, hgâŸ©,
  exact (measurable_embedding.subtype_coe hfâ‚‚).comp e.measurable_embedding
end
lemma of_measurable_inverse {g : Î² â†’ Î±} (hfâ‚ : measurable f)
  (hfâ‚‚ : measurable_set (range f)) (hg : measurable g)
  (H : left_inverse g f) : measurable_embedding f :=
of_measurable_inverse_on_range hfâ‚ hfâ‚‚ (hg.comp measurable_subtype_coe) H
end measurable_embedding
namespace filter
variables [measurable_space Î±]
class is_measurably_generated (f : filter Î±) : Prop :=
(exists_measurable_subset : âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆƒ t âˆˆ f, measurable_set t âˆ§ t âŠ† s)
instance is_measurably_generated_bot : is_measurably_generated (âŠ¥ : filter Î±) :=
âŸ¨Î» _ _, âŸ¨âˆ…, mem_bot, measurable_set.empty, empty_subset _âŸ©âŸ©
instance is_measurably_generated_top : is_measurably_generated (âŠ¤ : filter Î±) :=
âŸ¨Î» s hs, âŸ¨univ, univ_mem, measurable_set.univ, Î» x _, hs xâŸ©âŸ©
lemma eventually.exists_measurable_mem {f : filter Î±} [is_measurably_generated f]
  {p : Î± â†’ Prop} (h : âˆ€á¶  x in f, p x) :
  âˆƒ s âˆˆ f, measurable_set s âˆ§ âˆ€ x âˆˆ s, p x :=
is_measurably_generated.exists_measurable_subset h
lemma eventually.exists_measurable_mem_of_small_sets {f : filter Î±} [is_measurably_generated f]
  {p : set Î± â†’ Prop} (h : âˆ€á¶  s in f.small_sets, p s) :
  âˆƒ s âˆˆ f, measurable_set s âˆ§ p s :=
let âŸ¨s, hsf, hsâŸ© := eventually_small_sets.1 h,
  âŸ¨t, htf, htm, htsâŸ© := is_measurably_generated.exists_measurable_subset hsf
in âŸ¨t, htf, htm, hs t htsâŸ©
instance inf_is_measurably_generated (f g : filter Î±) [is_measurably_generated f]
  [is_measurably_generated g] :
  is_measurably_generated (f âŠ“ g) :=
begin
  refine âŸ¨_âŸ©,
  rintros t âŸ¨sf, hsf, sg, hsg, rflâŸ©,
  rcases is_measurably_generated.exists_measurable_subset hsf with âŸ¨s'f, hs'f, hmf, hs'sfâŸ©,
  rcases is_measurably_generated.exists_measurable_subset hsg with âŸ¨s'g, hs'g, hmg, hs'sgâŸ©,
  refine âŸ¨s'f âˆ© s'g, inter_mem_inf hs'f hs'g, hmf.inter hmg, _âŸ©,
  exact inter_subset_inter hs'sf hs'sg
end
lemma principal_is_measurably_generated_iff {s : set Î±} :
  is_measurably_generated (ğ“Ÿ s) â†” measurable_set s :=
begin
  refine âŸ¨_, Î» hs, âŸ¨Î» t ht, âŸ¨s, mem_principal_self s, hs, htâŸ©âŸ©âŸ©,
  rintros âŸ¨hsâŸ©,
  rcases hs (mem_principal_self s) with âŸ¨t, ht, htm, htsâŸ©,
  have : t = s := subset.antisymm hts ht,
  rwa â† this
end
alias principal_is_measurably_generated_iff â†”
  _ _root_.measurable_set.principal_is_measurably_generated
instance infi_is_measurably_generated {f : Î¹ â†’ filter Î±} [âˆ€ i, is_measurably_generated (f i)] :
  is_measurably_generated (â¨… i, f i) :=
begin
  refine âŸ¨Î» s hs, _âŸ©,
  rw [â† equiv.plift.surjective.infi_comp, mem_infi] at hs,
  rcases hs with âŸ¨t, ht, âŸ¨V, hVf, rflâŸ©âŸ©,
  choose U hUf hU using Î» i, is_measurably_generated.exists_measurable_subset (hVf i),
  refine âŸ¨â‹‚ i : t, U i, _, _, _âŸ©,
  { rw [â† equiv.plift.surjective.infi_comp, mem_infi],
    refine âŸ¨t, ht, U, hUf, rflâŸ© },
  { haveI := ht.countable.to_encodable,
    exact measurable_set.Inter (Î» i, (hU i).1) },
  { exact Inter_mono (Î» i, (hU i).2) }
end
end filter
def is_countably_spanning (C : set (set Î±)) : Prop :=
âˆƒ (s : â„• â†’ set Î±), (âˆ€ n, s n âˆˆ C) âˆ§ (â‹ƒ n, s n) = univ
lemma is_countably_spanning_measurable_set [measurable_space Î±] :
  is_countably_spanning {s : set Î± | measurable_set s} :=
âŸ¨Î» _, univ, Î» _, measurable_set.univ, Union_const _âŸ©
namespace measurable_set
variables [measurable_space Î±]
instance : has_mem Î± (subtype (measurable_set : set Î± â†’ Prop)) :=
âŸ¨Î» a s, a âˆˆ (s : set Î±)âŸ©
@[simp] lemma mem_coe (a : Î±) (s : subtype (measurable_set : set Î± â†’ Prop)) :
  a âˆˆ (s : set Î±) â†” a âˆˆ s := iff.rfl
instance : has_emptyc (subtype (measurable_set : set Î± â†’ Prop)) :=
âŸ¨âŸ¨âˆ…, measurable_set.emptyâŸ©âŸ©
@[simp] lemma coe_empty : â†‘(âˆ… : subtype (measurable_set : set Î± â†’ Prop)) = (âˆ… : set Î±) := rfl
instance [measurable_singleton_class Î±] : has_insert Î± (subtype (measurable_set : set Î± â†’ Prop)) :=
âŸ¨Î» a s, âŸ¨has_insert.insert a s, s.prop.insert aâŸ©âŸ©
@[simp] lemma coe_insert [measurable_singleton_class Î±] (a : Î±)
  (s : subtype (measurable_set : set Î± â†’ Prop)) :
  â†‘(has_insert.insert a s) = (has_insert.insert a s : set Î±) := rfl
instance : has_compl (subtype (measurable_set : set Î± â†’ Prop)) :=
âŸ¨Î» x, âŸ¨xá¶œ, x.prop.complâŸ©âŸ©
@[simp] lemma coe_compl (s : subtype (measurable_set : set Î± â†’ Prop)) : â†‘(sá¶œ) = (sá¶œ : set Î±) := rfl
instance : has_union (subtype (measurable_set : set Î± â†’ Prop)) :=
âŸ¨Î» x y, âŸ¨x âˆª y, x.prop.union y.propâŸ©âŸ©
@[simp] lemma coe_union (s t : subtype (measurable_set : set Î± â†’ Prop)) :
  â†‘(s âˆª t) = (s âˆª t : set Î±) := rfl
instance : has_inter (subtype (measurable_set : set Î± â†’ Prop)) :=
âŸ¨Î» x y, âŸ¨x âˆ© y, x.prop.inter y.propâŸ©âŸ©
@[simp] lemma coe_inter (s t : subtype (measurable_set : set Î± â†’ Prop)) :
  â†‘(s âˆ© t) = (s âˆ© t : set Î±) := rfl
instance : has_sdiff (subtype (measurable_set : set Î± â†’ Prop)) :=
âŸ¨Î» x y, âŸ¨x \ y, x.prop.diff y.propâŸ©âŸ©
@[simp] lemma coe_sdiff (s t : subtype (measurable_set : set Î± â†’ Prop)) :
  â†‘(s \ t) = (s \ t : set Î±) := rfl
instance : has_bot (subtype (measurable_set : set Î± â†’ Prop)) :=
âŸ¨âŸ¨âŠ¥, measurable_set.emptyâŸ©âŸ©
@[simp] lemma coe_bot : â†‘(âŠ¥ : subtype (measurable_set : set Î± â†’ Prop)) = (âŠ¥ : set Î±) := rfl
instance : has_top (subtype (measurable_set : set Î± â†’ Prop)) :=
âŸ¨âŸ¨âŠ¤, measurable_set.univâŸ©âŸ©
@[simp] lemma coe_top : â†‘(âŠ¤ : subtype (measurable_set : set Î± â†’ Prop)) = (âŠ¤ : set Î±) := rfl
instance : partial_order (subtype (measurable_set : set Î± â†’ Prop)) :=
partial_order.lift _ subtype.coe_injective
instance : distrib_lattice (subtype (measurable_set : set Î± â†’ Prop)) :=
{ sup := (âˆª),
  le_sup_left := Î» a b, show (a : set Î±) â‰¤ a âŠ” b, from le_sup_left,
  le_sup_right := Î» a b, show (b : set Î±) â‰¤ a âŠ” b, from le_sup_right,
  sup_le := Î» a b c ha hb, show (a âŠ” b : set Î±) â‰¤ c, from sup_le ha hb,
  inf := (âˆ©),
  inf_le_left := Î» a b, show (a âŠ“ b : set Î±) â‰¤ a, from inf_le_left,
  inf_le_right := Î» a b, show (a âŠ“ b : set Î±) â‰¤ b, from inf_le_right,
  le_inf := Î» a b c ha hb, show (a : set Î±) â‰¤ b âŠ“ c, from le_inf ha hb,
  le_sup_inf := Î» x y z, show ((x âŠ” y) âŠ“ (x âŠ” z) : set Î±) â‰¤ x âŠ” y âŠ“ z, from le_sup_inf,
  .. measurable_set.subtype.partial_order }
instance : bounded_order (subtype (measurable_set : set Î± â†’ Prop)) :=
{ top := âŠ¤,
  le_top := Î» a, show (a : set Î±) â‰¤ âŠ¤, from le_top,
  bot := âŠ¥,
  bot_le := Î» a, show (âŠ¥ : set Î±) â‰¤ a, from bot_le }
instance : boolean_algebra (subtype (measurable_set : set Î± â†’ Prop)) :=
{ sdiff := (\),
  sup_inf_sdiff := Î» a b, subtype.eq $ sup_inf_sdiff a b,
  inf_inf_sdiff := Î» a b, subtype.eq $ inf_inf_sdiff a b,
  compl := has_compl.compl,
  inf_compl_le_bot := Î» a, boolean_algebra.inf_compl_le_bot (a : set Î±),
  top_le_sup_compl := Î» a, boolean_algebra.top_le_sup_compl (a : set Î±),
  sdiff_eq := Î» a b, subtype.eq $ sdiff_eq,
  .. measurable_set.subtype.bounded_order,
  .. measurable_set.subtype.distrib_lattice }
end measurable_set
