import data.nat.interval
import data.int.succ_pred
import order.atoms
set_option old_structure_cmd true
open finset nat order_dual
variables {ğ•† â„™ Î± Î² : Type*}
class grade_order (ğ•† Î± : Type*) [preorder ğ•†] [preorder Î±] :=
(grade : Î± â†’ ğ•†)
(grade_strict_mono : strict_mono grade)
(covby_grade â¦ƒa b : Î±â¦„ : a â‹– b â†’ grade a â‹– grade b)
class grade_min_order (ğ•† Î± : Type*) [preorder ğ•†] [preorder Î±] extends grade_order ğ•† Î± :=
(is_min_grade â¦ƒa : Î±â¦„ : is_min a â†’ is_min (grade a))
class grade_max_order (ğ•† Î± : Type*) [preorder ğ•†] [preorder Î±] extends grade_order ğ•† Î± :=
(is_max_grade â¦ƒa : Î±â¦„ : is_max a â†’ is_max (grade a))
class grade_bounded_order (ğ•† Î± : Type*) [preorder ğ•†] [preorder Î±]
  extends grade_min_order ğ•† Î±, grade_max_order ğ•† Î±
def grade : Î± â†’ ğ•† := grade_order.grade
protected lemma covby.grade (h : a â‹– b) : grade ğ•† a â‹– grade ğ•† b := grade_order.covby_grade h
variables {ğ•†}
lemma grade_strict_mono : strict_mono (grade ğ•† : Î± â†’ ğ•†) := grade_order.grade_strict_mono
lemma covby_iff_lt_covby_grade : a â‹– b â†” a < b âˆ§ grade ğ•† a â‹– grade ğ•† b :=
âŸ¨Î» h, âŸ¨h.1, h.grade _âŸ©, and.imp_right $ Î» h c ha hb,
  h.2 (grade_strict_mono ha) $ grade_strict_mono hbâŸ©
end grade_order
section grade_min_order
variables (ğ•†) [grade_min_order ğ•† Î±] {a : Î±}
protected lemma is_min.grade (h : is_min a) : is_min (grade ğ•† a) := grade_min_order.is_min_grade h
variables {ğ•†}
@[simp] lemma is_min_grade_iff : is_min (grade ğ•† a) â†” is_min a :=
âŸ¨grade_strict_mono.is_min_of_apply, is_min.grade _âŸ©
end grade_min_order
section grade_max_order
variables (ğ•†) [grade_max_order ğ•† Î±] {a : Î±}
protected lemma is_max.grade (h : is_max a) : is_max (grade ğ•† a) := grade_max_order.is_max_grade h
variables {ğ•†}
@[simp] lemma is_max_grade_iff : is_max (grade ğ•† a) â†” is_max a :=
âŸ¨grade_strict_mono.is_max_of_apply, is_max.grade _âŸ©
end grade_max_order
variables [preorder ğ•†] [preorder â„™] [preorder Î±] [preorder Î²]
instance preorder.to_grade_bounded_order : grade_bounded_order Î± Î± :=
{ grade := id,
  is_min_grade := Î» _, id,
  is_max_grade := Î» _, id,
  grade_strict_mono := strict_mono_id,
  covby_grade := Î» a b, id }
@[simp] lemma grade_self (a : Î±) : grade Î± a = a := rfl
instance [grade_order ğ•† Î±] : grade_order ğ•†áµ’áµˆ Î±áµ’áµˆ :=
{ grade := to_dual âˆ˜ grade ğ•† âˆ˜ of_dual,
  grade_strict_mono := grade_strict_mono.dual,
  covby_grade := Î» a b h, (h.of_dual.grade _).to_dual }
instance [grade_max_order ğ•† Î±] : grade_min_order ğ•†áµ’áµˆ Î±áµ’áµˆ :=
{ is_min_grade := Î» _, is_max.grade _,
  ..order_dual.grade_order }
instance [grade_min_order ğ•† Î±] : grade_max_order ğ•†áµ’áµˆ Î±áµ’áµˆ :=
{ is_max_grade := Î» _, is_min.grade _,
  ..order_dual.grade_order }
instance [grade_bounded_order ğ•† Î±] : grade_bounded_order ğ•†áµ’áµˆ Î±áµ’áµˆ :=
{ ..order_dual.grade_min_order, ..order_dual.grade_max_order }
@[simp] lemma grade_to_dual [grade_order ğ•† Î±] (a : Î±) :
  grade ğ•†áµ’áµˆ (to_dual a) = to_dual (grade ğ•† a) := rfl
@[simp] lemma grade_of_dual [grade_order ğ•† Î±] (a : Î±áµ’áµˆ) :
  grade ğ•† (of_dual a) = of_dual (grade ğ•†áµ’áµˆ a) := rfl
