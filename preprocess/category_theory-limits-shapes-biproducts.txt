import algebra.group.ext
import category_theory.limits.shapes.finite_products
import category_theory.limits.shapes.binary_products
import category_theory.preadditive
import category_theory.limits.shapes.kernels
noncomputable theory
universes w w' v u
open category_theory
open category_theory.functor
open_locale classical
namespace category_theory
namespace limits
variables {J : Type w}
variables {C : Type u} [category.{v} C] [has_zero_morphisms C]
@[nolint has_inhabited_instance]
structure bicone (F : J â†’ C) :=
(X : C)
(Ï€ : Î  j, X âŸ¶ F j)
(Î¹ : Î  j, F j âŸ¶ X)
(Î¹_Ï€ : âˆ€ j j', Î¹ j â‰« Ï€ j' = if h : j = j' then eq_to_hom (congr_arg F h) else 0 . obviously)
@[simp, reassoc] lemma bicone_Î¹_Ï€_self {F : J â†’ C} (B : bicone F) (j : J) :
  B.Î¹ j â‰« B.Ï€ j = ğŸ™ (F j) :=
by simpa using B.Î¹_Ï€ j j
@[simp, reassoc] lemma bicone_Î¹_Ï€_ne {F : J â†’ C} (B : bicone F) {j j' : J} (h : j â‰  j') :
  B.Î¹ j â‰« B.Ï€ j' = 0 :=
by simpa [h] using B.Î¹_Ï€ j j'
variables {F : J â†’ C}
namespace bicone
local attribute [tidy] tactic.discrete_cases
def to_cone (B : bicone F) : cone (discrete.functor F) :=
{ X := B.X,
  Ï€ := { app := Î» j, B.Ï€ j.as }, }
@[simp] lemma to_cone_X (B : bicone F) : B.to_cone.X = B.X := rfl
@[simp] lemma to_cone_Ï€_app (B : bicone F) (j : J) : B.to_cone.Ï€.app âŸ¨jâŸ© = B.Ï€ j := rfl
def to_cocone (B : bicone F) : cocone (discrete.functor F) :=
{ X := B.X,
  Î¹ := { app := Î» j, B.Î¹ j.as }, }
@[simp] lemma to_cocone_X (B : bicone F) : B.to_cocone.X = B.X := rfl
@[simp] lemma to_cocone_Î¹_app (B : bicone F) (j : J) : B.to_cocone.Î¹.app âŸ¨jâŸ© = B.Î¹ j := rfl
@[simps]
def of_limit_cone {f : J â†’ C} {t : cone (discrete.functor f)} (ht : is_limit t) :
  bicone f :=
{ X := t.X,
  Ï€ := Î» j, t.Ï€.app âŸ¨jâŸ©,
  Î¹ := Î» j, ht.lift (fan.mk _ (Î» j', if h : j = j' then eq_to_hom (congr_arg f h) else 0)),
  Î¹_Ï€ := Î» j j', by simp }
lemma Î¹_of_is_limit {f : J â†’ C} {t : bicone f} (ht : is_limit t.to_cone) (j : J) :
  t.Î¹ j = ht.lift (fan.mk _ (Î» j', if h : j = j' then eq_to_hom (congr_arg f h) else 0)) :=
ht.hom_ext (Î» j', by { rw ht.fac, discrete_cases, simp [t.Î¹_Ï€] })
@[simps]
def of_colimit_cocone {f : J â†’ C} {t : cocone (discrete.functor f)} (ht : is_colimit t) :
  bicone f :=
{ X := t.X,
  Ï€ := Î» j, ht.desc (cofan.mk _ (Î» j', if h : j' = j then eq_to_hom (congr_arg f h) else 0)),
  Î¹ := Î» j, t.Î¹.app âŸ¨jâŸ©,
  Î¹_Ï€ := Î» j j', by simp }
lemma Ï€_of_is_colimit {f : J â†’ C} {t : bicone f} (ht : is_colimit t.to_cocone) (j : J) :
  t.Ï€ j = ht.desc (cofan.mk _ (Î» j', if h : j' = j then eq_to_hom (congr_arg f h) else 0)) :=
ht.hom_ext (Î» j', by { rw ht.fac, discrete_cases, simp [t.Î¹_Ï€] })
@[nolint has_inhabited_instance]
structure is_bilimit {F : J â†’ C} (B : bicone F) :=
(is_limit : is_limit B.to_cone)
(is_colimit : is_colimit B.to_cocone)
local attribute [ext] bicone.is_bilimit
instance subsingleton_is_bilimit {f : J â†’ C} {c : bicone f} : subsingleton c.is_bilimit :=
âŸ¨Î» h h', bicone.is_bilimit.ext _ _ (subsingleton.elim _ _) (subsingleton.elim _ _)âŸ©
section whisker
variables {K : Type w'}
@[simps]
def whisker {f : J â†’ C} (c : bicone f) (g : K â‰ƒ J) : bicone (f âˆ˜ g) :=
{ X := c.X,
  Ï€ := Î» k, c.Ï€ (g k),
  Î¹ := Î» k, c.Î¹ (g k),
  Î¹_Ï€ := Î» k k',
  begin
    simp only [c.Î¹_Ï€],
    split_ifs with h h' h'; simp [equiv.apply_eq_iff_eq g] at h h'; tauto
  end }
local attribute [tidy] tactic.discrete_cases
def whisker_to_cone {f : J â†’ C} (c : bicone f) (g : K â‰ƒ J) :
  (c.whisker g).to_cone â‰… (cones.postcompose (discrete.functor_comp f g).inv).obj
    (c.to_cone.whisker (discrete.functor (discrete.mk âˆ˜ g))) :=
cones.ext (iso.refl _) (by tidy)
def whisker_to_cocone {f : J â†’ C} (c : bicone f) (g : K â‰ƒ J) :
  (c.whisker g).to_cocone â‰… (cocones.precompose (discrete.functor_comp f g).hom).obj
    (c.to_cocone.whisker (discrete.functor (discrete.mk âˆ˜ g))) :=
cocones.ext (iso.refl _) (by tidy)
def whisker_is_bilimit_iff {f : J â†’ C} (c : bicone f) (g : K â‰ƒ J) :
  (c.whisker g).is_bilimit â‰ƒ c.is_bilimit :=
begin
  refine equiv_of_subsingleton_of_subsingleton (Î» hc, âŸ¨_, _âŸ©) (Î» hc, âŸ¨_, _âŸ©),
  { let := is_limit.of_iso_limit hc.is_limit (bicone.whisker_to_cone c g),
    let := (is_limit.postcompose_hom_equiv (discrete.functor_comp f g).symm _) this,
    exact is_limit.of_whisker_equivalence (discrete.equivalence g) this },
  { let := is_colimit.of_iso_colimit hc.is_colimit (bicone.whisker_to_cocone c g),
    let := (is_colimit.precompose_hom_equiv (discrete.functor_comp f g) _) this,
    exact is_colimit.of_whisker_equivalence (discrete.equivalence g) this },
  { apply is_limit.of_iso_limit _ (bicone.whisker_to_cone c g).symm,
    apply (is_limit.postcompose_hom_equiv (discrete.functor_comp f g).symm _).symm _,
    exact is_limit.whisker_equivalence hc.is_limit (discrete.equivalence g) },
  { apply is_colimit.of_iso_colimit _ (bicone.whisker_to_cocone c g).symm,
    apply (is_colimit.precompose_hom_equiv (discrete.functor_comp f g) _).symm _,
    exact is_colimit.whisker_equivalence hc.is_colimit (discrete.equivalence g) }
end
end whisker
end bicone
@[nolint has_inhabited_instance]
structure limit_bicone (F : J â†’ C) :=
(bicone : bicone F)
(is_bilimit : bicone.is_bilimit)
class has_biproduct (F : J â†’ C) : Prop :=
mk' :: (exists_biproduct : nonempty (limit_bicone F))
lemma has_biproduct.mk {F : J â†’ C} (d : limit_bicone F) : has_biproduct F :=
âŸ¨nonempty.intro dâŸ©
def get_biproduct_data (F : J â†’ C) [has_biproduct F] : limit_bicone F :=
classical.choice has_biproduct.exists_biproduct
def biproduct.bicone (F : J â†’ C) [has_biproduct F] : bicone F :=
(get_biproduct_data F).bicone
def biproduct.is_bilimit (F : J â†’ C) [has_biproduct F] : (biproduct.bicone F).is_bilimit :=
(get_biproduct_data F).is_bilimit
def biproduct.is_limit (F : J â†’ C) [has_biproduct F] : is_limit (biproduct.bicone F).to_cone :=
(get_biproduct_data F).is_bilimit.is_limit
def biproduct.is_colimit (F : J â†’ C) [has_biproduct F] :
  is_colimit (biproduct.bicone F).to_cocone :=
(get_biproduct_data F).is_bilimit.is_colimit
@[priority 100]
instance has_product_of_has_biproduct [has_biproduct F] : has_limit (discrete.functor F) :=
has_limit.mk { cone := (biproduct.bicone F).to_cone,
  is_limit := biproduct.is_limit F, }
@[priority 100]
instance has_coproduct_of_has_biproduct [has_biproduct F] : has_colimit (discrete.functor F) :=
has_colimit.mk { cocone := (biproduct.bicone F).to_cocone,
  is_colimit := biproduct.is_colimit F, }
variables (J C)
class has_biproducts_of_shape : Prop :=
(has_biproduct : Î  F : J â†’ C, has_biproduct F)
attribute [instance, priority 100] has_biproducts_of_shape.has_biproduct
class has_finite_biproducts : Prop :=
(has_biproducts_of_shape : Î  (J : Type) [fintype J],
  has_biproducts_of_shape J C)
attribute [instance, priority 100] has_finite_biproducts.has_biproducts_of_shape
@[priority 100]
instance has_finite_products_of_has_finite_biproducts [has_finite_biproducts C] :
  has_finite_products C :=
{ out := Î» J _, âŸ¨Î» F, by exactI has_limit_of_iso discrete.nat_iso_functor.symmâŸ© }
@[priority 100]
instance has_finite_coproducts_of_has_finite_biproducts [has_finite_biproducts C] :
  has_finite_coproducts C :=
{ out := Î» J _, âŸ¨Î» F, by exactI has_colimit_of_iso discrete.nat_iso_functorâŸ© }
variables {J C}
def biproduct_iso (F : J â†’ C) [has_biproduct F] :
  limits.pi_obj F â‰… limits.sigma_obj F :=
(is_limit.cone_point_unique_up_to_iso (limit.is_limit _) (biproduct.is_limit F)).trans $
  is_colimit.cocone_point_unique_up_to_iso (biproduct.is_colimit F) (colimit.is_colimit _)
end limits
namespace limits
variables {J : Type w}
variables {C : Type u} [category.{v} C] [has_zero_morphisms C]
abbreviation biproduct (f : J â†’ C) [has_biproduct f] : C :=
(biproduct.bicone f).X
notation `â¨ ` f:20 := biproduct f
abbreviation biproduct.Ï€ (f : J â†’ C) [has_biproduct f] (b : J) : â¨ f âŸ¶ f b :=
(biproduct.bicone f).Ï€ b
@[simp]
lemma biproduct.bicone_Ï€ (f : J â†’ C) [has_biproduct f] (b : J) :
  (biproduct.bicone f).Ï€ b = biproduct.Ï€ f b := rfl
abbreviation biproduct.Î¹ (f : J â†’ C) [has_biproduct f] (b : J) : f b âŸ¶ â¨ f :=
(biproduct.bicone f).Î¹ b
@[simp]
lemma biproduct.bicone_Î¹ (f : J â†’ C) [has_biproduct f] (b : J) :
  (biproduct.bicone f).Î¹ b = biproduct.Î¹ f b := rfl
@[reassoc]
lemma biproduct.Î¹_Ï€ [decidable_eq J] (f : J â†’ C) [has_biproduct f] (j j' : J) :
  biproduct.Î¹ f j â‰« biproduct.Ï€ f j' = if h : j = j' then eq_to_hom (congr_arg f h) else 0 :=
by convert (biproduct.bicone f).Î¹_Ï€ j j'
@[simp,reassoc]
lemma biproduct.Î¹_Ï€_self (f : J â†’ C) [has_biproduct f] (j : J) :
  biproduct.Î¹ f j â‰« biproduct.Ï€ f j = ğŸ™ _ :=
by simp [biproduct.Î¹_Ï€]
@[simp,reassoc]
lemma biproduct.Î¹_Ï€_ne (f : J â†’ C) [has_biproduct f] {j j' : J} (h : j â‰  j') :
  biproduct.Î¹ f j â‰« biproduct.Ï€ f j' = 0 :=
by simp [biproduct.Î¹_Ï€, h]
abbreviation biproduct.lift
  {f : J â†’ C} [has_biproduct f] {P : C} (p : Î  b, P âŸ¶ f b) : P âŸ¶ â¨ f :=
(biproduct.is_limit f).lift (fan.mk P p)
abbreviation biproduct.desc
  {f : J â†’ C} [has_biproduct f] {P : C} (p : Î  b, f b âŸ¶ P) : â¨ f âŸ¶ P :=
(biproduct.is_colimit f).desc (cofan.mk P p)
@[simp, reassoc]
lemma biproduct.lift_Ï€ {f : J â†’ C} [has_biproduct f] {P : C} (p : Î  b, P âŸ¶ f b) (j : J) :
  biproduct.lift p â‰« biproduct.Ï€ f j = p j :=
(biproduct.is_limit f).fac _ âŸ¨jâŸ©
@[simp, reassoc]
lemma biproduct.Î¹_desc {f : J â†’ C} [has_biproduct f] {P : C} (p : Î  b, f b âŸ¶ P) (j : J) :
  biproduct.Î¹ f j â‰« biproduct.desc p = p j :=
(biproduct.is_colimit f).fac _ âŸ¨jâŸ©
abbreviation biproduct.map {f g : J â†’ C} [has_biproduct f] [has_biproduct g]
  (p : Î  b, f b âŸ¶ g b) : â¨ f âŸ¶ â¨ g :=
is_limit.map (biproduct.bicone f).to_cone (biproduct.is_limit g)
  (discrete.nat_trans (Î» j, p j.as))
abbreviation biproduct.map' {f g : J â†’ C} [has_biproduct f] [has_biproduct g]
  (p : Î  b, f b âŸ¶ g b) : â¨ f âŸ¶ â¨ g :=
is_colimit.map (biproduct.is_colimit f) (biproduct.bicone g).to_cocone
  (discrete.nat_trans (Î» j, p j.as))
@[ext] lemma biproduct.hom_ext {f : J â†’ C} [has_biproduct f]
  {Z : C} (g h : Z âŸ¶ â¨ f)
  (w : âˆ€ j, g â‰« biproduct.Ï€ f j = h â‰« biproduct.Ï€ f j) : g = h :=
(biproduct.is_limit f).hom_ext (Î» j, w j.as)
@[ext] lemma biproduct.hom_ext' {f : J â†’ C} [has_biproduct f]
  {Z : C} (g h : â¨ f âŸ¶ Z)
  (w : âˆ€ j, biproduct.Î¹ f j â‰« g = biproduct.Î¹ f j â‰« h) : g = h :=
(biproduct.is_colimit f).hom_ext (Î» j, w j.as)
lemma biproduct.map_eq_map' {f g : J â†’ C} [has_biproduct f] [has_biproduct g]
  (p : Î  b, f b âŸ¶ g b) : biproduct.map p = biproduct.map' p :=
begin
  ext j j',
  simp only [discrete.nat_trans_app, limits.is_colimit.Î¹_map, limits.is_limit.map_Ï€, category.assoc,
    â†bicone.to_cone_Ï€_app, â†biproduct.bicone_Ï€, â†bicone.to_cocone_Î¹_app, â†biproduct.bicone_Î¹],
  simp only [biproduct.bicone_Î¹, biproduct.bicone_Ï€, bicone.to_cocone_Î¹_app, bicone.to_cone_Ï€_app],
  dsimp,
  rw [biproduct.Î¹_Ï€_assoc, biproduct.Î¹_Ï€],
  split_ifs,
  { subst h, rw [eq_to_hom_refl, category.id_comp], erw category.comp_id, },
  { simp, },
end
@[simp, reassoc]
lemma biproduct.map_Ï€ {f g : J â†’ C} [has_biproduct f] [has_biproduct g]
  (p : Î  j, f j âŸ¶ g j) (j : J) :
  biproduct.map p â‰« biproduct.Ï€ g j = biproduct.Ï€ f j â‰« p j :=
limits.is_limit.map_Ï€ _ _ _ (discrete.mk j)
@[simp, reassoc]
lemma biproduct.Î¹_map {f g : J â†’ C} [has_biproduct f] [has_biproduct g]
  (p : Î  j, f j âŸ¶ g j) (j : J) :
  biproduct.Î¹ f j â‰« biproduct.map p = p j â‰« biproduct.Î¹ g j :=
begin
  rw biproduct.map_eq_map',
  convert limits.is_colimit.Î¹_map _ _ _ (discrete.mk j); refl
end
@[simp, reassoc]
lemma biproduct.map_desc {f g : J â†’ C} [has_biproduct f] [has_biproduct g]
  (p : Î  j, f j âŸ¶ g j) {P : C} (k : Î  j, g j âŸ¶ P) :
  biproduct.map p â‰« biproduct.desc k = biproduct.desc (Î» j, p j â‰« k j) :=
by { ext, simp, }
@[simp, reassoc]
lemma biproduct.lift_map {f g : J â†’ C} [has_biproduct f] [has_biproduct g]
  {P : C} (k : Î  j, P âŸ¶ f j) (p : Î  j, f j âŸ¶ g j)  :
  biproduct.lift k â‰« biproduct.map p = biproduct.lift (Î» j, k j â‰« p j) :=
by { ext, simp, }
@[simps]
def biproduct.map_iso {f g : J â†’ C} [has_biproduct f] [has_biproduct g]
  (p : Î  b, f b â‰… g b) : â¨ f â‰… â¨ g :=
{ hom := biproduct.map (Î» b, (p b).hom),
  inv := biproduct.map (Î» b, (p b).inv), }
section Ï€_kernel
section
variables (f : J â†’ C) [has_biproduct f]
variables (p : J â†’ Prop) [has_biproduct (subtype.restrict p f)]
def biproduct.from_subtype : â¨ subtype.restrict p f âŸ¶ â¨ f :=
biproduct.desc $ Î» j, biproduct.Î¹ _ _
def biproduct.to_subtype : â¨ f âŸ¶ â¨ subtype.restrict p f :=
biproduct.lift $ Î» j, biproduct.Ï€ _ _
@[simp, reassoc]
lemma biproduct.from_subtype_Ï€ [decidable_pred p] (j : J) :
  biproduct.from_subtype f p â‰« biproduct.Ï€ f j =
    if h : p j then biproduct.Ï€ (subtype.restrict p f) âŸ¨j, hâŸ© else 0 :=
begin
  ext i,
  rw [biproduct.from_subtype, biproduct.Î¹_desc_assoc, biproduct.Î¹_Ï€],
  by_cases h : p j,
  { rw [dif_pos h, biproduct.Î¹_Ï€],
    split_ifs with hâ‚ hâ‚‚ hâ‚‚,
    exacts [rfl, false.elim (hâ‚‚ (subtype.ext hâ‚)),
      false.elim (hâ‚ (congr_arg subtype.val hâ‚‚)), rfl] },
  { rw [dif_neg h, dif_neg (show (i : J) â‰  j, from Î» hâ‚‚, h (hâ‚‚ â–¸ i.2)), comp_zero] }
end
lemma biproduct.from_subtype_eq_lift [decidable_pred p] : biproduct.from_subtype f p =
    biproduct.lift (Î» j, if h : p j then biproduct.Ï€ (subtype.restrict p f) âŸ¨j, hâŸ© else 0) :=
biproduct.hom_ext _ _ (by simp)
@[simp, reassoc]
lemma biproduct.from_subtype_Ï€_subtype (j : subtype p) :
  biproduct.from_subtype f p â‰« biproduct.Ï€ f j = biproduct.Ï€ (subtype.restrict p f) j :=
begin
  ext i,
  rw [biproduct.from_subtype, biproduct.Î¹_desc_assoc, biproduct.Î¹_Ï€, biproduct.Î¹_Ï€],
  split_ifs with hâ‚ hâ‚‚ hâ‚‚,
  exacts [rfl, false.elim (hâ‚‚ (subtype.ext hâ‚)), false.elim (hâ‚ (congr_arg subtype.val hâ‚‚)), rfl]
end
@[simp, reassoc]
lemma biproduct.to_subtype_Ï€ (j : subtype p) :
  biproduct.to_subtype f p â‰« biproduct.Ï€ (subtype.restrict p f) j = biproduct.Ï€ f j :=
biproduct.lift_Ï€ _ _
@[simp, reassoc]
lemma biproduct.Î¹_to_subtype [decidable_pred p] (j : J) :
  biproduct.Î¹ f j â‰« biproduct.to_subtype f p =
    if h : p j then biproduct.Î¹ (subtype.restrict p f) âŸ¨j, hâŸ© else 0 :=
begin
  ext i,
  rw [biproduct.to_subtype, category.assoc, biproduct.lift_Ï€, biproduct.Î¹_Ï€],
  by_cases h : p j,
  { rw [dif_pos h, biproduct.Î¹_Ï€],
    split_ifs with hâ‚ hâ‚‚ hâ‚‚,
    exacts [rfl, false.elim (hâ‚‚ (subtype.ext hâ‚)),
      false.elim (hâ‚ (congr_arg subtype.val hâ‚‚)), rfl] },
  { rw [dif_neg h, dif_neg (show j â‰  i, from Î» hâ‚‚, h (hâ‚‚.symm â–¸ i.2)), zero_comp] }
end
lemma biproduct.to_subtype_eq_desc [decidable_pred p] : biproduct.to_subtype f p =
  biproduct.desc (Î» j, if h : p j then biproduct.Î¹ (subtype.restrict p f) âŸ¨j, hâŸ© else 0) :=
biproduct.hom_ext' _ _ (by simp)
@[simp, reassoc]
lemma biproduct.Î¹_to_subtype_subtype (j : subtype p) :
  biproduct.Î¹ f j â‰« biproduct.to_subtype f p = biproduct.Î¹ (subtype.restrict p f) j :=
begin
  ext i,
  rw [biproduct.to_subtype, category.assoc, biproduct.lift_Ï€, biproduct.Î¹_Ï€, biproduct.Î¹_Ï€],
  split_ifs with hâ‚ hâ‚‚ hâ‚‚,
  exacts [rfl, false.elim (hâ‚‚ (subtype.ext hâ‚)), false.elim (hâ‚ (congr_arg subtype.val hâ‚‚)), rfl]
end
@[simp, reassoc]
lemma biproduct.Î¹_from_subtype (j : subtype p) :
  biproduct.Î¹ (subtype.restrict p f) j â‰« biproduct.from_subtype f p = biproduct.Î¹ f j :=
biproduct.Î¹_desc _ _
@[simp, reassoc]
lemma biproduct.from_subtype_to_subtype :
  biproduct.from_subtype f p â‰« biproduct.to_subtype f p = ğŸ™ (â¨ subtype.restrict p f) :=
begin
  refine biproduct.hom_ext _ _ (Î» j, _),
  rw [category.assoc, biproduct.to_subtype_Ï€, biproduct.from_subtype_Ï€_subtype, category.id_comp]
end
@[simp, reassoc]
lemma biproduct.to_subtype_from_subtype [decidable_pred p] :
  biproduct.to_subtype f p â‰« biproduct.from_subtype f p =
    biproduct.map (Î» j, if p j then ğŸ™ (f j) else 0) :=
begin
  ext1 i,
  by_cases h : p i,
  { simp [h], congr },
  { simp [h] }
end
end
variables (f : J â†’ C) (i : J) [has_biproduct f] [has_biproduct (subtype.restrict (Î» j, i â‰  j) f)]
def biproduct.is_limit_from_subtype : is_limit
  (kernel_fork.of_Î¹ (biproduct.from_subtype f (Î» j, i â‰  j))
    (by simp) : kernel_fork (biproduct.Ï€ f i)) :=
fork.is_limit.mk' _ $ Î» s,
âŸ¨s.Î¹ â‰« biproduct.to_subtype _ _,
 begin
   ext j,
   rw [kernel_fork.Î¹_of_Î¹, category.assoc, category.assoc,
     biproduct.to_subtype_from_subtype_assoc, biproduct.map_Ï€],
   rcases em (i = j) with (rfl|h),
   { rw [if_neg (not_not.2 rfl), comp_zero, comp_zero, kernel_fork.condition] },
   { rw [if_pos, category.comp_id], exact h, }
 end,
 begin
   intros m hm,
   rw [â† hm, kernel_fork.Î¹_of_Î¹, category.assoc, biproduct.from_subtype_to_subtype],
   exact (category.comp_id _).symm
 endâŸ©
def biproduct.is_colimit_to_subtype : is_colimit
  (cokernel_cofork.of_Ï€ (biproduct.to_subtype f (Î» j, i â‰  j))
    (by simp) : cokernel_cofork (biproduct.Î¹ f i)) :=
cofork.is_colimit.mk' _ $ Î» s,
âŸ¨biproduct.from_subtype _ _ â‰« s.Ï€,
 begin
   ext j,
   rw [cokernel_cofork.Ï€_of_Ï€, biproduct.to_subtype_from_subtype_assoc,
     biproduct.Î¹_map_assoc],
   rcases em (i = j) with (rfl|h),
   { rw [if_neg (not_not.2 rfl), zero_comp, cokernel_cofork.condition] },
   { rw [if_pos, category.id_comp], exact h, }
 end,
 begin
   intros m hm,
   rw [â† hm, cokernel_cofork.Ï€_of_Ï€, â† category.assoc, biproduct.from_subtype_to_subtype],
   exact (category.id_comp _).symm
 endâŸ©
end Ï€_kernel
end limits
namespace limits
section finite_biproducts
variables {J : Type} [fintype J] {K : Type} [fintype K]
  {C : Type u} [category.{v} C] [has_zero_morphisms C] [has_finite_biproducts C]
  {f : J â†’ C} {g : K â†’ C}
def biproduct.matrix (m : Î  j k, f j âŸ¶ g k) : â¨ f âŸ¶ â¨ g :=
biproduct.desc (Î» j, biproduct.lift (Î» k, m j k))
@[simp, reassoc]
lemma biproduct.matrix_Ï€ (m : Î  j k, f j âŸ¶ g k) (k : K) :
  biproduct.matrix m â‰« biproduct.Ï€ g k = biproduct.desc (Î» j, m j k) :=
by { ext, simp [biproduct.matrix], }
@[simp, reassoc]
lemma biproduct.Î¹_matrix (m : Î  j k, f j âŸ¶ g k) (j : J) :
  biproduct.Î¹ f j â‰« biproduct.matrix m = biproduct.lift (Î» k, m j k) :=
by { ext, simp [biproduct.matrix], }
def biproduct.components (m : â¨ f âŸ¶ â¨ g) (j : J) (k : K) : f j âŸ¶ g k :=
biproduct.Î¹ f j â‰« m â‰« biproduct.Ï€ g k
@[simp] lemma biproduct.matrix_components (m : Î  j k, f j âŸ¶ g k) (j : J) (k : K) :
  biproduct.components (biproduct.matrix m) j k = m j k :=
by simp [biproduct.components]
@[simp] lemma biproduct.components_matrix (m : â¨ f âŸ¶ â¨ g) :
  biproduct.matrix (Î» j k, biproduct.components m j k) = m :=
by { ext, simp [biproduct.components], }
@[simps]
def biproduct.matrix_equiv : (â¨ f âŸ¶ â¨ g) â‰ƒ (Î  j k, f j âŸ¶ g k) :=
{ to_fun := biproduct.components,
  inv_fun := biproduct.matrix,
  left_inv := biproduct.components_matrix,
  right_inv := Î» m, by { ext, apply biproduct.matrix_components } }
end finite_biproducts
variables {J : Type w} {C : Type u} [category.{v} C] [has_zero_morphisms C]
instance biproduct.Î¹_mono (f : J â†’ C) [has_biproduct f]
  (b : J) : split_mono (biproduct.Î¹ f b) :=
{ retraction := biproduct.desc $
    Î» b', if h : b' = b then eq_to_hom (congr_arg f h) else biproduct.Î¹ f b' â‰« biproduct.Ï€ f b }
instance biproduct.Ï€_epi (f : J â†’ C) [has_biproduct f]
  (b : J) : split_epi (biproduct.Ï€ f b) :=
{ section_ := biproduct.lift $
    Î» b', if h : b = b' then eq_to_hom (congr_arg f h) else biproduct.Î¹ f b â‰« biproduct.Ï€ f b' }
lemma biproduct.cone_point_unique_up_to_iso_hom (f : J â†’ C) [has_biproduct f] {b : bicone f}
  (hb : b.is_bilimit) :
  (hb.is_limit.cone_point_unique_up_to_iso (biproduct.is_limit _)).hom = biproduct.lift b.Ï€ :=
rfl
lemma biproduct.cone_point_unique_up_to_iso_inv (f : J â†’ C) [has_biproduct f] {b : bicone f}
  (hb : b.is_bilimit) :
  (hb.is_limit.cone_point_unique_up_to_iso (biproduct.is_limit _)).inv = biproduct.desc b.Î¹ :=
begin
  refine biproduct.hom_ext' _ _ (Î» j, hb.is_limit.hom_ext (Î» j', _)),
  discrete_cases,
  rw [category.assoc, is_limit.cone_point_unique_up_to_iso_inv_comp, bicone.to_cone_Ï€_app,
    biproduct.bicone_Ï€, biproduct.Î¹_desc, biproduct.Î¹_Ï€, b.to_cone_Ï€_app, b.Î¹_Ï€]
end
@[simps]
def biproduct.unique_up_to_iso (f : J â†’ C) [has_biproduct f] {b : bicone f} (hb : b.is_bilimit) :
  b.X â‰… â¨ f :=
{ hom := biproduct.lift b.Ï€,
  inv := biproduct.desc b.Î¹,
  hom_inv_id' := by rw [â† biproduct.cone_point_unique_up_to_iso_hom f hb,
    â† biproduct.cone_point_unique_up_to_iso_inv f hb, iso.hom_inv_id],
  inv_hom_id' := by rw [â† biproduct.cone_point_unique_up_to_iso_hom f hb,
    â† biproduct.cone_point_unique_up_to_iso_inv f hb, iso.inv_hom_id] }
variables (C)
@[simps]
def limit_bicone_of_unique : limit_bicone f :=
{ bicone :=
  { X := f default,
    Ï€ := Î» j, eq_to_hom (by congr),
    Î¹ := Î» j, eq_to_hom (by congr), },
  is_bilimit :=
  { is_limit := (limit_cone_of_unique f).is_limit,
    is_colimit := (colimit_cocone_of_unique f).is_colimit, }, }
@[priority 100] instance has_biproduct_unique : has_biproduct f :=
has_biproduct.mk (limit_bicone_of_unique f)
@[simps]
def biproduct_unique_iso : â¨ f â‰… f default :=
(biproduct.unique_up_to_iso _ (limit_bicone_of_unique f).is_bilimit).symm
end
variables {C}
@[nolint has_inhabited_instance]
structure binary_bicone (P Q : C) :=
(X : C)
(fst : X âŸ¶ P)
(snd : X âŸ¶ Q)
(inl : P âŸ¶ X)
(inr : Q âŸ¶ X)
(inl_fst' : inl â‰« fst = ğŸ™ P . obviously)
(inl_snd' : inl â‰« snd = 0 . obviously)
(inr_fst' : inr â‰« fst = 0 . obviously)
(inr_snd' : inr â‰« snd = ğŸ™ Q . obviously)
restate_axiom binary_bicone.inl_fst'
restate_axiom binary_bicone.inl_snd'
restate_axiom binary_bicone.inr_fst'
restate_axiom binary_bicone.inr_snd'
attribute [simp, reassoc] binary_bicone.inl_fst binary_bicone.inl_snd
  binary_bicone.inr_fst binary_bicone.inr_snd
namespace binary_bicone
variables {P Q : C}
def to_cone (c : binary_bicone P Q) : cone (pair P Q) :=
binary_fan.mk c.fst c.snd
@[simp]
lemma to_cone_X (c : binary_bicone P Q) :
  c.to_cone.X = c.X := rfl
@[simp]
lemma to_cone_Ï€_app_left (c : binary_bicone P Q) :
  c.to_cone.Ï€.app âŸ¨walking_pair.leftâŸ© = c.fst := rfl
@[simp]
lemma to_cone_Ï€_app_right (c : binary_bicone P Q) :
  c.to_cone.Ï€.app âŸ¨walking_pair.rightâŸ© = c.snd := rfl
@[simp]
lemma binary_fan_fst_to_cone (c : binary_bicone P Q) : binary_fan.fst c.to_cone = c.fst := rfl
@[simp]
lemma binary_fan_snd_to_cone (c : binary_bicone P Q) : binary_fan.snd c.to_cone = c.snd := rfl
def to_cocone (c : binary_bicone P Q) : cocone (pair P Q) :=
binary_cofan.mk c.inl c.inr
@[simp]
lemma to_cocone_X (c : binary_bicone P Q) :
  c.to_cocone.X = c.X := rfl
@[simp]
lemma to_cocone_Î¹_app_left (c : binary_bicone P Q) :
  c.to_cocone.Î¹.app âŸ¨walking_pair.leftâŸ© = c.inl := rfl
@[simp]
lemma to_cocone_Î¹_app_right (c : binary_bicone P Q) :
  c.to_cocone.Î¹.app âŸ¨walking_pair.rightâŸ© = c.inr := rfl
@[simp]
lemma binary_cofan_inl_to_cocone (c : binary_bicone P Q) : binary_cofan.inl c.to_cocone = c.inl :=
rfl
@[simp]
lemma binary_cofan_inr_to_cocone (c : binary_bicone P Q) : binary_cofan.inr c.to_cocone = c.inr :=
rfl
@[simps]
def to_bicone {X Y : C} (b : binary_bicone X Y) : bicone (pair_function X Y) :=
{ X := b.X,
  Ï€ := Î» j, walking_pair.cases_on j b.fst b.snd,
  Î¹ := Î» j, walking_pair.cases_on j b.inl b.inr,
  Î¹_Ï€ := Î» j j', by { rcases j with âŸ¨âŸ©; rcases j' with âŸ¨âŸ©, tidy } }
def to_bicone_is_limit {X Y : C} (b : binary_bicone X Y) :
  is_limit (b.to_bicone.to_cone) â‰ƒ is_limit (b.to_cone) :=
is_limit.equiv_iso_limit $ cones.ext (iso.refl _) (Î» j, by { cases j, tidy })
def to_bicone_is_colimit {X Y : C} (b : binary_bicone X Y) :
  is_colimit (b.to_bicone.to_cocone) â‰ƒ is_colimit (b.to_cocone) :=
is_colimit.equiv_iso_colimit $ cocones.ext (iso.refl _) (Î» j, by { cases j, tidy })
end binary_bicone
namespace bicone
@[simps]
def to_binary_bicone {X Y : C} (b : bicone (pair_function X Y)) : binary_bicone X Y :=
{ X := b.X,
  fst := b.Ï€ walking_pair.left,
  snd := b.Ï€ walking_pair.right,
  inl := b.Î¹ walking_pair.left,
  inr := b.Î¹ walking_pair.right,
  inl_fst' := by { simp [bicone.Î¹_Ï€], refl, },
  inr_fst' := by simp [bicone.Î¹_Ï€],
  inl_snd' := by simp [bicone.Î¹_Ï€],
  inr_snd' := by { simp [bicone.Î¹_Ï€], refl, }, }
def to_binary_bicone_is_limit {X Y : C} (b : bicone (pair_function X Y)) :
  is_limit (b.to_binary_bicone.to_cone) â‰ƒ is_limit (b.to_cone) :=
is_limit.equiv_iso_limit $ cones.ext (iso.refl _) (Î» j, by { rcases j with âŸ¨âŸ¨âŸ©âŸ©; tidy })
def to_binary_bicone_is_colimit {X Y : C} (b : bicone (pair_function X Y)) :
  is_colimit (b.to_binary_bicone.to_cocone) â‰ƒ is_colimit (b.to_cocone) :=
is_colimit.equiv_iso_colimit $ cocones.ext (iso.refl _) (Î» j, by { rcases j with âŸ¨âŸ¨âŸ©âŸ©; tidy })
end bicone
@[nolint has_inhabited_instance]
structure binary_bicone.is_bilimit {P Q : C} (b : binary_bicone P Q) :=
(is_limit : is_limit b.to_cone)
(is_colimit : is_colimit b.to_cocone)
def binary_bicone.to_bicone_is_bilimit {X Y : C} (b : binary_bicone X Y) :
  b.to_bicone.is_bilimit â‰ƒ b.is_bilimit :=
{ to_fun := Î» h, âŸ¨b.to_bicone_is_limit h.is_limit, b.to_bicone_is_colimit h.is_colimitâŸ©,
  inv_fun := Î» h, âŸ¨b.to_bicone_is_limit.symm h.is_limit, b.to_bicone_is_colimit.symm h.is_colimitâŸ©,
  left_inv := Î» âŸ¨h, h'âŸ©, by { dsimp only, simp },
  right_inv := Î» âŸ¨h, h'âŸ©, by { dsimp only, simp } }
def bicone.to_binary_bicone_is_bilimit {X Y : C} (b : bicone (pair_function X Y)) :
  b.to_binary_bicone.is_bilimit â‰ƒ b.is_bilimit :=
{ to_fun := Î» h, âŸ¨b.to_binary_bicone_is_limit h.is_limit,
    b.to_binary_bicone_is_colimit h.is_colimitâŸ©,
  inv_fun := Î» h, âŸ¨b.to_binary_bicone_is_limit.symm h.is_limit,
    b.to_binary_bicone_is_colimit.symm h.is_colimitâŸ©,
  left_inv := Î» âŸ¨h, h'âŸ©, by { dsimp only, simp },
  right_inv := Î» âŸ¨h, h'âŸ©, by { dsimp only, simp } }
@[nolint has_inhabited_instance]
structure binary_biproduct_data (P Q : C) :=
(bicone : binary_bicone P Q)
(is_bilimit : bicone.is_bilimit)
class has_binary_biproduct (P Q : C) : Prop :=
mk' :: (exists_binary_biproduct : nonempty (binary_biproduct_data P Q))
lemma has_binary_biproduct.mk {P Q : C} (d : binary_biproduct_data P Q) :
  has_binary_biproduct P Q :=
âŸ¨nonempty.intro dâŸ©
def get_binary_biproduct_data (P Q : C) [has_binary_biproduct P Q] : binary_biproduct_data P Q :=
classical.choice has_binary_biproduct.exists_binary_biproduct
def binary_biproduct.bicone (P Q : C) [has_binary_biproduct P Q] : binary_bicone P Q :=
(get_binary_biproduct_data P Q).bicone
def binary_biproduct.is_bilimit (P Q : C) [has_binary_biproduct P Q] :
  (binary_biproduct.bicone P Q).is_bilimit :=
(get_binary_biproduct_data P Q).is_bilimit
def binary_biproduct.is_limit (P Q : C) [has_binary_biproduct P Q] :
  is_limit (binary_biproduct.bicone P Q).to_cone :=
(get_binary_biproduct_data P Q).is_bilimit.is_limit
def binary_biproduct.is_colimit (P Q : C) [has_binary_biproduct P Q] :
  is_colimit (binary_biproduct.bicone P Q).to_cocone :=
(get_binary_biproduct_data P Q).is_bilimit.is_colimit
section
variable (C)
class has_binary_biproducts : Prop :=
(has_binary_biproduct : Î  (P Q : C), has_binary_biproduct P Q)
attribute [instance, priority 100] has_binary_biproducts.has_binary_biproduct
lemma has_binary_biproducts_of_finite_biproducts [has_finite_biproducts C] :
  has_binary_biproducts C :=
{ has_binary_biproduct := Î» P Q, has_binary_biproduct.mk
  { bicone := (biproduct.bicone (pair_function P Q)).to_binary_bicone,
    is_bilimit := (bicone.to_binary_bicone_is_bilimit _).symm (biproduct.is_bilimit _) } }
end
variables {P Q : C}
instance has_binary_biproduct.has_limit_pair [has_binary_biproduct P Q] :
  has_limit (pair P Q) :=
has_limit.mk âŸ¨_, binary_biproduct.is_limit P QâŸ©
instance has_binary_biproduct.has_colimit_pair [has_binary_biproduct P Q] :
  has_colimit (pair P Q) :=
has_colimit.mk âŸ¨_, binary_biproduct.is_colimit P QâŸ©
@[priority 100]
instance has_binary_products_of_has_binary_biproducts [has_binary_biproducts C] :
  has_binary_products C :=
{ has_limit := Î» F, has_limit_of_iso (diagram_iso_pair F).symm }
@[priority 100]
instance has_binary_coproducts_of_has_binary_biproducts [has_binary_biproducts C] :
  has_binary_coproducts C :=
{ has_colimit := Î» F, has_colimit_of_iso (diagram_iso_pair F) }
def biprod_iso (X Y : C) [has_binary_biproduct X Y]  :
  limits.prod X Y â‰… limits.coprod X Y :=
(is_limit.cone_point_unique_up_to_iso (limit.is_limit _) (binary_biproduct.is_limit X Y)).trans $
  is_colimit.cocone_point_unique_up_to_iso (binary_biproduct.is_colimit X Y) (colimit.is_colimit _)
abbreviation biprod (X Y : C) [has_binary_biproduct X Y] := (binary_biproduct.bicone X Y).X
notation X ` âŠ `:20 Y:20 := biprod X Y
abbreviation biprod.fst {X Y : C} [has_binary_biproduct X Y] : X âŠ Y âŸ¶ X :=
(binary_biproduct.bicone X Y).fst
abbreviation biprod.snd {X Y : C} [has_binary_biproduct X Y] : X âŠ Y âŸ¶ Y :=
(binary_biproduct.bicone X Y).snd
abbreviation biprod.inl {X Y : C} [has_binary_biproduct X Y] : X âŸ¶ X âŠ Y :=
(binary_biproduct.bicone X Y).inl
abbreviation biprod.inr {X Y : C} [has_binary_biproduct X Y] : Y âŸ¶ X âŠ Y :=
(binary_biproduct.bicone X Y).inr
section
variables {X Y : C} [has_binary_biproduct X Y]
@[simp] lemma binary_biproduct.bicone_fst : (binary_biproduct.bicone X Y).fst = biprod.fst := rfl
@[simp] lemma binary_biproduct.bicone_snd : (binary_biproduct.bicone X Y).snd = biprod.snd := rfl
@[simp] lemma binary_biproduct.bicone_inl : (binary_biproduct.bicone X Y).inl = biprod.inl := rfl
@[simp] lemma binary_biproduct.bicone_inr : (binary_biproduct.bicone X Y).inr = biprod.inr := rfl
end
@[simp,reassoc]
lemma biprod.inl_fst {X Y : C} [has_binary_biproduct X Y] :
  (biprod.inl : X âŸ¶ X âŠ Y) â‰« (biprod.fst : X âŠ Y âŸ¶ X) = ğŸ™ X :=
(binary_biproduct.bicone X Y).inl_fst
@[simp,reassoc]
lemma biprod.inl_snd {X Y : C} [has_binary_biproduct X Y] :
  (biprod.inl : X âŸ¶ X âŠ Y) â‰« (biprod.snd : X âŠ Y âŸ¶ Y) = 0 :=
(binary_biproduct.bicone X Y).inl_snd
@[simp,reassoc]
lemma biprod.inr_fst {X Y : C} [has_binary_biproduct X Y] :
  (biprod.inr : Y âŸ¶ X âŠ Y) â‰« (biprod.fst : X âŠ Y âŸ¶ X) = 0 :=
(binary_biproduct.bicone X Y).inr_fst
@[simp,reassoc]
lemma biprod.inr_snd {X Y : C} [has_binary_biproduct X Y] :
  (biprod.inr : Y âŸ¶ X âŠ Y) â‰« (biprod.snd : X âŠ Y âŸ¶ Y) = ğŸ™ Y :=
(binary_biproduct.bicone X Y).inr_snd
abbreviation biprod.lift {W X Y : C} [has_binary_biproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :
  W âŸ¶ X âŠ Y :=
(binary_biproduct.is_limit X Y).lift (binary_fan.mk f g)
abbreviation biprod.desc {W X Y : C} [has_binary_biproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) :
  X âŠ Y âŸ¶ W :=
(binary_biproduct.is_colimit X Y).desc (binary_cofan.mk f g)
@[simp, reassoc]
lemma biprod.lift_fst {W X Y : C} [has_binary_biproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :
  biprod.lift f g â‰« biprod.fst = f :=
(binary_biproduct.is_limit X Y).fac _ âŸ¨walking_pair.leftâŸ©
@[simp, reassoc]
lemma biprod.lift_snd {W X Y : C} [has_binary_biproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :
  biprod.lift f g â‰« biprod.snd = g :=
(binary_biproduct.is_limit X Y).fac _ âŸ¨walking_pair.rightâŸ©
@[simp, reassoc]
lemma biprod.inl_desc {W X Y : C} [has_binary_biproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) :
  biprod.inl â‰« biprod.desc f g = f :=
(binary_biproduct.is_colimit X Y).fac _ âŸ¨walking_pair.leftâŸ©
@[simp, reassoc]
lemma biprod.inr_desc {W X Y : C} [has_binary_biproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) :
  biprod.inr â‰« biprod.desc f g = g :=
(binary_biproduct.is_colimit X Y).fac _ âŸ¨walking_pair.rightâŸ©
instance biprod.mono_lift_of_mono_left {W X Y : C} [has_binary_biproduct X Y] (f : W âŸ¶ X)
  (g : W âŸ¶ Y) [mono f] : mono (biprod.lift f g) :=
mono_of_mono_fac $ biprod.lift_fst _ _
instance biprod.mono_lift_of_mono_right {W X Y : C} [has_binary_biproduct X Y] (f : W âŸ¶ X)
  (g : W âŸ¶ Y) [mono g] : mono (biprod.lift f g) :=
mono_of_mono_fac $ biprod.lift_snd _ _
instance biprod.epi_desc_of_epi_left {W X Y : C} [has_binary_biproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W)
  [epi f] : epi (biprod.desc f g) :=
epi_of_epi_fac $ biprod.inl_desc _ _
instance biprod.epi_desc_of_epi_right {W X Y : C} [has_binary_biproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W)
  [epi g] : epi (biprod.desc f g) :=
epi_of_epi_fac $ biprod.inr_desc _ _
abbreviation biprod.map {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) : W âŠ X âŸ¶ Y âŠ Z :=
is_limit.map (binary_biproduct.bicone W X).to_cone (binary_biproduct.is_limit Y Z)
  (@map_pair _ _ (pair W X) (pair Y Z) f g)
abbreviation biprod.map' {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) : W âŠ X âŸ¶ Y âŠ Z :=
is_colimit.map (binary_biproduct.is_colimit W X) (binary_biproduct.bicone Y Z).to_cocone
  (@map_pair _ _ (pair W X) (pair Y Z) f g)
@[ext] lemma biprod.hom_ext {X Y Z : C} [has_binary_biproduct X Y] (f g : Z âŸ¶ X âŠ Y)
  (hâ‚€ : f â‰« biprod.fst = g â‰« biprod.fst) (hâ‚ : f â‰« biprod.snd = g â‰« biprod.snd) : f = g :=
binary_fan.is_limit.hom_ext (binary_biproduct.is_limit X Y) hâ‚€ hâ‚
@[ext] lemma biprod.hom_ext' {X Y Z : C} [has_binary_biproduct X Y] (f g : X âŠ Y âŸ¶ Z)
  (hâ‚€ : biprod.inl â‰« f = biprod.inl â‰« g) (hâ‚ : biprod.inr â‰« f = biprod.inr â‰« g) : f = g :=
binary_cofan.is_colimit.hom_ext (binary_biproduct.is_colimit X Y) hâ‚€ hâ‚
lemma biprod.map_eq_map' {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) : biprod.map f g = biprod.map' f g :=
begin
  ext,
  { simp only [map_pair_left, is_colimit.Î¹_map, is_limit.map_Ï€, biprod.inl_fst_assoc,
    category.assoc, â†binary_bicone.to_cone_Ï€_app_left, â†binary_biproduct.bicone_fst,
    â†binary_bicone.to_cocone_Î¹_app_left, â†binary_biproduct.bicone_inl],
    simp },
  { simp only [map_pair_left, is_colimit.Î¹_map, is_limit.map_Ï€, zero_comp,
      biprod.inl_snd_assoc, category.assoc,
      â†binary_bicone.to_cone_Ï€_app_right, â†binary_biproduct.bicone_snd,
      â†binary_bicone.to_cocone_Î¹_app_left, â†binary_biproduct.bicone_inl],
    simp },
  { simp only [map_pair_right, biprod.inr_fst_assoc, is_colimit.Î¹_map, is_limit.map_Ï€,
      zero_comp, category.assoc,
      â†binary_bicone.to_cone_Ï€_app_left, â†binary_biproduct.bicone_fst,
      â†binary_bicone.to_cocone_Î¹_app_right, â†binary_biproduct.bicone_inr],
    simp },
  { simp only [map_pair_right, is_colimit.Î¹_map, is_limit.map_Ï€, biprod.inr_snd_assoc,
      category.assoc, â†binary_bicone.to_cone_Ï€_app_right, â†binary_biproduct.bicone_snd,
      â†binary_bicone.to_cocone_Î¹_app_right, â†binary_biproduct.bicone_inr],
    simp }
end
instance biprod.inl_mono {X Y : C} [has_binary_biproduct X Y] :
  split_mono (biprod.inl : X âŸ¶ X âŠ Y) :=
{ retraction := biprod.desc (ğŸ™ X) (biprod.inr â‰« biprod.fst) }
instance biprod.inr_mono {X Y : C} [has_binary_biproduct X Y] :
  split_mono (biprod.inr : Y âŸ¶ X âŠ Y) :=
{ retraction := biprod.desc (biprod.inl â‰« biprod.snd) (ğŸ™ Y)}
instance biprod.fst_epi {X Y : C} [has_binary_biproduct X Y] :
  split_epi (biprod.fst : X âŠ Y âŸ¶ X) :=
{ section_ := biprod.lift (ğŸ™ X) (biprod.inl â‰« biprod.snd) }
instance biprod.snd_epi {X Y : C} [has_binary_biproduct X Y] :
  split_epi (biprod.snd : X âŠ Y âŸ¶ Y) :=
{ section_ := biprod.lift (biprod.inr â‰« biprod.fst) (ğŸ™ Y) }
@[simp,reassoc]
lemma biprod.map_fst {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) :
  biprod.map f g â‰« biprod.fst = biprod.fst â‰« f :=
is_limit.map_Ï€ _ _ _ (âŸ¨walking_pair.leftâŸ© : discrete walking_pair)
@[simp,reassoc]
lemma biprod.map_snd {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z]
  (f : W âŸ¶ Y) (g : X âŸ¶ Z) :
  biprod.map f g â‰« biprod.snd = biprod.snd â‰« g :=
is_limit.map_Ï€ _ _ _ (âŸ¨walking_pair.rightâŸ© : discrete walking_pair)
@[simps]
def biprod.map_iso {W X Y Z : C} [has_binary_biproduct W X] [has_binary_biproduct Y Z]
  (f : W â‰… Y) (g : X â‰… Z) : W âŠ X â‰… Y âŠ Z :=
{ hom := biprod.map f.hom g.hom,
  inv := biprod.map f.inv g.inv }
lemma biprod.cone_point_unique_up_to_iso_hom (X Y : C) [has_binary_biproduct X Y]
  {b : binary_bicone X Y} (hb : b.is_bilimit) :
  (hb.is_limit.cone_point_unique_up_to_iso (binary_biproduct.is_limit _ _)).hom
    = biprod.lift b.fst b.snd :=
rfl
lemma biprod.cone_point_unique_up_to_iso_inv (X Y : C) [has_binary_biproduct X Y]
  {b : binary_bicone X Y} (hb : b.is_bilimit) :
  (hb.is_limit.cone_point_unique_up_to_iso (binary_biproduct.is_limit _ _)).inv
    = biprod.desc b.inl b.inr :=
begin
  refine biprod.hom_ext' _ _ (hb.is_limit.hom_ext (Î» j, _)) (hb.is_limit.hom_ext (Î» j, _)),
  all_goals { simp only [category.assoc, is_limit.cone_point_unique_up_to_iso_inv_comp],
    rcases j with âŸ¨âŸ¨âŸ©âŸ© },
  all_goals { simp }
end
@[simps]
def biprod.unique_up_to_iso (X Y : C) [has_binary_biproduct X Y] {b : binary_bicone X Y}
  (hb : b.is_bilimit) : b.X â‰… X âŠ Y :=
{ hom := biprod.lift b.fst b.snd,
  inv := biprod.desc b.inl b.inr,
  hom_inv_id' := by rw [â† biprod.cone_point_unique_up_to_iso_hom X Y hb,
    â† biprod.cone_point_unique_up_to_iso_inv X Y hb, iso.hom_inv_id],
  inv_hom_id' := by rw [â† biprod.cone_point_unique_up_to_iso_hom X Y hb,
    â† biprod.cone_point_unique_up_to_iso_inv X Y hb, iso.inv_hom_id] }
section
variables (X Y : C) [has_binary_biproduct X Y]
def biprod.fst_kernel_fork : kernel_fork (biprod.fst : X âŠ Y âŸ¶ X) :=
kernel_fork.of_Î¹ biprod.inr biprod.inr_fst
@[simp]
lemma biprod.fst_kernel_fork_Î¹ : fork.Î¹ (biprod.fst_kernel_fork X Y) = biprod.inr :=
rfl
def biprod.is_kernel_fst_kernel_fork : is_limit (biprod.fst_kernel_fork X Y) :=
fork.is_limit.mk' _ $ Î» s, âŸ¨s.Î¹ â‰« biprod.snd, by ext; simp, Î» m hm, by simp [â† hm]âŸ©
def biprod.snd_kernel_fork : kernel_fork (biprod.snd : X âŠ Y âŸ¶ Y) :=
kernel_fork.of_Î¹ biprod.inl biprod.inl_snd
@[simp]
lemma biprod.snd_kernel_fork_Î¹ : fork.Î¹ (biprod.snd_kernel_fork X Y) = biprod.inl :=
rfl
def biprod.is_kernel_snd_kernel_fork : is_limit (biprod.snd_kernel_fork X Y) :=
fork.is_limit.mk' _ $ Î» s, âŸ¨s.Î¹ â‰« biprod.fst, by ext; simp, Î» m hm, by simp [â† hm]âŸ©
def biprod.inl_cokernel_fork : cokernel_cofork (biprod.inl : X âŸ¶ X âŠ Y) :=
cokernel_cofork.of_Ï€ biprod.snd biprod.inl_snd
@[simp]
lemma biprod.inl_cokernel_fork_Ï€ : cofork.Ï€ (biprod.inl_cokernel_fork X Y) = biprod.snd :=
rfl
def biprod.is_cokernel_inl_cokernel_fork : is_colimit (biprod.inl_cokernel_fork X Y) :=
cofork.is_colimit.mk' _ $ Î» s, âŸ¨biprod.inr â‰« s.Ï€, by ext; simp, Î» m hm, by simp [â† hm]âŸ©
def biprod.inr_cokernel_fork : cokernel_cofork (biprod.inr : Y âŸ¶ X âŠ Y) :=
cokernel_cofork.of_Ï€ biprod.fst biprod.inr_fst
@[simp]
lemma biprod.inr_cokernel_fork_Ï€ : cofork.Ï€ (biprod.inr_cokernel_fork X Y) = biprod.fst :=
rfl
def biprod.is_cokernel_inr_cokernel_fork : is_colimit (biprod.inr_cokernel_fork X Y) :=
cofork.is_colimit.mk' _ $ Î» s, âŸ¨biprod.inl â‰« s.Ï€, by ext; simp, Î» m hm, by simp [â† hm]âŸ©
end biprod_kernel
section is_zero
@[simps]
def iso_biprod_zero {X Y : C} [has_binary_biproduct X Y] (hY : is_zero Y) : X â‰… X âŠ Y :=
{ hom := biprod.inl,
  inv := biprod.fst,
  inv_hom_id' := begin
    apply category_theory.limits.biprod.hom_ext;
    simp only [category.assoc, biprod.inl_fst, category.comp_id, category.id_comp,
      biprod.inl_snd, comp_zero],
    apply hY.eq_of_tgt
  end }
@[simps]
def iso_zero_biprod {X Y : C} [has_binary_biproduct X Y] (hY : is_zero X) : Y â‰… X âŠ Y :=
{ hom := biprod.inr,
  inv := biprod.snd,
  inv_hom_id' := begin
    apply category_theory.limits.biprod.hom_ext;
    simp only [category.assoc, biprod.inr_snd, category.comp_id, category.id_comp,
      biprod.inr_fst, comp_zero],
    apply hY.eq_of_tgt
  end }
end is_zero
section
variables [has_binary_biproducts C]
@[simps] def biprod.braiding (P Q : C) : P âŠ Q â‰… Q âŠ P :=
{ hom := biprod.lift biprod.snd biprod.fst,
  inv := biprod.lift biprod.snd biprod.fst }
@[simps]
def biprod.braiding' (P Q : C) : P âŠ Q â‰… Q âŠ P :=
{ hom := biprod.desc biprod.inr biprod.inl,
  inv := biprod.desc biprod.inr biprod.inl }
lemma biprod.braiding'_eq_braiding {P Q : C} :
  biprod.braiding' P Q = biprod.braiding P Q :=
by tidy
@[reassoc] lemma biprod.braid_natural {W X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ W) :
  biprod.map f g â‰« (biprod.braiding _ _).hom = (biprod.braiding _ _).hom â‰« biprod.map g f :=
by tidy
@[reassoc] lemma biprod.braiding_map_braiding {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) :
  (biprod.braiding X W).hom â‰« biprod.map f g â‰« (biprod.braiding Y Z).hom = biprod.map g f :=
by tidy
@[simp, reassoc] lemma biprod.symmetry' (P Q : C) :
  biprod.lift biprod.snd biprod.fst â‰« biprod.lift biprod.snd biprod.fst = ğŸ™ (P âŠ Q) :=
by tidy
@[reassoc] lemma biprod.symmetry (P Q : C) :
  (biprod.braiding P Q).hom â‰« (biprod.braiding Q P).hom = ğŸ™ _ :=
by simp
end
def is_bilimit_of_total {f : J â†’ C} (b : bicone f) (total : âˆ‘ j : J, b.Ï€ j â‰« b.Î¹ j = ğŸ™ b.X) :
  b.is_bilimit :=
{ is_limit :=
  { lift := Î» s, âˆ‘ (j : J), s.Ï€.app âŸ¨jâŸ© â‰« b.Î¹ j,
    uniq' := Î» s m h,
    begin
      erw [â†category.comp_id m, â†total, comp_sum],
      apply finset.sum_congr rfl,
      intros j m,
      erw [reassoc_of (h âŸ¨jâŸ©)],
    end,
    fac' := Î» s j,
    begin
      cases j,
      simp only [sum_comp, category.assoc, bicone.to_cone_Ï€_app, b.Î¹_Ï€, comp_dite],
lemma has_biproduct_of_total {f : J â†’ C} (b : bicone f) (total : âˆ‘ j : J, b.Ï€ j â‰« b.Î¹ j = ğŸ™ b.X) :
  has_biproduct f :=
has_biproduct.mk
{ bicone := b,
  is_bilimit := is_bilimit_of_total b total }
def is_bilimit_of_is_limit {f : J â†’ C} (t : bicone f) (ht : is_limit t.to_cone) : t.is_bilimit :=
is_bilimit_of_total _ $ ht.hom_ext $
  Î» j, by { cases j, simp [sum_comp, t.Î¹_Ï€, dite_comp, comp_dite] }
def bicone_is_bilimit_of_limit_cone_of_is_limit {f : J â†’ C} {t : cone (discrete.functor f)}
  (ht : is_limit t) : (bicone.of_limit_cone ht).is_bilimit :=
is_bilimit_of_is_limit _ $
  is_limit.of_iso_limit ht $ cones.ext (iso.refl _) (by { rintro âŸ¨jâŸ©, tidy })
lemma has_biproduct.of_has_product (f : J â†’ C) [has_product f] : has_biproduct f :=
has_biproduct.mk
{ bicone := _,
  is_bilimit := bicone_is_bilimit_of_limit_cone_of_is_limit (limit.is_limit _) }
def is_bilimit_of_is_colimit {f : J â†’ C} (t : bicone f) (ht : is_colimit t.to_cocone) :
  t.is_bilimit :=
is_bilimit_of_total _ $ ht.hom_ext $ Î» j, begin
  cases j,
  simp_rw [bicone.to_cocone_Î¹_app, comp_sum, â† category.assoc, t.Î¹_Ï€, dite_comp],
  tidy
end
def bicone_is_bilimit_of_colimit_cocone_of_is_colimit {f : J â†’ C} {t : cocone (discrete.functor f)}
  (ht : is_colimit t) : (bicone.of_colimit_cocone ht).is_bilimit :=
is_bilimit_of_is_colimit _ $
  is_colimit.of_iso_colimit ht $ cocones.ext (iso.refl _) (by { rintro âŸ¨jâŸ©, tidy })
lemma has_biproduct.of_has_coproduct (f : J â†’ C) [has_coproduct f] : has_biproduct f :=
has_biproduct.mk
{ bicone := _,
  is_bilimit := bicone_is_bilimit_of_colimit_cocone_of_is_colimit (colimit.is_colimit _) }
lemma has_finite_biproducts.of_has_finite_products [has_finite_products C] :
  has_finite_biproducts C :=
âŸ¨Î» J _, { has_biproduct := Î» F, by exactI has_biproduct.of_has_product _ }âŸ©
lemma has_finite_biproducts.of_has_finite_coproducts [has_finite_coproducts C] :
  has_finite_biproducts C :=
âŸ¨Î» J _, { has_biproduct := Î» F, by exactI has_biproduct.of_has_coproduct _ }âŸ©
section
variables {f : J â†’ C} [has_biproduct f]
@[simp] lemma biproduct.total : âˆ‘ j : J, biproduct.Ï€ f j â‰« biproduct.Î¹ f j = ğŸ™ (â¨ f) :=
is_bilimit.total (biproduct.is_bilimit _)
lemma biproduct.lift_eq {T : C} {g : Î  j, T âŸ¶ f j} :
  biproduct.lift g = âˆ‘ j, g j â‰« biproduct.Î¹ f j :=
begin
  ext j,
  simp [sum_comp, biproduct.Î¹_Ï€, comp_dite],
end
lemma biproduct.desc_eq {T : C} {g : Î  j, f j âŸ¶ T} :
  biproduct.desc g = âˆ‘ j, biproduct.Ï€ f j â‰« g j :=
begin
  ext j,
  simp [comp_sum, biproduct.Î¹_Ï€_assoc, dite_comp],
end
@[simp, reassoc] lemma biproduct.lift_desc {T U : C} {g : Î  j, T âŸ¶ f j} {h : Î  j, f j âŸ¶ U} :
  biproduct.lift g â‰« biproduct.desc h = âˆ‘ j : J, g j â‰« h j :=
by simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.Î¹_Ï€_assoc,
  comp_dite, dite_comp]
lemma biproduct.map_eq [has_finite_biproducts C] {f g : J â†’ C} {h : Î  j, f j âŸ¶ g j} :
  biproduct.map h = âˆ‘ j : J, biproduct.Ï€ f j â‰« h j â‰« biproduct.Î¹ g j :=
begin
  ext,
  simp [biproduct.Î¹_Ï€, biproduct.Î¹_Ï€_assoc, comp_sum, sum_comp, comp_dite, dite_comp],
end
@[simp, reassoc]
lemma biproduct.matrix_desc
  {K : Type} [fintype K] [has_finite_biproducts C]
  {f : J â†’ C} {g : K â†’ C} (m : Î  j k, f j âŸ¶ g k) {P} (x : Î  k, g k âŸ¶ P) :
  biproduct.matrix m â‰« biproduct.desc x = biproduct.desc (Î» j, âˆ‘ k, m j k â‰« x k) :=
by { ext, simp, }
@[simp, reassoc]
lemma biproduct.lift_matrix
  {K : Type} [fintype K] [has_finite_biproducts C]
  {f : J â†’ C} {g : K â†’ C} {P} (x : Î  j, P âŸ¶ f j) (m : Î  j k, f j âŸ¶ g k)  :
  biproduct.lift x â‰« biproduct.matrix m = biproduct.lift (Î» k, âˆ‘ j, x j â‰« m j k) :=
by { ext, simp, }
@[reassoc]
lemma biproduct.matrix_map
  {K : Type} [fintype K] [has_finite_biproducts C]
  {f : J â†’ C} {g : K â†’ C} {h : K â†’ C} (m : Î  j k, f j âŸ¶ g k) (n : Î  k, g k âŸ¶ h k) :
  biproduct.matrix m â‰« biproduct.map n = biproduct.matrix (Î» j k, m j k â‰« n k) :=
by { ext, simp, }
@[reassoc]
lemma biproduct.map_matrix
  {K : Type} [fintype K] [has_finite_biproducts C]
  {f : J â†’ C} {g : J â†’ C} {h : K â†’ C} (m : Î  k, f k âŸ¶ g k) (n : Î  j k, g j âŸ¶ h k) :
  biproduct.map m â‰« biproduct.matrix n = biproduct.matrix (Î» j k, m j â‰« n j k) :=
by { ext, simp, }
end
@[simps]
def biproduct.reindex {Î² Î³ : Type} [fintype Î²] [decidable_eq Î²] [decidable_eq Î³]
  (Îµ : Î² â‰ƒ Î³) (f : Î³ â†’ C) [has_biproduct f] [has_biproduct (f âˆ˜ Îµ)] : (â¨ (f âˆ˜ Îµ)) â‰… (â¨ f) :=
{ hom := biproduct.desc (Î» b, biproduct.Î¹ f (Îµ b)),
  inv := biproduct.lift (Î» b, biproduct.Ï€ f (Îµ b)),
  hom_inv_id' := by { ext b b', by_cases h : b = b', { subst h, simp, }, { simp [h], }, },
  inv_hom_id' := begin
    ext g g',
    by_cases h : g = g';
    simp [preadditive.sum_comp, preadditive.comp_sum, biproduct.Î¹_Ï€, biproduct.Î¹_Ï€_assoc, comp_dite,
      equiv.apply_eq_iff_eq_symm_apply, finset.sum_dite_eq' finset.univ (Îµ.symm g') _, h],
  end, }
def is_binary_bilimit_of_total {X Y : C} (b : binary_bicone X Y)
  (total : b.fst â‰« b.inl + b.snd â‰« b.inr = ğŸ™ b.X) : b.is_bilimit :=
{ is_limit :=
  { lift := Î» s, binary_fan.fst s â‰« b.inl +
      binary_fan.snd s â‰« b.inr,
    uniq' := Î» s m h, by erw [â†category.comp_id m, â†total,
      comp_add, reassoc_of (h âŸ¨walking_pair.leftâŸ©), reassoc_of (h âŸ¨walking_pair.rightâŸ©)],
    fac' := Î» s j, by rcases j with âŸ¨âŸ¨âŸ©âŸ©; simp, },
  is_colimit :=
  { desc := Î» s, b.fst â‰« binary_cofan.inl s +
      b.snd â‰« binary_cofan.inr s,
    uniq' := Î» s m h, by erw [â†category.id_comp m, â†total,
      add_comp, category.assoc, category.assoc, h âŸ¨walking_pair.leftâŸ©, h âŸ¨walking_pair.rightâŸ©],
    fac' := Î» s j, by rcases j with âŸ¨âŸ¨âŸ©âŸ©; simp, } }
lemma is_bilimit.binary_total {X Y : C} {b : binary_bicone X Y} (i : b.is_bilimit) :
  b.fst â‰« b.inl + b.snd â‰« b.inr = ğŸ™ b.X :=
i.is_limit.hom_ext (Î» j, by { rcases j with âŸ¨âŸ¨âŸ©âŸ©; simp, })
lemma has_binary_biproduct_of_total {X Y : C} (b : binary_bicone X Y)
  (total : b.fst â‰« b.inl + b.snd â‰« b.inr = ğŸ™ b.X) : has_binary_biproduct X Y :=
has_binary_biproduct.mk
{ bicone := b,
  is_bilimit := is_binary_bilimit_of_total b total }
@[simps]
def binary_bicone.of_limit_cone {X Y : C} {t : cone (pair X Y)} (ht : is_limit t) :
  binary_bicone X Y :=
{ X := t.X,
  fst := t.Ï€.app âŸ¨walking_pair.leftâŸ©,
  snd := t.Ï€.app âŸ¨walking_pair.rightâŸ©,
  inl := ht.lift (binary_fan.mk (ğŸ™ X) 0),
  inr := ht.lift (binary_fan.mk 0 (ğŸ™ Y)) }
lemma inl_of_is_limit {X Y : C} {t : binary_bicone X Y} (ht : is_limit t.to_cone) :
  t.inl = ht.lift (binary_fan.mk (ğŸ™ X) 0) :=
ht.hom_ext $ Î» j, by { rw ht.fac, rcases j with âŸ¨âŸ¨âŸ©âŸ©; simp }
lemma inr_of_is_limit {X Y : C} {t : binary_bicone X Y} (ht : is_limit t.to_cone) :
  t.inr = ht.lift (binary_fan.mk 0 (ğŸ™ Y)) :=
ht.hom_ext $ Î» j, by { rw ht.fac, rcases j with âŸ¨âŸ¨âŸ©âŸ©; simp }
def is_binary_bilimit_of_is_limit {X Y : C} (t : binary_bicone X Y) (ht : is_limit t.to_cone) :
  t.is_bilimit :=
is_binary_bilimit_of_total _ (by refine binary_fan.is_limit.hom_ext ht _ _; simp)
def binary_bicone_is_bilimit_of_limit_cone_of_is_limit {X Y : C} {t : cone (pair X Y)}
  (ht : is_limit t) : (binary_bicone.of_limit_cone ht).is_bilimit :=
is_binary_bilimit_of_total _ $ binary_fan.is_limit.hom_ext ht (by simp) (by simp)
lemma has_binary_biproduct.of_has_binary_product (X Y : C) [has_binary_product X Y] :
  has_binary_biproduct X Y :=
has_binary_biproduct.mk
{ bicone := _,
  is_bilimit := binary_bicone_is_bilimit_of_limit_cone_of_is_limit (limit.is_limit _) }
lemma has_binary_biproducts.of_has_binary_products [has_binary_products C] :
  has_binary_biproducts C :=
{ has_binary_biproduct := Î» X Y, has_binary_biproduct.of_has_binary_product X Y, }
@[simps]
def binary_bicone.of_colimit_cocone {X Y : C} {t : cocone (pair X Y)} (ht : is_colimit t) :
  binary_bicone X Y :=
{ X := t.X,
  fst := ht.desc (binary_cofan.mk (ğŸ™ X) 0),
  snd := ht.desc (binary_cofan.mk 0 (ğŸ™ Y)),
  inl := t.Î¹.app âŸ¨walking_pair.leftâŸ©,
  inr := t.Î¹.app âŸ¨walking_pair.rightâŸ© }
lemma fst_of_is_colimit {X Y : C} {t : binary_bicone X Y} (ht : is_colimit t.to_cocone) :
  t.fst = ht.desc (binary_cofan.mk (ğŸ™ X) 0) :=
begin
  refine ht.hom_ext (Î» j, _),
  rw ht.fac,
  rcases j with âŸ¨âŸ¨âŸ©âŸ©,
  all_goals { simp only [binary_bicone.to_cocone_Î¹_app_left, binary_bicone.inl_fst,
      binary_cofan.mk_Î¹_app_left, binary_bicone.to_cocone_Î¹_app_right, binary_bicone.inr_fst,
      binary_cofan.mk_Î¹_app_right] },
  refl
end
lemma snd_of_is_colimit {X Y : C} {t : binary_bicone X Y} (ht : is_colimit t.to_cocone) :
  t.snd = ht.desc (binary_cofan.mk 0 (ğŸ™ Y)) :=
begin
  refine ht.hom_ext (Î» j, _),
  rw ht.fac,
  rcases j with âŸ¨âŸ¨âŸ©âŸ©,
  all_goals { simp only [binary_bicone.to_cocone_Î¹_app_left, binary_bicone.inl_snd,
    binary_cofan.mk_Î¹_app_left, binary_bicone.to_cocone_Î¹_app_right, binary_bicone.inr_snd,
    binary_cofan.mk_Î¹_app_right] },
  refl
end
def is_binary_bilimit_of_is_colimit {X Y : C} (t : binary_bicone X Y)
  (ht : is_colimit t.to_cocone) : t.is_bilimit :=
is_binary_bilimit_of_total _
begin
  refine binary_cofan.is_colimit.hom_ext ht _ _; simp,
  { rw [category.comp_id t.inl] },
  { rw [category.comp_id t.inr] }
end
def binary_bicone_is_bilimit_of_colimit_cocone_of_is_colimit {X Y : C} {t : cocone (pair X Y)}
  (ht : is_colimit t) : (binary_bicone.of_colimit_cocone ht).is_bilimit :=
is_binary_bilimit_of_is_colimit (binary_bicone.of_colimit_cocone ht) $
  is_colimit.of_iso_colimit ht $ cocones.ext (iso.refl _) $ Î» j, by { rcases j with âŸ¨âŸ¨âŸ©âŸ©, tidy }
lemma has_binary_biproduct.of_has_binary_coproduct (X Y : C) [has_binary_coproduct X Y] :
  has_binary_biproduct X Y :=
has_binary_biproduct.mk
{ bicone := _,
  is_bilimit := binary_bicone_is_bilimit_of_colimit_cocone_of_is_colimit (colimit.is_colimit _) }
lemma has_binary_biproducts.of_has_binary_coproducts [has_binary_coproducts C] :
  has_binary_biproducts C :=
{ has_binary_biproduct := Î» X Y, has_binary_biproduct.of_has_binary_coproduct X Y, }
section
variables {X Y : C} [has_binary_biproduct X Y]
@[simp] lemma biprod.total : biprod.fst â‰« biprod.inl + biprod.snd â‰« biprod.inr = ğŸ™ (X âŠ Y) :=
begin
  ext; simp [add_comp],
end
lemma biprod.lift_eq {T : C} {f : T âŸ¶ X} {g : T âŸ¶ Y} :
  biprod.lift f g = f â‰« biprod.inl + g â‰« biprod.inr :=
begin
  ext; simp [add_comp],
end
lemma biprod.desc_eq {T : C} {f : X âŸ¶ T} {g : Y âŸ¶ T} :
  biprod.desc f g = biprod.fst â‰« f + biprod.snd â‰« g :=
begin
  ext; simp [add_comp],
end
@[simp, reassoc] lemma biprod.lift_desc {T U : C} {f : T âŸ¶ X} {g : T âŸ¶ Y} {h : X âŸ¶ U} {i : Y âŸ¶ U} :
  biprod.lift f g â‰« biprod.desc h i = f â‰« h + g â‰« i :=
by simp [biprod.lift_eq, biprod.desc_eq]
lemma biprod.map_eq [has_binary_biproducts C] {W X Y Z : C} {f : W âŸ¶ Y} {g : X âŸ¶ Z} :
  biprod.map f g = biprod.fst â‰« f â‰« biprod.inl + biprod.snd â‰« g â‰« biprod.inr :=
by apply biprod.hom_ext; apply biprod.hom_ext'; simp
@[simps]
def binary_bicone_of_split_mono_of_cokernel {X Y : C} {f : X âŸ¶ Y} [split_mono f]
  {c : cokernel_cofork f} (i : is_colimit c) : binary_bicone X c.X :=
{ X := Y,
  fst := retraction f,
  snd := c.Ï€,
  inl := f,
  inr :=
    let c' : cokernel_cofork (ğŸ™ Y - (ğŸ™ Y - retraction f â‰« f)) :=
      cokernel_cofork.of_Ï€ (cofork.Ï€ c) (by simp) in
    let i' : is_colimit c' := is_cokernel_epi_comp i (retraction f) (by simp) in
    let i'' := is_colimit_cofork_of_cokernel_cofork i' in
    (split_epi_of_idempotent_of_is_colimit_cofork C (by simp) i'').section_,
  inl_fst' := by simp,
  inl_snd' := by simp,
  inr_fst' :=
  begin
    dsimp only,
    rw [split_epi_of_idempotent_of_is_colimit_cofork_section_,
      is_colimit_cofork_of_cokernel_cofork_desc, is_cokernel_epi_comp_desc],
    dsimp only [cokernel_cofork_of_cofork_of_Ï€],
    letI := epi_of_is_colimit_cofork i,
    apply zero_of_epi_comp c.Ï€,
    simp only [sub_comp, comp_sub, category.comp_id, category.assoc, split_mono.id, sub_self,
      cofork.is_colimit.Ï€_desc_assoc, cokernel_cofork.Ï€_of_Ï€, split_mono.id_assoc],
    apply sub_eq_zero_of_eq,
    apply category.id_comp
  end,
  inr_snd' := by apply split_epi.id }
def is_bilimit_binary_bicone_of_split_mono_of_cokernel {X Y : C} {f : X âŸ¶ Y} [split_mono f]
  {c : cokernel_cofork f} (i : is_colimit c) :
  (binary_bicone_of_split_mono_of_cokernel i).is_bilimit :=
is_binary_bilimit_of_total _
begin
  simp only [binary_bicone_of_split_mono_of_cokernel_fst,
    binary_bicone_of_split_mono_of_cokernel_inr, binary_bicone_of_split_mono_of_cokernel_snd,
    split_epi_of_idempotent_of_is_colimit_cofork_section_],
  dsimp only [binary_bicone_of_split_mono_of_cokernel_X],
  rw [is_colimit_cofork_of_cokernel_cofork_desc, is_cokernel_epi_comp_desc],
  simp only [binary_bicone_of_split_mono_of_cokernel_inl, cofork.is_colimit.Ï€_desc,
    cokernel_cofork_of_cofork_Ï€, cofork.Ï€_of_Ï€, add_sub_cancel'_right]
end
def binary_bicone.is_bilimit_of_kernel_inl {X Y : C} (b : binary_bicone X Y)
  (hb : is_limit (kernel_fork.of_Î¹ _ b.inl_snd)) : b.is_bilimit :=
is_binary_bilimit_of_is_limit _ $ binary_fan.is_limit.mk _
  (Î» T f g, f â‰« b.inl + g â‰« b.inr) (Î» T f g, by simp) (Î» T f g, by simp) $ Î» T f g m hâ‚ hâ‚‚,
  begin
    have hâ‚' : (m - (f â‰« b.inl + g â‰« b.inr)) â‰« b.fst = 0 := by simpa using sub_eq_zero.2 hâ‚,
    have hâ‚‚' : (m - (f â‰« b.inl + g â‰« b.inr)) â‰« b.snd = 0 := by simpa using sub_eq_zero.2 hâ‚‚,
    obtain âŸ¨q : T âŸ¶ X, hq : q â‰« b.inl = m - (f â‰« b.inl + g â‰« b.inr)âŸ© :=
      kernel_fork.is_limit.lift' hb _ hâ‚‚',
    rw [â†sub_eq_zero, â†hq, â†category.comp_id q, â†b.inl_fst, â†category.assoc, hq, hâ‚', zero_comp]
  end
def binary_bicone.is_bilimit_of_kernel_inr {X Y : C} (b : binary_bicone X Y)
  (hb : is_limit (kernel_fork.of_Î¹ _ b.inr_fst)) : b.is_bilimit :=
is_binary_bilimit_of_is_limit _ $ binary_fan.is_limit.mk _
  (Î» T f g, f â‰« b.inl + g â‰« b.inr) (Î» t f g, by simp) (Î» t f g, by simp) $ Î» T f g m hâ‚ hâ‚‚,
  begin
    have hâ‚' : (m - (f â‰« b.inl + g â‰« b.inr)) â‰« b.fst = 0 := by simpa using sub_eq_zero.2 hâ‚,
    have hâ‚‚' : (m - (f â‰« b.inl + g â‰« b.inr)) â‰« b.snd = 0 := by simpa using sub_eq_zero.2 hâ‚‚,
    obtain âŸ¨q : T âŸ¶ Y, hq : q â‰« b.inr = m - (f â‰« b.inl + g â‰« b.inr)âŸ© :=
      kernel_fork.is_limit.lift' hb _ hâ‚',
    rw [â†sub_eq_zero, â†hq, â†category.comp_id q, â†b.inr_snd, â†category.assoc, hq, hâ‚‚', zero_comp]
  end
def binary_bicone.is_bilimit_of_cokernel_fst {X Y : C} (b : binary_bicone X Y)
  (hb : is_colimit (cokernel_cofork.of_Ï€ _ b.inr_fst)) : b.is_bilimit :=
is_binary_bilimit_of_is_colimit _ $ binary_cofan.is_colimit.mk _
  (Î» T f g, b.fst â‰« f + b.snd â‰« g) (Î» T f g, by simp) (Î» T f g, by simp) $ Î» T f g m hâ‚ hâ‚‚,
  begin
    have hâ‚' : b.inl â‰« (m - (b.fst â‰« f + b.snd â‰« g)) = 0 := by simpa using sub_eq_zero.2 hâ‚,
    have hâ‚‚' : b.inr â‰« (m - (b.fst â‰« f + b.snd â‰« g)) = 0 := by simpa using sub_eq_zero.2 hâ‚‚,
    obtain âŸ¨q : X âŸ¶ T, hq : b.fst â‰« q = m - (b.fst â‰« f + b.snd â‰« g)âŸ© :=
      cokernel_cofork.is_colimit.desc' hb _ hâ‚‚',
    rw [â†sub_eq_zero, â†hq, â†category.id_comp q, â†b.inl_fst, category.assoc, hq, hâ‚', comp_zero]
  end
def binary_bicone.is_bilimit_of_cokernel_snd {X Y : C} (b : binary_bicone X Y)
  (hb : is_colimit (cokernel_cofork.of_Ï€ _ b.inl_snd)) : b.is_bilimit :=
is_binary_bilimit_of_is_colimit _ $ binary_cofan.is_colimit.mk _
  (Î» T f g, b.fst â‰« f + b.snd â‰« g) (Î» T f g, by simp) (Î» T f g, by simp) $ Î» T f g m hâ‚ hâ‚‚,
  begin
    have hâ‚' : b.inl â‰« (m - (b.fst â‰« f + b.snd â‰« g)) = 0 := by simpa using sub_eq_zero.2 hâ‚,
    have hâ‚‚' : b.inr â‰« (m - (b.fst â‰« f + b.snd â‰« g)) = 0 := by simpa using sub_eq_zero.2 hâ‚‚,
    obtain âŸ¨q : Y âŸ¶ T, hq : b.snd â‰« q = m - (b.fst â‰« f + b.snd â‰« g)âŸ© :=
      cokernel_cofork.is_colimit.desc' hb _ hâ‚',
    rw [â†sub_eq_zero, â†hq, â†category.id_comp q, â†b.inr_snd, category.assoc, hq, hâ‚‚', comp_zero]
  end
@[simps]
def binary_bicone_of_split_epi_of_kernel {X Y : C} {f : X âŸ¶ Y} [split_epi f]
  {c : kernel_fork f} (i : is_limit c) : binary_bicone c.X Y :=
{ X := X,
  fst :=
    let c' : kernel_fork (ğŸ™ X - (ğŸ™ X - f â‰« section_ f)) :=
      kernel_fork.of_Î¹ (fork.Î¹ c) (by simp) in
    let i' : is_limit c' := is_kernel_comp_mono i (section_ f) (by simp) in
    let i'' := is_limit_fork_of_kernel_fork i' in
    (split_mono_of_idempotent_of_is_limit_fork C (by simp) i'').retraction,
  snd := f,
  inl := c.Î¹,
  inr := section_ f,
  inl_fst' := by apply split_mono.id,
  inl_snd' := by simp,
  inr_fst' :=
  begin
    dsimp only,
    rw [split_mono_of_idempotent_of_is_limit_fork_retraction,
      is_limit_fork_of_kernel_fork_lift, is_kernel_comp_mono_lift],
    dsimp only [kernel_fork_of_fork_Î¹],
    letI := mono_of_is_limit_fork i,
    apply zero_of_comp_mono c.Î¹,
    simp only [comp_sub, category.comp_id, category.assoc, sub_self, fork.is_limit.lift_Î¹,
      fork.Î¹_of_Î¹, split_epi.id_assoc]
  end,
  inr_snd' := by simp }
def is_bilimit_binary_bicone_of_split_epi_of_kernel {X Y : C} {f : X âŸ¶ Y} [split_epi f]
  {c : kernel_fork f} (i : is_limit c) :
  (binary_bicone_of_split_epi_of_kernel i).is_bilimit :=
binary_bicone.is_bilimit_of_kernel_inl _ $ i.of_iso_limit $ fork.ext (iso.refl _) (by simp)
end
section
variables {X Y : C} (f g : X âŸ¶ Y)
lemma biprod.add_eq_lift_id_desc [has_binary_biproduct X X] :
  f + g = biprod.lift (ğŸ™ X) (ğŸ™ X) â‰« biprod.desc f g :=
by simp
lemma biprod.add_eq_lift_desc_id [has_binary_biproduct Y Y] :
  f + g = biprod.lift f g â‰« biprod.desc (ğŸ™ Y) (ğŸ™ Y) :=
by simp
end
end preadditive
end limits
open category_theory.limits
section
local attribute [ext] preadditive
instance subsingleton_preadditive_of_has_binary_biproducts {C : Type u} [category.{v} C]
  [has_zero_morphisms C] [has_binary_biproducts C] : subsingleton (preadditive C) :=
subsingleton.intro $ Î» a b,
begin
  ext X Y f g,
  have hâ‚ := @biprod.add_eq_lift_id_desc _ _ a _ _ f g
    (by convert (infer_instance : has_binary_biproduct X X)),
  have hâ‚‚ := @biprod.add_eq_lift_id_desc _ _ b _ _ f g
    (by convert (infer_instance : has_binary_biproduct X X)),
  refine hâ‚.trans (eq.trans _ hâ‚‚.symm),
  congr' 2;
  exact subsingleton.elim _ _
end
end
variables {C : Type u} [category.{v} C] [has_zero_morphisms C] [has_binary_biproducts C]
def indecomposable (X : C) : Prop := Â¬ is_zero X âˆ§ âˆ€ Y Z, (X â‰… Y âŠ Z) â†’ is_zero Y âˆ¨ is_zero Z
end category_theory
