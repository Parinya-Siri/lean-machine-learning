import analysis.normed_space.basic
import topology.metric_space.pi_nat
import topology.metric_space.isometry
import topology.metric_space.gluing
noncomputable theory
open_locale classical topological_space filter
open topological_space set metric filter function
variables {Œ± : Type*} {Œ≤ : Type*}
class polish_space (Œ± : Type*) [h : topological_space Œ±] : Prop :=
(second_countable [] : second_countable_topology Œ±)
(complete : ‚àÉ m : metric_space Œ±, m.to_uniform_space.to_topological_space = h ‚àß
  @complete_space Œ± m.to_uniform_space)
class upgraded_polish_space (Œ± : Type*) extends metric_space Œ±, second_countable_topology Œ±,
  complete_space Œ±
@[priority 100]
instance polish_space_of_complete_second_countable
  [m : metric_space Œ±] [h : second_countable_topology Œ±] [h' : complete_space Œ±] :
  polish_space Œ± :=
{ second_countable := h,
  complete := ‚ü®m, rfl, h'‚ü© }
def polish_space_metric (Œ± : Type*) [ht : topological_space Œ±] [h : polish_space Œ±] :
  metric_space Œ± :=
h.complete.some.replace_topology h.complete.some_spec.1.symm
lemma complete_polish_space_metric (Œ± : Type*) [ht : topological_space Œ±] [h : polish_space Œ±] :
  @complete_space Œ± (polish_space_metric Œ±).to_uniform_space :=
begin
  convert h.complete.some_spec.2,
  exact metric_space.replace_topology_eq _ _
end
def upgrade_polish_space (Œ± : Type*) [ht : topological_space Œ±] [h : polish_space Œ±] :
  upgraded_polish_space Œ± :=
begin
  letI := polish_space_metric Œ±,
  exact { .. complete_polish_space_metric Œ±, .. polish_space.second_countable Œ± }
end
namespace polish_space
@[priority 100]
instance t2_space (Œ± : Type*) [topological_space Œ±] [polish_space Œ±] : t2_space Œ± :=
by { letI := upgrade_polish_space Œ±, apply_instance }
instance pi_countable {Œπ : Type*} [encodable Œπ] {E : Œπ ‚Üí Type*}
  [‚àÄ i, topological_space (E i)] [‚àÄ i, polish_space (E i)] :
  polish_space (Œ† i, E i) :=
begin
  letI := Œª i, upgrade_polish_space (E i),
  letI : metric_space (Œ† i, E i) := pi_countable.metric_space,
  apply_instance,
end
instance nat_fun [topological_space Œ±] [polish_space Œ±] :
  polish_space (‚Ñï ‚Üí Œ±) :=
by apply_instance
instance sigma {Œπ : Type*} [encodable Œπ]
  {E : Œπ ‚Üí Type*} [‚àÄ n, topological_space (E n)] [‚àÄ n, polish_space (E n)] :
  polish_space (Œ£ n, E n) :=
begin
  letI := Œª n, upgrade_polish_space (E n),
  letI : metric_space (Œ£ n, E n) := sigma.metric_space,
  haveI : complete_space (Œ£ n, E n) := sigma.complete_space,
  apply_instance
end
instance sum [topological_space Œ±] [polish_space Œ±] [topological_space Œ≤] [polish_space Œ≤] :
  polish_space (Œ± ‚äï Œ≤) :=
begin
  letI := upgrade_polish_space Œ±,
  letI := upgrade_polish_space Œ≤,
  letI : metric_space (Œ± ‚äï Œ≤) := metric_space_sum,
  apply_instance
end
lemma exists_nat_nat_continuous_surjective
  (Œ± : Type*) [topological_space Œ±] [polish_space Œ±] [nonempty Œ±] :
  ‚àÉ (f : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±), continuous f ‚àß surjective f :=
begin
  letI := upgrade_polish_space Œ±,
  exact exists_nat_nat_continuous_surjective_of_complete_space Œ±
end
lemma _root_.closed_embedding.polish_space [topological_space Œ±] [topological_space Œ≤]
  [polish_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : closed_embedding f) :
  polish_space Œ± :=
begin
  letI := upgrade_polish_space Œ≤,
  letI : metric_space Œ± := hf.to_embedding.comap_metric_space f,
  haveI : second_countable_topology Œ± := hf.to_embedding.second_countable_topology,
  haveI : complete_space Œ±,
  { rw complete_space_iff_is_complete_range hf.to_embedding.to_isometry.uniform_inducing,
    apply is_closed.is_complete,
    exact hf.closed_range },
  apply_instance
end
lemma _root_.equiv.polish_space_induced [t : topological_space Œ≤] [polish_space Œ≤]
  (f : Œ± ‚âÉ Œ≤) :
  @polish_space Œ± (t.induced f) :=
begin
  letI : topological_space Œ± := t.induced f,
  exact (f.to_homeomorph_of_inducing ‚ü®rfl‚ü©).closed_embedding.polish_space,
end
lemma _root_.is_closed.polish_space {Œ± : Type*} [topological_space Œ±] [polish_space Œ±] {s : set Œ±}
  (hs : is_closed s) :
  polish_space s :=
(is_closed.closed_embedding_subtype_coe hs).polish_space
@[nolint unused_arguments has_inhabited_instance]
def aux_copy (Œ± : Type*) {Œπ : Type*} (i : Œπ) : Type* := Œ±
lemma exists_polish_space_forall_le {Œπ : Type*} [encodable Œπ]
  [t : topological_space Œ±] [p : polish_space Œ±]
  (m : Œπ ‚Üí topological_space Œ±) (hm : ‚àÄ n, m n ‚â§ t) (h'm : ‚àÄ n, @polish_space Œ± (m n)) :
  ‚àÉ (t' : topological_space Œ±), (‚àÄ n, t' ‚â§ m n) ‚àß (t' ‚â§ t) ‚àß @polish_space Œ± t' :=
begin
  rcases is_empty_or_nonempty Œπ with hŒπ|hŒπ,
  { exact ‚ü®t, Œª i, (is_empty.elim hŒπ i : _), le_rfl, p‚ü© },
  unfreezingI { inhabit Œπ },
  letI : ‚àÄ (n : Œπ), topological_space (aux_copy Œ± n) := Œª n, m n,
  haveI : ‚àÄ (n : Œπ), polish_space (aux_copy Œ± n) := Œª n, h'm n,
  letI T : topological_space (Œ† (n : Œπ), aux_copy Œ± n) := by apply_instance,
  let f : Œ± ‚Üí Œ† (n : Œπ), aux_copy Œ± n := Œª x n, x,
section complete_copy
variables [metric_space Œ±] {s : set Œ±}
@[nolint has_inhabited_instance]
def complete_copy {Œ± : Type*} (s : set Œ±) : Type* := s
def has_dist_complete_copy (s : set Œ±) : has_dist (complete_copy s) :=
‚ü®Œª x y, dist x.1 y.1 + abs (1 / inf_dist x.1 s·∂ú - 1 / inf_dist y.1 s·∂ú)‚ü©
local attribute [instance] has_dist_complete_copy
lemma dist_complete_copy_eq (x y : complete_copy s) :
  dist x y = dist x.1 y.1 + abs (1/inf_dist x.1 s·∂ú - 1 / inf_dist y.1 s·∂ú) := rfl
lemma dist_le_dist_complete_copy (x y : complete_copy s) :
  dist x.1 y.1 ‚â§ dist x y :=
(le_add_iff_nonneg_right _).2 (abs_nonneg _)
def complete_copy_metric_space (s : set Œ±) : metric_space (complete_copy s) :=
{ dist_self := Œª x, by simp [dist_complete_copy_eq],
  dist_comm := Œª x y, by simp [dist_complete_copy_eq, dist_comm, abs_sub_comm],
  dist_triangle := Œª x y z, calc
    dist x z = dist x.1 z.1 + abs (1 / inf_dist x.1 s·∂ú - 1 / inf_dist z.1 s·∂ú) : rfl
    ... ‚â§ (dist x.1 y.1 + dist y.1 z.1) +
      (abs (1 / inf_dist x.1 s·∂ú - 1 / inf_dist y.1 s·∂ú)
      + abs (1 / inf_dist y.1 s·∂ú - 1 / inf_dist z.1 s·∂ú)) :
    begin
      rw [‚Üê real.dist_eq, ‚Üê real.dist_eq, ‚Üê real.dist_eq],
      exact add_le_add (dist_triangle _ _ _) (dist_triangle _ _ _)
    end
    ... = dist x y + dist y z : by { rw [dist_complete_copy_eq, dist_complete_copy_eq], abel },
  eq_of_dist_eq_zero :=
  begin
    assume x y hxy,
    apply subtype.coe_injective,
    refine dist_le_zero.1 _,
    rw ‚Üê hxy,
    exact dist_le_dist_complete_copy x y
  end }
local attribute [instance] complete_copy_metric_space
def complete_copy_id_homeo (hs : is_open s) (h's : s·∂ú.nonempty) : complete_copy s ‚âÉ‚Çú s :=
{ to_fun := id,
  inv_fun := id,
  left_inv := Œª x, rfl,
  right_inv := Œª x, rfl,
  continuous_to_fun :=
  begin
    have : lipschitz_with 1 (Œª (x : complete_copy s), (id x : s)),
    { apply lipschitz_with.mk_one,
      exact dist_le_dist_complete_copy },
    exact this.continuous,
  end,
  continuous_inv_fun :=
  begin
    apply continuous_iff_continuous_at.2 (Œª x, _),
    suffices H : tendsto (Œª (b : s), dist b.1 x.1
      + |1 / inf_dist b.1 s·∂ú - 1 / inf_dist x.1 s·∂ú|) (ùìù x)
      (ùìù (dist x.1 x.1 + abs (1 / inf_dist x.1 s·∂ú - 1 / inf_dist x.1 s·∂ú))),
    { rw [continuous_at, tendsto_iff_dist_tendsto_zero],
      simpa only [sub_self, abs_zero, add_zero, dist_self] using H },
    have I : 0 < inf_dist x.val s·∂ú,
    { rw ‚Üê hs.is_closed_compl.not_mem_iff_inf_dist_pos h's,
      simp },
    apply tendsto.add,
    { apply continuous.tendsto, exact continuous_subtype_coe.dist continuous_const },
    { refine (tendsto.sub_const _ _).abs,
      refine tendsto.div tendsto_const_nhds _ I.ne',
      exact ((continuous_inf_dist_pt _).comp continuous_subtype_coe).tendsto _ }
  end }
lemma complete_space_complete_copy [complete_space Œ±] (hs : is_open s) (h's : s·∂ú.nonempty) :
  complete_space (complete_copy s) :=
begin
  refine metric.complete_of_convergent_controlled_sequences (Œª n, (1/2)^n) (by simp) _,
  assume u hu,
  have A : cauchy_seq (Œª n, (u n).1),
  { apply cauchy_seq_of_le_tendsto_0 (Œª (n : ‚Ñï), (1/2)^n) (Œª n m N hNn hNm, _) _,
    { exact (dist_le_dist_complete_copy (u n) (u m)).trans (hu N n m hNn hNm).le },
    { exact tendsto_pow_at_top_nhds_0_of_lt_1 (by norm_num) (by norm_num) } },
  obtain ‚ü®x, xlim‚ü© : ‚àÉ x, tendsto (Œª n, (u n).1) at_top (ùìù x),
  { haveI : nonempty Œ± := ‚ü®(u 0).1‚ü©,
    exact ‚ü®_, A.tendsto_lim‚ü© },
  suffices xs : x ‚àà s,
  { refine ‚ü®‚ü®x, xs‚ü©, _‚ü©,
    have L : tendsto (Œª n, (id ‚ü®(u n).1, (u n).2‚ü© : s)) at_top (ùìù (‚ü®x, xs‚ü©)),
    { apply embedding_subtype_coe.tendsto_nhds_iff.2, exact xlim },
    convert ((complete_copy_id_homeo hs h's).symm.continuous.tendsto _).comp L,
    ext1 n,
    simp [complete_copy_id_homeo] },
  obtain ‚ü®C, hC‚ü© : ‚àÉ C, ‚àÄ n, 1 / inf_dist (u n).1 s·∂ú < C,
  { refine ‚ü®(1/2)^0 + dist (1 / inf_dist (u 0).1 s·∂ú) 0, Œª n, _‚ü©,
    calc 1 / inf_dist (u n).val s·∂ú ‚â§ dist (1 / inf_dist (u n).val s·∂ú) 0 :
      by { rw real.dist_0_eq_abs, exact le_abs_self _ }
    ... ‚â§ dist (1 / inf_dist (u n).1 s·∂ú) (1 / inf_dist (u 0).1 s·∂ú)
          + dist (1 / inf_dist (u 0).1 s·∂ú) 0 : dist_triangle _ _ _
    ... ‚â§ (dist (u n).1 (u 0).1 + dist (1 / inf_dist (u n).1 s·∂ú) (1 / inf_dist (u 0).1 s·∂ú))
          + dist (1 / inf_dist (u 0).1 s·∂ú) 0 :
      add_le_add (le_add_of_nonneg_left dist_nonneg) le_rfl
    ... = dist (u n) (u 0) +  dist (1 / inf_dist (u 0).1 s·∂ú) 0 : rfl
    ... < (1/2)^0 + dist (1 / inf_dist (u 0).1 s·∂ú) 0 :
      add_lt_add_right (hu 0 n 0 (zero_le _) le_rfl) _ },
  have Cpos : 0 < C,
  { apply lt_of_le_of_lt _ (hC 0),
    simp [inf_dist_nonneg] },
  have I : ‚àÄ n, 1/C ‚â§ inf_dist (u n).1 s·∂ú,
  { assume n,
    have : 0 < inf_dist (u n).val s·∂ú,
    { apply (hs.is_closed_compl.not_mem_iff_inf_dist_pos h's).1, simp },
    rw div_le_iff' Cpos,
    exact (div_le_iff this).1 (hC n).le },
  have I' : 1/C ‚â§ inf_dist x s·∂ú,
  { have : tendsto (Œª n, inf_dist (u n).1 s·∂ú) at_top (ùìù (inf_dist x s·∂ú)) :=
      ((continuous_inf_dist_pt s·∂ú).tendsto x).comp xlim,
    exact ge_of_tendsto' this I },
  suffices : x ‚àâ s·∂ú, by simpa,
  apply (hs.is_closed_compl.not_mem_iff_inf_dist_pos h's).2 (lt_of_lt_of_le _ I'),
  simp [Cpos],
end
lemma _root_.is_open.polish_space {Œ± : Type*} [topological_space Œ±] [polish_space Œ±] {s : set Œ±}
  (hs : is_open s) :
  polish_space s :=
begin
  rcases eq_empty_or_nonempty s·∂ú with h's|h's,
  { simp at h's,
    apply is_closed.polish_space,
    rw h's,
    exact is_closed_univ },
  { letI := upgrade_polish_space Œ±,
    haveI : complete_space (complete_copy s) := complete_space_complete_copy hs h's,
    haveI : second_countable_topology (complete_copy s) :=
      (complete_copy_id_homeo hs h's).embedding.second_countable_topology,
    exact (complete_copy_id_homeo hs h's).symm.closed_embedding.polish_space }
end
end complete_copy
def is_clopenable [t : topological_space Œ±] (s : set Œ±) : Prop :=
‚àÉ (t' : topological_space Œ±), t' ‚â§ t ‚àß @polish_space Œ± t' ‚àß @is_closed Œ± t' s ‚àß @is_open Œ± t' s
lemma _root_.is_closed.is_clopenable [topological_space Œ±] [polish_space Œ±] {s : set Œ±}
  (hs : is_closed s) : is_clopenable s :=
begin
  haveI : polish_space s := hs.polish_space,
  let t : set Œ± := s·∂ú,
  haveI : polish_space t := hs.is_open_compl.polish_space,
  let f : Œ± ‚âÉ (s ‚äï t) := (equiv.set.sum_compl s).symm,
  letI T : topological_space (s ‚äï t) := by apply_instance,
  let t' : topological_space Œ± := T.induced f,
  let g := @equiv.to_homeomorph_of_inducing  _ _ t' T f { induced := rfl },
  have A : g ‚Åª¬π' (range (sum.inl : s ‚Üí s ‚äï t)) = s,
  { ext x,
    by_cases h : x ‚àà s,
    { simp only [equiv.set.sum_compl_symm_apply_of_mem, h, mem_preimage, equiv.to_fun_as_coe,
        mem_range_self, equiv.to_homeomorph_of_inducing_apply]},
    { simp only [equiv.set.sum_compl_symm_apply_of_not_mem, h, not_false_iff, mem_preimage,
        equiv.to_homeomorph_of_inducing_apply, equiv.to_fun_as_coe, mem_range, exists_false]} },
  refine ‚ü®t', _, f.polish_space_induced, _, _‚ü©,
  { assume u hu,
    change ‚àÉ (s' : set (‚Ü•s ‚äï ‚Ü•t)), T.is_open s' ‚àß f ‚Åª¬π' s' = u,
    refine ‚ü®f.symm ‚Åª¬π' u, _, by simp only [equiv.symm_symm, equiv.symm_preimage_preimage]‚ü©,
    refine is_open_sum_iff.2 ‚ü®_, _‚ü©,
    { have : is_open ((coe : s ‚Üí Œ±) ‚Åª¬π' u) := is_open.preimage continuous_subtype_coe hu,
      have : sum.inl ‚Åª¬π' (‚áë(f.symm) ‚Åª¬π' u) = (coe : s ‚Üí Œ±) ‚Åª¬π' u,
        by { ext x, simp only [equiv.symm_symm, mem_preimage, equiv.set.sum_compl_apply_inl] },
      rwa this },
    { have : is_open ((coe : t ‚Üí Œ±) ‚Åª¬π' u) := is_open.preimage continuous_subtype_coe hu,
      have : sum.inr ‚Åª¬π' (‚áë(f.symm) ‚Åª¬π' u) = (coe : t ‚Üí Œ±) ‚Åª¬π' u,
        by { ext x, simp only [equiv.symm_symm, mem_preimage, equiv.set.sum_compl_apply_inr] },
      rwa this } },
  { have : @is_closed Œ± t' (g ‚Åª¬π' (range (sum.inl : s ‚Üí s ‚äï t))),
    { apply is_closed.preimage,
      { exact @homeomorph.continuous _ _ t' _ g },
      { exact is_closed_range_inl } },
    convert this,
    exact A.symm },
  { have : @is_open Œ± t' (g ‚Åª¬π' (range (sum.inl : s ‚Üí s ‚äï t))),
    { apply is_open.preimage,
      { exact @homeomorph.continuous _ _ t' _ g },
      { exact is_open_range_inl } },
    convert this,
    exact A.symm },
end
lemma is_clopenable.compl [topological_space Œ±] {s : set Œ±} (hs : is_clopenable s) :
  is_clopenable s·∂ú :=
begin
  rcases hs with ‚ü®t, t_le, t_polish, h, h'‚ü©,
  exact ‚ü®t, t_le, t_polish, @is_open.is_closed_compl Œ± t s h', @is_closed.is_open_compl Œ± t s h‚ü©,
end
lemma _root_.is_open.is_clopenable [topological_space Œ±] [polish_space Œ±] {s : set Œ±}
  (hs : is_open s) : is_clopenable s :=
by simpa using hs.is_closed_compl.is_clopenable.compl
lemma is_clopenable.Union [t : topological_space Œ±] [polish_space Œ±] {s : ‚Ñï ‚Üí set Œ±}
  (hs : ‚àÄ n, is_clopenable (s n)) :
  is_clopenable (‚ãÉ n, s n) :=
begin
  choose m mt m_polish m_closed m_open using hs,
  obtain ‚ü®t', t'm, -, t'_polish‚ü© :
    ‚àÉ (t' : topological_space Œ±), (‚àÄ (n : ‚Ñï), t' ‚â§ m n) ‚àß (t' ‚â§ t) ‚àß @polish_space Œ± t' :=
      exists_polish_space_forall_le m mt m_polish,
  have A : @is_open Œ± t' (‚ãÉ n, s n),
  { apply is_open_Union,
    assume n,
    apply t'm n,
    exact m_open n },
  obtain ‚ü®t'', t''_le, t''_polish, h1, h2‚ü© :
    ‚àÉ (t'' : topological_space Œ±), t'' ‚â§ t' ‚àß @polish_space Œ± t''
      ‚àß @is_closed Œ± t'' (‚ãÉ n, s n) ‚àß @is_open Œ± t'' (‚ãÉ n, s n) :=
        @is_open.is_clopenable Œ± t' t'_polish _ A,
  exact ‚ü®t'', t''_le.trans ((t'm 0).trans (mt 0)), t''_polish, h1, h2‚ü©,
end
end polish_space
