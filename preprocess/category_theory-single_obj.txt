import category_theory.endomorphism
import category_theory.category.Cat
import algebra.category.Mon.basic
universes u v w
namespace category_theory
@[nolint unused_arguments has_inhabited_instance]
def single_obj (Œ± : Type u) : Type := unit
namespace single_obj
variables (Œ± : Type u)
instance category_struct [has_one Œ±] [has_mul Œ±] : category_struct (single_obj Œ±) :=
{ hom := Œª _ _, Œ±,
  comp := Œª _ _ _ x y, y * x,
  id := Œª _, 1 }
instance category [monoid Œ±] : category (single_obj Œ±) :=
{ comp_id' := Œª _ _, one_mul,
  id_comp' := Œª _ _, mul_one,
  assoc' := Œª _ _ _ _ x y z, (mul_assoc z y x).symm }
lemma id_as_one [monoid Œ±] (x : single_obj Œ±) : ùüô x = 1 := rfl
lemma comp_as_mul [monoid Œ±] {x y z : single_obj Œ±} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
  f ‚â´ g = g * f := rfl
instance groupoid [group Œ±] : groupoid (single_obj Œ±) :=
{ inv := Œª _ _ x, x‚Åª¬π,
  inv_comp' := Œª _ _, mul_right_inv,
  comp_inv' := Œª _ _, mul_left_inv }
lemma inv_as_inv [group Œ±] {x y : single_obj Œ±} (f : x ‚ü∂ y) : inv f = f‚Åª¬π :=
by { ext, rw [comp_as_mul, inv_mul_self, id_as_one] }
protected def star : single_obj Œ± := unit.star
def to_End [monoid Œ±] : Œ± ‚âÉ* End (single_obj.star Œ±) :=
{ map_mul' := Œª x y, rfl,
  .. equiv.refl Œ± }
lemma to_End_def [monoid Œ±] (x : Œ±) : to_End Œ± x = x := rfl
def map_hom (Œ± : Type u) (Œ≤ : Type v) [monoid Œ±] [monoid Œ≤] :
  (Œ± ‚Üí* Œ≤) ‚âÉ (single_obj Œ±) ‚•§ (single_obj Œ≤) :=
{ to_fun := Œª f,
  { obj := id,
    map := Œª _ _, ‚áëf,
    map_id' := Œª _, f.map_one,
    map_comp' := Œª _ _ _ x y, f.map_mul y x },
  inv_fun := Œª f,
    { to_fun := @functor.map _ _ _ _ f (single_obj.star Œ±) (single_obj.star Œ±),
      map_one' := f.map_id _,
      map_mul' := Œª x y, f.map_comp y x },
  left_inv := Œª ‚ü®f, h‚ÇÅ, h‚ÇÇ‚ü©, rfl,
  right_inv := Œª f, by cases f; obviously }
lemma map_hom_id (Œ± : Type u) [monoid Œ±] : map_hom Œ± Œ± (monoid_hom.id Œ±) = ùü≠ _ := rfl
lemma map_hom_comp {Œ± : Type u} {Œ≤ : Type v} [monoid Œ±] [monoid Œ≤] (f : Œ± ‚Üí* Œ≤)
  {Œ≥ : Type w} [monoid Œ≥] (g : Œ≤ ‚Üí* Œ≥) :
  map_hom Œ± Œ≥ (g.comp f) = map_hom Œ± Œ≤ f ‚ãô map_hom Œ≤ Œ≥ g :=
rfl
@[simps] def difference_functor {C G} [category C] [group G] (f : C ‚Üí G) : C ‚•§ single_obj G :=
{ obj := Œª _, (),
  map := Œª x y _, f y * (f x)‚Åª¬π,
  map_id' := by { intro, rw [single_obj.id_as_one, mul_right_inv] },
  map_comp' := by { intros, rw [single_obj.comp_as_mul, ‚Üêmul_assoc,
    mul_left_inj, mul_assoc, inv_mul_self, mul_one] } }
end single_obj
end category_theory
open category_theory
namespace monoid_hom
@[reducible] def to_functor {Œ± : Type u} {Œ≤ : Type v} [monoid Œ±] [monoid Œ≤] (f : Œ± ‚Üí* Œ≤) :
  (single_obj Œ±) ‚•§ (single_obj Œ≤) :=
single_obj.map_hom Œ± Œ≤ f
@[simp] lemma id_to_functor (Œ± : Type u) [monoid Œ±] : (id Œ±).to_functor = ùü≠ _ := rfl
@[simp] lemma comp_to_functor {Œ± : Type u} {Œ≤ : Type v} [monoid Œ±] [monoid Œ≤] (f : Œ± ‚Üí* Œ≤)
  {Œ≥ : Type w} [monoid Œ≥] (g : Œ≤ ‚Üí* Œ≥) :
  (g.comp f).to_functor = f.to_functor ‚ãô g.to_functor :=
rfl
end monoid_hom
namespace units
variables (Œ± : Type u) [monoid Œ±]
def to_Aut : Œ±À£ ‚âÉ* Aut (single_obj.star Œ±) :=
(units.map_equiv (single_obj.to_End Œ±)).trans $
  Aut.units_End_equiv_Aut _
@[simp] lemma to_Aut_hom (x : Œ±À£) : (to_Aut Œ± x).hom = single_obj.to_End Œ± x := rfl
@[simp] lemma to_Aut_inv (x : Œ±À£) :
  (to_Aut Œ± x).inv = single_obj.to_End Œ± (x‚Åª¬π : Œ±À£) :=
rfl
end units
namespace Mon
open category_theory
def to_Cat : Mon ‚•§ Cat :=
{ obj := Œª x, Cat.of (single_obj x),
  map := Œª x y f, single_obj.map_hom x y f }
instance to_Cat_full : full to_Cat :=
{ preimage := Œª x y, (single_obj.map_hom x y).inv_fun,
  witness' := Œª x y, by apply equiv.right_inv }
instance to_Cat_faithful : faithful to_Cat :=
{ map_injective' := Œª x y, by apply equiv.injective }
end Mon
