import category_theory.bicategory.basic
set_option old_structure_cmd true
namespace category_theory
open category bicategory
open_locale bicategory
universes wâ‚ wâ‚‚ wâ‚ƒ vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ
section
variables {B : Type uâ‚} [quiver.{vâ‚+1} B] [âˆ€ a b : B, quiver.{wâ‚+1} (a âŸ¶ b)]
variables {C : Type uâ‚‚} [quiver.{vâ‚‚+1} C] [âˆ€ a b : C, quiver.{wâ‚‚+1} (a âŸ¶ b)]
variables {D : Type uâ‚ƒ} [quiver.{vâ‚ƒ+1} D] [âˆ€ a b : D, quiver.{wâ‚ƒ+1} (a âŸ¶ b)]
structure prelax_functor
  (B : Type uâ‚) [quiver.{vâ‚+1} B] [âˆ€ a b : B, quiver.{wâ‚+1} (a âŸ¶ b)]
  (C : Type uâ‚‚) [quiver.{vâ‚‚+1} C] [âˆ€ a b : C, quiver.{wâ‚‚+1} (a âŸ¶ b)] extends prefunctor B C :=
(mapâ‚‚ {a b : B} {f g : a âŸ¶ b} : (f âŸ¶ g) â†’ (map f âŸ¶ map g))
add_decl_doc prelax_functor.to_prefunctor
namespace prelax_functor
instance has_coe_to_prefunctor : has_coe (prelax_functor B C) (prefunctor B C) := âŸ¨to_prefunctorâŸ©
variables (F : prelax_functor B C)
@[simp] lemma to_prefunctor_eq_coe : F.to_prefunctor = F := rfl
@[simp] lemma to_prefunctor_obj : (F : prefunctor B C).obj = F.obj := rfl
@[simp] lemma to_prefunctor_map : (F : prefunctor B C).map = F.map := rfl
@[simps]
def id (B : Type uâ‚) [quiver.{vâ‚+1} B] [âˆ€ a b : B, quiver.{wâ‚+1} (a âŸ¶ b)] : prelax_functor B B :=
{ mapâ‚‚ := Î» a b f g Î·, Î·, .. prefunctor.id B }
instance : inhabited (prelax_functor B B) := âŸ¨prelax_functor.id BâŸ©
@[simps]
def comp (F : prelax_functor B C) (G : prelax_functor C D) : prelax_functor B D :=
{ mapâ‚‚ := Î» a b f g Î·, G.mapâ‚‚ (F.mapâ‚‚ Î·), .. (F : prefunctor B C).comp â†‘G }
end prelax_functor
end
section
variables {B : Type uâ‚} [bicategory.{wâ‚ vâ‚} B] {C : Type uâ‚‚} [bicategory.{wâ‚‚ vâ‚‚} C]
variables {D : Type uâ‚ƒ} [bicategory.{wâ‚ƒ vâ‚ƒ} D]
@[simp]
def oplax_functor.mapâ‚‚_associator_aux
  (obj : B â†’ C) (map : Î  {X Y : B}, (X âŸ¶ Y) â†’ (obj X âŸ¶ obj Y))
  (mapâ‚‚ : Î  {a b : B} {f g : a âŸ¶ b}, (f âŸ¶ g) â†’ (map f âŸ¶ map g))
  (map_comp : Î  {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c), map (f â‰« g) âŸ¶ map f â‰« map g)
  {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d) : Prop :=
mapâ‚‚ (Î±_ f g h).hom â‰« map_comp f (g â‰« h) â‰« map f â— map_comp g h =
  map_comp (f â‰« g) h â‰« map_comp f g â–· map h â‰« (Î±_ (map f) (map g) (map h)).hom
structure oplax_functor (B : Type uâ‚) [bicategory.{wâ‚ vâ‚} B] (C : Type uâ‚‚) [bicategory.{wâ‚‚ vâ‚‚} C]
  extends prelax_functor B C :=
(map_id (a : B) : map (ğŸ™ a) âŸ¶ ğŸ™ (obj a))
(map_comp {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c) : map (f â‰« g) âŸ¶ map f â‰« map g)
(map_comp_naturality_left' : âˆ€ {a b c : B} {f f' : a âŸ¶ b} (Î· : f âŸ¶ f') (g : b âŸ¶ c),
  mapâ‚‚ (Î· â–· g) â‰« map_comp f' g = map_comp f g â‰« mapâ‚‚ Î· â–· map g . obviously)
(map_comp_naturality_right' : âˆ€ {a b c : B} (f : a âŸ¶ b) {g g' : b âŸ¶ c} (Î· : g âŸ¶ g'),
  mapâ‚‚ (f â— Î·) â‰« map_comp f g' = map_comp f g â‰« map f â— mapâ‚‚ Î· . obviously)
(mapâ‚‚_id' : âˆ€ {a b : B} (f : a âŸ¶ b), mapâ‚‚ (ğŸ™ f) = ğŸ™ (map f) . obviously)
(mapâ‚‚_comp' : âˆ€ {a b : B} {f g h : a âŸ¶ b} (Î· : f âŸ¶ g) (Î¸ : g âŸ¶ h),
  mapâ‚‚ (Î· â‰« Î¸) = mapâ‚‚ Î· â‰« mapâ‚‚ Î¸ . obviously)
(mapâ‚‚_associator' : âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d),
  oplax_functor.mapâ‚‚_associator_aux obj (Î» a b, map) (Î» a b f g, mapâ‚‚) (Î» a b c, map_comp) f g h
    . obviously)
(mapâ‚‚_left_unitor' : âˆ€ {a b : B} (f : a âŸ¶ b),
  mapâ‚‚ (Î»_ f).hom = map_comp (ğŸ™ a) f â‰« map_id a â–· map f â‰« (Î»_ (map f)).hom . obviously)
(mapâ‚‚_right_unitor' : âˆ€ {a b : B} (f : a âŸ¶ b),
  mapâ‚‚ (Ï_ f).hom = map_comp f (ğŸ™ b) â‰« map f â— map_id b â‰« (Ï_ (map f)).hom . obviously)
namespace oplax_functor
restate_axiom map_comp_naturality_left'
restate_axiom map_comp_naturality_right'
restate_axiom mapâ‚‚_id'
restate_axiom mapâ‚‚_comp'
restate_axiom mapâ‚‚_associator'
restate_axiom mapâ‚‚_left_unitor'
restate_axiom mapâ‚‚_right_unitor'
attribute [simp] map_comp_naturality_left map_comp_naturality_right mapâ‚‚_id mapâ‚‚_associator
attribute [reassoc]
  map_comp_naturality_left map_comp_naturality_right mapâ‚‚_comp
  mapâ‚‚_associator mapâ‚‚_left_unitor mapâ‚‚_right_unitor
attribute [simp] mapâ‚‚_comp mapâ‚‚_left_unitor mapâ‚‚_right_unitor
section
add_decl_doc oplax_functor.to_prelax_functor
instance has_coe_to_prelax : has_coe (oplax_functor B C) (prelax_functor B C) :=
âŸ¨to_prelax_functorâŸ©
variables (F : oplax_functor B C)
@[simp] lemma to_prelax_eq_coe : F.to_prelax_functor = F := rfl
@[simp] lemma to_prelax_functor_obj : (F : prelax_functor B C).obj = F.obj := rfl
@[simp] lemma to_prelax_functor_map : (F : prelax_functor B C).map = F.map := rfl
@[simp] lemma to_prelax_functor_mapâ‚‚ : (F : prelax_functor B C).mapâ‚‚ = F.mapâ‚‚ := rfl
@[simps]
def map_functor (a b : B) : (a âŸ¶ b) â¥¤ (F.obj a âŸ¶ F.obj b) :=
{ obj := Î» f, F.map f,
  map := Î» f g Î·, F.mapâ‚‚ Î· }
@[simps]
def id (B : Type uâ‚) [bicategory.{wâ‚ vâ‚} B] : oplax_functor B B :=
{ map_id := Î» a, ğŸ™ (ğŸ™ a),
  map_comp := Î» a b c f g, ğŸ™ (f â‰« g),
  .. prelax_functor.id B }
instance : inhabited (oplax_functor B B) := âŸ¨id BâŸ©
@[simps]
def comp (F : oplax_functor B C) (G : oplax_functor C D) : oplax_functor B D :=
{ map_id := Î» a,
    (G.map_functor _ _).map (F.map_id a) â‰« G.map_id (F.obj a),
  map_comp := Î» a b c f g,
    (G.map_functor _ _).map (F.map_comp f g) â‰« G.map_comp (F.map f) (F.map g),
  map_comp_naturality_left' := Î» a b c f f' Î· g, by
  { dsimp,
    rw [â†mapâ‚‚_comp_assoc, map_comp_naturality_left, mapâ‚‚_comp_assoc, map_comp_naturality_left,
      assoc] },
  map_comp_naturality_right' := Î» a b c f g g' Î·, by
  { dsimp,
    rw [â†mapâ‚‚_comp_assoc, map_comp_naturality_right, mapâ‚‚_comp_assoc, map_comp_naturality_right,
      assoc] },
  mapâ‚‚_associator' := Î» a b c d f g h, by
  { dsimp,
    simp only [mapâ‚‚_associator, â†mapâ‚‚_comp_assoc, â†map_comp_naturality_right_assoc,
      whisker_left_comp, assoc],
    simp only [mapâ‚‚_associator, mapâ‚‚_comp, map_comp_naturality_left_assoc,
      comp_whisker_right, assoc] },
  mapâ‚‚_left_unitor' := Î» a b f, by
  { dsimp,
    simp only [mapâ‚‚_left_unitor, mapâ‚‚_comp, map_comp_naturality_left_assoc,
      comp_whisker_right, assoc] },
  mapâ‚‚_right_unitor' := Î» a b f, by
  { dsimp,
    simp only [mapâ‚‚_right_unitor, mapâ‚‚_comp, map_comp_naturality_right_assoc,
      whisker_left_comp, assoc] },
  .. (F : prelax_functor B C).comp â†‘G }
@[nolint has_inhabited_instance]
structure pseudo_core (F : oplax_functor B C) :=
(map_id_iso (a : B) : F.map (ğŸ™ a) â‰… ğŸ™ (F.obj a))
(map_comp_iso {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c) : F.map (f â‰« g) â‰… F.map f â‰« F.map g)
(map_id_iso_hom' : âˆ€ {a : B}, (map_id_iso a).hom = F.map_id a . obviously)
(map_comp_iso_hom' : âˆ€ {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c),
  (map_comp_iso f g).hom = F.map_comp f g . obviously)
restate_axiom pseudo_core.map_id_iso_hom'
restate_axiom pseudo_core.map_comp_iso_hom'
attribute [simp] pseudo_core.map_id_iso_hom pseudo_core.map_comp_iso_hom
end
end oplax_functor
@[simp]
def pseudofunctor.mapâ‚‚_associator_aux
  (obj : B â†’ C) (map : Î  {X Y : B}, (X âŸ¶ Y) â†’ (obj X âŸ¶ obj Y))
  (mapâ‚‚ : Î  {a b : B} {f g : a âŸ¶ b}, (f âŸ¶ g) â†’ (map f âŸ¶ map g))
  (map_comp : Î  {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c), map (f â‰« g) â‰… map f â‰« map g)
  {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d) : Prop :=
mapâ‚‚ (Î±_ f g h).hom = (map_comp (f â‰« g) h).hom â‰« (map_comp f g).hom â–· map h â‰«
  (Î±_ (map f) (map g) (map h)).hom â‰« map f â— (map_comp g h).inv â‰« (map_comp f (g â‰« h)).inv
structure pseudofunctor (B : Type uâ‚) [bicategory.{wâ‚ vâ‚} B] (C : Type uâ‚‚) [bicategory.{wâ‚‚ vâ‚‚} C]
  extends prelax_functor B C :=
(map_id (a : B) : map (ğŸ™ a) â‰… ğŸ™ (obj a))
(map_comp {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c) : map (f â‰« g) â‰… map f â‰« map g)
(mapâ‚‚_id' : âˆ€ {a b : B} (f : a âŸ¶ b), mapâ‚‚ (ğŸ™ f) = ğŸ™ (map f) . obviously)
(mapâ‚‚_comp' : âˆ€ {a b : B} {f g h : a âŸ¶ b} (Î· : f âŸ¶ g) (Î¸ : g âŸ¶ h),
  mapâ‚‚ (Î· â‰« Î¸) = mapâ‚‚ Î· â‰« mapâ‚‚ Î¸ . obviously)
(mapâ‚‚_whisker_left' : âˆ€ {a b c : B} (f : a âŸ¶ b) {g h : b âŸ¶ c} (Î· : g âŸ¶ h),
  mapâ‚‚ (f â— Î·) = (map_comp f g).hom â‰« map f â— mapâ‚‚ Î· â‰« (map_comp f h).inv . obviously)
(mapâ‚‚_whisker_right' : âˆ€ {a b c : B} {f g : a âŸ¶ b} (Î· : f âŸ¶ g) (h : b âŸ¶ c),
  mapâ‚‚ (Î· â–· h) = (map_comp f h).hom â‰« mapâ‚‚ Î· â–· map h â‰« (map_comp g h).inv . obviously)
(mapâ‚‚_associator' : âˆ€ {a b c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d),
  pseudofunctor.mapâ‚‚_associator_aux obj (Î» a b, map) (Î» a b f g, mapâ‚‚) (Î» a b c, map_comp) f g h
    . obviously)
(mapâ‚‚_left_unitor' : âˆ€ {a b : B} (f : a âŸ¶ b),
  mapâ‚‚ (Î»_ f).hom = (map_comp (ğŸ™ a) f).hom â‰« (map_id a).hom â–· map f â‰« (Î»_ (map f)).hom
    . obviously)
(mapâ‚‚_right_unitor' : âˆ€ {a b : B} (f : a âŸ¶ b),
  mapâ‚‚ (Ï_ f).hom = (map_comp f (ğŸ™ b)).hom â‰« map f â— (map_id b).hom â‰« (Ï_ (map f)).hom
    . obviously)
namespace pseudofunctor
restate_axiom mapâ‚‚_id'
restate_axiom mapâ‚‚_comp'
restate_axiom mapâ‚‚_whisker_left'
restate_axiom mapâ‚‚_whisker_right'
restate_axiom mapâ‚‚_associator'
restate_axiom mapâ‚‚_left_unitor'
restate_axiom mapâ‚‚_right_unitor'
attribute [reassoc]
  mapâ‚‚_comp mapâ‚‚_whisker_left mapâ‚‚_whisker_right mapâ‚‚_associator mapâ‚‚_left_unitor mapâ‚‚_right_unitor
attribute [simp]
  mapâ‚‚_id mapâ‚‚_comp mapâ‚‚_whisker_left mapâ‚‚_whisker_right
  mapâ‚‚_associator mapâ‚‚_left_unitor mapâ‚‚_right_unitor
section
open iso
add_decl_doc pseudofunctor.to_prelax_functor
instance has_coe_to_prelax_functor : has_coe (pseudofunctor B C) (prelax_functor B C) :=
âŸ¨to_prelax_functorâŸ©
variables (F : pseudofunctor B C)
@[simp] lemma to_prelax_functor_eq_coe : F.to_prelax_functor = F := rfl
@[simp] lemma to_prelax_functor_obj : (F : prelax_functor B C).obj = F.obj := rfl
@[simp] lemma to_prelax_functor_map : (F : prelax_functor B C).map = F.map := rfl
@[simp] lemma to_prelax_functor_mapâ‚‚ : (F : prelax_functor B C).mapâ‚‚ = F.mapâ‚‚ := rfl
def to_oplax : oplax_functor B C :=
{ map_id := Î» a, (F.map_id a).hom,
  map_comp := Î» a b c f g, (F.map_comp f g).hom,
  .. (F : prelax_functor B C) }
instance has_coe_to_oplax : has_coe (pseudofunctor B C) (oplax_functor B C) := âŸ¨to_oplaxâŸ©
@[simp] lemma to_oplax_eq_coe : F.to_oplax = F := rfl
@[simp] lemma to_oplax_obj : (F : oplax_functor B C).obj = F.obj := rfl
@[simp] lemma to_oplax_map : (F : oplax_functor B C).map = F.map := rfl
@[simp] lemma to_oplax_mapâ‚‚ : (F : oplax_functor B C).mapâ‚‚ = F.mapâ‚‚ := rfl
@[simp] lemma to_oplax_map_id (a : B) : (F : oplax_functor B C).map_id a = (F.map_id a).hom := rfl
@[simp] lemma to_oplax_map_comp {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c) :
  (F : oplax_functor B C).map_comp f g = (F.map_comp f g).hom := rfl
@[simps]
def map_functor (a b : B) : (a âŸ¶ b) â¥¤ (F.obj a âŸ¶ F.obj b) :=
(F : oplax_functor B C).map_functor a b
@[simps]
def id (B : Type uâ‚) [bicategory.{wâ‚ vâ‚} B] : pseudofunctor B B :=
{ map_id := Î» a, iso.refl (ğŸ™ a),
  map_comp := Î» a b c f g, iso.refl (f â‰« g),
  .. prelax_functor.id B }
instance : inhabited (pseudofunctor B B) := âŸ¨id BâŸ©
@[simps]
def comp (F : pseudofunctor B C) (G : pseudofunctor C D) : pseudofunctor B D :=
{ map_id := Î» a, (G.map_functor _ _).map_iso (F.map_id a) â‰ªâ‰« G.map_id (F.obj a),
  map_comp := Î» a b c f g,
    (G.map_functor _ _).map_iso (F.map_comp f g) â‰ªâ‰« G.map_comp (F.map f) (F.map g),
  .. (F : prelax_functor B C).comp â†‘G }
@[simps]
def mk_of_oplax (F : oplax_functor B C) (F' : F.pseudo_core) : pseudofunctor B C :=
{ map_id := F'.map_id_iso,
  map_comp := F'.map_comp_iso,
  mapâ‚‚_whisker_left' := Î» a b c f g h Î·, by
  { dsimp,
    rw [F'.map_comp_iso_hom f g, â†F.map_comp_naturality_right_assoc,
      â†F'.map_comp_iso_hom f h, hom_inv_id, comp_id] },
  mapâ‚‚_whisker_right' := Î» a b c f g Î· h, by
  { dsimp,
    rw [F'.map_comp_iso_hom f h, â†F.map_comp_naturality_left_assoc,
      â†F'.map_comp_iso_hom g h, hom_inv_id, comp_id] },
  mapâ‚‚_associator' := Î» a b c d f g h, by
  { dsimp,
    rw [F'.map_comp_iso_hom (f â‰« g) h, F'.map_comp_iso_hom f g, â†F.mapâ‚‚_associator_assoc,
      â†F'.map_comp_iso_hom f (g â‰« h), â†F'.map_comp_iso_hom g h,
      hom_inv_whisker_left_assoc, hom_inv_id, comp_id] },
  .. (F : prelax_functor B C) }
@[simps]
noncomputable
def mk_of_oplax' (F : oplax_functor B C)
  [âˆ€ a, is_iso (F.map_id a)] [âˆ€ {a b c} (f : a âŸ¶ b) (g : b âŸ¶ c), is_iso (F.map_comp f g)] :
  pseudofunctor B C :=
{ map_id := Î» a, as_iso (F.map_id a),
  map_comp := Î» a b c f g, as_iso (F.map_comp f g),
  mapâ‚‚_whisker_left' := Î» a b c f g h Î·, by
  { dsimp,
    rw [â†assoc, is_iso.eq_comp_inv, F.map_comp_naturality_right] },
  mapâ‚‚_whisker_right' := Î» a b c f g Î· h, by
  { dsimp,
    rw [â†assoc, is_iso.eq_comp_inv, F.map_comp_naturality_left] },
  mapâ‚‚_associator' := Î» a b c d f g h, by
  { dsimp,
    simp only [â†assoc],
    rw [is_iso.eq_comp_inv, â†inv_whisker_left, is_iso.eq_comp_inv],
    simp only [assoc, F.mapâ‚‚_associator] },
  .. (F : prelax_functor B C) }
end
end pseudofunctor
end
end category_theory
