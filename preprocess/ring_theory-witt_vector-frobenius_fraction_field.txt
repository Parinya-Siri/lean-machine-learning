import field_theory.is_alg_closed.basic
import ring_theory.witt_vector.discrete_valuation_ring
noncomputable theory
namespace witt_vector
variables (p : â„•) [hp : fact p.prime]
local notation `ğ•` := witt_vector p
namespace recursion_main
section comm_ring
include hp
variables {k : Type*} [comm_ring k] [char_p k p]
open polynomial
def succ_nth_defining_poly (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : fin (n+1) â†’ k) : polynomial k :=
X^p * C (aâ‚.coeff 0 ^ (p^(n+1))) - X * C (aâ‚‚.coeff 0 ^ (p^(n+1)))
  + C (aâ‚.coeff (n+1) * ((bs 0)^p)^(p^(n+1)) +
      nth_remainder p n (Î» v, (bs v)^p) (truncate_fun (n+1) aâ‚) -
      aâ‚‚.coeff (n+1) * (bs 0)^p^(n+1) - nth_remainder p n bs (truncate_fun (n+1) aâ‚‚))
lemma succ_nth_defining_poly_degree [is_domain k] (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : fin (n+1) â†’ k)
  (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :
  (succ_nth_defining_poly p n aâ‚ aâ‚‚ bs).degree = p :=
begin
  have : (X ^ p * C (aâ‚.coeff 0 ^ p ^ (n+1))).degree = p,
  { rw [degree_mul, degree_C],
    { simp only [nat.cast_with_bot, add_zero, degree_X, degree_pow, nat.smul_one_eq_coe] },
    { exact pow_ne_zero _ haâ‚ } },
  have : (X ^ p * C (aâ‚.coeff 0 ^ p ^ (n+1)) - X * C (aâ‚‚.coeff 0 ^ p ^ (n+1))).degree = p,
  { rw [degree_sub_eq_left_of_degree_lt, this],
    rw [this, degree_mul, degree_C, degree_X, add_zero],
    { exact_mod_cast hp.out.one_lt },
    { exact pow_ne_zero _ haâ‚‚ } },
  rw [succ_nth_defining_poly, degree_add_eq_left_of_degree_lt, this],
  apply lt_of_le_of_lt (degree_C_le),
  rw [this],
  exact_mod_cast hp.out.pos
end
end comm_ring
section is_alg_closed
include hp
variables {k : Type*} [field k] [char_p k p] [is_alg_closed k]
lemma root_exists (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : fin (n+1) â†’ k)
  (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :
  âˆƒ b : k, (succ_nth_defining_poly p n aâ‚ aâ‚‚ bs).is_root b :=
is_alg_closed.exists_root _ $
  by simp [(succ_nth_defining_poly_degree p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚), hp.out.ne_zero]
def succ_nth_val (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : fin (n+1) â†’ k)
  (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) : k :=
classical.some (root_exists p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚)
lemma succ_nth_val_spec (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : fin (n+1) â†’ k)
  (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :
  (succ_nth_defining_poly p n aâ‚ aâ‚‚ bs).is_root (succ_nth_val p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚) :=
classical.some_spec (root_exists p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚)
lemma succ_nth_val_spec' (n : â„•) (aâ‚ aâ‚‚ : ğ• k) (bs : fin (n+1) â†’ k)
  (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :
  (succ_nth_val p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚)^p * aâ‚.coeff 0 ^ (p^(n+1)) +
    aâ‚.coeff (n+1) * ((bs 0)^p)^(p^(n+1)) +
    nth_remainder p n (Î» v, (bs v)^p) (truncate_fun (n+1) aâ‚)
   = (succ_nth_val p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚) * aâ‚‚.coeff 0 ^ (p^(n+1)) +
     aâ‚‚.coeff (n+1) * (bs 0)^(p^(n+1)) + nth_remainder p n bs (truncate_fun (n+1) aâ‚‚) :=
begin
  rw â† sub_eq_zero,
  have := succ_nth_val_spec p n aâ‚ aâ‚‚ bs haâ‚ haâ‚‚,
  simp only [polynomial.map_add, polynomial.eval_X, polynomial.map_pow, polynomial.eval_C,
    polynomial.eval_pow, succ_nth_defining_poly, polynomial.eval_mul, polynomial.eval_add,
    polynomial.eval_sub, polynomial.map_mul, polynomial.map_sub, polynomial.is_root.def] at this,
  convert this using 1,
  ring
end
end is_alg_closed
end recursion_main
namespace recursion_base
include hp
variables {k : Type*} [field k] [is_alg_closed k]
lemma solution_pow (aâ‚ aâ‚‚ : ğ• k) :
  âˆƒ x : k, x^(p-1) = aâ‚‚.coeff 0 / aâ‚.coeff 0 :=
is_alg_closed.exists_pow_nat_eq _ $ by linarith [hp.out.one_lt, le_of_lt hp.out.one_lt]
def solution (aâ‚ aâ‚‚ : ğ• k) : k :=
classical.some $ solution_pow p aâ‚ aâ‚‚
lemma solution_spec (aâ‚ aâ‚‚ : ğ• k) :
  (solution p aâ‚ aâ‚‚)^(p-1) = aâ‚‚.coeff 0 / aâ‚.coeff 0 :=
classical.some_spec $ solution_pow p aâ‚ aâ‚‚
lemma solution_nonzero {aâ‚ aâ‚‚ : ğ• k} (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :
  solution p aâ‚ aâ‚‚ â‰  0 :=
begin
  intro h,
  have := solution_spec p aâ‚ aâ‚‚,
  rw [h, zero_pow] at this,
  { simpa [haâ‚, haâ‚‚] using _root_.div_eq_zero_iff.mp this.symm },
  { linarith [hp.out.one_lt, le_of_lt hp.out.one_lt] }
end
lemma solution_spec' {aâ‚ : ğ• k} (haâ‚ : aâ‚.coeff 0 â‰  0) (aâ‚‚ : ğ• k) :
  (solution p aâ‚ aâ‚‚)^p * aâ‚.coeff 0 = (solution p aâ‚ aâ‚‚) * aâ‚‚.coeff 0 :=
begin
  have := solution_spec p aâ‚ aâ‚‚,
  cases nat.exists_eq_succ_of_ne_zero hp.out.ne_zero with q hq,
  have hq' : q = p - 1 := by simp only [hq, tsub_zero, nat.succ_sub_succ_eq_sub],
  conv_lhs {congr, congr, skip, rw hq},
  rw [pow_succ', hq', this],
  field_simp [haâ‚, mul_comm],
end
end recursion_base
open recursion_main recursion_base
section frobenius_rotation
section is_alg_closed
include hp
variables {k : Type*} [field k] [char_p k p] [is_alg_closed k]
noncomputable def frobenius_rotation_coeff {aâ‚ aâ‚‚ : ğ• k}
  (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) : â„• â†’ k
| 0       := solution p aâ‚ aâ‚‚
| (n + 1) := succ_nth_val p n aâ‚ aâ‚‚ (Î» i, frobenius_rotation_coeff i.val) haâ‚ haâ‚‚
using_well_founded { dec_tac := `[apply fin.is_lt] }
def frobenius_rotation {aâ‚ aâ‚‚ : ğ• k} (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) : ğ• k :=
witt_vector.mk p (frobenius_rotation_coeff p haâ‚ haâ‚‚)
lemma frobenius_rotation_nonzero {aâ‚ aâ‚‚ : ğ• k} (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :
  frobenius_rotation p haâ‚ haâ‚‚ â‰  0 :=
begin
  intro h,
  apply solution_nonzero p haâ‚ haâ‚‚,
  simpa [â† h, frobenius_rotation, frobenius_rotation_coeff] using witt_vector.zero_coeff p k 0
end
lemma frobenius_frobenius_rotation {aâ‚ aâ‚‚ : ğ• k} (haâ‚ : aâ‚.coeff 0 â‰  0) (haâ‚‚ : aâ‚‚.coeff 0 â‰  0) :
  frobenius (frobenius_rotation p haâ‚ haâ‚‚) * aâ‚ = (frobenius_rotation p haâ‚ haâ‚‚) * aâ‚‚ :=
begin
  ext n,
  induction n with n ih,
  { simp only [witt_vector.mul_coeff_zero, witt_vector.coeff_frobenius_char_p,
      frobenius_rotation, frobenius_rotation_coeff],
    apply solution_spec' _ haâ‚ },
  { simp only [nth_remainder_spec, witt_vector.coeff_frobenius_char_p, frobenius_rotation_coeff,
      frobenius_rotation, fin.val_eq_coe],
    have := succ_nth_val_spec' p n aâ‚ aâ‚‚
      (Î» (i : fin (n + 1)), frobenius_rotation_coeff p haâ‚ haâ‚‚ i.val) haâ‚ haâ‚‚,
    simp only [frobenius_rotation_coeff, fin.val_eq_coe, fin.val_zero] at this,
    convert this using 4,
    apply truncated_witt_vector.ext,
    intro i,
    simp only [fin.val_eq_coe, witt_vector.coeff_truncate_fun, witt_vector.coeff_frobenius_char_p],
    refl }
end
local notation `Ï†` := is_fraction_ring.field_equiv_of_ring_equiv (frobenius_equiv p k)
lemma exists_frobenius_solution_fraction_ring_aux
  (m n : â„•) (r' q' : ğ• k) (hr' : r'.coeff 0 â‰  0) (hq' : q'.coeff 0 â‰  0)
  (hq : â†‘p ^ n * q' âˆˆ non_zero_divisors (ğ• k)) :
  let b : ğ• k := frobenius_rotation p hr' hq' in
  is_fraction_ring.field_equiv_of_ring_equiv
      (frobenius_equiv p k)
      (algebra_map (ğ• k) (fraction_ring (ğ• k)) b) *
    localization.mk (â†‘p ^ m * r') âŸ¨â†‘p ^ n * q', hqâŸ© =
  â†‘p ^ (m - n : â„¤) * algebra_map (ğ• k) (fraction_ring (ğ• k)) b :=
begin
  intros b,
  have key : witt_vector.frobenius b * p ^ m * r' * p ^ n = p ^ m * b * (p ^ n * q'),
  { have H := congr_arg (Î» x : ğ• k, x * p ^ m * p ^ n) (frobenius_frobenius_rotation p hr' hq'),
    dsimp at H,
    refine (eq.trans _ H).trans _; ring },
  have hq'' : algebra_map (ğ• k) (fraction_ring (ğ• k)) q' â‰  0,
  { have hq''' : q' â‰  0 := Î» h, hq' (by simp [h]),
    simpa only [ne.def, map_zero] using
      (is_fraction_ring.injective (ğ• k) (fraction_ring (ğ• k))).ne hq''' },
  rw zpow_subâ‚€ (fraction_ring.p_nonzero p k),
  field_simp [fraction_ring.p_nonzero p k],
  simp only [is_fraction_ring.field_equiv_of_ring_equiv,
    is_localization.ring_equiv_of_ring_equiv_eq, ring_equiv.coe_of_bijective],
  convert congr_arg (Î» x, algebra_map (ğ• k) (fraction_ring (ğ• k)) x) key using 1,
  { simp only [ring_hom.map_mul, ring_hom.map_pow, map_nat_cast, frobenius_equiv_apply],
    ring },
  { simp only [ring_hom.map_mul, ring_hom.map_pow, map_nat_cast] }
end
lemma exists_frobenius_solution_fraction_ring {a : fraction_ring (ğ• k)} (ha : a â‰  0) :
  âˆƒ (b : fraction_ring (ğ• k)) (hb : b â‰  0) (m : â„¤), Ï† b * a = p ^ m * b :=
begin
  revert ha,
  refine localization.induction_on a _,
  rintros âŸ¨r, q, hqâŸ© hrq,
  have hq0 : q â‰  0 := mem_non_zero_divisors_iff_ne_zero.1 hq,
  have hr0 : r â‰  0 := Î» h, hrq (by simp [h]),
  obtain âŸ¨m, r', hr', rflâŸ© := exists_eq_pow_p_mul r hr0,
  obtain âŸ¨n, q', hq', rflâŸ© := exists_eq_pow_p_mul q hq0,
  let b := frobenius_rotation p hr' hq',
  refine âŸ¨algebra_map (ğ• k) _ b, _, m - n, _âŸ©,
  { simpa only [map_zero] using
      (is_fraction_ring.injective (witt_vector p k) (fraction_ring (witt_vector p k))).ne
        (frobenius_rotation_nonzero p hr' hq')},
  exact exists_frobenius_solution_fraction_ring_aux p m n r' q' hr' hq' hq,
end
end is_alg_closed
end frobenius_rotation
end witt_vector
