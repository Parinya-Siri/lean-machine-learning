import topology.urysohns_lemma
import topology.continuous_function.bounded
open set filter metric
open_locale bounded_continuous_function filter topological_space
namespace topological_space
variables {Œπ X Y : Type*} {œÄ : Œπ ‚Üí Type*} [topological_space X] [topological_space Y]
  [fintype Œπ] [Œ† i, topological_space (œÄ i)]
class pseudo_metrizable_space (X : Type*) [t : topological_space X] : Prop :=
(exists_pseudo_metric : ‚àÉ (m : pseudo_metric_space X), m.to_uniform_space.to_topological_space = t)
@[priority 100]
instance _root_.pseudo_metric_space.to_pseudo_metrizable_space {X : Type*}
  [m : pseudo_metric_space X] :
  pseudo_metrizable_space X :=
‚ü®‚ü®m, rfl‚ü©‚ü©
noncomputable def pseudo_metrizable_space_pseudo_metric
  (X : Type*) [topological_space X] [h : pseudo_metrizable_space X] :
  pseudo_metric_space X :=
h.exists_pseudo_metric.some.replace_topology h.exists_pseudo_metric.some_spec.symm
instance pseudo_metrizable_space_prod [pseudo_metrizable_space X] [pseudo_metrizable_space Y] :
  pseudo_metrizable_space (X √ó Y) :=
begin
  letI : pseudo_metric_space X := pseudo_metrizable_space_pseudo_metric X,
  letI : pseudo_metric_space Y := pseudo_metrizable_space_pseudo_metric Y,
  apply_instance
end
lemma _root_.inducing.pseudo_metrizable_space [pseudo_metrizable_space Y] {f : X ‚Üí Y}
  (hf : inducing f) :
  pseudo_metrizable_space X :=
begin
  letI : pseudo_metric_space Y := pseudo_metrizable_space_pseudo_metric Y,
  exact ‚ü®‚ü®hf.comap_pseudo_metric_space, rfl‚ü©‚ü©
end
instance pseudo_metrizable_space.subtype [pseudo_metrizable_space X]
  (s : set X) : pseudo_metrizable_space s :=
inducing_coe.pseudo_metrizable_space
instance pseudo_metrizable_space_pi [Œ† i, pseudo_metrizable_space (œÄ i)] :
  pseudo_metrizable_space (Œ† i, œÄ i) :=
by { letI := Œª i, pseudo_metrizable_space_pseudo_metric (œÄ i), apply_instance }
class metrizable_space (X : Type*) [t : topological_space X] : Prop :=
(exists_metric : ‚àÉ (m : metric_space X), m.to_uniform_space.to_topological_space = t)
@[priority 100]
instance _root_.metric_space.to_metrizable_space {X : Type*} [m : metric_space X] :
  metrizable_space X :=
‚ü®‚ü®m, rfl‚ü©‚ü©
@[priority 100]
instance metrizable_space.to_pseudo_metrizable_space [h : metrizable_space X] :
  pseudo_metrizable_space X :=
‚ü®let ‚ü®m, hm‚ü© := h.1 in ‚ü®m.to_pseudo_metric_space, hm‚ü©‚ü©
noncomputable def metrizable_space_metric (X : Type*) [topological_space X]
  [h : metrizable_space X] :
  metric_space X :=
h.exists_metric.some.replace_topology h.exists_metric.some_spec.symm
@[priority 100]
instance t2_space_of_metrizable_space [metrizable_space X] : t2_space X :=
by { letI : metric_space X := metrizable_space_metric X, apply_instance }
instance metrizable_space_prod [metrizable_space X] [metrizable_space Y] :
  metrizable_space (X √ó Y) :=
begin
  letI : metric_space X := metrizable_space_metric X,
  letI : metric_space Y := metrizable_space_metric Y,
  apply_instance
end
lemma _root_.embedding.metrizable_space [metrizable_space Y] {f : X ‚Üí Y} (hf : embedding f) :
  metrizable_space X :=
begin
  letI : metric_space Y := metrizable_space_metric Y,
  exact ‚ü®‚ü®hf.comap_metric_space f, rfl‚ü©‚ü©
end
instance metrizable_space.subtype [metrizable_space X] (s : set X) : metrizable_space s :=
embedding_subtype_coe.metrizable_space
instance metrizable_space_pi [Œ† i, metrizable_space (œÄ i)] : metrizable_space (Œ† i, œÄ i) :=
by { letI := Œª i, metrizable_space_metric (œÄ i), apply_instance }
variables (X) [regular_space X] [second_countable_topology X]
lemma exists_embedding_l_infty : ‚àÉ f : X ‚Üí (‚Ñï ‚Üí·µá ‚Ñù), embedding f :=
begin
  haveI : normal_space X := normal_space_of_regular_second_countable X,
  have : ‚àÄ UV : s, ‚àÉ f : C(X, ‚Ñù), eq_on f 0 UV.1.1 ‚àß eq_on f (Œª _, Œµ UV) UV.1.2·∂ú ‚àß
    ‚àÄ x, f x ‚àà Icc 0 (Œµ UV),
  { intro UV,
    rcases exists_continuous_zero_one_of_closed is_closed_closure
      (hB.is_open UV.2.1.2).is_closed_compl (hd UV) with ‚ü®f, hf‚ÇÄ, hf‚ÇÅ, hf01‚ü©,
    exact ‚ü®Œµ UV ‚Ä¢ f, Œª x hx, by simp [hf‚ÇÄ (subset_closure hx)], Œª x hx, by simp [hf‚ÇÅ hx],
      Œª x, ‚ü®mul_nonneg (Œµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Œµ01 _).1.le (hf01 _).2‚ü©‚ü© },
  choose f hf0 hfŒµ hf0Œµ,
  have hf01 : ‚àÄ UV x, f UV x ‚àà Icc (0 : ‚Ñù) 1,
    from Œª UV x, Icc_subset_Icc_right (Œµ01 _).2 (hf0Œµ _ _),
  set F : X ‚Üí s ‚Üí·µá ‚Ñù := Œª x, ‚ü®‚ü®Œª UV, f UV x, continuous_of_discrete_topology‚ü©, 1, Œª UV‚ÇÅ UV‚ÇÇ,
    real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)‚ü©,
  have hF : ‚àÄ x UV, F x UV = f UV x := Œª _ _, rfl,
  refine ‚ü®F, embedding.mk' _ (Œª x y hxy, _) (Œª x, le_antisymm _ _)‚ü©,
    refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_has_basis).2 _,
    rintro V ‚ü®hVB, hxV‚ü©,
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with ‚ü®U, hUB, hxU, hUV‚ü©,
    set UV : ‚Ü•s := ‚ü®(U, V), ‚ü®hUB, hVB‚ü©, hUV‚ü©,
    refine ‚ü®Œµ UV, (Œµ01 UV).1, Œª y (hy : dist (F y) (F x) < Œµ UV), _‚ü©,
    replace hy : dist (F y UV) (F x UV) < Œµ UV,
      from (bounded_continuous_function.dist_coe_le_dist _).trans_lt hy,
    contrapose! hy,
    rw [hF, hF, hfŒµ UV hy, hf0 UV hxU, pi.zero_apply, dist_zero_right],
    exact le_abs_self _ },
    refine (nhds_basis_closed_ball.comap _).ge_iff.2 (Œª Œ¥ Œ¥0, _),
    have h_fin : {UV : s | Œ¥ ‚â§ Œµ UV}.finite, by simpa only [‚Üê not_lt] using hŒµ (gt_mem_nhds Œ¥0),
    have : ‚àÄ·∂† y in ùìù x, ‚àÄ UV, Œ¥ ‚â§ Œµ UV ‚Üí dist (F y UV) (F x UV) ‚â§ Œ¥,
    { refine (eventually_all_finite h_fin).2 (Œª UV hUV, _),
      exact (f UV).continuous.tendsto x (closed_ball_mem_nhds _ Œ¥0) },
    refine this.mono (Œª y hy, (bounded_continuous_function.dist_le Œ¥0.le).2 $ Œª UV, _),
    cases le_total Œ¥ (Œµ UV) with hle hle,
    exacts [hy _ hle, (real.dist_le_of_mem_Icc (hf0Œµ _ _) (hf0Œµ _ _)).trans (by rwa sub_zero)] }
end
lemma metrizable_space_of_regular_second_countable : metrizable_space X :=
let ‚ü®f, hf‚ü© := exists_embedding_l_infty X in hf.metrizable_space
instance : metrizable_space ennreal := metrizable_space_of_regular_second_countable ennreal
end topological_space
