import data.bundle
import topology.algebra.order.basic
import topology.local_homeomorph
variables {Œπ : Type*} {B : Type*} {F : Type*}
open topological_space filter set bundle
open_locale topological_space classical
section topological_fiber_bundle
variables (F) {Z : Type*} [topological_space B] [topological_space F] {proj : Z ‚Üí B}
@[nolint has_inhabited_instance]
structure topological_fiber_bundle.pretrivialization (proj : Z ‚Üí B) extends local_equiv Z (B √ó F) :=
(open_target   : is_open target)
(base_set      : set B)
(open_base_set : is_open base_set)
(source_eq     : source = proj ‚Åª¬π' base_set)
(target_eq     : target = base_set √óÀ¢ (univ : set F))
(proj_to_fun   : ‚àÄ p ‚àà source, (to_fun p).1 = proj p)
open topological_fiber_bundle
namespace topological_fiber_bundle.pretrivialization
instance : has_coe_to_fun (pretrivialization F proj) (Œª _, Z ‚Üí (B √ó F)) := ‚ü®Œª e, e.to_fun‚ü©
variables {F} (e : pretrivialization F proj) {x : Z}
@[simp, mfld_simps] lemma coe_coe : ‚áëe.to_local_equiv = e := rfl
@[simp, mfld_simps] lemma coe_fst (ex : x ‚àà e.source) : (e x).1 = proj x := e.proj_to_fun x ex
lemma mem_source : x ‚àà e.source ‚Üî proj x ‚àà e.base_set := by rw [e.source_eq, mem_preimage]
lemma coe_fst' (ex : proj x ‚àà e.base_set) : (e x).1 = proj x := e.coe_fst (e.mem_source.2 ex)
protected lemma eq_on : eq_on (prod.fst ‚àò e) proj e.source := Œª x hx, e.coe_fst hx
lemma mk_proj_snd (ex : x ‚àà e.source) : (proj x, (e x).2) = e x := prod.ext (e.coe_fst ex).symm rfl
lemma mk_proj_snd' (ex : proj x ‚àà e.base_set) : (proj x, (e x).2) = e x :=
prod.ext (e.coe_fst' ex).symm rfl
def set_symm : e.target ‚Üí Z := e.target.restrict e.to_local_equiv.symm
lemma mem_target {x : B √ó F} : x ‚àà e.target ‚Üî x.1 ‚àà e.base_set :=
by rw [e.target_eq, prod_univ, mem_preimage]
lemma proj_symm_apply {x : B √ó F} (hx : x ‚àà e.target) : proj (e.to_local_equiv.symm x) = x.1 :=
begin
  have := (e.coe_fst (e.to_local_equiv.map_target hx)).symm,
  rwa [‚Üê e.coe_coe, e.to_local_equiv.right_inv hx] at this
end
lemma proj_symm_apply' {b : B} {x : F} (hx : b ‚àà e.base_set) :
  proj (e.to_local_equiv.symm (b, x)) = b :=
e.proj_symm_apply (e.mem_target.2 hx)
lemma proj_surj_on_base_set [nonempty F] : set.surj_on proj e.source e.base_set :=
Œª b hb, let ‚ü®y‚ü© := ‚Äπnonempty F‚Ä∫ in ‚ü®e.to_local_equiv.symm (b, y),
  e.to_local_equiv.map_target $ e.mem_target.2 hb, e.proj_symm_apply' hb‚ü©
lemma apply_symm_apply {x : B √ó F} (hx : x ‚àà e.target) : e (e.to_local_equiv.symm x) = x :=
e.to_local_equiv.right_inv hx
lemma apply_symm_apply' {b : B} {x : F} (hx : b ‚àà e.base_set) :
  e (e.to_local_equiv.symm (b, x)) = (b, x) :=
e.apply_symm_apply (e.mem_target.2 hx)
lemma symm_apply_apply {x : Z} (hx : x ‚àà e.source) : e.to_local_equiv.symm (e x) = x :=
e.to_local_equiv.left_inv hx
@[simp, mfld_simps] lemma symm_apply_mk_proj {x : Z} (ex : x ‚àà e.source) :
  e.to_local_equiv.symm (proj x, (e x).2) = x :=
by rw [‚Üê e.coe_fst ex, prod.mk.eta, ‚Üê e.coe_coe, e.to_local_equiv.left_inv ex]
@[simp, mfld_simps] lemma preimage_symm_proj_base_set :
  (e.to_local_equiv.symm ‚Åª¬π' (proj ‚Åª¬π' e.base_set)) ‚à© e.target  = e.target :=
begin
  refine inter_eq_right_iff_subset.mpr (Œª x hx, _),
  simp only [mem_preimage, local_equiv.inv_fun_as_coe, e.proj_symm_apply hx],
  exact e.mem_target.mp hx,
end
@[simp, mfld_simps] lemma preimage_symm_proj_inter (s : set B) :
  (e.to_local_equiv.symm ‚Åª¬π' (proj ‚Åª¬π' s)) ‚à© e.base_set √óÀ¢ (univ : set F) =
    (s ‚à© e.base_set) √óÀ¢ (univ : set F) :=
begin
  ext ‚ü®x, y‚ü©,
  suffices : x ‚àà e.base_set ‚Üí (proj (e.to_local_equiv.symm (x, y)) ‚àà s ‚Üî x ‚àà s),
    by simpa only [prod_mk_mem_set_prod_eq, mem_inter_eq, and_true, mem_univ, and.congr_left_iff],
  intro h,
  rw [e.proj_symm_apply' h]
end
lemma target_inter_preimage_symm_source_eq (e f : pretrivialization F proj) :
  f.target ‚à© (f.to_local_equiv.symm) ‚Åª¬π' e.source
  = (e.base_set ‚à© f.base_set) √óÀ¢ (univ : set F) :=
by rw [inter_comm, f.target_eq, e.source_eq, f.preimage_symm_proj_inter]
lemma trans_source (e f : pretrivialization F proj) :
  (f.to_local_equiv.symm.trans e.to_local_equiv).source
  = (e.base_set ‚à© f.base_set) √óÀ¢ (univ : set F) :=
by rw [local_equiv.trans_source, local_equiv.symm_source, e.target_inter_preimage_symm_source_eq]
lemma symm_trans_symm (e e' : pretrivialization F proj) :
  (e.to_local_equiv.symm.trans e'.to_local_equiv).symm =
  e'.to_local_equiv.symm.trans e.to_local_equiv :=
by rw [local_equiv.trans_symm_eq_symm_trans_symm, local_equiv.symm_symm]
lemma symm_trans_source_eq (e e' : pretrivialization F proj) :
  (e.to_local_equiv.symm.trans e'.to_local_equiv).source =
  (e.base_set ‚à© e'.base_set) √óÀ¢ (univ : set F) :=
by rw [local_equiv.trans_source, e'.source_eq, local_equiv.symm_source, e.target_eq, inter_comm,
  e.preimage_symm_proj_inter, inter_comm]
lemma symm_trans_target_eq (e e' : pretrivialization F proj) :
  (e.to_local_equiv.symm.trans e'.to_local_equiv).target =
  (e.base_set ‚à© e'.base_set) √óÀ¢ (univ : set F) :=
by rw [‚Üê local_equiv.symm_source, symm_trans_symm, symm_trans_source_eq, inter_comm]
end topological_fiber_bundle.pretrivialization
variable [topological_space Z]
@[nolint has_inhabited_instance]
structure topological_fiber_bundle.trivialization (proj : Z ‚Üí B)
  extends local_homeomorph Z (B √ó F) :=
(base_set      : set B)
(open_base_set : is_open base_set)
(source_eq     : source = proj ‚Åª¬π' base_set)
(target_eq     : target = base_set √óÀ¢ (univ : set F))
(proj_to_fun   : ‚àÄ p ‚àà source, (to_local_homeomorph p).1 = proj p)
open topological_fiber_bundle
namespace topological_fiber_bundle.trivialization
variables {F} (e : trivialization F proj) {x : Z}
def to_pretrivialization : topological_fiber_bundle.pretrivialization F proj := { ..e }
instance : has_coe_to_fun (trivialization F proj) (Œª _, Z ‚Üí B √ó F) := ‚ü®Œª e, e.to_fun‚ü©
instance : has_coe (trivialization F proj) (pretrivialization F proj) :=
‚ü®to_pretrivialization‚ü©
@[simp, mfld_simps] lemma coe_coe : ‚áëe.to_local_homeomorph = e := rfl
@[simp, mfld_simps] lemma coe_fst (ex : x ‚àà e.source) : (e x).1 = proj x := e.proj_to_fun x ex
protected lemma eq_on : eq_on (prod.fst ‚àò e) proj e.source := Œª x hx, e.coe_fst hx
lemma mem_source : x ‚àà e.source ‚Üî proj x ‚àà e.base_set := by rw [e.source_eq, mem_preimage]
lemma coe_fst' (ex : proj x ‚àà e.base_set) : (e x).1 = proj x := e.coe_fst (e.mem_source.2 ex)
lemma mk_proj_snd (ex : x ‚àà e.source) : (proj x, (e x).2) = e x := prod.ext (e.coe_fst ex).symm rfl
lemma mk_proj_snd' (ex : proj x ‚àà e.base_set) : (proj x, (e x).2) = e x :=
prod.ext (e.coe_fst' ex).symm rfl
lemma source_inter_preimage_target_inter (s : set (B √ó F)) :
  e.source ‚à© (e ‚Åª¬π' (e.target ‚à© s)) = e.source ‚à© (e ‚Åª¬π' s) :=
e.to_local_homeomorph.source_inter_preimage_target_inter s
@[simp, mfld_simps] lemma coe_mk (e : local_homeomorph Z (B √ó F)) (i j k l m) (x : Z) :
  (trivialization.mk e i j k l m : trivialization F proj) x = e x := rfl
lemma mem_target {x : B √ó F} : x ‚àà e.target ‚Üî x.1 ‚àà e.base_set :=
e.to_pretrivialization.mem_target
lemma map_target {x : B √ó F} (hx : x ‚àà e.target) : e.to_local_homeomorph.symm x ‚àà e.source :=
e.to_local_homeomorph.map_target hx
lemma proj_symm_apply {x : B √ó F} (hx : x ‚àà e.target) : proj (e.to_local_homeomorph.symm x) = x.1 :=
e.to_pretrivialization.proj_symm_apply hx
lemma proj_symm_apply' {b : B} {x : F}
  (hx : b ‚àà e.base_set) : proj (e.to_local_homeomorph.symm (b, x)) = b :=
e.to_pretrivialization.proj_symm_apply' hx
lemma proj_surj_on_base_set [nonempty F] : set.surj_on proj e.source e.base_set :=
e.to_pretrivialization.proj_surj_on_base_set
lemma apply_symm_apply {x : B √ó F} (hx : x ‚àà e.target) : e (e.to_local_homeomorph.symm x) = x :=
e.to_local_homeomorph.right_inv hx
lemma apply_symm_apply'
  {b : B} {x : F} (hx : b ‚àà e.base_set) : e (e.to_local_homeomorph.symm (b, x)) = (b, x) :=
e.to_pretrivialization.apply_symm_apply' hx
@[simp, mfld_simps] lemma symm_apply_mk_proj (ex : x ‚àà e.source) :
  e.to_local_homeomorph.symm (proj x, (e x).2) = x :=
e.to_pretrivialization.symm_apply_mk_proj ex
lemma symm_trans_source_eq (e e' : trivialization F proj) :
  (e.to_local_equiv.symm.trans e'.to_local_equiv).source
  = (e.base_set ‚à© e'.base_set) √óÀ¢ (univ : set F) :=
pretrivialization.symm_trans_source_eq e.to_pretrivialization e'
lemma symm_trans_target_eq (e e' : trivialization F proj) :
  (e.to_local_equiv.symm.trans e'.to_local_equiv).target
  = (e.base_set ‚à© e'.base_set) √óÀ¢ (univ : set F) :=
pretrivialization.symm_trans_target_eq e.to_pretrivialization e'
lemma coe_fst_eventually_eq_proj (ex : x ‚àà e.source) : prod.fst ‚àò e =·∂†[ùìù x] proj  :=
mem_nhds_iff.2 ‚ü®e.source, Œª y hy, e.coe_fst hy, e.open_source, ex‚ü©
lemma coe_fst_eventually_eq_proj' (ex : proj x ‚àà e.base_set) : prod.fst ‚àò e =·∂†[ùìù x] proj :=
e.coe_fst_eventually_eq_proj (e.mem_source.2 ex)
lemma map_proj_nhds (ex : x ‚àà e.source) : map proj (ùìù x) = ùìù (proj x) :=
by rw [‚Üê e.coe_fst ex, ‚Üê map_congr (e.coe_fst_eventually_eq_proj ex), ‚Üê map_map, ‚Üê e.coe_coe,
  e.to_local_homeomorph.map_nhds_eq ex, map_fst_nhds]
lemma continuous_at_proj (ex : x ‚àà e.source) : continuous_at proj x :=
(e.map_proj_nhds ex).le
def comp_homeomorph {Z' : Type*} [topological_space Z'] (h : Z' ‚âÉ‚Çú Z) :
  trivialization F (proj ‚àò h) :=
{ to_local_homeomorph := h.to_local_homeomorph.trans e.to_local_homeomorph,
  base_set := e.base_set,
  open_base_set := e.open_base_set,
  source_eq := by simp [e.source_eq, preimage_preimage],
  target_eq := by simp [e.target_eq],
  proj_to_fun := Œª p hp,
    have hp : h p ‚àà e.source, by simpa using hp,
    by simp [hp] }
lemma continuous_at_of_comp_right {X : Type*} [topological_space X] {f : Z ‚Üí X} {z : Z}
  (e : trivialization F proj) (he : proj z ‚àà e.base_set)
  (hf : continuous_at (f ‚àò e.to_local_equiv.symm) (e z)) :
  continuous_at f z :=
begin
  have hez : z ‚àà e.to_local_equiv.symm.target,
  { rw [local_equiv.symm_target, e.mem_source],
    exact he },
  rwa [e.to_local_homeomorph.symm.continuous_at_iff_continuous_at_comp_right hez,
   local_homeomorph.symm_symm]
end
lemma continuous_at_of_comp_left {X : Type*} [topological_space X] {f : X ‚Üí Z} {x : X}
  (e : trivialization F proj) (hf_proj : continuous_at (proj ‚àò f) x) (he : proj (f x) ‚àà e.base_set)
  (hf : continuous_at (e ‚àò f) x) :
  continuous_at f x :=
begin
  rw e.to_local_homeomorph.continuous_at_iff_continuous_at_comp_left,
  { exact hf },
  rw [e.source_eq, ‚Üê preimage_comp],
  exact hf_proj.preimage_mem_nhds (e.open_base_set.mem_nhds he),
end
end topological_fiber_bundle.trivialization
def is_topological_fiber_bundle (proj : Z ‚Üí B) : Prop :=
‚àÄ x : B, ‚àÉe : trivialization F proj, x ‚àà e.base_set
def is_trivial_topological_fiber_bundle (proj : Z ‚Üí B) : Prop :=
‚àÉ e : Z ‚âÉ‚Çú (B √ó F), ‚àÄ x, (e x).1 = proj x
variables {F}
lemma is_trivial_topological_fiber_bundle.is_topological_fiber_bundle
  (h : is_trivial_topological_fiber_bundle F proj) :
  is_topological_fiber_bundle F proj :=
let ‚ü®e, he‚ü© := h in Œª x,
‚ü®‚ü®e.to_local_homeomorph, univ, is_open_univ, rfl, univ_prod_univ.symm, Œª x _, he x‚ü©, mem_univ x‚ü©
lemma is_topological_fiber_bundle.map_proj_nhds (h : is_topological_fiber_bundle F proj) (x : Z) :
  map proj (ùìù x) = ùìù (proj x) :=
let ‚ü®e, ex‚ü© := h (proj x) in e.map_proj_nhds $ e.mem_source.2 ex
lemma is_topological_fiber_bundle.continuous_proj (h : is_topological_fiber_bundle F proj) :
  continuous proj :=
continuous_iff_continuous_at.2 $ Œª x, (h.map_proj_nhds _).le
lemma is_topological_fiber_bundle.is_open_map_proj (h : is_topological_fiber_bundle F proj) :
  is_open_map proj :=
is_open_map.of_nhds_le $ Œª x, (h.map_proj_nhds x).ge
lemma is_topological_fiber_bundle.surjective_proj [nonempty F]
  (h : is_topological_fiber_bundle F proj) :
  function.surjective proj :=
Œª b, let ‚ü®e, eb‚ü© := h b, ‚ü®x, _, hx‚ü© := e.proj_surj_on_base_set eb in ‚ü®x, hx‚ü©
lemma is_topological_fiber_bundle.quotient_map_proj [nonempty F]
  (h : is_topological_fiber_bundle F proj) :
  quotient_map proj :=
h.is_open_map_proj.to_quotient_map h.continuous_proj h.surjective_proj
lemma is_trivial_topological_fiber_bundle_fst :
  is_trivial_topological_fiber_bundle F (prod.fst : B √ó F ‚Üí B) :=
‚ü®homeomorph.refl _, Œª x, rfl‚ü©
lemma is_topological_fiber_bundle_fst : is_topological_fiber_bundle F (prod.fst : B √ó F ‚Üí B) :=
is_trivial_topological_fiber_bundle_fst.is_topological_fiber_bundle
lemma is_trivial_topological_fiber_bundle_snd :
  is_trivial_topological_fiber_bundle F (prod.snd : F √ó B ‚Üí B) :=
‚ü®homeomorph.prod_comm _ _, Œª x, rfl‚ü©
lemma is_topological_fiber_bundle_snd : is_topological_fiber_bundle F (prod.snd : F √ó B ‚Üí B) :=
is_trivial_topological_fiber_bundle_snd.is_topological_fiber_bundle
lemma is_topological_fiber_bundle.comp_homeomorph {Z' : Type*} [topological_space Z']
  (e : is_topological_fiber_bundle F proj) (h : Z' ‚âÉ‚Çú Z) :
  is_topological_fiber_bundle F (proj ‚àò h) :=
Œª x, let ‚ü®e, he‚ü© := e x in
‚ü®e.comp_homeomorph h, by simpa [topological_fiber_bundle.trivialization.comp_homeomorph] using he‚ü©
namespace topological_fiber_bundle.trivialization
def trans_fiber_homeomorph {F' : Type*} [topological_space F']
  (e : trivialization F proj) (h : F ‚âÉ‚Çú F') : trivialization F' proj :=
{ to_local_homeomorph := e.to_local_homeomorph.trans_homeomorph $ (homeomorph.refl _).prod_congr h,
  base_set := e.base_set,
  open_base_set := e.open_base_set,
  source_eq := e.source_eq,
  target_eq := by simp [e.target_eq, prod_univ, preimage_preimage],
  proj_to_fun := e.proj_to_fun }
@[simp] lemma trans_fiber_homeomorph_apply {F' : Type*} [topological_space F']
  (e : trivialization F proj) (h : F ‚âÉ‚Çú F') (x : Z) :
  e.trans_fiber_homeomorph h x = ((e x).1, h (e x).2) :=
rfl
def coord_change (e‚ÇÅ e‚ÇÇ : trivialization F proj) (b : B) (x : F) : F :=
(e‚ÇÇ $ e‚ÇÅ.to_local_homeomorph.symm (b, x)).2
lemma mk_coord_change
  (e‚ÇÅ e‚ÇÇ : trivialization F proj) {b : B}
  (h‚ÇÅ : b ‚àà e‚ÇÅ.base_set) (h‚ÇÇ : b ‚àà e‚ÇÇ.base_set) (x : F) :
  (b, e‚ÇÅ.coord_change e‚ÇÇ b x) = e‚ÇÇ (e‚ÇÅ.to_local_homeomorph.symm (b, x)) :=
begin
  refine prod.ext _ rfl,
  rw [e‚ÇÇ.coe_fst', ‚Üê e‚ÇÅ.coe_fst', e‚ÇÅ.apply_symm_apply' h‚ÇÅ],
  { rwa [e‚ÇÅ.proj_symm_apply' h‚ÇÅ] },
  { rwa [e‚ÇÅ.proj_symm_apply' h‚ÇÅ] }
end
lemma coord_change_apply_snd
  (e‚ÇÅ e‚ÇÇ : trivialization F proj) {p : Z}
  (h : proj p ‚àà e‚ÇÅ.base_set) :
  e‚ÇÅ.coord_change e‚ÇÇ (proj p) (e‚ÇÅ p).snd = (e‚ÇÇ p).snd :=
by rw [coord_change, e‚ÇÅ.symm_apply_mk_proj (e‚ÇÅ.mem_source.2 h)]
lemma coord_change_same_apply
  (e : trivialization F proj) {b : B} (h : b ‚àà e.base_set) (x : F) :
  e.coord_change e b x = x :=
by rw [coord_change, e.apply_symm_apply' h]
lemma coord_change_same
  (e : trivialization F proj) {b : B} (h : b ‚àà e.base_set) :
  e.coord_change e b = id :=
funext $ e.coord_change_same_apply h
lemma coord_change_coord_change
  (e‚ÇÅ e‚ÇÇ e‚ÇÉ : trivialization F proj) {b : B}
  (h‚ÇÅ : b ‚àà e‚ÇÅ.base_set) (h‚ÇÇ : b ‚àà e‚ÇÇ.base_set) (x : F) :
  e‚ÇÇ.coord_change e‚ÇÉ b (e‚ÇÅ.coord_change e‚ÇÇ b x) = e‚ÇÅ.coord_change e‚ÇÉ b x :=
begin
  rw [coord_change, e‚ÇÅ.mk_coord_change _ h‚ÇÅ h‚ÇÇ, ‚Üê e‚ÇÇ.coe_coe,
    e‚ÇÇ.to_local_homeomorph.left_inv, coord_change],
  rwa [e‚ÇÇ.mem_source, e‚ÇÅ.proj_symm_apply' h‚ÇÅ]
end
lemma continuous_coord_change (e‚ÇÅ e‚ÇÇ : trivialization F proj) {b : B}
  (h‚ÇÅ : b ‚àà e‚ÇÅ.base_set) (h‚ÇÇ : b ‚àà e‚ÇÇ.base_set) :
  continuous (e‚ÇÅ.coord_change e‚ÇÇ b) :=
begin
  refine continuous_snd.comp (e‚ÇÇ.to_local_homeomorph.continuous_on.comp_continuous
    (e‚ÇÅ.to_local_homeomorph.continuous_on_symm.comp_continuous _ _) _),
  { exact continuous_const.prod_mk continuous_id },
  { exact Œª x, e‚ÇÅ.mem_target.2 h‚ÇÅ },
  { intro x,
    rwa [e‚ÇÇ.mem_source, e‚ÇÅ.proj_symm_apply' h‚ÇÅ] }
end
def coord_change_homeomorph
  (e‚ÇÅ e‚ÇÇ : trivialization F proj) {b : B} (h‚ÇÅ : b ‚àà e‚ÇÅ.base_set) (h‚ÇÇ : b ‚àà e‚ÇÇ.base_set) :
  F ‚âÉ‚Çú F :=
{ to_fun := e‚ÇÅ.coord_change e‚ÇÇ b,
  inv_fun := e‚ÇÇ.coord_change e‚ÇÅ b,
  left_inv := Œª x, by simp only [*, coord_change_coord_change, coord_change_same_apply],
  right_inv := Œª x, by simp only [*, coord_change_coord_change, coord_change_same_apply],
  continuous_to_fun := e‚ÇÅ.continuous_coord_change e‚ÇÇ h‚ÇÅ h‚ÇÇ,
  continuous_inv_fun := e‚ÇÇ.continuous_coord_change e‚ÇÅ h‚ÇÇ h‚ÇÅ }
@[simp] lemma coord_change_homeomorph_coe
  (e‚ÇÅ e‚ÇÇ : trivialization F proj) {b : B} (h‚ÇÅ : b ‚àà e‚ÇÅ.base_set) (h‚ÇÇ : b ‚àà e‚ÇÇ.base_set) :
  ‚áë(e‚ÇÅ.coord_change_homeomorph e‚ÇÇ h‚ÇÅ h‚ÇÇ) = e‚ÇÅ.coord_change e‚ÇÇ b :=
rfl
end topological_fiber_bundle.trivialization
section comap
open_locale classical
variables {B' : Type*} [topological_space B']
noncomputable def topological_fiber_bundle.trivialization.comap
  (e : trivialization F proj) (f : B' ‚Üí B) (hf : continuous f)
  (b' : B') (hb' : f b' ‚àà e.base_set) :
  trivialization F (Œª x : {p : B' √ó Z | f p.1 = proj p.2}, (x : B' √ó Z).1) :=
{ to_fun := Œª p, ((p : B' √ó Z).1, (e (p : B' √ó Z).2).2),
  inv_fun := Œª p, if h : f p.1 ‚àà e.base_set
    then ‚ü®‚ü®p.1, e.to_local_homeomorph.symm (f p.1, p.2)‚ü©, by simp [e.proj_symm_apply' h]‚ü©
    else ‚ü®‚ü®b', e.to_local_homeomorph.symm (f b', p.2)‚ü©, by simp [e.proj_symm_apply' hb']‚ü©,
  source := {p | f (p : B' √ó Z).1 ‚àà e.base_set},
  target := {p | f p.1 ‚àà e.base_set},
  map_source' := Œª p hp, hp,
  map_target' := Œª p (hp : f p.1 ‚àà e.base_set), by simp [hp],
  left_inv' :=
    begin
      rintro ‚ü®‚ü®b, x‚ü©, hbx‚ü© hb,
      dsimp at *,
      have hx : x ‚àà e.source, from e.mem_source.2 (hbx ‚ñ∏ hb),
      ext; simp *
    end,
  right_inv' := Œª p (hp : f p.1 ‚àà e.base_set), by simp [*, e.apply_symm_apply'],
  open_source := e.open_base_set.preimage (hf.comp $ continuous_fst.comp continuous_subtype_coe),
  open_target := e.open_base_set.preimage (hf.comp continuous_fst),
  continuous_to_fun := ((continuous_fst.comp continuous_subtype_coe).continuous_on).prod $
    continuous_snd.comp_continuous_on $ e.continuous_to_fun.comp
      (continuous_snd.comp continuous_subtype_coe).continuous_on $
      by { rintro ‚ü®‚ü®b, x‚ü©, (hbx : f b = proj x)‚ü© (hb : f b ‚àà e.base_set),
           rw hbx at hb,
           exact e.mem_source.2 hb },
  continuous_inv_fun :=
    begin
      rw [embedding_subtype_coe.continuous_on_iff],
      suffices : continuous_on (Œª p : B' √ó F, (p.1, e.to_local_homeomorph.symm (f p.1, p.2)))
        {p : B' √ó F | f p.1 ‚àà e.base_set},
      { refine this.congr (Œª p (hp : f p.1 ‚àà e.base_set), _),
        simp [hp] },
      { refine continuous_on_fst.prod (e.to_local_homeomorph.symm.continuous_on.comp _ _),
        { exact ((hf.comp continuous_fst).prod_mk continuous_snd).continuous_on },
        { exact Œª p hp, e.mem_target.2 hp } }
    end,
  base_set := f ‚Åª¬π' e.base_set,
  source_eq := rfl,
  target_eq := by { ext, simp },
  open_base_set := e.open_base_set.preimage hf,
  proj_to_fun := Œª _ _, rfl }
lemma is_topological_fiber_bundle.comap (h : is_topological_fiber_bundle F proj)
  {f : B' ‚Üí B} (hf : continuous f) :
  is_topological_fiber_bundle F (Œª x : {p : B' √ó Z | f p.1 = proj p.2}, (x : B' √ó Z).1) :=
Œª x, let ‚ü®e, he‚ü© := h (f x) in ‚ü®e.comap f hf x he, he‚ü©
end comap
namespace topological_fiber_bundle.trivialization
lemma is_image_preimage_prod (e : trivialization F proj) (s : set B) :
  e.to_local_homeomorph.is_image (proj ‚Åª¬π' s) (s √óÀ¢ (univ : set F)) :=
Œª x hx, by simp [e.coe_fst', hx]
def restr_open (e : trivialization F proj) (s : set B)
  (hs : is_open s) : trivialization F proj :=
{ to_local_homeomorph := ((e.is_image_preimage_prod s).symm.restr
    (is_open.inter e.open_target (hs.prod is_open_univ))).symm,
  base_set := e.base_set ‚à© s,
  open_base_set := is_open.inter e.open_base_set hs,
  source_eq := by simp [e.source_eq],
  target_eq := by simp [e.target_eq, prod_univ],
  proj_to_fun := Œª p hp, e.proj_to_fun p hp.1 }
section piecewise
lemma frontier_preimage (e : trivialization F proj) (s : set B) :
  e.source ‚à© frontier (proj ‚Åª¬π' s) = proj ‚Åª¬π' (e.base_set ‚à© frontier s) :=
by rw [‚Üê (e.is_image_preimage_prod s).frontier.preimage_eq, frontier_prod_univ_eq,
  (e.is_image_preimage_prod _).preimage_eq, e.source_eq, preimage_inter]
noncomputable def piecewise (e e' : trivialization F proj) (s : set B)
  (Hs : e.base_set ‚à© frontier s = e'.base_set ‚à© frontier s)
  (Heq : eq_on e e' $ proj ‚Åª¬π' (e.base_set ‚à© frontier s)) :
  trivialization F proj :=
{ to_local_homeomorph := e.to_local_homeomorph.piecewise e'.to_local_homeomorph
    (proj ‚Åª¬π' s) (s √óÀ¢ (univ : set F)) (e.is_image_preimage_prod s) (e'.is_image_preimage_prod s)
    (by rw [e.frontier_preimage, e'.frontier_preimage, Hs])
    (by rwa e.frontier_preimage),
  base_set := s.ite e.base_set e'.base_set,
  open_base_set := e.open_base_set.ite e'.open_base_set Hs,
  source_eq := by simp [e.source_eq, e'.source_eq],
  target_eq := by simp [e.target_eq, e'.target_eq, prod_univ],
  proj_to_fun := by rintro p (‚ü®he, hs‚ü©|‚ü®he, hs‚ü©); simp * }
noncomputable def piecewise_le_of_eq [linear_order B] [order_topology B]
  (e e' : trivialization F proj) (a : B) (He : a ‚àà e.base_set) (He' : a ‚àà e'.base_set)
  (Heq : ‚àÄ p, proj p = a ‚Üí e p = e' p) :
  trivialization F proj :=
e.piecewise e' (Iic a)
  (set.ext $ Œª x, and.congr_left_iff.2 $ Œª hx,
    by simp [He, He', mem_singleton_iff.1 (frontier_Iic_subset _ hx)])
  (Œª p hp, Heq p $ frontier_Iic_subset _ hp.2)
noncomputable def piecewise_le [linear_order B] [order_topology B]
  (e e' : trivialization F proj) (a : B) (He : a ‚àà e.base_set) (He' : a ‚àà e'.base_set) :
  trivialization F proj :=
e.piecewise_le_of_eq (e'.trans_fiber_homeomorph (e'.coord_change_homeomorph e He' He))
  a He He' $ by { unfreezingI {rintro p rfl },
    ext1,
    { simp [e.coe_fst', e'.coe_fst', *] },
    { simp [e'.coord_change_apply_snd, *] } }
noncomputable def disjoint_union (e e' : trivialization F proj)
  (H : disjoint e.base_set e'.base_set) :
  trivialization F proj :=
{ to_local_homeomorph := e.to_local_homeomorph.disjoint_union e'.to_local_homeomorph
    (Œª x hx, by { rw [e.source_eq, e'.source_eq] at hx, exact H hx })
    (Œª x hx, by { rw [e.target_eq, e'.target_eq] at hx, exact H ‚ü®hx.1.1, hx.2.1‚ü© }),
  base_set := e.base_set ‚à™ e'.base_set,
  open_base_set := is_open.union e.open_base_set e'.open_base_set,
  source_eq := congr_arg2 (‚à™) e.source_eq e'.source_eq,
  target_eq := (congr_arg2 (‚à™) e.target_eq e'.target_eq).trans union_prod.symm,
  proj_to_fun :=
    begin
      rintro p (hp|hp'),
      { show (e.source.piecewise e e' p).1 = proj p,
        rw [piecewise_eq_of_mem, e.coe_fst]; exact hp },
      { show (e.source.piecewise e e' p).1 = proj p,
        rw [piecewise_eq_of_not_mem, e'.coe_fst hp'],
        simp only [e.source_eq, e'.source_eq] at hp' ‚ä¢,
        exact Œª h, H ‚ü®h, hp'‚ü© }
    end }
lemma _root_.is_topological_fiber_bundle.exists_trivialization_Icc_subset
  [conditionally_complete_linear_order B] [order_topology B]
  (h : is_topological_fiber_bundle F proj) (a b : B) :
  ‚àÉ e : trivialization F proj, Icc a b ‚äÜ e.base_set :=
begin
  classical,
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : trivialization F proj, a ‚àà ea.base_set := h a,
  set s : set B := {x ‚àà Icc a b | ‚àÉ e : trivialization F proj, Icc a x ‚äÜ e.base_set},
  have ha : a ‚àà s, from ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©,
  have sne : s.nonempty := ‚ü®a, ha‚ü©,
  have hsb : b ‚àà upper_bounds s, from Œª x hx, hx.1.2,
  have sbd : bdd_above s := ‚ü®b, hsb‚ü©,
  set c := Sup s,
  have hsc : is_lub s c, from is_lub_cSup sne sbd,
  have hc : c ‚àà Icc a b, from ‚ü®hsc.1 ha, hsc.2 hsb‚ü©,
  obtain ‚ü®-, ec : trivialization F proj, hec : Icc a c ‚äÜ ec.base_set‚ü© : c ‚àà s,
  { cases hc.1.eq_or_lt with heq hlt, { rwa ‚Üê heq },
    refine ‚ü®hc, _‚ü©,
    rcases h c with ‚ü®ec, hc‚ü©,
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.base_set :=
      (mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhds_within_of_mem_nhds $ is_open.mem_nhds ec.open_base_set hc),
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2,
    refine ‚ü®ead.piecewise_le ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 _‚ü©,
    refine ‚ü®Œª x hx, had ‚ü®hx.1.1, hx.2‚ü©, Œª x hx, hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü© },
  cases hc.2.eq_or_lt with heq hlt, { exact ‚ü®ec, heq ‚ñ∏ hec‚ü© },
  suffices : ‚àÉ (d ‚àà Ioc c b) (e : trivialization F proj), Icc a d ‚äÜ e.base_set,
  { rcases this with ‚ü®d, hdcb, hd‚ü©,
    exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim },
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.base_set :=
    (mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhds_within_of_mem_nhds $ is_open.mem_nhds ec.open_base_set (hec ‚ü®hc.1, le_rfl‚ü©)),
  have had : Ico a d ‚äÜ ec.base_set,
    from Ico_subset_Icc_union_Ico.trans (union_subset hec hd),
  by_cases he : disjoint (Iio d) (Ioi c),
    rcases h d with ‚ü®ed, hed‚ü©,
    refine ‚ü®d, hdcb, (ec.restr_open (Iio d) is_open_Iio).disjoint_union
      (ed.restr_open (Ioi c) is_open_Ioi) (he.mono (inter_subset_right _ _)
        (inter_subset_right _ _)), Œª x hx, _‚ü©,
    rcases hx.2.eq_or_lt with rfl|hxd,
    exacts [or.inr ‚ü®hed, hdcb.1‚ü©, or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©] },
    rw [disjoint_left] at he, push_neg at he, rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©,
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü© }
end
end piecewise
end topological_fiber_bundle.trivialization
end topological_fiber_bundle
namespace bundle
variable (E : B ‚Üí Type*)
attribute [mfld_simps] total_space.proj total_space_mk coe_fst coe_snd coe_snd_map_apply
  coe_snd_map_smul total_space.mk_cast
instance [I : topological_space F] : ‚àÄ x : B, topological_space (trivial B F x) := Œª x, I
instance [t‚ÇÅ : topological_space B] [t‚ÇÇ : topological_space F] :
  topological_space (total_space (trivial B F)) :=
induced total_space.proj t‚ÇÅ ‚äì induced (trivial.proj_snd B F) t‚ÇÇ
end bundle
@[nolint has_inhabited_instance]
structure topological_fiber_bundle_core (Œπ : Type*) (B : Type*) [topological_space B]
  (F : Type*) [topological_space F] :=
(base_set          : Œπ ‚Üí set B)
(is_open_base_set  : ‚àÄ i, is_open (base_set i))
(index_at          : B ‚Üí Œπ)
(mem_base_set_at   : ‚àÄ x, x ‚àà base_set (index_at x))
(coord_change      : Œπ ‚Üí Œπ ‚Üí B ‚Üí F ‚Üí F)
(coord_change_self : ‚àÄ i, ‚àÄ x ‚àà base_set i, ‚àÄ v, coord_change i i x v = v)
(coord_change_continuous : ‚àÄ i j, continuous_on (Œªp : B √ó F, coord_change i j p.1 p.2)
                                               (((base_set i) ‚à© (base_set j)) √óÀ¢ (univ : set F)))
(coord_change_comp : ‚àÄ i j k, ‚àÄ x ‚àà (base_set i) ‚à© (base_set j) ‚à© (base_set k), ‚àÄ v,
  (coord_change j k x) (coord_change i j x v) = coord_change i k x v)
namespace topological_fiber_bundle_core
variables [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Œπ B F)
include Z
@[nolint unused_arguments has_inhabited_instance]
def index := Œπ
@[nolint unused_arguments, reducible]
def base := B
@[nolint unused_arguments has_inhabited_instance]
def fiber (x : B) := F
section fiber_instances
local attribute [reducible] fiber
instance topological_space_fiber (x : B) : topological_space (Z.fiber x) := by apply_instance
end fiber_instances
@[nolint unused_arguments, reducible]
def total_space := bundle.total_space Z.fiber
@[reducible, simp, mfld_simps] def proj : Z.total_space ‚Üí B := bundle.total_space.proj
def triv_change (i j : Œπ) : local_homeomorph (B √ó F) (B √ó F) :=
{ source      := (Z.base_set i ‚à© Z.base_set j) √óÀ¢ (univ : set F),
  target      := (Z.base_set i ‚à© Z.base_set j) √óÀ¢ (univ : set F),
  to_fun      := Œªp, ‚ü®p.1, Z.coord_change i j p.1 p.2‚ü©,
  inv_fun     := Œªp, ‚ü®p.1, Z.coord_change j i p.1 p.2‚ü©,
  map_source' := Œªp hp, by simpa using hp,
  map_target' := Œªp hp, by simpa using hp,
  left_inv'   := begin
    rintros ‚ü®x, v‚ü© hx,
    simp only [prod_mk_mem_set_prod_eq, mem_inter_eq, and_true, mem_univ] at hx,
    rw [Z.coord_change_comp, Z.coord_change_self],
    { exact hx.1 },
    { simp [hx] }
  end,
  right_inv'  := begin
    rintros ‚ü®x, v‚ü© hx,
    simp only [prod_mk_mem_set_prod_eq, mem_inter_eq, and_true, mem_univ] at hx,
    rw [Z.coord_change_comp, Z.coord_change_self],
    { exact hx.2 },
    { simp [hx] },
  end,
  open_source :=
    (is_open.inter (Z.is_open_base_set i) (Z.is_open_base_set j)).prod is_open_univ,
  open_target :=
    (is_open.inter (Z.is_open_base_set i) (Z.is_open_base_set j)).prod is_open_univ,
  continuous_to_fun  :=
    continuous_on.prod continuous_fst.continuous_on (Z.coord_change_continuous i j),
  continuous_inv_fun := by simpa [inter_comm]
    using continuous_on.prod continuous_fst.continuous_on (Z.coord_change_continuous j i) }
@[simp, mfld_simps] lemma mem_triv_change_source (i j : Œπ) (p : B √ó F) :
  p ‚àà (Z.triv_change i j).source ‚Üî p.1 ‚àà Z.base_set i ‚à© Z.base_set j :=
by { erw [mem_prod], simp }
def local_triv_as_local_equiv (i : Œπ) : local_equiv Z.total_space (B √ó F) :=
{ source      := Z.proj ‚Åª¬π' (Z.base_set i),
  target      := Z.base_set i √óÀ¢ (univ : set F),
  inv_fun     := Œªp, ‚ü®p.1, Z.coord_change i (Z.index_at p.1) p.1 p.2‚ü©,
  to_fun      := Œªp, ‚ü®p.1, Z.coord_change (Z.index_at p.1) i p.1 p.2‚ü©,
  map_source' := Œªp hp,
    by simpa only [set.mem_preimage, and_true, set.mem_univ, set.prod_mk_mem_set_prod_eq] using hp,
  map_target' := Œªp hp,
    by simpa only [set.mem_preimage, and_true, set.mem_univ, set.mem_prod] using hp,
  left_inv'   := begin
    rintros ‚ü®x, v‚ü© hx,
    change x ‚àà Z.base_set i at hx,
    dsimp only,
    rw [Z.coord_change_comp, Z.coord_change_self],
    { exact Z.mem_base_set_at _ },
    { simp only [hx, mem_inter_eq, and_self, mem_base_set_at] }
  end,
  right_inv' := begin
    rintros ‚ü®x, v‚ü© hx,
    simp only [prod_mk_mem_set_prod_eq, and_true, mem_univ] at hx,
    rw [Z.coord_change_comp, Z.coord_change_self],
    { exact hx },
    { simp only [hx, mem_inter_eq, and_self, mem_base_set_at] }
  end }
variable (i : Œπ)
lemma mem_local_triv_as_local_equiv_source (p : Z.total_space) :
  p ‚àà (Z.local_triv_as_local_equiv i).source ‚Üî p.1 ‚àà Z.base_set i :=
iff.rfl
lemma mem_local_triv_as_local_equiv_target (p : B √ó F) :
  p ‚àà (Z.local_triv_as_local_equiv i).target ‚Üî p.1 ‚àà Z.base_set i :=
by { erw [mem_prod], simp only [and_true, mem_univ] }
lemma local_triv_as_local_equiv_apply (p : Z.total_space) :
  (Z.local_triv_as_local_equiv i) p = ‚ü®p.1, Z.coord_change (Z.index_at p.1) i p.1 p.2‚ü© := rfl
lemma local_triv_as_local_equiv_trans (i j : Œπ) :
  (Z.local_triv_as_local_equiv i).symm.trans
    (Z.local_triv_as_local_equiv j) ‚âà (Z.triv_change i j).to_local_equiv :=
begin
  split,
  { ext x, simp only [mem_local_triv_as_local_equiv_target] with mfld_simps, refl, },
  { rintros ‚ü®x, v‚ü© hx,
    simp only [triv_change, local_triv_as_local_equiv, local_equiv.symm, true_and, prod.mk.inj_iff,
      prod_mk_mem_set_prod_eq, local_equiv.trans_source, mem_inter_eq, and_true, mem_preimage, proj,
      mem_univ, local_equiv.coe_mk, eq_self_iff_true, local_equiv.coe_trans,
      total_space.proj] at hx ‚ä¢,
    simp only [Z.coord_change_comp, hx, mem_inter_eq, and_self, mem_base_set_at], }
end
variable (Œπ)
instance to_topological_space : topological_space (bundle.total_space Z.fiber) :=
topological_space.generate_from $ ‚ãÉ (i : Œπ) (s : set (B √ó F)) (s_open : is_open s),
  {(Z.local_triv_as_local_equiv i).source ‚à© (Z.local_triv_as_local_equiv i) ‚Åª¬π' s}
variable {Œπ}
lemma open_source' (i : Œπ) : is_open (Z.local_triv_as_local_equiv i).source :=
begin
  apply topological_space.generate_open.basic,
  simp only [exists_prop, mem_Union, mem_singleton_iff],
  refine ‚ü®i, Z.base_set i √óÀ¢ (univ : set F), (Z.is_open_base_set i).prod is_open_univ, _‚ü©,
  ext p,
  simp only [local_triv_as_local_equiv_apply, prod_mk_mem_set_prod_eq, mem_inter_eq, and_self,
    mem_local_triv_as_local_equiv_source, and_true, mem_univ, mem_preimage],
end
open topological_fiber_bundle
def local_triv (i : Œπ) : trivialization F Z.proj :=
{ base_set      := Z.base_set i,
  open_base_set := Z.is_open_base_set i,
  source_eq     := rfl,
  target_eq     := rfl,
  proj_to_fun   := Œª p hp, by { simp only with mfld_simps, refl },
  open_source := Z.open_source' i,
  open_target := (Z.is_open_base_set i).prod is_open_univ,
  continuous_to_fun := begin
    rw continuous_on_open_iff (Z.open_source' i),
    assume s s_open,
    apply topological_space.generate_open.basic,
    simp only [exists_prop, mem_Union, mem_singleton_iff],
    exact ‚ü®i, s, s_open, rfl‚ü©
  end,
  continuous_inv_fun := begin
    apply continuous_on_open_of_generate_from ((Z.is_open_base_set i).prod is_open_univ),
    assume t ht,
    simp only [exists_prop, mem_Union, mem_singleton_iff] at ht,
    obtain ‚ü®j, s, s_open, ts‚ü© : ‚àÉ j s, is_open s ‚àß t =
      (local_triv_as_local_equiv Z j).source ‚à© (local_triv_as_local_equiv Z j) ‚Åª¬π' s := ht,
    rw ts,
    simp only [local_equiv.right_inv, preimage_inter, local_equiv.left_inv],
    let e := Z.local_triv_as_local_equiv i,
    let e' := Z.local_triv_as_local_equiv j,
    let f := e.symm.trans e',
    have : is_open (f.source ‚à© f ‚Åª¬π' s),
    { rw [(Z.local_triv_as_local_equiv_trans i j).source_inter_preimage_eq],
      exact (continuous_on_open_iff (Z.triv_change i j).open_source).1
        ((Z.triv_change i j).continuous_on) _ s_open },
    convert this using 1,
    dsimp [local_equiv.trans_source],
    rw [‚Üê preimage_comp, inter_assoc],
    refl,
  end,
  to_local_equiv := Z.local_triv_as_local_equiv i }
protected theorem is_topological_fiber_bundle : is_topological_fiber_bundle F Z.proj :=
Œªx, ‚ü®Z.local_triv (Z.index_at x), Z.mem_base_set_at x‚ü©
lemma continuous_proj : continuous Z.proj :=
Z.is_topological_fiber_bundle.continuous_proj
lemma is_open_map_proj : is_open_map Z.proj :=
Z.is_topological_fiber_bundle.is_open_map_proj
def local_triv_at (b : B) : trivialization F Z.proj :=
Z.local_triv (Z.index_at b)
@[simp, mfld_simps] lemma local_triv_at_def (b : B) :
  Z.local_triv (Z.index_at b) = Z.local_triv_at b := rfl
lemma continuous_const_section (v : F)
  (h : ‚àÄ i j, ‚àÄ x ‚àà (Z.base_set i) ‚à© (Z.base_set j), Z.coord_change i j x v = v) :
  continuous (show B ‚Üí Z.total_space, from Œª x, ‚ü®x, v‚ü©) :=
begin
  apply continuous_iff_continuous_at.2 (Œª x, _),
  have A : Z.base_set (Z.index_at x) ‚àà ùìù x :=
    is_open.mem_nhds (Z.is_open_base_set (Z.index_at x)) (Z.mem_base_set_at x),
  apply ((Z.local_triv_at x).to_local_homeomorph.continuous_at_iff_continuous_at_comp_left _).2,
  { simp only [(‚àò)] with mfld_simps,
    apply continuous_at_id.prod,
    have : continuous_on (Œª (y : B), v) (Z.base_set (Z.index_at x)) := continuous_on_const,
    apply (this.congr _).continuous_at A,
    assume y hy,
    simp only [h, hy, mem_base_set_at] with mfld_simps },
  { exact A }
end
@[simp, mfld_simps] lemma local_triv_as_local_equiv_coe :
  ‚áë(Z.local_triv_as_local_equiv i) = Z.local_triv i := rfl
@[simp, mfld_simps] lemma local_triv_as_local_equiv_source :
  (Z.local_triv_as_local_equiv i).source = (Z.local_triv i).source := rfl
@[simp, mfld_simps] lemma local_triv_as_local_equiv_target :
  (Z.local_triv_as_local_equiv i).target = (Z.local_triv i).target := rfl
@[simp, mfld_simps] lemma local_triv_as_local_equiv_symm :
  (Z.local_triv_as_local_equiv i).symm = (Z.local_triv i).to_local_equiv.symm := rfl
@[simp, mfld_simps] lemma base_set_at : Z.base_set i = (Z.local_triv i).base_set := rfl
@[simp, mfld_simps] lemma local_triv_apply (p : Z.total_space) :
  (Z.local_triv i) p = ‚ü®p.1, Z.coord_change (Z.index_at p.1) i p.1 p.2‚ü© := rfl
@[simp, mfld_simps] lemma local_triv_at_apply (p : Z.total_space) :
  ((Z.local_triv_at p.1) p) = ‚ü®p.1, p.2‚ü© :=
by { rw [local_triv_at, local_triv_apply, coord_change_self], exact Z.mem_base_set_at p.1 }
@[simp, mfld_simps] lemma local_triv_at_apply_mk (b : B) (a : F) :
  ((Z.local_triv_at b) ‚ü®b, a‚ü©) = ‚ü®b, a‚ü© :=
Z.local_triv_at_apply _
@[simp, mfld_simps] lemma mem_local_triv_source (p : Z.total_space) :
  p ‚àà (Z.local_triv i).source ‚Üî p.1 ‚àà (Z.local_triv i).base_set := iff.rfl
@[simp, mfld_simps] lemma mem_local_triv_at_source (p : Z.total_space) (b : B) :
  p ‚àà (Z.local_triv_at b).source ‚Üî p.1 ‚àà (Z.local_triv_at b).base_set := iff.rfl
@[simp, mfld_simps] lemma mem_local_triv_target (p : B √ó F) :
  p ‚àà (Z.local_triv i).target ‚Üî p.1 ‚àà (Z.local_triv i).base_set :=
trivialization.mem_target _
@[simp, mfld_simps] lemma mem_local_triv_at_target (p : B √ó F) (b : B) :
  p ‚àà (Z.local_triv_at b).target ‚Üî p.1 ‚àà (Z.local_triv_at b).base_set :=
trivialization.mem_target _
@[simp, mfld_simps] lemma local_triv_symm_apply (p : B √ó F) :
  (Z.local_triv i).to_local_homeomorph.symm p =
    ‚ü®p.1, Z.coord_change i (Z.index_at p.1) p.1 p.2‚ü© := rfl
@[simp, mfld_simps] lemma mem_local_triv_at_base_set (b : B) :
  b ‚àà (Z.local_triv_at b).base_set :=
by { rw [local_triv_at, ‚Üêbase_set_at], exact Z.mem_base_set_at b, }
@[continuity]
lemma continuous_total_space_mk (b : B) :
  continuous (total_space_mk b : Z.fiber b ‚Üí bundle.total_space Z.fiber) :=
begin
  rw [continuous_iff_le_induced, topological_fiber_bundle_core.to_topological_space],
  apply le_induced_generate_from,
  simp only [total_space_mk, mem_Union, mem_singleton_iff, local_triv_as_local_equiv_source,
    local_triv_as_local_equiv_coe],
  rintros s ‚ü®i, t, ht, rfl‚ü©,
  rw [‚Üê((Z.local_triv i).source_inter_preimage_target_inter t), preimage_inter, ‚Üêpreimage_comp,
    trivialization.source_eq],
  apply is_open.inter,
  { simp only [total_space.proj, proj, ‚Üêpreimage_comp],
    by_cases (b ‚àà (Z.local_triv i).base_set),
    { rw preimage_const_of_mem h, exact is_open_univ, },
    { rw preimage_const_of_not_mem h, exact is_open_empty, }},
  { simp only [function.comp, local_triv_apply],
    rw [preimage_inter, preimage_comp],
    by_cases (b ‚àà Z.base_set i),
    { have hc : continuous (Œª (x : Z.fiber b), (Z.coord_change (Z.index_at b) i b) x),
        from (Z.coord_change_continuous (Z.index_at b) i).comp_continuous
          (continuous_const.prod_mk continuous_id) (Œª x, ‚ü®‚ü®Z.mem_base_set_at b, h‚ü©, mem_univ x‚ü©),
      exact (((Z.local_triv i).open_target.inter ht).preimage (continuous.prod.mk b)).preimage hc },
    { rw [(Z.local_triv i).target_eq, ‚Üêbase_set_at, mk_preimage_prod_right_eq_empty h,
        preimage_empty, empty_inter],
      exact is_open_empty, }}
end
end topological_fiber_bundle_core
variables (F) {Z : Type*} [topological_space B] [topological_space F] {proj : Z ‚Üí B}
open topological_fiber_bundle
@[nolint has_inhabited_instance]
structure topological_fiber_prebundle (proj : Z ‚Üí B) :=
(pretrivialization_atlas : set (pretrivialization F proj))
(pretrivialization_at : B ‚Üí pretrivialization F proj)
(mem_base_pretrivialization_at : ‚àÄ x : B, x ‚àà (pretrivialization_at x).base_set)
(pretrivialization_mem_atlas : ‚àÄ x : B, pretrivialization_at x ‚àà pretrivialization_atlas)
(continuous_triv_change : ‚àÄ e e' ‚àà pretrivialization_atlas,
  continuous_on (e ‚àò e'.to_local_equiv.symm) (e'.target ‚à© (e'.to_local_equiv.symm ‚Åª¬π' e.source)))
namespace topological_fiber_prebundle
variables {F} (a : topological_fiber_prebundle F proj) {e : pretrivialization F proj}
def total_space_topology (a : topological_fiber_prebundle F proj) : topological_space Z :=
‚®Ü (e : pretrivialization F proj) (he : e ‚àà a.pretrivialization_atlas),
  coinduced e.set_symm (subtype.topological_space)
lemma continuous_symm_of_mem_pretrivialization_atlas (he : e ‚àà a.pretrivialization_atlas) :
  @continuous_on _ _ _ a.total_space_topology
  e.to_local_equiv.symm e.target :=
begin
  refine id (Œª z H, id (Œª U h, preimage_nhds_within_coinduced' H
    e.open_target (le_def.1 (nhds_mono _) U h))),
  exact le_supr‚ÇÇ e he,
end
lemma is_open_source (e : pretrivialization F proj) : @is_open _ a.total_space_topology e.source :=
begin
  letI := a.total_space_topology,
  refine is_open_supr_iff.mpr (Œª e', _),
  refine is_open_supr_iff.mpr (Œª he', _),
  refine is_open_coinduced.mpr (is_open_induced_iff.mpr ‚ü®e.target, e.open_target, _‚ü©),
  rw [pretrivialization.set_symm, restrict, e.target_eq,
    e.source_eq, preimage_comp, subtype.preimage_coe_eq_preimage_coe_iff,
    e'.target_eq, prod_inter_prod, inter_univ,
    pretrivialization.preimage_symm_proj_inter],
end
lemma is_open_target_of_mem_pretrivialization_atlas_inter (e e' : pretrivialization F proj)
  (he' : e' ‚àà a.pretrivialization_atlas) :
  is_open (e'.to_local_equiv.target ‚à© e'.to_local_equiv.symm ‚Åª¬π' e.source) :=
begin
  letI := a.total_space_topology,
  obtain ‚ü®u, hu1, hu2‚ü© := continuous_on_iff'.mp (a.continuous_symm_of_mem_pretrivialization_atlas
    he') e.source (a.is_open_source e),
  rw [inter_comm, hu2],
  exact hu1.inter e'.open_target,
end
def trivialization_of_mem_pretrivialization_atlas (he : e ‚àà a.pretrivialization_atlas) :
  @trivialization B F Z _ _ a.total_space_topology proj :=
{ open_source := a.is_open_source e,
  continuous_to_fun := begin
    letI := a.total_space_topology,
    refine continuous_on_iff'.mpr (Œª s hs, ‚ü®e ‚Åª¬π' s ‚à© e.source, (is_open_supr_iff.mpr (Œª e', _)),
      by { rw [inter_assoc, inter_self], refl }‚ü©),
    refine (is_open_supr_iff.mpr (Œª he', _)),
    rw [is_open_coinduced, is_open_induced_iff],
    obtain ‚ü®u, hu1, hu2‚ü© := continuous_on_iff'.mp (a.continuous_triv_change _ he _ he') s hs,
    have hu3 := congr_arg (Œª s, (Œª x : e'.target, (x : B √ó F)) ‚Åª¬π' s) hu2,
    simp only [subtype.coe_preimage_self, preimage_inter, univ_inter] at hu3,
    refine ‚ü®u ‚à© e'.to_local_equiv.target ‚à©
      (e'.to_local_equiv.symm ‚Åª¬π' e.source), _, by
      { simp only [preimage_inter, inter_univ, subtype.coe_preimage_self, hu3.symm], refl }‚ü©,
    rw inter_assoc,
    exact hu1.inter (a.is_open_target_of_mem_pretrivialization_atlas_inter e e' he'),
  end,
  continuous_inv_fun := a.continuous_symm_of_mem_pretrivialization_atlas he,
  .. e }
lemma is_topological_fiber_bundle :
  @is_topological_fiber_bundle B F Z _ _ a.total_space_topology proj :=
Œª x, ‚ü®a.trivialization_of_mem_pretrivialization_atlas (a.pretrivialization_mem_atlas x),
  a.mem_base_pretrivialization_at x ‚ü©
lemma continuous_proj : @continuous _ _ a.total_space_topology _ proj :=
by { letI := a.total_space_topology, exact a.is_topological_fiber_bundle.continuous_proj, }
lemma continuous_on_of_comp_right {X : Type*} [topological_space X] {f : Z ‚Üí X} {s : set B}
  (hs : is_open s)
  (hf : ‚àÄ b ‚àà s, continuous_on (f ‚àò (a.pretrivialization_at b).to_local_equiv.symm)
    ((s ‚à© (a.pretrivialization_at b).base_set) √óÀ¢ (set.univ : set F))) :
  @continuous_on _ _ a.total_space_topology _ f (proj ‚Åª¬π' s) :=
begin
  letI := a.total_space_topology,
  intros z hz,
  let e : trivialization F proj :=
  a.trivialization_of_mem_pretrivialization_atlas (a.pretrivialization_mem_atlas (proj z)),
  refine (e.continuous_at_of_comp_right _
    ((hf (proj z) hz).continuous_at (is_open.mem_nhds _ _))).continuous_within_at,
  { exact a.mem_base_pretrivialization_at (proj z) },
  { exact ((hs.inter (a.pretrivialization_at (proj z)).open_base_set).prod is_open_univ) },
  refine ‚ü®_, mem_univ _‚ü©,
  rw e.coe_fst,
  { exact ‚ü®hz, a.mem_base_pretrivialization_at (proj z)‚ü© },
  { rw e.mem_source,
    exact a.mem_base_pretrivialization_at (proj z) },
end
end topological_fiber_prebundle
