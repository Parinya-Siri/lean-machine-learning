import analysis.convex.cone
import analysis.convex.gauge
open set
open_locale pointwise
variables {ğ•œ E : Type*}
lemma separate_convex_open_set [semi_normed_group E] [normed_space â„ E] {s : set E}
  (hsâ‚€ : (0 : E) âˆˆ s) (hsâ‚ : convex â„ s) (hsâ‚‚ : is_open s) {xâ‚€ : E} (hxâ‚€ : xâ‚€ âˆ‰ s) :
  âˆƒ f : E â†’L[â„] â„, f xâ‚€ = 1 âˆ§ âˆ€ x âˆˆ s, f x < 1 :=
begin
  let f : linear_pmap â„ E â„ :=
    linear_pmap.mk_span_singleton xâ‚€ 1 (ne_of_mem_of_not_mem hsâ‚€ hxâ‚€).symm,
  obtain âŸ¨r, hr, hrsâŸ© := metric.mem_nhds_iff.1
    (filter.inter_mem (hsâ‚‚.mem_nhds hsâ‚€) $ hsâ‚‚.neg.mem_nhds $ by rwa [mem_neg, neg_zero]),
  obtain âŸ¨Ï†, hÏ†â‚, hÏ†â‚‚âŸ© := exists_extension_of_le_sublinear f (gauge s)
    (Î» c hc, gauge_smul_of_nonneg hc.le)
    (gauge_add_le hsâ‚ $ absorbent_nhds_zero $ hsâ‚‚.mem_nhds hsâ‚€) _,
  { refine âŸ¨Ï†.mk_continuous (râ»Â¹) $ Î» x, _, _, _âŸ©,
    { rw [real.norm_eq_abs, abs_le, neg_le, â†linear_map.map_neg],
      nth_rewrite 0 â†norm_neg x,
      suffices : âˆ€ x, Ï† x â‰¤ râ»Â¹ * âˆ¥xâˆ¥,
      { exact âŸ¨this _, this _âŸ© },
      refine Î» x, (hÏ†â‚‚ _).trans _,
      rw [â†div_eq_inv_mul, â†gauge_ball hr],
      exact gauge_mono (absorbent_ball_zero hr) (hrs.trans $ inter_subset_left _ _) x },
    { dsimp,
      rw [â†submodule.coe_mk xâ‚€ (submodule.mem_span_singleton_self _), hÏ†â‚,
        linear_pmap.mk_span_singleton'_apply_self] },
    { exact Î» x hx, (hÏ†â‚‚ x).trans_lt (gauge_lt_one_of_mem_of_open hsâ‚ hsâ‚€ hsâ‚‚ hx) } },
  rintro âŸ¨x, hxâŸ©,
  obtain âŸ¨y, rflâŸ© := submodule.mem_span_singleton.1 hx,
  rw linear_pmap.mk_span_singleton'_apply,
  simp only [mul_one, algebra.id.smul_eq_mul, submodule.coe_mk],
  obtain h | h := le_or_lt y 0,
  { exact h.trans (gauge_nonneg _) },
  { rw [gauge_smul_of_nonneg h.le, smul_eq_mul, le_mul_iff_one_le_right h],
    exact one_le_gauge_of_not_mem (hsâ‚.star_convex hsâ‚€)
      ((absorbent_ball_zero hr).subset $ hrs.trans $ inter_subset_left _ _).absorbs hxâ‚€,
    apply_instance }
end
variables [normed_group E] [normed_space â„ E] {s t : set E} {x y : E}
theorem geometric_hahn_banach_open (hsâ‚ : convex â„ s) (hsâ‚‚ : is_open s) (ht : convex â„ t)
  (disj : disjoint s t) :
  âˆƒ (f : E â†’L[â„] â„) (u : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ âˆ€ b âˆˆ t, u â‰¤ f b :=
begin
  obtain rfl | âŸ¨aâ‚€, haâ‚€âŸ© := s.eq_empty_or_nonempty,
  { exact âŸ¨0, 0, by simp, Î» b hb, le_rflâŸ© },
  obtain rfl | âŸ¨bâ‚€, hbâ‚€âŸ© := t.eq_empty_or_nonempty,
  { exact âŸ¨0, 1, Î» a ha, zero_lt_one, by simpâŸ© },
  let xâ‚€ := bâ‚€ - aâ‚€,
  let C := xâ‚€ +áµ¥ (s - t),
  have : (0:E) âˆˆ C := âŸ¨aâ‚€ - bâ‚€, sub_mem_sub haâ‚€ hbâ‚€,
    by rw [vadd_eq_add, sub_add_sub_cancel', sub_self]âŸ©,
  have : convex â„ C := (hsâ‚.sub ht).vadd _,
  have : xâ‚€ âˆ‰ C,
  { intro hxâ‚€,
    rw â†add_zero xâ‚€ at hxâ‚€,
    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hxâ‚€) },
  obtain âŸ¨f, hfâ‚, hfâ‚‚âŸ© := separate_convex_open_set â€¹0 âˆˆ Câ€º â€¹_â€º (hsâ‚‚.sub_right.vadd _) â€¹xâ‚€ âˆ‰ Câ€º,
  have : f bâ‚€ = f aâ‚€ + 1 := by simp [â†hfâ‚],
  have forall_le : âˆ€ (a âˆˆ s) (b âˆˆ t), f a â‰¤ f b,
  { intros a ha b hb,
    have := hfâ‚‚ (xâ‚€ + (a - b)) (vadd_mem_vadd_set $ sub_mem_sub ha hb),
    simp only [f.map_add, f.map_sub, hfâ‚] at this,
    linarith },
  refine âŸ¨f, Inf (f '' t), image_subset_iff.1 (_ : f '' s âŠ† Iio (Inf (f '' t))), Î» b hb, _âŸ©,
  { rw â†interior_Iic,
    refine interior_maximal (image_subset_iff.2 $ Î» a ha, _) (f.is_open_map_of_ne_zero _ _ hsâ‚‚),
    { exact le_cInf (nonempty.image _ âŸ¨_, hbâ‚€âŸ©) (ball_image_of_ball $ forall_le _ ha) },
    { rintro rfl,
      simpa using hfâ‚ } },
  { exact cInf_le âŸ¨f aâ‚€, ball_image_of_ball $ forall_le _ haâ‚€âŸ© (mem_image_of_mem _ hb) }
end
theorem geometric_hahn_banach_open_point (hsâ‚ : convex â„ s) (hsâ‚‚ : is_open s) (disj : x âˆ‰ s) :
  âˆƒ f : E â†’L[â„] â„, âˆ€ a âˆˆ s, f a < f x :=
let âŸ¨f, s, hs, hxâŸ© := geometric_hahn_banach_open hsâ‚ hsâ‚‚ (convex_singleton x)
  (disjoint_singleton_right.2 disj)
  in âŸ¨f, Î» a ha, lt_of_lt_of_le (hs a ha) (hx x (mem_singleton _))âŸ©
theorem geometric_hahn_banach_point_open (htâ‚ : convex â„ t) (htâ‚‚ : is_open t) (disj : x âˆ‰ t) :
  âˆƒ f : E â†’L[â„] â„, âˆ€ b âˆˆ t, f x < f b :=
let âŸ¨f, hfâŸ© := geometric_hahn_banach_open_point htâ‚ htâ‚‚ disj in âŸ¨-f, by simpaâŸ©
theorem geometric_hahn_banach_open_open (hsâ‚ : convex â„ s) (hsâ‚‚ : is_open s) (htâ‚ : convex â„ t)
  (htâ‚ƒ : is_open t) (disj : disjoint s t) :
  âˆƒ (f : E â†’L[â„] â„) (u : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ âˆ€ b âˆˆ t, u < f b :=
begin
  obtain (rfl | âŸ¨aâ‚€, haâ‚€âŸ©) := s.eq_empty_or_nonempty,
  { exact âŸ¨0, -1, by simp, Î» b hb, by norm_numâŸ© },
  obtain (rfl | âŸ¨bâ‚€, hbâ‚€âŸ©) := t.eq_empty_or_nonempty,
  { exact âŸ¨0, 1, Î» a ha, by norm_num, by simpâŸ© },
  obtain âŸ¨f, s, hfâ‚, hfâ‚‚âŸ© := geometric_hahn_banach_open hsâ‚ hsâ‚‚ htâ‚ disj,
  have hf : is_open_map f,
  { refine f.is_open_map_of_ne_zero _,
    rintro rfl,
    exact (hfâ‚ _ haâ‚€).not_le (hfâ‚‚ _ hbâ‚€) },
  refine âŸ¨f, s, hfâ‚, image_subset_iff.1 (_ : f '' t âŠ† Ioi s)âŸ©,
  rw â†interior_Ici,
  refine interior_maximal (image_subset_iff.2 hfâ‚‚) (f.is_open_map_of_ne_zero _ _ htâ‚ƒ),
  rintro rfl,
  exact (hfâ‚ _ haâ‚€).not_le (hfâ‚‚ _ hbâ‚€),
end
theorem geometric_hahn_banach_compact_closed (hsâ‚ : convex â„ s) (hsâ‚‚ : is_compact s)
  (htâ‚ : convex â„ t) (htâ‚‚ : is_closed t) (disj : disjoint s t) :
  âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ u < v âˆ§ âˆ€ b âˆˆ t, v < f b :=
begin
  obtain rfl | hs := s.eq_empty_or_nonempty,
  { exact âŸ¨0, -2, -1, by simp, by norm_num, Î» b hb, by norm_numâŸ© },
  unfreezingI { obtain rfl | ht := t.eq_empty_or_nonempty },
  { exact âŸ¨0, 1, 2, Î» a ha, by norm_num, by norm_num, by simpâŸ© },
  obtain âŸ¨U, V, hU, hV, hUâ‚, hVâ‚, sU, tV, disj'âŸ© := disj.exists_open_convexes hsâ‚ hsâ‚‚ htâ‚ htâ‚‚,
  obtain âŸ¨f, u, hfâ‚, hfâ‚‚âŸ© := geometric_hahn_banach_open_open hUâ‚ hU hVâ‚ hV disj',
  obtain âŸ¨x, hxâ‚, hxâ‚‚âŸ© := hsâ‚‚.exists_forall_ge hs f.continuous.continuous_on,
  have : f x < u := hfâ‚ x (sU hxâ‚),
  exact âŸ¨f, (f x + u)/2, u, Î» a ha, by linarith [hxâ‚‚ a ha], by linarith, Î» b hb, hfâ‚‚ b (tV hb)âŸ©,
end
theorem geometric_hahn_banach_closed_compact (hsâ‚ : convex â„ s) (hsâ‚‚ : is_closed s)
  (htâ‚ : convex â„ t) (htâ‚‚ : is_compact t) (disj : disjoint s t) :
  âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ u < v âˆ§ âˆ€ b âˆˆ t, v < f b :=
let âŸ¨f, s, t, hs, st, htâŸ© := geometric_hahn_banach_compact_closed htâ‚ htâ‚‚ hsâ‚ hsâ‚‚ disj.symm in
âŸ¨-f, -t, -s, by simpa using ht, by simpa using st, by simpa using hsâŸ©
theorem geometric_hahn_banach_point_closed (htâ‚ : convex â„ t) (htâ‚‚ : is_closed t) (disj : x âˆ‰ t) :
  âˆƒ (f : E â†’L[â„] â„) (u : â„), f x < u âˆ§ âˆ€ b âˆˆ t, u < f b :=
let âŸ¨f, u, v, ha, hst, hbâŸ© := geometric_hahn_banach_compact_closed (convex_singleton x)
  is_compact_singleton htâ‚ htâ‚‚ (disjoint_singleton_left.2 disj)
  in âŸ¨f, v, hst.trans' $ ha x $ mem_singleton _, hbâŸ©
theorem geometric_hahn_banach_closed_point (hsâ‚ : convex â„ s) (hsâ‚‚ : is_closed s) (disj : x âˆ‰ s) :
  âˆƒ (f : E â†’L[â„] â„) (u : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ u < f x :=
let âŸ¨f, s, t, ha, hst, hbâŸ© := geometric_hahn_banach_closed_compact hsâ‚ hsâ‚‚ (convex_singleton x)
  is_compact_singleton (disjoint_singleton_right.2 disj)
  in âŸ¨f, s, ha, hst.trans $ hb x $ mem_singleton _âŸ©
theorem geometric_hahn_banach_point_point (hxy : x â‰  y) : âˆƒ (f : E â†’L[â„] â„), f x < f y :=
begin
  obtain âŸ¨f, s, t, hs, st, htâŸ© :=
    geometric_hahn_banach_compact_closed (convex_singleton x) is_compact_singleton
      (convex_singleton y) is_closed_singleton (disjoint_singleton.2 hxy),
  exact âŸ¨f, by linarith [hs x rfl, ht y rfl]âŸ©,
end
lemma Inter_halfspaces_eq (hsâ‚ : convex â„ s) (hsâ‚‚ : is_closed s) :
  (â‹‚ (l : E â†’L[â„] â„), {x | âˆƒ y âˆˆ s, l x â‰¤ l y}) = s :=
begin
  rw set.Inter_set_of,
  refine set.subset.antisymm (Î» x hx, _) (Î» x hx l, âŸ¨x, hx, le_rflâŸ©),
  by_contra,
  obtain âŸ¨l, s, hlA, hlâŸ© := geometric_hahn_banach_closed_point hsâ‚ hsâ‚‚ h,
  obtain âŸ¨y, hy, hxyâŸ© := hx l,
  exact ((hxy.trans_lt (hlA y hy)).trans hl).not_le le_rfl,
end
