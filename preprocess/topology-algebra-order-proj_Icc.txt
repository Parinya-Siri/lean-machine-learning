import data.set.intervals.proj_Icc
import topology.algebra.order.basic
open set filter
open_locale filter topological_space
variables {Î± Î² Î³ : Type*} [linear_order Î±] [topological_space Î³] {a b c : Î±} {h : a â‰¤ b}
lemma filter.tendsto.Icc_extend (f : Î³ â†’ Icc a b â†’ Î²) {z : Î³} {l : filter Î±} {l' : filter Î²}
  (hf : tendsto â†¿f (ğ“ z Ã—á¶  l.map (proj_Icc a b h)) l') :
  tendsto â†¿(Icc_extend h âˆ˜ f) (ğ“ z Ã—á¶  l) l' :=
show tendsto (â†¿f âˆ˜ prod.map id (proj_Icc a b h)) (ğ“ z Ã—á¶  l) l', from
hf.comp $ tendsto_id.prod_map tendsto_map
variables [topological_space Î±] [order_topology Î±] [topological_space Î²]
@[continuity]
lemma continuous_proj_Icc : continuous (proj_Icc a b h) :=
continuous_subtype_mk _ $ continuous_const.max $ continuous_const.min continuous_id
lemma quotient_map_proj_Icc : quotient_map (proj_Icc a b h) :=
quotient_map_iff.2 âŸ¨proj_Icc_surjective h, Î» s,
  âŸ¨Î» hs, hs.preimage continuous_proj_Icc,
   Î» hs, âŸ¨_, hs, by { ext, simp }âŸ©âŸ©âŸ©
@[simp] lemma continuous_Icc_extend_iff {f : Icc a b â†’ Î²} :
  continuous (Icc_extend h f) â†” continuous f :=
quotient_map_proj_Icc.continuous_iff.symm
lemma continuous.Icc_extend {f : Î³ â†’ Icc a b â†’ Î²} {g : Î³ â†’ Î±}
  (hf : continuous â†¿f) (hg : continuous g) : continuous (Î» a, Icc_extend h (f a) (g a)) :=
hf.comp $ continuous_id.prod_mk $ continuous_proj_Icc.comp hg
@[continuity]
lemma continuous.Icc_extend' {f : Icc a b â†’ Î²} (hf : continuous f) : continuous (Icc_extend h f) :=
hf.comp continuous_proj_Icc
lemma continuous_at.Icc_extend {x : Î³} (f : Î³ â†’ Icc a b â†’ Î²) {g : Î³ â†’ Î±}
  (hf : continuous_at â†¿f (x, proj_Icc a b h (g x))) (hg : continuous_at g x) :
  continuous_at (Î» a, Icc_extend h (f a) (g a)) x :=
show continuous_at (â†¿f âˆ˜ Î» x, (x, proj_Icc a b h (g x))) x, from
continuous_at.comp hf $ continuous_at_id.prod $ continuous_proj_Icc.continuous_at.comp hg
