import category_theory.adjunction.reflective
import category_theory.monad.algebra
namespace category_theory
open category
@[simps]
def to_monad (h : L ‚ä£ R) : monad C :=
{ to_functor := L ‚ãô R,
  Œ∑' := h.unit,
  Œº' := whisker_right (whisker_left L h.counit) R,
  assoc' := Œª X, by { dsimp, rw [‚ÜêR.map_comp], simp },
  right_unit' := Œª X, by { dsimp, rw [‚ÜêR.map_comp], simp } }
@[simps]
def to_comonad (h : L ‚ä£ R) : comonad D :=
{ to_functor := R ‚ãô L,
  Œµ' := h.counit,
  Œ¥' := whisker_right (whisker_left R h.unit) L,
  coassoc' := Œª X, by { dsimp, rw ‚Üê L.map_comp, simp },
  right_counit' := Œª X, by { dsimp, rw ‚Üê L.map_comp, simp } }
@[simps]
def adj_to_monad_iso (T : monad C) : T.adj.to_monad ‚âÖ T :=
monad_iso.mk (nat_iso.of_components (Œª X, iso.refl _) (by tidy))
  (Œª X, by { dsimp, simp })
  (Œª X, by { dsimp, simp })
@[simps]
def adj_to_comonad_iso (G : comonad C) : G.adj.to_comonad ‚âÖ G :=
comonad_iso.mk (nat_iso.of_components (Œª X, iso.refl _) (by tidy))
  (Œª X, by { dsimp, simp })
  (Œª X, by { dsimp, simp })
end adjunction
@[simps]
def monad.comparison (h : L ‚ä£ R) : D ‚•§ h.to_monad.algebra :=
{ obj := Œª X,
  { A := R.obj X,
    a := R.map (h.counit.app X),
    assoc' := by { dsimp, rw [‚Üê R.map_comp, ‚Üê adjunction.counit_naturality, R.map_comp], refl } },
  map := Œª X Y f,
  { f := R.map f,
    h' := by { dsimp, rw [‚Üê R.map_comp, adjunction.counit_naturality, R.map_comp] } } }.
@[simps]
def monad.comparison_forget (h : L ‚ä£ R) :
  monad.comparison h ‚ãô h.to_monad.forget ‚âÖ R :=
{ hom := { app := Œª X, ùüô _, },
  inv := { app := Œª X, ùüô _, } }
lemma monad.left_comparison (h : L ‚ä£ R) : L ‚ãô monad.comparison h = h.to_monad.free := rfl
instance [faithful R] (h : L ‚ä£ R) :
  faithful (monad.comparison h) :=
{ map_injective' := Œª X Y f g w, R.map_injective (congr_arg monad.algebra.hom.f w : _) }
instance (T : monad C) : full (monad.comparison T.adj) :=
{ preimage := Œª X Y f, ‚ü®f.f, by simpa using f.h‚ü© }
instance (T : monad C) : ess_surj (monad.comparison T.adj) :=
{ mem_ess_image := Œª X,
  ‚ü®{ A := X.A, a := X.a, unit' := by simpa using X.unit, assoc' := by simpa using X.assoc },
    ‚ü®monad.algebra.iso_mk (iso.refl _) (by simp)‚ü©‚ü© }
@[simps]
def comonad.comparison (h : L ‚ä£ R) : C ‚•§ h.to_comonad.coalgebra :=
{ obj := Œª X,
  { A := L.obj X,
    a := L.map (h.unit.app X),
    coassoc' := by { dsimp, rw [‚Üê L.map_comp, ‚Üê adjunction.unit_naturality, L.map_comp], refl } },
  map := Œª X Y f,
  { f := L.map f,
    h' := by { dsimp, rw ‚Üê L.map_comp, simp } } }
@[simps]
def comonad.comparison_forget {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) :
  comonad.comparison h ‚ãô h.to_comonad.forget ‚âÖ L :=
{ hom := { app := Œª X, ùüô _, },
  inv := { app := Œª X, ùüô _, } }
lemma comonad.left_comparison (h : L ‚ä£ R) : R ‚ãô comonad.comparison h = h.to_comonad.cofree := rfl
instance comonad.comparison_faithful_of_faithful [faithful L] (h : L ‚ä£ R) :
  faithful (comonad.comparison h) :=
{ map_injective' := Œª X Y f g w, L.map_injective (congr_arg comonad.coalgebra.hom.f w : _) }
instance (G : comonad C) : full (comonad.comparison G.adj) :=
{ preimage := Œª X Y f, ‚ü®f.f, by simpa using f.h‚ü© }
instance (G : comonad C) : ess_surj (comonad.comparison G.adj) :=
{ mem_ess_image := Œª X,
  ‚ü®{ A := X.A, a := X.a, counit' := by simpa using X.counit, coassoc' := by simpa using X.coassoc },
    ‚ü®comonad.coalgebra.iso_mk (iso.refl _) (by simp)‚ü©‚ü© }
class monadic_right_adjoint (R : D ‚•§ C) extends is_right_adjoint R :=
(eqv : is_equivalence (monad.comparison (adjunction.of_right_adjoint R)))
class comonadic_left_adjoint (L : C ‚•§ D) extends is_left_adjoint L :=
(eqv : is_equivalence (comonad.comparison (adjunction.of_left_adjoint L)))
noncomputable instance (T : monad C) : monadic_right_adjoint T.forget :=
‚ü®(equivalence.of_fully_faithfully_ess_surj _ : is_equivalence (monad.comparison T.adj))‚ü©
noncomputable instance (G : comonad C) : comonadic_left_adjoint G.forget :=
‚ü®(equivalence.of_fully_faithfully_ess_surj _ : is_equivalence (comonad.comparison G.adj))‚ü©
