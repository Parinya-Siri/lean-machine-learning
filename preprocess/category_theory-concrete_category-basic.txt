import category_theory.types
import category_theory.epi_mono
universes w v v' u
namespace category_theory
class concrete_category (C : Type u) [category.{v} C] :=
(forget [] : C ‚•§ Type w)
[forget_faithful : faithful forget]
attribute [instance] concrete_category.forget_faithful
@[reducible] def forget (C : Type v) [category C] [concrete_category.{u} C] : C ‚•§ Type u :=
concrete_category.forget C
instance concrete_category.types : concrete_category (Type u) :=
{ forget := ùü≠ _ }
def concrete_category.has_coe_to_sort (C : Type v) [category C] [concrete_category C] :
  has_coe_to_sort C (Type u) :=
‚ü®(concrete_category.forget C).obj‚ü©
section
local attribute [instance] concrete_category.has_coe_to_sort
variables {C : Type v} [category C] [concrete_category C]
@[simp] lemma forget_obj_eq_coe {X : C} : (forget C).obj X = X := rfl
def concrete_category.has_coe_to_fun {X Y : C} : has_coe_to_fun (X ‚ü∂ Y) (Œª f, X ‚Üí Y) :=
‚ü®Œª f, (forget _).map f‚ü©
local attribute [instance] concrete_category.has_coe_to_fun
lemma concrete_category.hom_ext {X Y : C} (f g : X ‚ü∂ Y) (w : ‚àÄ x : X, f x = g x) : f = g :=
begin
  apply faithful.map_injective (forget C),
  ext,
  exact w x,
end
@[simp] lemma forget_map_eq_coe {X Y : C} (f : X ‚ü∂ Y) : (forget C).map f = f := rfl
lemma congr_hom {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) (x : X) : f x = g x :=
congr_fun (congr_arg (Œª k : X ‚ü∂ Y, (k : X ‚Üí Y)) h) x
lemma coe_id {X : C} : ((ùüô X) : X ‚Üí X) = id :=
(forget _).map_id X
lemma coe_comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  (f ‚â´ g : X ‚Üí Z) = g ‚àò f :=
(forget _).map_comp f g
@[simp] lemma id_apply {X : C} (x : X) : ((ùüô X) : X ‚Üí X) x = x :=
congr_fun ((forget _).map_id X) x
@[simp] lemma comp_apply {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) :
  (f ‚â´ g) x = g (f x) :=
congr_fun ((forget _).map_comp _ _) x
lemma concrete_category.congr_hom {X Y : C} {f g : X ‚ü∂ Y} (h : f = g) (x : X) : f x = g x :=
congr_fun (congr_arg (Œª f : X ‚ü∂ Y, (f : X ‚Üí Y)) h) x
lemma concrete_category.congr_arg {X Y : C} (f : X ‚ü∂ Y) {x x' : X} (h : x = x') : f x = f x' :=
congr_arg (f : X ‚Üí Y) h
lemma concrete_category.mono_of_injective {X Y : C} (f : X ‚ü∂ Y) (i : function.injective f) :
  mono f :=
faithful_reflects_mono (forget C) ((mono_iff_injective f).2 i)
lemma concrete_category.epi_of_surjective {X Y : C} (f : X ‚ü∂ Y) (s : function.surjective f) :
  epi f :=
faithful_reflects_epi (forget C) ((epi_iff_surjective f).2 s)
@[simp] lemma concrete_category.has_coe_to_fun_Type {X Y : Type u} (f : X ‚ü∂ Y) :
  coe_fn f = f :=
rfl
end
class has_forget‚ÇÇ (C : Type v) (D : Type v') [category C] [concrete_category.{u} C] [category D]
  [concrete_category.{u} D] :=
(forget‚ÇÇ : C ‚•§ D)
(forget_comp : forget‚ÇÇ ‚ãô (forget D) = forget C . obviously)
@[reducible] def forget‚ÇÇ (C : Type v) (D : Type v') [category C] [concrete_category C] [category D]
  [concrete_category D] [has_forget‚ÇÇ C D] : C ‚•§ D :=
has_forget‚ÇÇ.forget‚ÇÇ
instance forget_faithful (C : Type v) (D : Type v') [category C] [concrete_category C] [category D]
  [concrete_category D] [has_forget‚ÇÇ C D] : faithful (forget‚ÇÇ C D) :=
has_forget‚ÇÇ.forget_comp.faithful_of_comp
instance induced_category.concrete_category {C : Type v} {D : Type v'} [category D]
  [concrete_category D] (f : C ‚Üí D) :
  concrete_category (induced_category D f) :=
{ forget := induced_functor f ‚ãô forget D }
instance induced_category.has_forget‚ÇÇ {C : Type v} {D : Type v'} [category D] [concrete_category D]
  (f : C ‚Üí D) :
  has_forget‚ÇÇ (induced_category D f) D :=
{ forget‚ÇÇ := induced_functor f,
  forget_comp := rfl }
instance full_subcategory.concrete_category {C : Type v} [category C] [concrete_category C]
  (Z : C ‚Üí Prop) : concrete_category {X : C // Z X} :=
{ forget := full_subcategory_inclusion Z ‚ãô forget C }
instance full_subcategory.has_forget‚ÇÇ {C : Type v} [category C] [concrete_category C]
  (Z : C ‚Üí Prop) : has_forget‚ÇÇ {X : C // Z X} C :=
{ forget‚ÇÇ := full_subcategory_inclusion Z,
  forget_comp := rfl }
def has_forget‚ÇÇ.mk' {C : Type v} {D : Type v'} [category C] [concrete_category C] [category D]
  [concrete_category D] (obj : C ‚Üí D) (h_obj : ‚àÄ X, (forget D).obj (obj X) = (forget C).obj X)
  (map : Œ† {X Y}, (X ‚ü∂ Y) ‚Üí (obj X ‚ü∂ obj Y))
  (h_map : ‚àÄ {X Y} {f : X ‚ü∂ Y}, (forget D).map (map f) == (forget C).map f) :
has_forget‚ÇÇ C D :=
{ forget‚ÇÇ := faithful.div _ _ _ @h_obj _ @h_map,
  forget_comp := by apply faithful.div_comp }
instance has_forget_to_Type (C : Type v) [category C] [concrete_category C] :
  has_forget‚ÇÇ C (Type u) :=
{ forget‚ÇÇ := forget C,
  forget_comp := functor.comp_id _ }
end category_theory
