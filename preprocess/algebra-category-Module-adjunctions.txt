import algebra.category.Module.monoidal
import category_theory.monoidal.functorial
import category_theory.monoidal.types
import linear_algebra.direct_sum.finsupp
import category_theory.linear.linear_functor
noncomputable theory
open category_theory
namespace Module
universe u
open_locale classical
variables (R : Type u)
section
variables [ring R]
@[simps]
def free : Type u â¥¤ Module R :=
{ obj := Î» X, Module.of R (X â†’â‚€ R),
  map := Î» X Y f, finsupp.lmap_domain _ _ f,
  map_id' := by { intros, exact finsupp.lmap_domain_id _ _ },
  map_comp' := by { intros, exact finsupp.lmap_domain_comp _ _ _ _, } }
def adj : free R âŠ£ forget (Module.{u} R) :=
adjunction.mk_of_hom_equiv
{ hom_equiv := Î» X M, (finsupp.lift M R X).to_equiv.symm,
  hom_equiv_naturality_left_symm' := Î» _ _ M f g,
  finsupp.lhom_ext' (Î» x, linear_map.ext_ring
    (finsupp.sum_map_domain_index_add_monoid_hom (Î» y, ((smul_add_hom R M).flip) (g y))).symm) }
instance : is_right_adjoint (forget (Module.{u} R)) := âŸ¨_, adj RâŸ©
end
namespace free
variables [comm_ring R]
local attribute [ext] tensor_product.ext
def Îµ : ğŸ™_ (Module.{u} R) âŸ¶ (free R).obj (ğŸ™_ (Type u)) :=
finsupp.lsingle punit.star
@[simp] lemma Îµ_apply (r : R) : Îµ R r = finsupp.single punit.star r := rfl
def Î¼ (Î± Î² : Type u) : (free R).obj Î± âŠ— (free R).obj Î² â‰… (free R).obj (Î± âŠ— Î²) :=
(finsupp_tensor_finsupp' R Î± Î²).to_Module_iso
lemma Î¼_natural {X Y X' Y' : Type u} (f : X âŸ¶ Y) (g : X' âŸ¶ Y') :
  ((free R).map f âŠ— (free R).map g) â‰« (Î¼ R Y Y').hom =
    (Î¼ R X X').hom â‰« (free R).map (f âŠ— g) :=
begin
  intros,
  ext x x' âŸ¨y, y'âŸ©,
  dsimp [Î¼],
  simp_rw [finsupp.map_domain_single, finsupp_tensor_finsupp'_single_tmul_single, mul_one,
    finsupp.map_domain_single, category_theory.tensor_apply],
end
lemma left_unitality (X : Type u) :
  (Î»_ ((free R).obj X)).hom =
  (Îµ R âŠ— ğŸ™ ((free R).obj X)) â‰« (Î¼ R (ğŸ™_ (Type u)) X).hom â‰« map (free R).obj (Î»_ X).hom :=
begin
  intros,
  ext,
  dsimp [Îµ, Î¼],
  simp_rw [finsupp_tensor_finsupp'_single_tmul_single,
    Module.monoidal_category.left_unitor_hom_apply, finsupp.smul_single', mul_one,
    finsupp.map_domain_single, category_theory.left_unitor_hom_apply],
end
lemma right_unitality (X : Type u) :
  (Ï_ ((free R).obj X)).hom =
  (ğŸ™ ((free R).obj X) âŠ— Îµ R) â‰« (Î¼ R X (ğŸ™_ (Type u))).hom â‰« map (free R).obj (Ï_ X).hom :=
begin
  intros,
  ext,
  dsimp [Îµ, Î¼],
  simp_rw [finsupp_tensor_finsupp'_single_tmul_single,
    Module.monoidal_category.right_unitor_hom_apply, finsupp.smul_single', mul_one,
    finsupp.map_domain_single, category_theory.right_unitor_hom_apply],
end
lemma associativity (X Y Z : Type u) :
  ((Î¼ R X Y).hom âŠ— ğŸ™ ((free R).obj Z)) â‰« (Î¼ R (X âŠ— Y) Z).hom â‰« map (free R).obj (Î±_ X Y Z).hom =
  (Î±_ ((free R).obj X) ((free R).obj Y) ((free R).obj Z)).hom â‰«
    (ğŸ™ ((free R).obj X) âŠ— (Î¼ R Y Z).hom) â‰« (Î¼ R X (Y âŠ— Z)).hom :=
begin
  intros,
  ext,
  dsimp [Î¼],
  simp_rw [finsupp_tensor_finsupp'_single_tmul_single, finsupp.map_domain_single, mul_one,
    category_theory.associator_hom_apply],
end
def monoidal_free : monoidal_functor (Type u) (Module.{u} R) :=
{ Îµ_is_iso := by { dsimp, apply_instance, },
  Î¼_is_iso := Î» X Y, by { dsimp, apply_instance, },
  ..lax_monoidal_functor.of (free R).obj }
example (X Y : Type u) : (free R).obj (X Ã— Y) â‰… (free R).obj X âŠ— (free R).obj Y :=
((monoidal_free R).Î¼_iso X Y).symm
end Module
namespace category_theory
universes v u
@[nolint unused_arguments has_inhabited_instance]
def Free (R : Type*) (C : Type u) := C
def Free.of (R : Type*) {C : Type u} (X : C) : Free R C := X
variables (R : Type*) [comm_ring R] (C : Type u) [category.{v} C]
open finsupp
@[simps]
def embedding : C â¥¤ Free R C :=
{ obj := Î» X, X,
  map := Î» X Y f, finsupp.single f 1,
  map_id' := Î» X, rfl,
  map_comp' := Î» X Y Z f g, by simp, }
variables (R) {C} {D : Type u} [category.{v} D] [preadditive D] [linear R D]
open preadditive linear
@[simps]
def lift (F : C â¥¤ D) : Free R C â¥¤ D :=
{ obj := Î» X, F.obj X,
  map := Î» X Y f, f.sum (Î» f' r, r â€¢ (F.map f')),
  map_id' := by { dsimp [category_theory.category_Free], simp },
  map_comp' := Î» X Y Z f g, begin
    apply finsupp.induction_linear f,
    { simp, },
    { intros fâ‚ fâ‚‚ wâ‚ wâ‚‚,
      rw add_comp,
      rw [finsupp.sum_add_index, finsupp.sum_add_index],
      { simp [wâ‚, wâ‚‚, add_comp], },
      { simp, },
      { intros, simp only [add_smul], },
      { simp, },
      { intros, simp only [add_smul], }, },
    { intros f' r,
      apply finsupp.induction_linear g,
      { simp, },
      { intros fâ‚ fâ‚‚ wâ‚ wâ‚‚,
        rw comp_add,
        rw [finsupp.sum_add_index, finsupp.sum_add_index],
        { simp [wâ‚, wâ‚‚, add_comp], },
        { simp, },
        { intros, simp only [add_smul], },
        { simp, },
        { intros, simp only [add_smul], }, },
      { intros g' s,
        erw single_comp_single,
        simp [mul_comm r s, mul_smul], } }
  end, }
@[simp]
lemma lift_map_single (F : C â¥¤ D) {X Y : C} (f : X âŸ¶ Y) (r : R) :
  (lift R F).map (single f r) = r â€¢ F.map f :=
by simp
instance lift_additive (F : C â¥¤ D) : (lift R F).additive :=
{ map_add' := Î» X Y f g, begin
    dsimp,
    rw finsupp.sum_add_index; simp [add_smul]
  end, }
instance lift_linear (F : C â¥¤ D) : (lift R F).linear R :=
{ map_smul' := Î» X Y f r, begin
    dsimp,
    rw finsupp.sum_smul_index;
    simp [finsupp.smul_sum, mul_smul],
  end, }
def embedding_lift_iso (F : C â¥¤ D) : embedding R C â‹™ lift R F â‰… F :=
nat_iso.of_components
  (Î» X, iso.refl _)
  (by tidy)
@[ext]
def ext {F G : Free R C â¥¤ D} [F.additive] [F.linear R] [G.additive] [G.linear R]
  (Î± : embedding R C â‹™ F â‰… embedding R C â‹™ G) : F â‰… G :=
nat_iso.of_components
  (Î» X, Î±.app X)
  begin
    intros X Y f,
    apply finsupp.induction_linear f,
    { simp, },
    { intros fâ‚ fâ‚‚ wâ‚ wâ‚‚,
      simp only [F.map_add, G.map_add, add_comp, comp_add, wâ‚, wâ‚‚], },
    { intros f' r,
      rw [iso.app_hom, iso.app_hom, â†smul_single_one, F.map_smul, G.map_smul, smul_comp, comp_smul],
      change r â€¢ (embedding R C â‹™ F).map f' â‰« _ = r â€¢ _ â‰« (embedding R C â‹™ G).map f',
      rw Î±.hom.naturality f',
def lift_unique (F : C â¥¤ D) (L : Free R C â¥¤ D) [L.additive] [L.linear R]
  (Î± : embedding R C â‹™ L â‰… F) :
  L â‰… lift R F :=
ext R (Î±.trans (embedding_lift_iso R F).symm)
end Free
end category_theory
