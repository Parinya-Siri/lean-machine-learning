import category_theory.limits.shapes.binary_products
import category_theory.limits.shapes.terminal
import category_theory.subobject.mono_over
universes vâ‚ vâ‚‚ uâ‚ uâ‚‚
noncomputable theory
namespace category_theory
open limits category
variables {C : Type uâ‚} [category.{vâ‚} C] {A : C}
def is_subterminal (A : C) : Prop := âˆ€ â¦ƒZ : Câ¦„ (f g : Z âŸ¶ A), f = g
lemma is_subterminal.def : is_subterminal A â†” âˆ€ â¦ƒZ : Câ¦„ (f g : Z âŸ¶ A), f = g := iff.rfl
lemma is_subterminal.mono_is_terminal_from (hA : is_subterminal A) {T : C} (hT : is_terminal T) :
  mono (hT.from A) :=
{ right_cancellation := Î» Z g h _, hA _ _ }
lemma is_subterminal.mono_terminal_from [has_terminal C] (hA : is_subterminal A) :
  mono (terminal.from A) :=
hA.mono_is_terminal_from terminal_is_terminal
lemma is_subterminal_of_mono_is_terminal_from {T : C} (hT : is_terminal T) [mono (hT.from A)] :
  is_subterminal A :=
Î» Z f g, by { rw â† cancel_mono (hT.from A), apply hT.hom_ext }
lemma is_subterminal_of_mono_terminal_from [has_terminal C] [mono (terminal.from A)] :
  is_subterminal A :=
Î» Z f g, by { rw â† cancel_mono (terminal.from A), apply subsingleton.elim }
lemma is_subterminal_of_is_terminal {T : C} (hT : is_terminal T) : is_subterminal T :=
Î» Z f g, hT.hom_ext _ _
lemma is_subterminal_of_terminal [has_terminal C] : is_subterminal (âŠ¤_ C) :=
Î» Z f g, subsingleton.elim _ _
lemma is_subterminal.is_iso_diag (hA : is_subterminal A) [has_binary_product A A] :
  is_iso (diag A) :=
âŸ¨âŸ¨limits.prod.fst, âŸ¨by simp, by { rw is_subterminal.def at hA, tidy }âŸ©âŸ©âŸ©
lemma is_subterminal_of_is_iso_diag [has_binary_product A A] [is_iso (diag A)] :
  is_subterminal A :=
Î» Z f g,
begin
  have : (limits.prod.fst : A â¨¯ A âŸ¶ _) = limits.prod.snd,
  { simp [â†cancel_epi (diag A)] },
  rw [â†prod.lift_fst f g, this, prod.lift_snd],
end
@[simps]
def is_subterminal.iso_diag (hA : is_subterminal A) [has_binary_product A A] :
  A â¨¯ A â‰… A :=
begin
  letI := is_subterminal.is_iso_diag hA,
  apply (as_iso (diag A)).symm,
end
variables (C)
@[derive category]
def subterminals (C : Type uâ‚) [category.{vâ‚} C] :=
{A : C // is_subterminal A}
instance [has_terminal C] : inhabited (subterminals C) :=
âŸ¨âŸ¨âŠ¤_ C, is_subterminal_of_terminalâŸ©âŸ©
@[derive [full, faithful], simps]
def subterminal_inclusion : subterminals C â¥¤ C := full_subcategory_inclusion _
instance subterminals_thin (X Y : subterminals C) : subsingleton (X âŸ¶ Y) :=
âŸ¨Î» f g, Y.2 f gâŸ©
@[simps]
def subterminals_equiv_mono_over_terminal [has_terminal C] :
  subterminals C â‰Œ mono_over (âŠ¤_ C) :=
{ functor :=
  { obj := Î» X, âŸ¨over.mk (terminal.from X.1), X.2.mono_terminal_fromâŸ©,
    map := Î» X Y f, mono_over.hom_mk f (by ext1 âŸ¨âŸ¨âŸ©âŸ©) },
  inverse :=
  { obj := Î» X, âŸ¨X.val.left, Î» Z f g, by { rw â† cancel_mono X.arrow, apply subsingleton.elim }âŸ©,
    map := Î» X Y f, f.1 },
  unit_iso :=
  { hom := { app := Î» X, ğŸ™ _ },
    inv := { app := Î» X, ğŸ™ _ } },
  counit_iso :=
  { hom := { app := Î» X, over.hom_mk (ğŸ™ _) },
    inv := { app := Î» X, over.hom_mk (ğŸ™ _) } } }
@[simp]
lemma subterminals_to_mono_over_terminal_comp_forget [has_terminal C] :
  (subterminals_equiv_mono_over_terminal C).functor â‹™ mono_over.forget _ â‹™ over.forget _ =
    subterminal_inclusion C :=
rfl
@[simp]
lemma mono_over_terminal_to_subterminals_comp [has_terminal C] :
  (subterminals_equiv_mono_over_terminal C).inverse â‹™ subterminal_inclusion C =
    mono_over.forget _ â‹™ over.forget _ :=
rfl
end category_theory
