import category_theory.over
import category_theory.limits.shapes.pullbacks
import category_theory.limits.shapes.wide_pullbacks
import category_theory.limits.shapes.finite_products
@[reducible]
def wide_pullback_diagram_of_diagram_over (B : C) {J : Type w} (F : discrete J â¥¤ over B) :
  wide_pullback_shape J â¥¤ C :=
wide_pullback_shape.wide_cospan B (Î» j, (F.obj âŸ¨jâŸ©).left) (Î» j, (F.obj âŸ¨jâŸ©).hom)
@[simps]
def cones_equiv_inverse_obj (B : C) {J : Type w} (F : discrete J â¥¤ over B) (c : cone F) :
  cone (wide_pullback_diagram_of_diagram_over B F) :=
{ X := c.X.left,
  Ï€ :=
  { app := Î» X, option.cases_on X c.X.hom (Î» (j : J), (c.Ï€.app âŸ¨jâŸ©).left),
@[simps]
def cones_equiv_inverse (B : C) {J : Type w} (F : discrete J â¥¤ over B) :
  cone F â¥¤ cone (wide_pullback_diagram_of_diagram_over B F) :=
{ obj := cones_equiv_inverse_obj B F,
  map := Î» câ‚ câ‚‚ f,
  { hom := f.hom.left,
    w' := Î» j,
    begin
      cases j,
      { simp },
      { dsimp,
        rw â† f.w âŸ¨jâŸ©,
        refl }
    end } }
local attribute [tidy] tactic.discrete_cases
@[simps]
def cones_equiv_functor (B : C) {J : Type w} (F : discrete J â¥¤ over B) :
  cone (wide_pullback_diagram_of_diagram_over B F) â¥¤ cone F :=
{ obj := Î» c,
  { X := over.mk (c.Ï€.app none),
    Ï€ :=
    { app := Î» âŸ¨jâŸ©, over.hom_mk (c.Ï€.app (some j))
                    (by apply c.w (wide_pullback_shape.hom.term j)) } },
  map := Î» câ‚ câ‚‚ f,
  { hom := over.hom_mk f.hom } }
local attribute [tidy] tactic.case_bash
@[simp]
def cones_equiv_unit_iso (B : C) (F : discrete J â¥¤ over B) :
  ğŸ­ (cone (wide_pullback_diagram_of_diagram_over B F)) â‰…
    cones_equiv_functor B F â‹™ cones_equiv_inverse B F :=
nat_iso.of_components (Î» _, cones.ext {hom := ğŸ™ _, inv := ğŸ™ _} (by tidy)) (by tidy)
@[simp]
def cones_equiv_counit_iso (B : C) (F : discrete J â¥¤ over B) :
  cones_equiv_inverse B F â‹™ cones_equiv_functor B F â‰… ğŸ­ (cone F) :=
nat_iso.of_components
  (Î» _, cones.ext {hom := over.hom_mk (ğŸ™ _), inv := over.hom_mk (ğŸ™ _)} (by tidy)) (by tidy)
@[simps]
def cones_equiv (B : C) (F : discrete J â¥¤ over B) :
  cone (wide_pullback_diagram_of_diagram_over B F) â‰Œ cone F :=
{ functor := cones_equiv_functor B F,
  inverse := cones_equiv_inverse B F,
  unit_iso := cones_equiv_unit_iso B F,
  counit_iso := cones_equiv_counit_iso B F, }
lemma has_over_limit_discrete_of_wide_pullback_limit {B : C} (F : discrete J â¥¤ over B)
  [has_limit (wide_pullback_diagram_of_diagram_over B F)] :
  has_limit F :=
has_limit.mk
{ cone := _,
  is_limit := is_limit.of_right_adjoint
    (cones_equiv B F).functor (limit.is_limit (wide_pullback_diagram_of_diagram_over B F)) }
lemma over_product_of_wide_pullback [has_limits_of_shape (wide_pullback_shape J) C] {B : C} :
  has_limits_of_shape (discrete J) (over B) :=
{ has_limit := Î» F, has_over_limit_discrete_of_wide_pullback_limit F }
lemma over_binary_product_of_pullback [has_pullbacks C] {B : C} :
  has_binary_products (over B) :=
over_product_of_wide_pullback
lemma over_products_of_wide_pullbacks [has_wide_pullbacks.{w} C] {B : C} :
  has_products.{w} (over B) :=
Î» J, over_product_of_wide_pullback
lemma over_finite_products_of_finite_wide_pullbacks [has_finite_wide_pullbacks C] {B : C} :
  has_finite_products (over B) :=
âŸ¨Î» J ğ’¥, by exactI over_product_of_wide_pullbackâŸ©
end construct_products
local attribute [tidy] tactic.discrete_cases
lemma over_has_terminal (B : C) : has_terminal (over B) :=
{ has_limit := Î» F, has_limit.mk
  { cone :=
    { X := over.mk (ğŸ™ _),
      Ï€ := { app := Î» p, p.as.elim } },
    is_limit :=
      { lift := Î» s, over.hom_mk _,
        fac' := Î» _ j, j.as.elim,
        uniq' := Î» s m _,
          begin
            ext,
            rw over.hom_mk_left,
            have := m.w,
            dsimp at this,
            rwa [category.comp_id, category.comp_id] at this
          end } } }
end category_theory.over
