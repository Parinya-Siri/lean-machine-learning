import analysis.convex.basic
import analysis.inner_product_space.basic
import analysis.normed_space.is_R_or_C
noncomputable theory
open is_R_or_C real filter
open_locale big_operators topological_space
variables {ğ•œ E F : Type*} [is_R_or_C ğ•œ]
variables [inner_product_space ğ•œ E] [inner_product_space â„ F]
local notation `âŸª`x`, `y`âŸ«` := @inner ğ•œ E _ x y
local notation `absR` := has_abs.abs
theorem norm_eq_infi_iff_real_inner_le_zero {K : set F} (h : convex â„ K) {u : F} {v : F}
  (hv : v âˆˆ K) : âˆ¥u - vâˆ¥ = (â¨… w : K, âˆ¥u - wâˆ¥) â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0 :=
iff.intro
begin
  assume eq w hw,
  let Î´ := â¨… w : K, âˆ¥u - wâˆ¥, let p := âŸªu - v, w - vâŸ«_â„, let q := âˆ¥w - vâˆ¥^2,
  letI : nonempty K := âŸ¨âŸ¨v, hvâŸ©âŸ©,
  have zero_le_Î´ : 0 â‰¤ Î´,
    apply le_cinfi, intro, exact norm_nonneg _,
  have Î´_le : âˆ€ w : K, Î´ â‰¤ âˆ¥u - wâˆ¥,
    assume w, apply cinfi_le, use (0:â„), rintros _ âŸ¨_, rflâŸ©, exact norm_nonneg _,
  have Î´_le' : âˆ€ w âˆˆ K, Î´ â‰¤ âˆ¥u - wâˆ¥ := assume w hw, Î´_le âŸ¨w, hwâŸ©,
  have : âˆ€Î¸:â„, 0 < Î¸ â†’ Î¸ â‰¤ 1 â†’ 2 * p â‰¤ Î¸ * q,
    assume Î¸ hÎ¸â‚ hÎ¸â‚‚,
    have : âˆ¥u - vâˆ¥^2 â‰¤ âˆ¥u - vâˆ¥^2 - 2 * Î¸ * âŸªu - v, w - vâŸ«_â„ + Î¸*Î¸*âˆ¥w - vâˆ¥^2 :=
    calc
      âˆ¥u - vâˆ¥^2 â‰¤ âˆ¥u - (Î¸â€¢w + (1-Î¸)â€¢v)âˆ¥^2 :
      begin
        simp only [sq], apply mul_self_le_mul_self (norm_nonneg _),
        rw [eq], apply Î´_le',
        apply h hw hv,
        exacts [le_of_lt hÎ¸â‚, sub_nonneg.2 hÎ¸â‚‚, add_sub_cancel'_right _ _],
      end
      ... = âˆ¥(u - v) - Î¸ â€¢ (w - v)âˆ¥^2 :
      begin
        have : u - (Î¸â€¢w + (1-Î¸)â€¢v) = (u - v) - Î¸ â€¢ (w - v),
        { rw [smul_sub, sub_smul, one_smul],
          simp only [sub_eq_add_neg, add_comm, add_left_comm, add_assoc, neg_add_rev] },
        rw this
      end
      ... = âˆ¥u - vâˆ¥^2 - 2 * Î¸ * inner (u - v) (w - v) + Î¸*Î¸*âˆ¥w - vâˆ¥^2 :
      begin
        rw [norm_sub_sq, inner_smul_right, norm_smul],
        simp only [sq],
        show âˆ¥u-vâˆ¥*âˆ¥u-vâˆ¥-2*(Î¸*inner(u-v)(w-v))+absR (Î¸)*âˆ¥w-vâˆ¥*(absR (Î¸)*âˆ¥w-vâˆ¥)=
                âˆ¥u-vâˆ¥*âˆ¥u-vâˆ¥-2*Î¸*inner(u-v)(w-v)+Î¸*Î¸*(âˆ¥w-vâˆ¥*âˆ¥w-vâˆ¥),
        rw abs_of_pos hÎ¸â‚, ring
      end,
    have eqâ‚ : âˆ¥u-vâˆ¥^2-2*Î¸*inner(u-v)(w-v)+Î¸*Î¸*âˆ¥w-vâˆ¥^2=âˆ¥u-vâˆ¥^2+(Î¸*Î¸*âˆ¥w-vâˆ¥^2-2*Î¸*inner(u-v)(w-v)),
      by abel,
    rw [eqâ‚, le_add_iff_nonneg_right] at this,
    have eqâ‚‚ : Î¸*Î¸*âˆ¥w-vâˆ¥^2-2*Î¸*inner(u-v)(w-v)=Î¸*(Î¸*âˆ¥w-vâˆ¥^2-2*inner(u-v)(w-v)), ring,
    rw eqâ‚‚ at this,
    have := le_of_sub_nonneg (nonneg_of_mul_nonneg_left this hÎ¸â‚),
    exact this,
  by_cases hq : q = 0,
  { rw hq at this,
    have : p â‰¤ 0,
      have := this (1:â„) (by norm_num) (by norm_num),
      linarith,
    exact this },
  { have q_pos : 0 < q,
      apply lt_of_le_of_ne, exact sq_nonneg _, intro h, exact hq h.symm,
    by_contradiction hp, rw not_le at hp,
    let Î¸ := min (1:â„) (p / q),
    have eqâ‚ : Î¸*q â‰¤ p := calc
      Î¸*q â‰¤ (p/q) * q : mul_le_mul_of_nonneg_right (min_le_right _ _) (sq_nonneg _)
      ... = p : div_mul_cancel _ hq,
    have : 2 * p â‰¤ p := calc
      2 * p â‰¤ Î¸*q : by { refine this Î¸ (lt_min (by norm_num) (div_pos hp q_pos)) (by norm_num) }
      ... â‰¤ p : eqâ‚,
    linarith }
end
begin
  assume h,
  letI : nonempty K := âŸ¨âŸ¨v, hvâŸ©âŸ©,
  apply le_antisymm,
  { apply le_cinfi, assume w,
    apply nonneg_le_nonneg_of_sq_le_sq (norm_nonneg _),
    have := h w w.2,
    calc
      âˆ¥u - vâˆ¥ * âˆ¥u - vâˆ¥ â‰¤ âˆ¥u - vâˆ¥ * âˆ¥u - vâˆ¥ - 2 * inner (u - v) ((w:F) - v) : by linarith
      ... â‰¤ âˆ¥u - vâˆ¥^2 - 2 * inner (u - v) ((w:F) - v) + âˆ¥(w:F) - vâˆ¥^2 :
        by { rw sq, refine le_add_of_nonneg_right _, exact sq_nonneg _ }
      ... = âˆ¥(u - v) - (w - v)âˆ¥^2 : norm_sub_sq.symm
      ... = âˆ¥u - wâˆ¥ * âˆ¥u - wâˆ¥ :
        by { have : (u - v) - (w - v) = u - w, abel, rw [this, sq] } },
  { show (â¨… (w : K), âˆ¥u - wâˆ¥) â‰¤ (Î»w:K, âˆ¥u - wâˆ¥) âŸ¨v, hvâŸ©,
      apply cinfi_le, use 0, rintros y âŸ¨z, rflâŸ©, exact norm_nonneg _ }
end
variables (K : submodule ğ•œ E)
theorem exists_norm_eq_infi_of_complete_subspace
  (h : is_complete (â†‘K : set E)) : âˆ€ u : E, âˆƒ v âˆˆ K, âˆ¥u - vâˆ¥ = â¨… w : (K : set E), âˆ¥u - wâˆ¥ :=
begin
  letI : inner_product_space â„ E := inner_product_space.is_R_or_C_to_real ğ•œ E,
  letI : module â„ E := restrict_scalars.module â„ ğ•œ E,
  let K' : submodule â„ E := submodule.restrict_scalars â„ K,
  exact exists_norm_eq_infi_of_complete_convex âŸ¨0, K'.zero_memâŸ© h K'.convex
end
theorem norm_eq_infi_iff_real_inner_eq_zero (K : submodule â„ F) {u : F} {v : F}
  (hv : v âˆˆ K) : âˆ¥u - vâˆ¥ = (â¨… w : (â†‘K : set F), âˆ¥u - wâˆ¥) â†” âˆ€ w âˆˆ K, âŸªu - v, wâŸ«_â„ = 0 :=
iff.intro
begin
  assume h,
  have h : âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0,
  { rwa [norm_eq_infi_iff_real_inner_le_zero] at h, exacts [K.convex, hv] },
  assume w hw,
  have le : âŸªu - v, wâŸ«_â„ â‰¤ 0,
    let w' := w + v,
    have : w' âˆˆ K := submodule.add_mem _ hw hv,
    have hâ‚ := h w' this,
    have hâ‚‚ : w' - v = w, simp only [add_neg_cancel_right, sub_eq_add_neg],
    rw hâ‚‚ at hâ‚, exact hâ‚,
  have ge : âŸªu - v, wâŸ«_â„ â‰¥ 0,
    let w'' := -w + v,
    have : w'' âˆˆ K := submodule.add_mem _ (submodule.neg_mem _ hw) hv,
    have hâ‚ := h w'' this,
    have hâ‚‚ : w'' - v = -w, simp only [neg_inj, add_neg_cancel_right, sub_eq_add_neg],
    rw [hâ‚‚, inner_neg_right] at hâ‚,
    linarith,
    exact le_antisymm le ge
end
begin
  assume h,
  have : âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0,
    assume w hw,
    let w' := w - v,
    have : w' âˆˆ K := submodule.sub_mem _ hw hv,
    have hâ‚ := h w' this,
    exact le_of_eq hâ‚,
  rwa norm_eq_infi_iff_real_inner_le_zero,
  exacts [submodule.convex _, hv]
end
theorem norm_eq_infi_iff_inner_eq_zero {u : E} {v : E}
  (hv : v âˆˆ K) : âˆ¥u - vâˆ¥ = (â¨… w : (â†‘K : set E), âˆ¥u - wâˆ¥) â†” âˆ€ w âˆˆ K, âŸªu - v, wâŸ« = 0 :=
begin
  letI : inner_product_space â„ E := inner_product_space.is_R_or_C_to_real ğ•œ E,
  letI : module â„ E := restrict_scalars.module â„ ğ•œ E,
  let K' : submodule â„ E := K.restrict_scalars â„,
  split,
  { assume H,
    have A : âˆ€ w âˆˆ K, re âŸªu - v, wâŸ« = 0 := (norm_eq_infi_iff_real_inner_eq_zero K' hv).1 H,
    assume w hw,
    apply ext,
    { simp [A w hw] },
    { symmetry, calc
      im (0 : ğ•œ) = 0 : im.map_zero
      ... = re âŸªu - v, (-I) â€¢ wâŸ« : (A _ (K.smul_mem (-I) hw)).symm
      ... = re ((-I) * âŸªu - v, wâŸ«) : by rw inner_smul_right
      ... = im âŸªu - v, wâŸ« : by simp } },
  { assume H,
    have : âˆ€ w âˆˆ K', âŸªu - v, wâŸ«_â„ = 0,
    { assume w hw,
      rw [real_inner_eq_re_inner, H w hw],
      exact zero_re' },
    exact (norm_eq_infi_iff_real_inner_eq_zero K' hv).2 this }
end
section orthogonal_projection
variables [complete_space K]
def orthogonal_projection_fn (v : E) :=
(exists_norm_eq_infi_of_complete_subspace K (complete_space_coe_iff_is_complete.mp â€¹_â€º) v).some
variables {K}
lemma orthogonal_projection_fn_mem (v : E) : orthogonal_projection_fn K v âˆˆ K :=
(exists_norm_eq_infi_of_complete_subspace K
  (complete_space_coe_iff_is_complete.mp â€¹_â€º) v).some_spec.some
lemma orthogonal_projection_fn_inner_eq_zero (v : E) :
  âˆ€ w âˆˆ K, âŸªv - orthogonal_projection_fn K v, wâŸ« = 0 :=
begin
  rw â†norm_eq_infi_iff_inner_eq_zero K (orthogonal_projection_fn_mem v),
  exact (exists_norm_eq_infi_of_complete_subspace K
    (complete_space_coe_iff_is_complete.mp â€¹_â€º) v).some_spec.some_spec
end
lemma eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero
  {u v : E} (hvm : v âˆˆ K) (hvo : âˆ€ w âˆˆ K, âŸªu - v, wâŸ« = 0) :
  orthogonal_projection_fn K u = v :=
begin
  rw [â†sub_eq_zero, â†inner_self_eq_zero],
  have hvs : orthogonal_projection_fn K u - v âˆˆ K :=
    submodule.sub_mem K (orthogonal_projection_fn_mem u) hvm,
  have huo : âŸªu - orthogonal_projection_fn K u, orthogonal_projection_fn K u - vâŸ« = 0 :=
    orthogonal_projection_fn_inner_eq_zero u _ hvs,
  have huv : âŸªu - v, orthogonal_projection_fn K u - vâŸ« = 0 := hvo _ hvs,
  have houv : âŸª(u - v) - (u - orthogonal_projection_fn K u), orthogonal_projection_fn K u - vâŸ« = 0,
  { rw [inner_sub_left, huo, huv, sub_zero] },
  rwa sub_sub_sub_cancel_left at houv
end
variables (K)
lemma orthogonal_projection_fn_norm_sq (v : E) :
  âˆ¥vâˆ¥ * âˆ¥vâˆ¥ = âˆ¥v - (orthogonal_projection_fn K v)âˆ¥ * âˆ¥v - (orthogonal_projection_fn K v)âˆ¥
            + âˆ¥orthogonal_projection_fn K vâˆ¥ * âˆ¥orthogonal_projection_fn K vâˆ¥ :=
begin
  set p := orthogonal_projection_fn K v,
  have h' : âŸªv - p, pâŸ« = 0,
  { exact orthogonal_projection_fn_inner_eq_zero _ _ (orthogonal_projection_fn_mem v) },
  convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero (v - p) p h' using 2;
  simp,
end
def orthogonal_projection : E â†’L[ğ•œ] K :=
linear_map.mk_continuous
  { to_fun := Î» v, âŸ¨orthogonal_projection_fn K v, orthogonal_projection_fn_mem vâŸ©,
    map_add' := Î» x y, begin
      have hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y âˆˆ K :=
        submodule.add_mem K (orthogonal_projection_fn_mem x) (orthogonal_projection_fn_mem y),
      have ho :
        âˆ€ w âˆˆ K, âŸªx + y - (orthogonal_projection_fn K x + orthogonal_projection_fn K y), wâŸ« = 0,
      { intros w hw,
        rw [add_sub_add_comm, inner_add_left, orthogonal_projection_fn_inner_eq_zero _ w hw,
            orthogonal_projection_fn_inner_eq_zero _ w hw, add_zero] },
      ext,
      simp [eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hm ho]
    end,
    map_smul' := Î» c x, begin
      have hm : c â€¢ orthogonal_projection_fn K x âˆˆ K :=
        submodule.smul_mem K _ (orthogonal_projection_fn_mem x),
      have ho : âˆ€ w âˆˆ K, âŸªc â€¢ x - c â€¢ orthogonal_projection_fn K x, wâŸ« = 0,
      { intros w hw,
        rw [â†smul_sub, inner_smul_left, orthogonal_projection_fn_inner_eq_zero _ w hw, mul_zero] },
      ext,
      simp [eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hm ho]
    end }
  1
  (Î» x, begin
    simp only [one_mul, linear_map.coe_mk],
    refine le_of_pow_le_pow 2 (norm_nonneg _) (by norm_num) _,
    change âˆ¥orthogonal_projection_fn K xâˆ¥ ^ 2 â‰¤ âˆ¥xâˆ¥ ^ 2,
    nlinarith [orthogonal_projection_fn_norm_sq K x]
  end)
variables {K}
@[simp]
lemma orthogonal_projection_fn_eq (v : E) :
  orthogonal_projection_fn K v = (orthogonal_projection K v : E) :=
rfl
@[simp]
lemma orthogonal_projection_inner_eq_zero (v : E) :
  âˆ€ w âˆˆ K, âŸªv - orthogonal_projection K v, wâŸ« = 0 :=
orthogonal_projection_fn_inner_eq_zero v
@[simp] lemma sub_orthogonal_projection_mem_orthogonal (v : E) :
  v - orthogonal_projection K v âˆˆ Ká—® :=
begin
  intros w hw,
  rw inner_eq_zero_sym,
  exact orthogonal_projection_inner_eq_zero _ _ hw
end
lemma eq_orthogonal_projection_of_mem_of_inner_eq_zero
  {u v : E} (hvm : v âˆˆ K) (hvo : âˆ€ w âˆˆ K, âŸªu - v, wâŸ« = 0) :
  (orthogonal_projection K u : E) = v :=
eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hvm hvo
lemma eq_orthogonal_projection_of_eq_submodule
  {K' : submodule ğ•œ E} [complete_space K'] (h : K = K') (u : E) :
  (orthogonal_projection K u : E) = (orthogonal_projection K' u : E) :=
begin
  change orthogonal_projection_fn K u = orthogonal_projection_fn K' u,
  congr,
  exact h
end
@[simp] lemma orthogonal_projection_mem_subspace_eq_self (v : K) : orthogonal_projection K v = v :=
by { ext, apply eq_orthogonal_projection_of_mem_of_inner_eq_zero; simp }
lemma orthogonal_projection_eq_self_iff {v : E} :
  (orthogonal_projection K v : E) = v â†” v âˆˆ K :=
begin
  refine âŸ¨Î» h, _, Î» h, eq_orthogonal_projection_of_mem_of_inner_eq_zero h _âŸ©,
  { rw â† h,
    simp },
  { simp }
end
lemma linear_isometry.map_orthogonal_projection {E E' : Type*} [inner_product_space ğ•œ E]
  [inner_product_space ğ•œ E'] (f : E â†’â‚—áµ¢[ğ•œ] E') (p : submodule ğ•œ E) [complete_space p]
  (x : E) :
  f (orthogonal_projection p x) = orthogonal_projection (p.map f.to_linear_map) (f x) :=
begin
  refine (eq_orthogonal_projection_of_mem_of_inner_eq_zero (submodule.apply_coe_mem_map _ _) $
    Î» y hy, _).symm,
  rcases hy with âŸ¨x', hx', rfl : f x' = yâŸ©,
  rw [f.coe_to_linear_map, â† f.map_sub, f.inner_map_map,
    orthogonal_projection_inner_eq_zero x x' hx']
end
lemma orthogonal_projection_map_apply {E E' : Type*} [inner_product_space ğ•œ E]
  [inner_product_space ğ•œ E'] (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (p : submodule ğ•œ E) [complete_space p]
  (x : E') :
  (orthogonal_projection (p.map (f.to_linear_equiv : E â†’â‚—[ğ•œ] E')) x : E')
  = f (orthogonal_projection p (f.symm x)) :=
by simpa only [f.coe_to_linear_isometry, f.apply_symm_apply]
  using (f.to_linear_isometry.map_orthogonal_projection p (f.symm x)).symm
@[simp] lemma orthogonal_projection_bot : orthogonal_projection (âŠ¥ : submodule ğ•œ E) = 0 :=
by ext
variables (K)
lemma orthogonal_projection_norm_le : âˆ¥orthogonal_projection Kâˆ¥ â‰¤ 1 :=
linear_map.mk_continuous_norm_le _ (by norm_num) _
variables (ğ•œ)
lemma smul_orthogonal_projection_singleton {v : E} (w : E) :
  (âˆ¥vâˆ¥ ^ 2 : ğ•œ) â€¢ (orthogonal_projection (ğ•œ âˆ™ v) w : E) = âŸªv, wâŸ« â€¢ v :=
begin
  suffices : â†‘(orthogonal_projection (ğ•œ âˆ™ v) ((âˆ¥vâˆ¥ ^ 2 : ğ•œ) â€¢ w)) = âŸªv, wâŸ« â€¢ v,
  { simpa using this },
  apply eq_orthogonal_projection_of_mem_of_inner_eq_zero,
  { rw submodule.mem_span_singleton,
    use âŸªv, wâŸ« },
  { intros x hx,
    obtain âŸ¨c, rflâŸ© := submodule.mem_span_singleton.mp hx,
    have hv : â†‘âˆ¥vâˆ¥ ^ 2 = âŸªv, vâŸ« := by { norm_cast, simp [norm_sq_eq_inner] },
    simp [inner_sub_left, inner_smul_left, inner_smul_right, ring_equiv.map_div, mul_comm, hv,
      inner_product_space.conj_sym, hv] }
end
lemma orthogonal_projection_singleton {v : E} (w : E) :
  (orthogonal_projection (ğ•œ âˆ™ v) w : E) = (âŸªv, wâŸ« / âˆ¥vâˆ¥ ^ 2) â€¢ v :=
begin
  by_cases hv : v = 0,
  { rw [hv, eq_orthogonal_projection_of_eq_submodule (submodule.span_zero_singleton ğ•œ)],
    { simp },
    { apply_instance } },
  have hv' : âˆ¥vâˆ¥ â‰  0 := ne_of_gt (norm_pos_iff.mpr hv),
  have key : ((âˆ¥vâˆ¥ ^ 2 : ğ•œ)â»Â¹ * âˆ¥vâˆ¥ ^ 2) â€¢ â†‘(orthogonal_projection (ğ•œ âˆ™ v) w)
              = ((âˆ¥vâˆ¥ ^ 2 : ğ•œ)â»Â¹ * âŸªv, wâŸ«) â€¢ v,
  { simp [mul_smul, smul_orthogonal_projection_singleton ğ•œ w] },
  convert key;
  field_simp [hv']
end
lemma orthogonal_projection_unit_singleton {v : E} (hv : âˆ¥vâˆ¥ = 1) (w : E) :
  (orthogonal_projection (ğ•œ âˆ™ v) w : E) = âŸªv, wâŸ« â€¢ v :=
by { rw â† smul_orthogonal_projection_singleton ğ•œ w, simp [hv] }
end orthogonal_projection
section reflection
variables {ğ•œ} (K) [complete_space K]
def reflection_linear_equiv : E â‰ƒâ‚—[ğ•œ] E :=
linear_equiv.of_involutive
  (bit0 (K.subtype.comp (orthogonal_projection K).to_linear_map) - linear_map.id)
  (Î» x, by simp [bit0])
def reflection : E â‰ƒâ‚—áµ¢[ğ•œ] E :=
{ norm_map' := begin
    intros x,
    let w : K := orthogonal_projection K x,
    let v := x - w,
    have : âŸªv, wâŸ« = 0 := orthogonal_projection_inner_eq_zero x w w.2,
    convert norm_sub_eq_norm_add this using 2,
    { rw [linear_equiv.coe_mk, reflection_linear_equiv,
        linear_equiv.to_fun_eq_coe, linear_equiv.coe_of_involutive,
        linear_map.sub_apply, linear_map.id_apply, bit0, linear_map.add_apply,
        linear_map.comp_apply, submodule.subtype_apply,
        continuous_linear_map.to_linear_map_eq_coe, continuous_linear_map.coe_coe],
      dsimp [w, v],
      abel, },
    { simp only [add_sub_cancel'_right, eq_self_iff_true], }
  end,
  ..reflection_linear_equiv K }
variables {K}
lemma reflection_apply (p : E) : reflection K p = bit0 â†‘(orthogonal_projection K p) - p := rfl
@[simp] lemma reflection_symm : (reflection K).symm = reflection K := rfl
@[simp] lemma reflection_inv : (reflection K)â»Â¹ = reflection K := rfl
variables (K)
@[simp] lemma reflection_reflection (p : E) : reflection K (reflection K p) = p :=
(reflection K).left_inv p
lemma reflection_involutive : function.involutive (reflection K) := reflection_reflection K
@[simp] lemma reflection_trans_reflection :
  (reflection K).trans (reflection K) = linear_isometry_equiv.refl ğ•œ E :=
linear_isometry_equiv.ext $ reflection_involutive K
@[simp] lemma reflection_mul_reflection : reflection K * reflection K = 1 :=
reflection_trans_reflection _
variables {K}
lemma reflection_eq_self_iff (x : E) : reflection K x = x â†” x âˆˆ K :=
begin
  rw [â†orthogonal_projection_eq_self_iff, reflection_apply, sub_eq_iff_eq_add', â† two_smul ğ•œ,
    â† two_smul' ğ•œ],
  refine (smul_right_injective E _).eq_iff,
  exact two_ne_zero
end
lemma reflection_mem_subspace_eq_self {x : E} (hx : x âˆˆ K) : reflection K x = x :=
(reflection_eq_self_iff x).mpr hx
lemma reflection_map_apply {E E' : Type*} [inner_product_space ğ•œ E] [inner_product_space ğ•œ E']
  (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (K : submodule ğ•œ E) [complete_space K] (x : E') :
  reflection (K.map (f.to_linear_equiv : E â†’â‚—[ğ•œ] E')) x = f (reflection K (f.symm x)) :=
by simp [bit0, reflection_apply, orthogonal_projection_map_apply f K x]
lemma reflection_map {E E' : Type*} [inner_product_space ğ•œ E] [inner_product_space ğ•œ E']
  (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (K : submodule ğ•œ E) [complete_space K] :
  reflection (K.map (f.to_linear_equiv : E â†’â‚—[ğ•œ] E')) = f.symm.trans ((reflection K).trans f) :=
linear_isometry_equiv.ext $ reflection_map_apply f K
@[simp] lemma reflection_bot : reflection (âŠ¥ : submodule ğ•œ E) = linear_isometry_equiv.neg ğ•œ :=
by ext; simp [reflection_apply]
end reflection
section orthogonal
lemma submodule.sup_orthogonal_inf_of_complete_space {Kâ‚ Kâ‚‚ : submodule ğ•œ E} (h : Kâ‚ â‰¤ Kâ‚‚)
  [complete_space Kâ‚] : Kâ‚ âŠ” (Kâ‚á—® âŠ“ Kâ‚‚) = Kâ‚‚ :=
begin
  ext x,
  rw submodule.mem_sup,
  let v : Kâ‚ := orthogonal_projection Kâ‚ x,
  have hvm : x - v âˆˆ Kâ‚á—® := sub_orthogonal_projection_mem_orthogonal x,
  split,
  { rintro âŸ¨y, hy, z, hz, rflâŸ©,
    exact Kâ‚‚.add_mem (h hy) hz.2 },
  { exact Î» hx, âŸ¨v, v.prop, x - v, âŸ¨hvm, Kâ‚‚.sub_mem hx (h v.prop)âŸ©, add_sub_cancel'_right _ _âŸ© }
end
variables {K}
lemma submodule.sup_orthogonal_of_complete_space [complete_space K] : K âŠ” Ká—® = âŠ¤ :=
begin
  convert submodule.sup_orthogonal_inf_of_complete_space (le_top : K â‰¤ âŠ¤),
  simp
end
variables (K)
lemma submodule.exists_sum_mem_mem_orthogonal [complete_space K] (v : E) :
  âˆƒ (y âˆˆ K) (z âˆˆ Ká—®), v = y + z :=
begin
  have h_mem : v âˆˆ K âŠ” Ká—® := by simp [submodule.sup_orthogonal_of_complete_space],
  obtain âŸ¨y, hy, z, hz, hyzâŸ© := submodule.mem_sup.mp h_mem,
  exact âŸ¨y, hy, z, hz, hyz.symmâŸ©
end
@[simp] lemma submodule.orthogonal_orthogonal [complete_space K] : Ká—®á—® = K :=
begin
  ext v,
  split,
  { obtain âŸ¨y, hy, z, hz, rflâŸ© := K.exists_sum_mem_mem_orthogonal v,
    intros hv,
    have hz' : z = 0,
    { have hyz : âŸªz, yâŸ« = 0 := by simp [hz y hy, inner_eq_zero_sym],
      simpa [inner_add_right, hyz] using hv z hz },
    simp [hy, hz'] },
  { intros hv w hw,
    rw inner_eq_zero_sym,
    exact hw v hv }
end
lemma submodule.orthogonal_orthogonal_eq_closure [complete_space E] :
  Ká—®á—® = K.topological_closure :=
begin
  refine le_antisymm _ _,
  { convert submodule.orthogonal_orthogonal_monotone K.submodule_topological_closure,
    haveI : complete_space K.topological_closure :=
      K.is_closed_topological_closure.complete_space_coe,
    rw K.topological_closure.orthogonal_orthogonal },
  { exact K.topological_closure_minimal K.le_orthogonal_orthogonal Ká—®.is_closed_orthogonal }
end
variables {K}
lemma submodule.is_compl_orthogonal_of_complete_space [complete_space K] : is_compl K Ká—® :=
âŸ¨K.orthogonal_disjoint, le_of_eq submodule.sup_orthogonal_of_complete_space.symmâŸ©
@[simp] lemma submodule.orthogonal_eq_bot_iff [complete_space (K : set E)] :
  Ká—® = âŠ¥ â†” K = âŠ¤ :=
begin
  refine âŸ¨_, Î» h, by rw [h, submodule.top_orthogonal_eq_bot] âŸ©,
  intro h,
  have : K âŠ” Ká—® = âŠ¤ := submodule.sup_orthogonal_of_complete_space,
  rwa [h, sup_comm, bot_sup_eq] at this,
end
lemma eq_orthogonal_projection_of_mem_orthogonal
  [complete_space K] {u v : E} (hv : v âˆˆ K) (hvo : u - v âˆˆ Ká—®) :
  (orthogonal_projection K u : E) = v :=
eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hv (Î» w, inner_eq_zero_sym.mp âˆ˜ (hvo w))
lemma eq_orthogonal_projection_of_mem_orthogonal'
  [complete_space K] {u v z : E} (hv : v âˆˆ K) (hz : z âˆˆ Ká—®) (hu : u = v + z) :
  (orthogonal_projection K u : E) = v :=
eq_orthogonal_projection_of_mem_orthogonal hv (by simpa [hu])
lemma orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero
  [complete_space K] {v : E} (hv : v âˆˆ Ká—®) :
  orthogonal_projection K v = 0 :=
by { ext, convert eq_orthogonal_projection_of_mem_orthogonal _ _; simp [hv] }
lemma reflection_mem_subspace_orthogonal_complement_eq_neg
  [complete_space K] {v : E} (hv : v âˆˆ Ká—®) :
  reflection K v = - v :=
by simp [reflection_apply, orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero hv]
lemma orthogonal_projection_mem_subspace_orthogonal_precomplement_eq_zero
  [complete_space E] {v : E} (hv : v âˆˆ K) :
  orthogonal_projection Ká—® v = 0 :=
orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero (K.le_orthogonal_orthogonal hv)
lemma reflection_mem_subspace_orthogonal_precomplement_eq_neg
  [complete_space E] {v : E} (hv : v âˆˆ K) :
  reflection Ká—® v = -v :=
reflection_mem_subspace_orthogonal_complement_eq_neg (K.le_orthogonal_orthogonal hv)
lemma orthogonal_projection_orthogonal_complement_singleton_eq_zero [complete_space E] (v : E) :
  orthogonal_projection (ğ•œ âˆ™ v)á—® v = 0 :=
orthogonal_projection_mem_subspace_orthogonal_precomplement_eq_zero
  (submodule.mem_span_singleton_self v)
lemma reflection_orthogonal_complement_singleton_eq_neg [complete_space E] (v : E) :
  reflection (ğ•œ âˆ™ v)á—® v = -v :=
reflection_mem_subspace_orthogonal_precomplement_eq_neg (submodule.mem_span_singleton_self v)
lemma reflection_sub [complete_space F] {v w : F} (h : âˆ¥vâˆ¥ = âˆ¥wâˆ¥) :
  reflection (â„ âˆ™ (v - w))á—® v = w :=
begin
  set R : F â‰ƒâ‚—áµ¢[â„] F := reflection (â„ âˆ™ (v - w))á—®,
  suffices : R v + R v = w + w,
  { apply smul_right_injective F (by norm_num : (2:â„) â‰  0),
    simpa [two_smul] using this },
  have hâ‚ : R (v - w) = -(v - w) := reflection_orthogonal_complement_singleton_eq_neg (v - w),
  have hâ‚‚ : R (v + w) = v + w,
  { apply reflection_mem_subspace_eq_self,
    apply mem_orthogonal_singleton_of_inner_left,
    rw real_inner_add_sub_eq_zero_iff,
    exact h },
  convert congr_arg2 (+) hâ‚‚ hâ‚ using 1,
  { simp },
  { abel }
end
variables (K)
lemma eq_sum_orthogonal_projection_self_orthogonal_complement
  [complete_space E] [complete_space K] (w : E) :
  w = (orthogonal_projection K w : E) + (orthogonal_projection Ká—® w : E) :=
begin
  obtain âŸ¨y, hy, z, hz, hwyzâŸ© := K.exists_sum_mem_mem_orthogonal w,
  convert hwyz,
  { exact eq_orthogonal_projection_of_mem_orthogonal' hy hz hwyz },
  { rw add_comm at hwyz,
    refine eq_orthogonal_projection_of_mem_orthogonal' hz _ hwyz,
    simp [hy] }
end
lemma norm_sq_eq_add_norm_sq_projection
  (x : E) (S : submodule ğ•œ E) [complete_space E] [complete_space S] :
  âˆ¥xâˆ¥^2 = âˆ¥orthogonal_projection S xâˆ¥^2 + âˆ¥orthogonal_projection Sá—® xâˆ¥^2 :=
begin
  let p1 := orthogonal_projection S,
  let p2 := orthogonal_projection Sá—®,
  have x_decomp : x = p1 x + p2 x :=
    eq_sum_orthogonal_projection_self_orthogonal_complement S x,
  have x_orth : âŸª p1 x, p2 x âŸ« = 0 :=
    submodule.inner_right_of_mem_orthogonal (set_like.coe_mem (p1 x)) (set_like.coe_mem (p2 x)),
  nth_rewrite 0 [x_decomp],
  simp only [sq, norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero ((p1 x) : E) (p2 x) x_orth,
             add_left_inj, mul_eq_mul_left_iff, norm_eq_zero, true_or, eq_self_iff_true,
             submodule.coe_norm, submodule.coe_eq_zero]
end
lemma id_eq_sum_orthogonal_projection_self_orthogonal_complement
  [complete_space E] [complete_space K] :
  continuous_linear_map.id ğ•œ E
  = K.subtypeL.comp (orthogonal_projection K)
  + Ká—®.subtypeL.comp (orthogonal_projection Ká—®) :=
by { ext w, exact eq_sum_orthogonal_projection_self_orthogonal_complement K w }
lemma inner_orthogonal_projection_left_eq_right [complete_space E]
  [complete_space K] (u v : E) :
  âŸªâ†‘(orthogonal_projection K u), vâŸ« = âŸªu, orthogonal_projection K vâŸ« :=
begin
  nth_rewrite 0 eq_sum_orthogonal_projection_self_orthogonal_complement K v,
  nth_rewrite 1 eq_sum_orthogonal_projection_self_orthogonal_complement K u,
  rw [inner_add_left, inner_add_right,
    submodule.inner_right_of_mem_orthogonal (submodule.coe_mem (orthogonal_projection K u))
      (submodule.coe_mem (orthogonal_projection Ká—® v)),
    submodule.inner_left_of_mem_orthogonal (submodule.coe_mem (orthogonal_projection K v))
      (submodule.coe_mem (orthogonal_projection Ká—® u))],
end
open finite_dimensional
lemma submodule.finrank_add_inf_finrank_orthogonal {Kâ‚ Kâ‚‚ : submodule ğ•œ E}
  [finite_dimensional ğ•œ Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) :
  finrank ğ•œ Kâ‚ + finrank ğ•œ (Kâ‚á—® âŠ“ Kâ‚‚ : submodule ğ•œ E) = finrank ğ•œ Kâ‚‚ :=
begin
  haveI := submodule.finite_dimensional_of_le h,
  haveI := proper_is_R_or_C ğ•œ Kâ‚,
  have hd := submodule.dim_sup_add_dim_inf_eq Kâ‚ (Kâ‚á—® âŠ“ Kâ‚‚),
  rw [â†inf_assoc, (submodule.orthogonal_disjoint Kâ‚).eq_bot, bot_inf_eq, finrank_bot,
      submodule.sup_orthogonal_inf_of_complete_space h] at hd,
  rw add_zero at hd,
  exact hd.symm
end
lemma submodule.finrank_add_inf_finrank_orthogonal' {Kâ‚ Kâ‚‚ : submodule ğ•œ E}
  [finite_dimensional ğ•œ Kâ‚‚] (h : Kâ‚ â‰¤ Kâ‚‚) {n : â„•} (h_dim : finrank ğ•œ Kâ‚ + n = finrank ğ•œ Kâ‚‚) :
  finrank ğ•œ (Kâ‚á—® âŠ“ Kâ‚‚ : submodule ğ•œ E) = n :=
by { rw â† add_right_inj (finrank ğ•œ Kâ‚),
     simp [submodule.finrank_add_inf_finrank_orthogonal h, h_dim] }
lemma submodule.finrank_add_finrank_orthogonal [finite_dimensional ğ•œ E] (K : submodule ğ•œ E) :
  finrank ğ•œ K + finrank ğ•œ Ká—® = finrank ğ•œ E :=
begin
  convert submodule.finrank_add_inf_finrank_orthogonal (le_top : K â‰¤ âŠ¤) using 1,
  { rw inf_top_eq },
  { simp }
end
lemma submodule.finrank_add_finrank_orthogonal' [finite_dimensional ğ•œ E] {K : submodule ğ•œ E} {n : â„•}
  (h_dim : finrank ğ•œ K + n = finrank ğ•œ E) :
  finrank ğ•œ Ká—® = n :=
by { rw â† add_right_inj (finrank ğ•œ K), simp [submodule.finrank_add_finrank_orthogonal, h_dim] }
local attribute [instance] fact_finite_dimensional_of_finrank_eq_succ
lemma finrank_orthogonal_span_singleton {n : â„•} [_i : fact (finrank ğ•œ E = n + 1)]
  {v : E} (hv : v â‰  0) :
  finrank ğ•œ (ğ•œ âˆ™ v)á—® = n :=
submodule.finrank_add_finrank_orthogonal' $ by simp [finrank_span_singleton hv, _i.elim, add_comm]
lemma linear_isometry_equiv.reflections_generate_dim_aux [finite_dimensional â„ F] {n : â„•}
  (Ï† : F â‰ƒâ‚—áµ¢[â„] F)
  (hn : finrank â„ (continuous_linear_map.id â„ F - Ï†.to_continuous_linear_equiv).kerá—® â‰¤ n) :
  âˆƒ l : list F, l.length â‰¤ n âˆ§ Ï† = (l.map (Î» v, reflection (â„ âˆ™ v)á—®)).prod :=
begin
lemma linear_isometry_equiv.reflections_generate_dim [finite_dimensional â„ F] (Ï† : F â‰ƒâ‚—áµ¢[â„] F) :
  âˆƒ l : list F, l.length â‰¤ finrank â„ F âˆ§ Ï† = (l.map (Î» v, reflection (â„ âˆ™ v)á—®)).prod :=
let âŸ¨l, hlâ‚, hlâ‚‚âŸ© := Ï†.reflections_generate_dim_aux le_rfl in
âŸ¨l, hlâ‚.trans (submodule.finrank_le _), hlâ‚‚âŸ©
lemma linear_isometry_equiv.reflections_generate [finite_dimensional â„ F] :
  subgroup.closure (set.range (Î» v : F, reflection (â„ âˆ™ v)á—®)) = âŠ¤ :=
begin
  rw subgroup.eq_top_iff',
  intros Ï†,
  rcases Ï†.reflections_generate_dim with âŸ¨l, _, rflâŸ©,
  apply (subgroup.closure _).list_prod_mem,
  intros x hx,
  rcases list.mem_map.mp hx with âŸ¨a, _, haxâŸ©,
  exact subgroup.subset_closure âŸ¨a, haxâŸ©,
end
end orthogonal
section orthogonal_family
variables {Î¹ : Type*}
lemma orthogonal_family.is_internal_iff_of_is_complete [decidable_eq Î¹]
  {V : Î¹ â†’ submodule ğ•œ E} (hV : @orthogonal_family ğ•œ _ _ _ _ (Î» i, V i) _ (Î» i, (V i).subtypeâ‚—áµ¢))
  (hc : is_complete (â†‘(supr V) : set E)) :
  direct_sum.is_internal V â†” (supr V)á—® = âŠ¥ :=
begin
  haveI : complete_space â†¥(supr V) := hc.complete_space_coe,
  simp only [direct_sum.is_internal_submodule_iff_independent_and_supr_eq_top, hV.independent,
    true_and, submodule.orthogonal_eq_bot_iff]
end
lemma orthogonal_family.is_internal_iff [decidable_eq Î¹] [finite_dimensional ğ•œ E]
  {V : Î¹ â†’ submodule ğ•œ E} (hV : @orthogonal_family ğ•œ _ _ _ _ (Î» i, V i) _ (Î» i, (V i).subtypeâ‚—áµ¢)) :
  direct_sum.is_internal V â†” (supr V)á—® = âŠ¥ :=
begin
  haveI h := finite_dimensional.proper_is_R_or_C ğ•œ â†¥(supr V),
  exact hV.is_internal_iff_of_is_complete
    (complete_space_coe_iff_is_complete.mp infer_instance)
end
end orthogonal_family
section orthonormal_basis
variables {ğ•œ E} {v : set E}
open finite_dimensional submodule set
lemma maximal_orthonormal_iff_orthogonal_complement_eq_bot (hv : orthonormal ğ•œ (coe : v â†’ E)) :
  (âˆ€ u âŠ‡ v, orthonormal ğ•œ (coe : u â†’ E) â†’ u = v) â†” (span ğ•œ v)á—® = âŠ¥ :=
begin
  rw submodule.eq_bot_iff,
  split,
  { contrapose!,
lemma maximal_orthonormal_iff_basis_of_finite_dimensional
  (hv : orthonormal ğ•œ (coe : v â†’ E)) :
  (âˆ€ u âŠ‡ v, orthonormal ğ•œ (coe : u â†’ E) â†’ u = v) â†” âˆƒ b : basis v ğ•œ E, â‡‘b = coe :=
begin
  haveI := proper_is_R_or_C ğ•œ (span ğ•œ v),
  rw maximal_orthonormal_iff_orthogonal_complement_eq_bot hv,
  have hv_compl : is_complete (span ğ•œ v : set E) := (span ğ•œ v).complete_of_finite_dimensional,
  rw submodule.orthogonal_eq_bot_iff,
  have hv_coe : range (coe : v â†’ E) = v := by simp,
  split,
  { refine Î» h, âŸ¨basis.mk hv.linear_independent _, basis.coe_mk _ _âŸ©,
    convert h },
  { rintros âŸ¨h, coe_hâŸ©,
    rw [â† h.span_eq, coe_h, hv_coe] }
end
lemma exists_subset_is_orthonormal_basis
  (hv : orthonormal ğ•œ (coe : v â†’ E)) :
  âˆƒ (u âŠ‡ v) (b : basis u ğ•œ E), orthonormal ğ•œ b âˆ§ â‡‘b = coe :=
begin
  obtain âŸ¨u, hus, hu, hu_maxâŸ© := exists_maximal_orthonormal hv,
  obtain âŸ¨b, hbâŸ© := (maximal_orthonormal_iff_basis_of_finite_dimensional hu).mp hu_max,
  exact âŸ¨u, hus, b, by rwa hb, hbâŸ©
end
variables (ğ•œ E)
def orthonormal_basis_index : set E :=
classical.some (exists_subset_is_orthonormal_basis (orthonormal_empty ğ•œ E))
def std_orthonormal_basis :
  basis (orthonormal_basis_index ğ•œ E) ğ•œ E :=
(exists_subset_is_orthonormal_basis (orthonormal_empty ğ•œ E)).some_spec.some_spec.some
lemma std_orthonormal_basis_orthonormal :
  orthonormal ğ•œ (std_orthonormal_basis ğ•œ E) :=
(exists_subset_is_orthonormal_basis (orthonormal_empty ğ•œ E)).some_spec.some_spec.some_spec.1
@[simp] lemma coe_std_orthonormal_basis :
  â‡‘(std_orthonormal_basis ğ•œ E) = coe :=
(exists_subset_is_orthonormal_basis (orthonormal_empty ğ•œ E)).some_spec.some_spec.some_spec.2
instance : fintype (orthonormal_basis_index ğ•œ E) :=
@is_noetherian.fintype_basis_index _ _ _ _ _ _
  (is_noetherian.iff_fg.2 infer_instance) (std_orthonormal_basis ğ•œ E)
variables {ğ•œ E}
def fin_std_orthonormal_basis {n : â„•} (hn : finrank ğ•œ E = n) :
  basis (fin n) ğ•œ E :=
have h : fintype.card (orthonormal_basis_index ğ•œ E) = n,
by rw [â† finrank_eq_card_basis (std_orthonormal_basis ğ•œ E), hn],
(std_orthonormal_basis ğ•œ E).reindex (fintype.equiv_fin_of_card_eq h)
lemma fin_std_orthonormal_basis_orthonormal {n : â„•} (hn : finrank ğ•œ E = n) :
  orthonormal ğ•œ (fin_std_orthonormal_basis hn) :=
suffices orthonormal ğ•œ (std_orthonormal_basis _ _ âˆ˜ equiv.symm _),
@[irreducible] def direct_sum.is_internal.sigma_orthonormal_basis_index_equiv :
  (Î£ i, orthonormal_basis_index ğ•œ (V i)) â‰ƒ fin n :=
let b := hV.collected_basis (Î» i, std_orthonormal_basis ğ•œ (V i)) in
fintype.equiv_fin_of_card_eq $ (finite_dimensional.finrank_eq_card_basis b).symm.trans hn
@[irreducible] def direct_sum.is_internal.subordinate_orthonormal_basis :
  basis (fin n) ğ•œ E :=
(hV.collected_basis (Î» i, std_orthonormal_basis ğ•œ (V i))).reindex
  (hV.sigma_orthonormal_basis_index_equiv hn)
def direct_sum.is_internal.subordinate_orthonormal_basis_index (a : fin n) : Î¹ :=
((hV.sigma_orthonormal_basis_index_equiv hn).symm a).1
lemma direct_sum.is_internal.subordinate_orthonormal_basis_orthonormal
  (hV' : @orthogonal_family ğ•œ _ _ _ _ (Î» i, V i) _ (Î» i, (V i).subtypeâ‚—áµ¢)) :
  orthonormal ğ•œ (hV.subordinate_orthonormal_basis hn) :=
begin
  simp only [direct_sum.is_internal.subordinate_orthonormal_basis, basis.coe_reindex],
  have : orthonormal ğ•œ (hV.collected_basis (Î» i, std_orthonormal_basis ğ•œ (V i))) :=
    hV.collected_basis_orthonormal hV' (Î» i, std_orthonormal_basis_orthonormal ğ•œ (V i)),
  exact this.comp _ (equiv.injective _),
end
lemma direct_sum.is_internal.subordinate_orthonormal_basis_subordinate (a : fin n) :
  hV.subordinate_orthonormal_basis hn a âˆˆ V (hV.subordinate_orthonormal_basis_index hn a) :=
by simpa only [direct_sum.is_internal.subordinate_orthonormal_basis, basis.coe_reindex]
  using hV.collected_basis_mem (Î» i, std_orthonormal_basis ğ•œ (V i))
    ((hV.sigma_orthonormal_basis_index_equiv hn).symm a)
attribute [irreducible] direct_sum.is_internal.subordinate_orthonormal_basis_index
end subordinate_orthonormal_basis
end finite_dimensional
end orthonormal_basis
