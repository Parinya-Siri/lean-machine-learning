import category_theory.limits.kan_extension
import category_theory.adjunction
import topology.category.Top.opens
universes w v u
open category_theory
open topological_space
open opposite
variables (C : Type u) [category.{v} C]
namespace Top
@[derive category, nolint has_inhabited_instance]
def presheaf (X : Top.{w}) := (opens X)áµ’áµ– â¥¤ C
variables {C}
namespace presheaf
def pushforward_obj {X Y : Top.{w}} (f : X âŸ¶ Y) (â„± : X.presheaf C) : Y.presheaf C :=
(opens.map f).op â‹™ â„±
infix ` _* `: 80 := pushforward_obj
@[simp] lemma pushforward_obj_obj {X Y : Top.{w}} (f : X âŸ¶ Y) (â„± : X.presheaf C) (U : (opens Y)áµ’áµ–) :
  (f _* â„±).obj U = â„±.obj ((opens.map f).op.obj U) := rfl
@[simp] lemma pushforward_obj_map {X Y : Top.{w}} (f : X âŸ¶ Y) (â„± : X.presheaf C)
  {U V : (opens Y)áµ’áµ–} (i : U âŸ¶ V) :
  (f _* â„±).map i = â„±.map ((opens.map f).op.map i) := rfl
def pushforward_eq {X Y : Top.{w}} {f g : X âŸ¶ Y} (h : f = g) (â„± : X.presheaf C) :
  f _* â„± â‰… g _* â„± :=
iso_whisker_right (nat_iso.op (opens.map_iso f g h).symm) â„±
lemma pushforward_eq' {X Y : Top.{w}} {f g : X âŸ¶ Y} (h : f = g) (â„± : X.presheaf C) :
  f _* â„± = g _* â„± :=
by rw h
@[simp] lemma pushforward_eq_hom_app
  {X Y : Top.{w}} {f g : X âŸ¶ Y} (h : f = g) (â„± : X.presheaf C) (U) :
  (pushforward_eq h â„±).hom.app U =
    â„±.map (begin dsimp [functor.op], apply quiver.hom.op, apply eq_to_hom, rw h, end) :=
by simp [pushforward_eq]
lemma pushforward_eq'_hom_app
  {X Y : Top.{w}} {f g : X âŸ¶ Y} (h : f = g) (â„± : X.presheaf C) (U) :
  nat_trans.app (eq_to_hom (pushforward_eq' h â„±)) U = â„±.map (eq_to_hom (by rw h)) :=
by simpa [eq_to_hom_map]
@[simp]
lemma pushforward_eq_rfl {X Y : Top.{w}} (f : X âŸ¶ Y) (â„± : X.presheaf C) (U) :
  (pushforward_eq (rfl : f = f) â„±).hom.app (op U) = ğŸ™ _ :=
begin
  dsimp [pushforward_eq],
  simp,
end
lemma pushforward_eq_eq {X Y : Top.{w}} {f g : X âŸ¶ Y} (hâ‚ hâ‚‚ : f = g) (â„± : X.presheaf C) :
  â„±.pushforward_eq hâ‚ = â„±.pushforward_eq hâ‚‚ :=
rfl
namespace pushforward
variables {X : Top.{w}} (â„± : X.presheaf C)
def id : (ğŸ™ X) _* â„± â‰… â„± :=
(iso_whisker_right (nat_iso.op (opens.map_id X).symm) â„±) â‰ªâ‰« functor.left_unitor _
lemma id_eq : (ğŸ™ X) _* â„± = â„± :=
by { unfold pushforward_obj, rw opens.map_id_eq, erw functor.id_comp }
@[simp] lemma id_hom_app' (U) (p) :
  (id â„±).hom.app (op âŸ¨U, pâŸ©) = â„±.map (ğŸ™ (op âŸ¨U, pâŸ©)) :=
by { dsimp [id], simp, }
local attribute [tidy] tactic.op_induction'
@[simp, priority 990] lemma id_hom_app (U) :
  (id â„±).hom.app U = â„±.map (eq_to_hom (opens.op_map_id_obj U)) := by tidy
@[simp] lemma id_inv_app' (U) (p) : (id â„±).inv.app (op âŸ¨U, pâŸ©) = â„±.map (ğŸ™ (op âŸ¨U, pâŸ©)) :=
by { dsimp [id], simp, }
def comp {Y Z : Top.{w}} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : (f â‰« g) _* â„± â‰… g _* (f _* â„±) :=
iso_whisker_right (nat_iso.op (opens.map_comp f g).symm) â„±
lemma comp_eq {Y Z : Top.{w}} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : (f â‰« g) _* â„± = g _* (f _* â„±) :=
rfl
@[simp] lemma comp_hom_app {Y Z : Top.{w}} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) :
  (comp â„± f g).hom.app U = ğŸ™ _ :=
by { dsimp [comp], tidy, }
@[simp] lemma comp_inv_app {Y Z : Top.{w}} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) :
  (comp â„± f g).inv.app U = ğŸ™ _ :=
by { dsimp [comp], tidy, }
end pushforward
@[simps]
def pushforward_map {X Y : Top.{w}} (f : X âŸ¶ Y) {â„± ğ’¢ : X.presheaf C} (Î± : â„± âŸ¶ ğ’¢) :
  f _* â„± âŸ¶ f _* ğ’¢ :=
{ app := Î» U, Î±.app _,
  naturality' := Î» U V i, by { erw Î±.naturality, refl, } }
open category_theory.limits
section pullback
variable [has_colimits C]
noncomputable theory
@[simps]
def pullback_obj {X Y : Top.{v}} (f : X âŸ¶ Y) (â„± : Y.presheaf C) : X.presheaf C :=
(Lan (opens.map f).op).obj â„±
def pullback_map {X Y : Top.{v}} (f : X âŸ¶ Y) {â„± ğ’¢ : Y.presheaf C} (Î± : â„± âŸ¶ ğ’¢) :
  pullback_obj f â„± âŸ¶ pullback_obj f ğ’¢ :=
(Lan (opens.map f).op).map Î±
@[simps]
def pullback_obj_obj_of_image_open {X Y : Top.{v}} (f : X âŸ¶ Y) (â„± : Y.presheaf C) (U : opens X)
  (H : is_open (f '' U)) : (pullback_obj f â„±).obj (op U) â‰… â„±.obj (op âŸ¨_, HâŸ©) :=
begin
  let x : costructured_arrow (opens.map f).op (op U) :=
  { left := op âŸ¨f '' U, HâŸ©,
    hom := ((@hom_of_le _ _ _ ((opens.map f).obj âŸ¨_, HâŸ©) (set.image_preimage.le_u_l _)).op :
    op ((opens.map f).obj (âŸ¨â‡‘f '' â†‘U, HâŸ©)) âŸ¶ op U) },
  have hx : is_terminal x :=
  { lift := Î» s,
    begin
      fapply costructured_arrow.hom_mk,
      change op (unop _) âŸ¶ op (âŸ¨_, HâŸ© : opens _),
      refine (hom_of_le _).op,
      exact (set.image_subset f s.X.hom.unop.le).trans (set.image_preimage.l_u_le â†‘(unop s.X.left)),
      simp
    end },
  exact is_colimit.cocone_point_unique_up_to_iso
    (colimit.is_colimit _)
    (colimit_of_diagram_terminal hx _),
end
namespace pullback
variables {X Y : Top.{v}} (â„± : Y.presheaf C)
def id : pullback_obj (ğŸ™ _) â„± â‰… â„± :=
nat_iso.of_components
  (Î» U, pullback_obj_obj_of_image_open (ğŸ™ _) â„± (unop U) (by simpa using U.unop.2) â‰ªâ‰«
    â„±.map_iso (eq_to_iso (by simp)))
  (Î» U V i,
  begin
      ext, simp,
      erw colimit.pre_desc_assoc,
      erw colimit.Î¹_desc_assoc,
      erw colimit.Î¹_desc_assoc,
      dsimp, simp only [â†â„±.map_comp], congr
  end)
lemma id_inv_app (U : opens Y) :
  (id â„±).inv.app (op U) = colimit.Î¹ (Lan.diagram (opens.map (ğŸ™ Y)).op â„± (op U))
    (@costructured_arrow.mk _ _ _ _ _ (op U) _ (eq_to_hom (by simp))) :=
begin
  dsimp[id], simp, dsimp[colimit_of_diagram_terminal],
  delta Lan.diagram,
  refine eq.trans _ (category.id_comp _),
  rw â† â„±.map_id,
  congr,
  any_goals { apply subsingleton.helim },
  all_goals { simp }
end
end pullback
end pullback
variable (C)
def pushforward {X Y : Top.{v}} (f : X âŸ¶ Y) : X.presheaf C â¥¤ Y.presheaf C :=
{ obj := pushforward_obj f,
  map := @pushforward_map _ _ X Y f }
@[simp]
lemma pushforward_map_app' {X Y : Top.{v}} (f : X âŸ¶ Y)
  {â„± ğ’¢ : X.presheaf C} (Î± : â„± âŸ¶ ğ’¢) {U : (opens Y)áµ’áµ–} :
  ((pushforward C f).map Î±).app U = Î±.app (op $ (opens.map f).obj U.unop) := rfl
lemma id_pushforward {X : Top.{v}} : pushforward C (ğŸ™ X) = ğŸ­ (X.presheaf C) :=
begin
  apply category_theory.functor.ext,
  { intros,
    ext U,
    have h := f.congr, erw h (opens.op_map_id_obj U),
    simpa [eq_to_hom_map], },
  { intros, apply pushforward.id_eq },
end
section iso
@[simps] def presheaf_equiv_of_iso {X Y : Top} (H : X â‰… Y) :
  X.presheaf C â‰Œ Y.presheaf C :=
equivalence.congr_left (opens.map_map_iso H).symm.op
variable {C}
def to_pushforward_of_iso {X Y : Top} (H : X â‰… Y) {â„± : X.presheaf C} {ğ’¢ : Y.presheaf C}
  (Î± : H.hom _* â„± âŸ¶ ğ’¢) : â„± âŸ¶ H.inv _* ğ’¢ :=
(presheaf_equiv_of_iso _ H).to_adjunction.hom_equiv â„± ğ’¢ Î±
@[simp]
lemma to_pushforward_of_iso_app {X Y : Top} (Hâ‚ : X â‰… Y) {â„± : X.presheaf C} {ğ’¢ : Y.presheaf C}
  (Hâ‚‚ : Hâ‚.hom _* â„± âŸ¶ ğ’¢) (U : (opens X)áµ’áµ–) :
(to_pushforward_of_iso Hâ‚ Hâ‚‚).app U =
  â„±.map (eq_to_hom (by simp [opens.map, set.preimage_preimage])) â‰«
  Hâ‚‚.app (op ((opens.map Hâ‚.inv).obj (unop U))) :=
begin
  delta to_pushforward_of_iso,
  simp only [equiv.to_fun_as_coe, nat_trans.comp_app, equivalence.equivalence_mk'_unit,
    eq_to_hom_map, eq_to_hom_op, eq_to_hom_trans, presheaf_equiv_of_iso_unit_iso_hom_app_app,
    equivalence.to_adjunction, equivalence.equivalence_mk'_counit,
    presheaf_equiv_of_iso_inverse_map_app, adjunction.mk_of_unit_counit_hom_equiv_apply],
  congr,
end
def pushforward_to_of_iso {X Y : Top} (Hâ‚ : X â‰… Y) {â„± : Y.presheaf C} {ğ’¢ : X.presheaf C}
  (Hâ‚‚ : â„± âŸ¶ Hâ‚.hom _* ğ’¢) : Hâ‚.inv _* â„± âŸ¶ ğ’¢ :=
((presheaf_equiv_of_iso _ Hâ‚.symm).to_adjunction.hom_equiv â„± ğ’¢).symm Hâ‚‚
@[simp]
lemma pushforward_to_of_iso_app {X Y : Top} (Hâ‚ : X â‰… Y) {â„± : Y.presheaf C} {ğ’¢ : X.presheaf C}
  (Hâ‚‚ : â„± âŸ¶ Hâ‚.hom _* ğ’¢) (U : (opens X)áµ’áµ–) :
(pushforward_to_of_iso Hâ‚ Hâ‚‚).app U =
  Hâ‚‚.app (op ((opens.map Hâ‚.inv).obj (unop U))) â‰«
  ğ’¢.map (eq_to_hom (by simp [opens.map, set.preimage_preimage])) :=
by simpa [pushforward_to_of_iso, equivalence.to_adjunction]
end iso
variables (C) [has_colimits C]
@[simps map_app]
def pullback {X Y : Top.{v}} (f : X âŸ¶ Y) : Y.presheaf C â¥¤ X.presheaf C := Lan (opens.map f).op
@[simp] lemma pullback_obj_eq_pullback_obj {C} [category C] [has_colimits C] {X Y : Top.{w}}
  (f : X âŸ¶ Y) (â„± : Y.presheaf C) : (pullback C f).obj â„± = pullback_obj f â„± := rfl
@[simps unit_app_app counit_app_app]
def pushforward_pullback_adjunction {X Y : Top.{v}} (f : X âŸ¶ Y) :
  pullback C f âŠ£ pushforward C f := Lan.adjunction _ _
def pullback_hom_iso_pushforward_inv {X Y : Top.{v}} (H : X â‰… Y) :
  pullback C H.hom â‰… pushforward C H.inv :=
adjunction.left_adjoint_uniq
  (pushforward_pullback_adjunction C H.hom)
  (presheaf_equiv_of_iso C H.symm).to_adjunction
def pullback_inv_iso_pushforward_hom {X Y : Top.{v}} (H : X â‰… Y) :
  pullback C H.inv â‰… pushforward C H.hom :=
adjunction.left_adjoint_uniq
  (pushforward_pullback_adjunction C H.inv)
  (presheaf_equiv_of_iso C H).to_adjunction
end presheaf
end Top
