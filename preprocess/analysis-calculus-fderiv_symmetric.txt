import analysis.calculus.deriv
import analysis.calculus.mean_value
import analysis.convex.topology
open asymptotics set
open_locale topological_space
variables {E F : Type*} [normed_group E] [normed_space â„ E]
[normed_group F] [normed_space â„ F]
{s : set E} (s_conv : convex â„ s)
{f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] (E â†’L[â„] F)}
(hf : âˆ€ x âˆˆ interior s, has_fderiv_at f (f' x) x)
{x : E} (xs : x âˆˆ s) (hx : has_fderiv_within_at f' f'' (interior s) x)
include s_conv xs hx hf
lemma convex.taylor_approx_two_segment
  {v w : E} (hv : x + v âˆˆ interior s) (hw : x + v + w âˆˆ interior s) :
  (Î» h : â„, f (x + h â€¢ v + h â€¢ w) - f (x + h â€¢ v) - h â€¢ f' x w
    - h^2 â€¢ f'' v w - (h^2/2) â€¢ f'' w w) =o[ğ“[>] 0] (Î» h, h^2) :=
begin
lemma convex.is_o_alternate_sum_square
  {v w : E} (h4v : x + (4 : â„) â€¢ v âˆˆ interior s) (h4w : x + (4 : â„) â€¢ w âˆˆ interior s) :
  (Î» h : â„, f (x + h â€¢ (2 â€¢ v + 2 â€¢ w)) + f (x + h â€¢ (v + w))
    - f (x + h â€¢ (2 â€¢ v + w)) - f (x + h â€¢ (v + 2 â€¢ w)) - h^2 â€¢ f'' v w) =o[ğ“[>] 0] (Î» h, h^2) :=
begin
  have A : (1 : â„)/2 âˆˆ Ioc (0 : â„) 1 := âŸ¨by norm_num, by norm_numâŸ©,
  have B : (1 : â„)/2 âˆˆ Icc (0 : â„) 1 := âŸ¨by norm_num, by norm_numâŸ©,
  have C : âˆ€ (w : E), (2 : â„) â€¢ w = 2 â€¢ w := Î» w, by simp only [two_smul],
  have h2v2w : x + (2 : â„) â€¢ v + (2 : â„) â€¢ w âˆˆ interior s,
  { convert s_conv.interior.add_smul_sub_mem h4v h4w B using 1,
    simp only [smul_sub, smul_smul, one_div, add_sub_add_left_eq_sub, mul_add, add_smul],
    norm_num,
    simp only [show (4 : â„) = (2 : â„) + (2 : â„), by norm_num, add_smul],
    abel },
  have h2vww : x + (2 â€¢ v + w) + w âˆˆ interior s,
  { convert h2v2w using 1,
    simp only [two_smul],
    abel },
  have h2v : x + (2 : â„) â€¢ v âˆˆ interior s,
  { convert s_conv.add_smul_sub_mem_interior xs h4v A using 1,
    simp only [smul_smul, one_div, add_sub_cancel', add_right_inj],
    norm_num },
  have h2w : x + (2 : â„) â€¢ w âˆˆ interior s,
  { convert s_conv.add_smul_sub_mem_interior xs h4w A using 1,
    simp only [smul_smul, one_div, add_sub_cancel', add_right_inj],
    norm_num },
  have hvw : x + (v + w) âˆˆ interior s,
  { convert s_conv.add_smul_sub_mem_interior xs h2v2w A using 1,
    simp only [smul_smul, one_div, add_sub_cancel', add_right_inj, smul_add, smul_sub],
    norm_num,
    abel },
  have h2vw : x + (2 â€¢ v + w) âˆˆ interior s,
  { convert s_conv.interior.add_smul_sub_mem h2v h2v2w B using 1,
    simp only [smul_add, smul_sub, smul_smul, â† C],
    norm_num,
    abel },
  have hvww : x + (v + w) + w âˆˆ interior s,
  { convert s_conv.interior.add_smul_sub_mem h2w h2v2w B using 1,
    simp only [one_div, add_sub_cancel', inv_smul_smulâ‚€, add_sub_add_right_eq_sub, ne.def,
      not_false_iff, bit0_eq_zero, one_ne_zero],
    rw two_smul,
    abel },
  have TA1 := s_conv.taylor_approx_two_segment hf xs hx h2vw h2vww,
  have TA2 := s_conv.taylor_approx_two_segment hf xs hx hvw hvww,
  convert TA1.sub TA2,
  ext h,
  simp only [two_smul, smul_add, â† add_assoc, continuous_linear_map.map_add,
    continuous_linear_map.add_apply, pi.smul_apply,
    continuous_linear_map.coe_smul', continuous_linear_map.map_smul],
  abel,
end
lemma convex.second_derivative_within_at_symmetric_of_mem_interior
  {v w : E} (h4v : x + (4 : â„) â€¢ v âˆˆ interior s) (h4w : x + (4 : â„) â€¢ w âˆˆ interior s) :
  f'' w v = f'' v w :=
begin
  have A : (Î» h : â„, h^2 â€¢ (f'' w v- f'' v w)) =o[ğ“[>] 0] (Î» h, h^2),
  { convert (s_conv.is_o_alternate_sum_square hf xs hx h4v h4w).sub
            (s_conv.is_o_alternate_sum_square hf xs hx h4w h4v),
    ext h,
    simp only [add_comm, smul_add, smul_sub],
    abel },
  have B : (Î» h : â„, f'' w v - f'' v w) =o[ğ“[>] 0] (Î» h, (1 : â„)),
  { have : (Î» h : â„, 1/h^2) =O[ğ“[>] 0] (Î» h, 1/h^2) := is_O_refl _ _,
    have C := this.smul_is_o A,
    apply C.congr' _ _,
    { filter_upwards [self_mem_nhds_within],
      assume h hpos,
      rw [â† one_smul â„ (f'' w v - f'' v w), smul_smul, smul_smul],
      congr' 1,
      field_simp [has_lt.lt.ne' hpos] },
    { filter_upwards [self_mem_nhds_within] with _ hpos,
      field_simp [has_lt.lt.ne' hpos, has_smul.smul], }, },
  simpa only [sub_eq_zero] using is_o_const_const_iff.1 B,
end
omit s_conv xs hx hf
theorem convex.second_derivative_within_at_symmetric
  {s : set E} (s_conv : convex â„ s) (hne : (interior s).nonempty)
  {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] (E â†’L[â„] F)}
  (hf : âˆ€ x âˆˆ interior s, has_fderiv_at f (f' x) x)
  {x : E} (xs : x âˆˆ s) (hx : has_fderiv_within_at f' f'' (interior s) x) (v w : E) :
  f'' v w = f'' w v :=
begin
  rcases hne with âŸ¨y, hyâŸ©,
  obtain âŸ¨z, hzâŸ© : âˆƒ z, z = ((1:â„) / 4) â€¢ (y - x) := âŸ¨((1:â„) / 4) â€¢ (y - x), rflâŸ©,
  have A : âˆ€ (m : E), filter.tendsto (Î» (t : â„), x + (4 : â„) â€¢ (z + t â€¢ m)) (ğ“ 0) (ğ“ y),
  { assume m,
    have : x + (4 : â„) â€¢ (z + (0 : â„) â€¢ m) = y, by simp [hz],
    rw â† this,
    refine tendsto_const_nhds.add _,
    refine tendsto_const_nhds.smul _,
    refine tendsto_const_nhds.add _,
    exact continuous_at_id.smul continuous_at_const },
  have B : âˆ€ (m : E), âˆ€á¶  t in ğ“[>] (0 : â„), x + (4 : â„) â€¢ (z + t â€¢ m) âˆˆ interior s,
  { assume m,
    apply nhds_within_le_nhds,
    apply A m,
    rw [mem_interior_iff_mem_nhds] at hy,
    exact interior_mem_nhds.2 hy },
theorem second_derivative_symmetric_of_eventually
  {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] (E â†’L[â„] F)}
  (hf : âˆ€á¶  y in ğ“ x, has_fderiv_at f (f' y) y)
  (hx : has_fderiv_at f' f'' x) (v w : E) :
  f'' v w = f'' w v :=
begin
  rcases metric.mem_nhds_iff.1 hf with âŸ¨Îµ, Îµpos, hÎµâŸ©,
  have A : (interior (metric.ball x Îµ)).nonempty,
    by rwa [metric.is_open_ball.interior_eq, metric.nonempty_ball],
  exact convex.second_derivative_within_at_symmetric (convex_ball x Îµ) A
    (Î» y hy, hÎµ (interior_subset hy)) (metric.mem_ball_self Îµpos) hx.has_fderiv_within_at v w,
end
theorem second_derivative_symmetric
  {f : E â†’ F} {f' : E â†’ (E â†’L[â„] F)} {f'' : E â†’L[â„] (E â†’L[â„] F)}
  (hf : âˆ€ y, has_fderiv_at f (f' y) y)
  (hx : has_fderiv_at f' f'' x) (v w : E) :
  f'' v w = f'' w v :=
second_derivative_symmetric_of_eventually (filter.eventually_of_forall hf) hx v w
