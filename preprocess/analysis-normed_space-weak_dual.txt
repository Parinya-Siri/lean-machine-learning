import topology.algebra.module.weak_dual
import analysis.normed_space.dual
import analysis.normed_space.operator_norm
noncomputable theory
open filter function metric set
open_locale topological_space filter
variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
variables {E : Type*} [semi_normed_group E] [normed_space ğ•œ E]
namespace normed_space
namespace dual
def to_weak_dual : dual ğ•œ E â‰ƒâ‚—[ğ•œ] weak_dual ğ•œ E := linear_equiv.refl ğ•œ (E â†’L[ğ•œ] ğ•œ)
@[simp] lemma coe_to_weak_dual (x' : dual ğ•œ E) : â‡‘(x'.to_weak_dual) = x' := rfl
@[simp] lemma to_weak_dual_eq_iff (x' y' : dual ğ•œ E) :
  x'.to_weak_dual = y'.to_weak_dual â†” x' = y' :=
to_weak_dual.injective.eq_iff
theorem to_weak_dual_continuous : continuous (Î» (x' : dual ğ•œ E), x'.to_weak_dual) :=
weak_bilin.continuous_of_continuous_eval _ $ Î» z, (inclusion_in_double_dual ğ•œ E z).continuous
def continuous_linear_map_to_weak_dual : dual ğ•œ E â†’L[ğ•œ] weak_dual ğ•œ E :=
{ cont := to_weak_dual_continuous, .. to_weak_dual, }
theorem dual_norm_topology_le_weak_dual_topology :
  (by apply_instance : topological_space (dual ğ•œ E)) â‰¤
    (by apply_instance : topological_space (weak_dual ğ•œ E)) :=
by { convert to_weak_dual_continuous.le_induced, exact induced_id.symm }
end dual
end normed_space
namespace weak_dual
open normed_space
def to_normed_dual : weak_dual ğ•œ E â‰ƒâ‚—[ğ•œ] dual ğ•œ E := normed_space.dual.to_weak_dual.symm
lemma to_normed_dual_apply (x : weak_dual ğ•œ E) (y : E) : (to_normed_dual x) y = x y := rfl
@[simp] lemma coe_to_normed_dual (x' : weak_dual ğ•œ E) : â‡‘(x'.to_normed_dual) = x' := rfl
@[simp] lemma to_normed_dual_eq_iff (x' y' : weak_dual ğ•œ E) :
  x'.to_normed_dual = y'.to_normed_dual â†” x' = y' :=
weak_dual.to_normed_dual.injective.eq_iff
lemma is_closed_closed_ball (x' : dual ğ•œ E) (r : â„) :
  is_closed (to_normed_dual â»Â¹' closed_ball x' r) :=
is_closed_induced_iff'.2 (continuous_linear_map.is_weak_closed_closed_ball x' r)
variables (ğ•œ)
def polar (s : set E) : set (weak_dual ğ•œ E) := to_normed_dual â»Â¹' polar ğ•œ s
lemma polar_def (s : set E) : polar ğ•œ s = {f : weak_dual ğ•œ E | âˆ€ x âˆˆ s, âˆ¥f xâˆ¥ â‰¤ 1} := rfl
lemma is_closed_polar (s : set E) : is_closed (polar ğ•œ s) :=
begin
  simp only [polar_def, set_of_forall],
  exact is_closed_bInter (Î» x hx, is_closed_Iic.preimage (weak_bilin.eval_continuous _ _).norm)
end
variable {ğ•œ}
lemma is_closed_image_coe_of_bounded_of_closed {s : set (weak_dual ğ•œ E)}
  (hb : bounded (dual.to_weak_dual â»Â¹' s)) (hc : is_closed s) :
  is_closed ((coe_fn : weak_dual ğ•œ E â†’ E â†’ ğ•œ) '' s) :=
continuous_linear_map.is_closed_image_coe_of_bounded_of_weak_closed hb (is_closed_induced_iff'.1 hc)
lemma is_compact_of_bounded_of_closed [proper_space ğ•œ] {s : set (weak_dual ğ•œ E)}
  (hb : bounded (dual.to_weak_dual â»Â¹' s)) (hc : is_closed s) :
  is_compact s :=
(embedding.is_compact_iff_is_compact_image fun_like.coe_injective.embedding_induced).mpr $
  continuous_linear_map.is_compact_image_coe_of_bounded_of_closed_image hb $
  is_closed_image_coe_of_bounded_of_closed hb hc
variable (ğ•œ)
lemma is_closed_image_polar_of_mem_nhds {s : set E} (s_nhd : s âˆˆ ğ“ (0 : E)) :
  is_closed ((coe_fn : weak_dual ğ•œ E â†’ E â†’ ğ•œ) '' polar ğ•œ s) :=
is_closed_image_coe_of_bounded_of_closed (bounded_polar_of_mem_nhds_zero ğ•œ s_nhd)
  (is_closed_polar _ _)
lemma _root_.normed_space.dual.is_closed_image_polar_of_mem_nhds {s : set E}
  (s_nhd : s âˆˆ ğ“ (0 : E)) : is_closed ((coe_fn : dual ğ•œ E â†’ E â†’ ğ•œ) '' normed_space.polar ğ•œ s) :=
is_closed_image_polar_of_mem_nhds ğ•œ s_nhd
theorem is_compact_polar [proper_space ğ•œ] {s : set E} (s_nhd : s âˆˆ ğ“ (0 : E)) :
  is_compact (polar ğ•œ s) :=
is_compact_of_bounded_of_closed (bounded_polar_of_mem_nhds_zero ğ•œ s_nhd) (is_closed_polar _ _)
theorem is_compact_closed_ball [proper_space ğ•œ] (x' : dual ğ•œ E) (r : â„) :
  is_compact (to_normed_dual â»Â¹' (closed_ball x' r)) :=
is_compact_of_bounded_of_closed bounded_closed_ball (is_closed_closed_ball x' r)
end weak_dual
