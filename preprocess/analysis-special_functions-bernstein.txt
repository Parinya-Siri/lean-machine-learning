import algebra.order.field
import ring_theory.polynomial.bernstein
import topology.continuous_function.polynomial
noncomputable theory
open_locale classical
open_locale big_operators
open_locale bounded_continuous_function
open_locale unit_interval
def bernstein (n ŒΩ : ‚Ñï) : C(I, ‚Ñù) :=
(bernstein_polynomial ‚Ñù n ŒΩ).to_continuous_map_on I
@[simp] lemma bernstein_apply (n ŒΩ : ‚Ñï) (x : I) :
  bernstein n ŒΩ x = n.choose ŒΩ * x^ŒΩ * (1-x)^(n-ŒΩ) :=
begin
  dsimp [bernstein, polynomial.to_continuous_map_on, polynomial.to_continuous_map,
    bernstein_polynomial],
  simp,
end
lemma bernstein_nonneg {n ŒΩ : ‚Ñï} {x : I} :
  0 ‚â§ bernstein n ŒΩ x :=
begin
  simp only [bernstein_apply],
  exact mul_nonneg
    (mul_nonneg (nat.cast_nonneg _) (pow_nonneg (by unit_interval) _))
    (pow_nonneg (by unit_interval) _),
end
namespace bernstein
def z {n : ‚Ñï} (k : fin (n+1)) : I :=
‚ü®(k : ‚Ñù) / n,
  begin
    cases n,
    { norm_num },
    { have h‚ÇÅ : 0 < (n.succ : ‚Ñù) := by exact_mod_cast (nat.succ_pos _),
      have h‚ÇÇ : ‚Üëk ‚â§ n.succ := by exact_mod_cast (fin.le_last k),
      rw [set.mem_Icc, le_div_iff h‚ÇÅ, div_le_iff h‚ÇÅ],
      norm_cast,
      simp [h‚ÇÇ], },
  end‚ü©
local postfix `/‚Çô`:90 := z
lemma probability (n : ‚Ñï) (x : I) :
  ‚àë k : fin (n+1), bernstein n k x = 1 :=
begin
  have := bernstein_polynomial.sum ‚Ñù n,
  apply_fun (Œª p, polynomial.aeval (x : ‚Ñù) p) at this,
  simp [alg_hom.map_sum, finset.sum_range] at this,
  exact this,
end
lemma variance {n : ‚Ñï} (h : 0 < (n : ‚Ñù)) (x : I) :
  ‚àë k : fin (n+1), (x - k/‚Çô : ‚Ñù)^2 * bernstein n k x = x * (1-x) / n :=
begin
  have h' : (n : ‚Ñù) ‚â† 0 := ne_of_gt h,
  apply_fun (Œª x : ‚Ñù, x * n) using group_with_zero.mul_right_injective h',
  apply_fun (Œª x : ‚Ñù, x * n) using group_with_zero.mul_right_injective h',
  dsimp,
  conv_lhs { simp only [finset.sum_mul, z], },
  conv_rhs { rw div_mul_cancel _ h', },
  have := bernstein_polynomial.variance ‚Ñù n,
  apply_fun (Œª p, polynomial.aeval (x : ‚Ñù) p) at this,
  simp [alg_hom.map_sum, finset.sum_range, ‚Üêpolynomial.nat_cast_mul] at this,
  convert this using 1,
  { congr' 1, funext k,
    rw [mul_comm _ (n : ‚Ñù), mul_comm _ (n : ‚Ñù), ‚Üêmul_assoc, ‚Üêmul_assoc],
    congr' 1,
    field_simp [h],
    ring, },
  { ring, },
end
end bernstein
open bernstein
local postfix `/‚Çô`:2000 := z
def bernstein_approximation (n : ‚Ñï) (f : C(I, ‚Ñù)) : C(I, ‚Ñù) :=
‚àë k : fin (n+1), f k/‚Çô ‚Ä¢ bernstein n k
namespace bernstein_approximation
@[simp] lemma apply (n : ‚Ñï) (f : C(I, ‚Ñù)) (x : I) :
  bernstein_approximation n f x = ‚àë k : fin (n+1), f k/‚Çô * bernstein n k x :=
by simp [bernstein_approximation]
def Œ¥ (f : C(I, ‚Ñù)) (Œµ : ‚Ñù) (h : 0 < Œµ) : ‚Ñù := f.modulus (Œµ/2) (half_pos h)
lemma Œ¥_pos {f : C(I, ‚Ñù)} {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < Œ¥ f Œµ h := f.modulus_pos
def S (f : C(I, ‚Ñù)) (Œµ : ‚Ñù) (h : 0 < Œµ) (n : ‚Ñï) (x : I) : finset (fin (n+1)) :=
{ k : fin (n+1) | dist k/‚Çô x < Œ¥ f Œµ h }.to_finset
lemma lt_of_mem_S
  {f : C(I, ‚Ñù)} {Œµ : ‚Ñù} {h : 0 < Œµ} {n : ‚Ñï} {x : I} {k : fin (n+1)} (m : k ‚àà S f Œµ h n x) :
  |f k/‚Çô - f x| < Œµ/2 :=
begin
  apply f.dist_lt_of_dist_lt_modulus (Œµ/2) (half_pos h),
  simpa [S] using m,
end
lemma le_of_mem_S_compl
  {f : C(I, ‚Ñù)} {Œµ : ‚Ñù} {h : 0 < Œµ} {n : ‚Ñï} {x : I} {k : fin (n+1)} (m : k ‚àà (S f Œµ h n x)·∂ú) :
  (1 : ‚Ñù) ‚â§ (Œ¥ f Œµ h)^(-2 : ‚Ñ§) * (x - k/‚Çô) ^ 2 :=
begin
  simp only [finset.mem_compl, not_lt, set.mem_to_finset, set.mem_set_of_eq, S] at m,
  erw [zpow_neg, ‚Üê div_eq_inv_mul, one_le_div (pow_pos Œ¥_pos 2), sq_le_sq, abs_of_pos Œ¥_pos],
  rwa [dist_comm] at m
end
end bernstein_approximation
open bernstein_approximation
open bounded_continuous_function
open filter
open_locale topological_space
theorem bernstein_approximation_uniform (f : C(I, ‚Ñù)) :
  tendsto (Œª n : ‚Ñï, bernstein_approximation n f) at_top (ùìù f) :=
begin
  simp only [metric.nhds_basis_ball.tendsto_right_iff, metric.mem_ball, dist_eq_norm],
  intros Œµ h,
  let Œ¥ := Œ¥ f Œµ h,
  have nhds_zero := tendsto_const_div_at_top_nhds_0_nat (2 * ‚à•f‚à• * Œ¥ ^ (-2 : ‚Ñ§)),
  filter_upwards [nhds_zero.eventually (gt_mem_nhds (half_pos h)), eventually_gt_at_top 0]
    with n nh npos',
  have npos : 0 < (n:‚Ñù) := by exact_mod_cast npos',
