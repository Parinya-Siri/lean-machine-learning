import measure_theory.measure.giry_monad
import dynamics.ergodic.measure_preserving
import measure_theory.integral.set_integral
import measure_theory.measure.open_pos
noncomputable theory
open_locale classical topological_space ennreal measure_theory
open set function real ennreal
open measure_theory measurable_space measure_theory.measure
open topological_space (hiding generate_from)
open filter (hiding prod_eq map)
variables {Œ± Œ±' Œ≤ Œ≤' Œ≥ E : Type*}
lemma is_pi_system.prod {C : set (set Œ±)} {D : set (set Œ≤)} (hC : is_pi_system C)
  (hD : is_pi_system D) : is_pi_system (image2 (√óÀ¢) C D) :=
begin
  rintro _ ‚ü®s‚ÇÅ, t‚ÇÅ, hs‚ÇÅ, ht‚ÇÅ, rfl‚ü© _ ‚ü®s‚ÇÇ, t‚ÇÇ, hs‚ÇÇ, ht‚ÇÇ, rfl‚ü© hst,
  rw [prod_inter_prod] at hst ‚ä¢, rw [prod_nonempty_iff] at hst,
  exact mem_image2_of_mem (hC _ hs‚ÇÅ _ hs‚ÇÇ hst.1) (hD _ ht‚ÇÅ _ ht‚ÇÇ hst.2)
end
lemma is_countably_spanning.prod {C : set (set Œ±)} {D : set (set Œ≤)}
  (hC : is_countably_spanning C) (hD : is_countably_spanning D) :
  is_countably_spanning (image2 (√óÀ¢) C D) :=
begin
  rcases ‚ü®hC, hD‚ü© with ‚ü®‚ü®s, h1s, h2s‚ü©, t, h1t, h2t‚ü©,
  refine ‚ü®Œª n, (s n.unpair.1) √óÀ¢ (t n.unpair.2), Œª n, mem_image2_of_mem (h1s _) (h1t _), _‚ü©,
  rw [Union_unpair_prod, h2s, h2t, univ_prod_univ]
end
variables [measurable_space Œ±] [measurable_space Œ±'] [measurable_space Œ≤] [measurable_space Œ≤']
variables [measurable_space Œ≥]
variables {Œº : measure Œ±} {ŒΩ : measure Œ≤} {œÑ : measure Œ≥}
variables [normed_group E]
lemma generate_from_prod_eq {Œ± Œ≤} {C : set (set Œ±)} {D : set (set Œ≤)}
  (hC : is_countably_spanning C) (hD : is_countably_spanning D) :
  @prod.measurable_space _ _ (generate_from C) (generate_from D) =
    generate_from (image2 (√óÀ¢) C D) :=
begin
  apply le_antisymm,
  { refine sup_le _ _; rw [comap_generate_from];
      apply generate_from_le; rintro _ ‚ü®s, hs, rfl‚ü©,
    { rcases hD with ‚ü®t, h1t, h2t‚ü©,
      rw [‚Üê prod_univ, ‚Üê h2t, prod_Union],
      apply measurable_set.Union,
      intro n, apply measurable_set_generate_from,
      exact ‚ü®s, t n, hs, h1t n, rfl‚ü© },
    { rcases hC with ‚ü®t, h1t, h2t‚ü©,
      rw [‚Üê univ_prod, ‚Üê h2t, Union_prod_const],
      apply measurable_set.Union,
      rintro n, apply measurable_set_generate_from,
      exact mem_image2_of_mem (h1t n) hs } },
  { apply generate_from_le, rintro _ ‚ü®s, t, hs, ht, rfl‚ü©, rw [prod_eq],
    apply (measurable_fst _).inter (measurable_snd _),
    { exact measurable_set_generate_from hs },
    { exact measurable_set_generate_from ht } }
end
lemma generate_from_eq_prod {C : set (set Œ±)} {D : set (set Œ≤)} (hC : generate_from C = ‚Äπ_‚Ä∫)
  (hD : generate_from D = ‚Äπ_‚Ä∫) (h2C : is_countably_spanning C) (h2D : is_countably_spanning D) :
    generate_from (image2 (√óÀ¢) C D) = prod.measurable_space :=
by rw [‚Üê hC, ‚Üê hD, generate_from_prod_eq h2C h2D]
lemma generate_from_prod :
  generate_from (image2 (√óÀ¢) {s : set Œ± | measurable_set s} {t : set Œ≤ | measurable_set t}) =
  prod.measurable_space :=
generate_from_eq_prod generate_from_measurable_set generate_from_measurable_set
  is_countably_spanning_measurable_set is_countably_spanning_measurable_set
lemma is_pi_system_prod :
  is_pi_system (image2 (√óÀ¢) {s : set Œ± | measurable_set s} {t : set Œ≤ | measurable_set t}) :=
is_pi_system_measurable_set.prod is_pi_system_measurable_set
lemma measurable_measure_prod_mk_left_finite [is_finite_measure ŒΩ] {s : set (Œ± √ó Œ≤)}
  (hs : measurable_set s) : measurable (Œª x, ŒΩ (prod.mk x ‚Åª¬π' s)) :=
begin
  refine induction_on_inter generate_from_prod.symm is_pi_system_prod _ _ _ _ hs,
  { simp [measurable_zero, const_def] },
  { rintro _ ‚ü®s, t, hs, ht, rfl‚ü©, simp only [mk_preimage_prod_right_eq_if, measure_if],
    exact measurable_const.indicator hs },
  { intros t ht h2t,
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ŒΩ _)],
    exact h2t.const_sub _ },
  { intros f h1f h2f h3f, simp_rw [preimage_Union],
    have : ‚àÄ b, ŒΩ (‚ãÉ i, prod.mk b ‚Åª¬π' f i) = ‚àë' i, ŒΩ (prod.mk b ‚Åª¬π' f i) :=
      Œª b, measure_Union (Œª i j hij, disjoint.preimage _ (h1f i j hij))
        (Œª i, measurable_prod_mk_left (h2f i)),
    simp_rw [this], apply measurable.ennreal_tsum h3f },
end
lemma measurable_measure_prod_mk_left [sigma_finite ŒΩ] {s : set (Œ± √ó Œ≤)}
  (hs : measurable_set s) : measurable (Œª x, ŒΩ (prod.mk x ‚Åª¬π' s)) :=
begin
  have : ‚àÄ x, measurable_set (prod.mk x ‚Åª¬π' s) := Œª x, measurable_prod_mk_left hs,
  simp only [‚Üê @supr_restrict_spanning_sets _ _ ŒΩ, this],
  apply measurable_supr, intro i,
  haveI := fact.mk (measure_spanning_sets_lt_top ŒΩ i),
  exact measurable_measure_prod_mk_left_finite hs
end
lemma measurable_measure_prod_mk_right {Œº : measure Œ±} [sigma_finite Œº] {s : set (Œ± √ó Œ≤)}
  (hs : measurable_set s) : measurable (Œª y, Œº ((Œª x, (x, y)) ‚Åª¬π' s)) :=
measurable_measure_prod_mk_left (measurable_set_swap_iff.mpr hs)
lemma measurable.map_prod_mk_left [sigma_finite ŒΩ] : measurable (Œª x : Œ±, map (prod.mk x) ŒΩ) :=
begin
  apply measurable_of_measurable_coe, intros s hs,
  simp_rw [map_apply measurable_prod_mk_left hs],
  exact measurable_measure_prod_mk_left hs
end
lemma measurable.map_prod_mk_right {Œº : measure Œ±} [sigma_finite Œº] :
  measurable (Œª y : Œ≤, map (Œª x : Œ±, (x, y)) Œº) :=
begin
  apply measurable_of_measurable_coe, intros s hs,
  simp_rw [map_apply measurable_prod_mk_right hs],
  exact measurable_measure_prod_mk_right hs
end
lemma measurable.lintegral_prod_right' [sigma_finite ŒΩ] :
  ‚àÄ {f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû} (hf : measurable f), measurable (Œª x, ‚à´‚Åª y, f (x, y) ‚àÇŒΩ) :=
begin
  have m := @measurable_prod_mk_left,
  refine measurable.ennreal_induction _ _ _,
  { intros c s hs, simp only [‚Üê indicator_comp_right],
    suffices : measurable (Œª x, c * ŒΩ (prod.mk x ‚Åª¬π' s)),
    { simpa [lintegral_indicator _ (m hs)] },
    exact (measurable_measure_prod_mk_left hs).const_mul _ },
  { rintro f g - hf hg h2f h2g, simp_rw [pi.add_apply, lintegral_add_left (hf.comp m)],
    exact h2f.add h2g },
  { intros f hf h2f h3f,
    have := measurable_supr h3f,
    have : ‚àÄ x, monotone (Œª n y, f n (x, y)) := Œª x i j hij y, h2f hij (x, y),
    simpa [lintegral_supr (Œª n, (hf n).comp m), this] }
end
lemma measurable.lintegral_prod_right [sigma_finite ŒΩ] {f : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû}
  (hf : measurable (uncurry f)) : measurable (Œª x, ‚à´‚Åª y, f x y ‚àÇŒΩ) :=
hf.lintegral_prod_right'
lemma measurable.lintegral_prod_left' [sigma_finite Œº] {f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû}
  (hf : measurable f) : measurable (Œª y, ‚à´‚Åª x, f (x, y) ‚àÇŒº) :=
(measurable_swap_iff.mpr hf).lintegral_prod_right'
lemma measurable.lintegral_prod_left [sigma_finite Œº] {f : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû}
  (hf : measurable (uncurry f)) : measurable (Œª y, ‚à´‚Åª x, f x y ‚àÇŒº) :=
hf.lintegral_prod_left'
lemma measurable_set_integrable [sigma_finite ŒΩ] ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable (uncurry f)) : measurable_set {x | integrable (f x) ŒΩ} :=
begin
  simp_rw [integrable, hf.of_uncurry_left.ae_strongly_measurable, true_and],
  exact measurable_set_lt (measurable.lintegral_prod_right hf.ennnorm) measurable_const
end
section
variables [normed_space ‚Ñù E] [complete_space E]
lemma measure_theory.strongly_measurable.integral_prod_right [sigma_finite ŒΩ] ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable (uncurry f)) : strongly_measurable (Œª x, ‚à´ y, f x y ‚àÇŒΩ) :=
begin
  borelize E,
  haveI : separable_space (range (uncurry f) ‚à™ {0} : set E) :=
    hf.separable_space_range_union_singleton,
  let s : ‚Ñï ‚Üí simple_func (Œ± √ó Œ≤) E := simple_func.approx_on _ hf.measurable
    (range (uncurry f) ‚à™ {0}) 0 (by simp),
  let s' : ‚Ñï ‚Üí Œ± ‚Üí simple_func Œ≤ E := Œª n x, (s n).comp (prod.mk x) measurable_prod_mk_left,
  let f' : ‚Ñï ‚Üí Œ± ‚Üí E := Œª n, {x | integrable (f x) ŒΩ}.indicator
    (Œª x, (s' n x).integral ŒΩ),
  have hf' : ‚àÄ n, strongly_measurable (f' n),
  { intro n, refine strongly_measurable.indicator _ (measurable_set_integrable hf),
    have : ‚àÄ x, (s' n x).range.filter (Œª x, x ‚â† 0) ‚äÜ (s n).range,
    { intros x, refine finset.subset.trans (finset.filter_subset _ _) _, intro y,
      simp_rw [simple_func.mem_range], rintro ‚ü®z, rfl‚ü©, exact ‚ü®(x, z), rfl‚ü© },
    simp only [simple_func.integral_eq_sum_of_subset (this _)],
    refine finset.strongly_measurable_sum _ (Œª x _, _),
    refine (measurable.ennreal_to_real _).strongly_measurable.smul_const _,
    simp only [simple_func.coe_comp, preimage_comp] {single_pass := tt},
    apply measurable_measure_prod_mk_left,
    exact (s n).measurable_set_fiber x },
  have h2f' : tendsto f' at_top (ùìù (Œª (x : Œ±), ‚à´ (y : Œ≤), f x y ‚àÇŒΩ)),
  { rw [tendsto_pi_nhds], intro x,
    by_cases hfx : integrable (f x) ŒΩ,
    { have : ‚àÄ n, integrable (s' n x) ŒΩ,
      { intro n, apply (hfx.norm.add hfx.norm).mono' (s' n x).ae_strongly_measurable,
        apply eventually_of_forall, intro y,
        simp_rw [s', simple_func.coe_comp], exact simple_func.norm_approx_on_zero_le _ _ (x, y) n },
      simp only [f', hfx, simple_func.integral_eq_integral _ (this _), indicator_of_mem,
        mem_set_of_eq],
      refine tendsto_integral_of_dominated_convergence (Œª y, ‚à•f x y‚à• + ‚à•f x y‚à•)
        (Œª n, (s' n x).ae_strongly_measurable) (hfx.norm.add hfx.norm) _ _,
      { exact Œª n, eventually_of_forall (Œª y, simple_func.norm_approx_on_zero_le _ _ (x, y) n) },
      { refine eventually_of_forall (Œª y, simple_func.tendsto_approx_on _ _ _),
        apply subset_closure,
        simp [-uncurry_apply_pair], } },
    { simpa [f', hfx, integral_undef] using @tendsto_const_nhds _ _ _ (0 : E) _, } },
  exact strongly_measurable_of_tendsto _ hf' h2f'
end
lemma measure_theory.strongly_measurable.integral_prod_right' [sigma_finite ŒΩ] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable f) : strongly_measurable (Œª x, ‚à´ y, f (x, y) ‚àÇŒΩ) :=
by { rw [‚Üê uncurry_curry f] at hf, exact hf.integral_prod_right }
lemma measure_theory.strongly_measurable.integral_prod_left [sigma_finite Œº] ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable (uncurry f)) : strongly_measurable (Œª y, ‚à´ x, f x y ‚àÇŒº) :=
(hf.comp_measurable measurable_swap).integral_prod_right'
lemma measure_theory.strongly_measurable.integral_prod_left' [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : strongly_measurable f) : strongly_measurable (Œª y, ‚à´ x, f (x, y) ‚àÇŒº) :=
(hf.comp_measurable measurable_swap).integral_prod_right'
end
namespace measure_theory
namespace measure
@[irreducible] protected def prod (Œº : measure Œ±) (ŒΩ : measure Œ≤) : measure (Œ± √ó Œ≤) :=
bind Œº $ Œª x : Œ±, map (prod.mk x) ŒΩ
instance prod.measure_space {Œ± Œ≤} [measure_space Œ±] [measure_space Œ≤] : measure_space (Œ± √ó Œ≤) :=
{ volume := volume.prod volume }
variables {Œº ŒΩ} [sigma_finite ŒΩ]
lemma volume_eq_prod (Œ± Œ≤) [measure_space Œ±] [measure_space Œ≤] :
  (volume : measure (Œ± √ó Œ≤)) = (volume : measure Œ±).prod (volume : measure Œ≤) :=
rfl
lemma prod_apply {s : set (Œ± √ó Œ≤)} (hs : measurable_set s) :
  Œº.prod ŒΩ s = ‚à´‚Åª x, ŒΩ (prod.mk x ‚Åª¬π' s) ‚àÇŒº :=
by simp_rw [measure.prod, bind_apply hs measurable.map_prod_mk_left,
  map_apply measurable_prod_mk_left hs]
@[simp] lemma prod_prod (s : set Œ±) (t : set Œ≤) : Œº.prod ŒΩ (s √óÀ¢ t) = Œº s * ŒΩ t :=
begin
  apply le_antisymm,
  { set ST := (to_measurable Œº s) √óÀ¢ (to_measurable ŒΩ t),
    have hSTm : measurable_set ST :=
      (measurable_set_to_measurable _ _).prod (measurable_set_to_measurable _ _),
    calc Œº.prod ŒΩ (s √óÀ¢ t) ‚â§ Œº.prod ŒΩ ST :
      measure_mono $ set.prod_mono (subset_to_measurable _ _) (subset_to_measurable _ _)
    ... = Œº (to_measurable Œº s) * ŒΩ (to_measurable ŒΩ t) :
      by simp_rw [prod_apply hSTm, mk_preimage_prod_right_eq_if, measure_if,
        lintegral_indicator _ (measurable_set_to_measurable _ _), lintegral_const,
        restrict_apply_univ, mul_comm]
    ... = Œº s * ŒΩ t : by rw [measure_to_measurable, measure_to_measurable] },
    set ST := to_measurable (Œº.prod ŒΩ) (s √óÀ¢ t),
    have hSTm : measurable_set ST := measurable_set_to_measurable _ _,
    have hST : s √óÀ¢ t ‚äÜ ST := subset_to_measurable _ _,
    set f : Œ± ‚Üí ‚Ñù‚â•0‚àû := Œª x, ŒΩ (prod.mk x ‚Åª¬π' ST),
    have hfm : measurable f := measurable_measure_prod_mk_left hSTm,
    set s' : set Œ± := {x | ŒΩ t ‚â§ f x},
    have hss' : s ‚äÜ s' := Œª x hx, measure_mono (Œª y hy, hST $ mk_mem_prod hx hy),
    calc Œº s * ŒΩ t ‚â§ Œº s' * ŒΩ t : mul_le_mul_right' (measure_mono hss') _
    ... = ‚à´‚Åª x in s', ŒΩ t ‚àÇŒº    : by rw [set_lintegral_const, mul_comm]
    ... ‚â§ ‚à´‚Åª x in s', f x ‚àÇŒº    : set_lintegral_mono measurable_const hfm (Œª x, id)
    ... ‚â§ ‚à´‚Åª x, f x ‚àÇŒº          : lintegral_mono' restrict_le_self le_rfl
    ... = Œº.prod ŒΩ ST           : (prod_apply hSTm).symm
    ... = Œº.prod ŒΩ (s √óÀ¢ t)     : measure_to_measurable _ }
end
instance {X Y : Type*} [topological_space X] [topological_space Y]
  {m : measurable_space X} {Œº : measure X} [is_open_pos_measure Œº]
  {m' : measurable_space Y} {ŒΩ : measure Y} [is_open_pos_measure ŒΩ] [sigma_finite ŒΩ] :
  is_open_pos_measure (Œº.prod ŒΩ) :=
begin
  constructor,
  rintros U U_open ‚ü®‚ü®x, y‚ü©, hxy‚ü©,
  rcases is_open_prod_iff.1 U_open x y hxy with ‚ü®u, v, u_open, v_open, xu, yv, huv‚ü©,
  refine ne_of_gt (lt_of_lt_of_le _ (measure_mono huv)),
  simp only [prod_prod, canonically_ordered_comm_semiring.mul_pos],
  split,
  { exact u_open.measure_pos Œº ‚ü®x, xu‚ü© },
  { exact v_open.measure_pos ŒΩ ‚ü®y, yv‚ü© }
end
instance {Œ± Œ≤ : Type*} {mŒ± : measurable_space Œ±} {mŒ≤ : measurable_space Œ≤}
  (Œº : measure Œ±) (ŒΩ : measure Œ≤) [is_finite_measure Œº] [is_finite_measure ŒΩ] :
  is_finite_measure (Œº.prod ŒΩ) :=
begin
  constructor,
  rw [‚Üê univ_prod_univ, prod_prod],
  exact mul_lt_top (measure_lt_top _ _).ne (measure_lt_top _ _).ne,
end
instance {Œ± Œ≤ : Type*} {mŒ± : measurable_space Œ±} {mŒ≤ : measurable_space Œ≤}
  (Œº : measure Œ±) (ŒΩ : measure Œ≤) [is_probability_measure Œº] [is_probability_measure ŒΩ] :
  is_probability_measure (Œº.prod ŒΩ) :=
‚ü®by rw [‚Üê univ_prod_univ, prod_prod, measure_univ, measure_univ, mul_one]‚ü©
instance {Œ± Œ≤ : Type*} [topological_space Œ±] [topological_space Œ≤]
  {mŒ± : measurable_space Œ±} {mŒ≤ : measurable_space Œ≤} (Œº : measure Œ±) (ŒΩ : measure Œ≤)
  [is_finite_measure_on_compacts Œº] [is_finite_measure_on_compacts ŒΩ] [sigma_finite ŒΩ] :
  is_finite_measure_on_compacts (Œº.prod ŒΩ) :=
begin
  refine ‚ü®Œª K hK, _‚ü©,
  set L := (prod.fst '' K) √óÀ¢ (prod.snd '' K) with hL,
  have : K ‚äÜ L,
  { rintros ‚ü®x, y‚ü© hxy,
    simp only [prod_mk_mem_set_prod_eq, mem_image, prod.exists, exists_and_distrib_right,
      exists_eq_right],
    exact ‚ü®‚ü®y, hxy‚ü©, ‚ü®x, hxy‚ü©‚ü© },
  apply lt_of_le_of_lt (measure_mono this),
  rw [hL, prod_prod],
  exact mul_lt_top ((is_compact.measure_lt_top ((hK.image continuous_fst))).ne)
                   ((is_compact.measure_lt_top ((hK.image continuous_snd))).ne)
end
lemma ae_measure_lt_top {s : set (Œ± √ó Œ≤)} (hs : measurable_set s)
  (h2s : (Œº.prod ŒΩ) s ‚â† ‚àû) : ‚àÄ·µê x ‚àÇŒº, ŒΩ (prod.mk x ‚Åª¬π' s) < ‚àû :=
by { simp_rw [prod_apply hs] at h2s, refine ae_lt_top (measurable_measure_prod_mk_left hs) h2s }
lemma integrable_measure_prod_mk_left {s : set (Œ± √ó Œ≤)}
  (hs : measurable_set s) (h2s : (Œº.prod ŒΩ) s ‚â† ‚àû) :
  integrable (Œª x, (ŒΩ (prod.mk x ‚Åª¬π' s)).to_real) Œº :=
begin
  refine ‚ü®(measurable_measure_prod_mk_left hs).ennreal_to_real.ae_measurable.ae_strongly_measurable,
    _‚ü©,
  simp_rw [has_finite_integral, ennnorm_eq_of_real to_real_nonneg],
  convert h2s.lt_top using 1, simp_rw [prod_apply hs], apply lintegral_congr_ae,
  refine (ae_measure_lt_top hs h2s).mp _, apply eventually_of_forall, intros x hx,
  rw [lt_top_iff_ne_top] at hx, simp [of_real_to_real, hx],
end
lemma measure_prod_null {s : set (Œ± √ó Œ≤)}
  (hs : measurable_set s) : Œº.prod ŒΩ s = 0 ‚Üî (Œª x, ŒΩ (prod.mk x ‚Åª¬π' s)) =·µê[Œº] 0 :=
by simp_rw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]
lemma measure_ae_null_of_prod_null {s : set (Œ± √ó Œ≤)}
  (h : Œº.prod ŒΩ s = 0) : (Œª x, ŒΩ (prod.mk x ‚Åª¬π' s)) =·µê[Œº] 0 :=
begin
  obtain ‚ü®t, hst, mt, ht‚ü© := exists_measurable_superset_of_null h,
  simp_rw [measure_prod_null mt] at ht,
  rw [eventually_le_antisymm_iff],
  exact ‚ü®eventually_le.trans_eq
    (eventually_of_forall $ Œª x, (measure_mono (preimage_mono hst) : _)) ht,
    eventually_of_forall $ Œª x, zero_le _‚ü©
end
lemma ae_ae_of_ae_prod {p : Œ± √ó Œ≤ ‚Üí Prop} (h : ‚àÄ·µê z ‚àÇŒº.prod ŒΩ, p z) :
  ‚àÄ·µê x ‚àÇ Œº, ‚àÄ·µê y ‚àÇ ŒΩ, p (x, y) :=
measure_ae_null_of_prod_null h
noncomputable! def finite_spanning_sets_in.prod {ŒΩ : measure Œ≤} {C : set (set Œ±)} {D : set (set Œ≤)}
  (hŒº : Œº.finite_spanning_sets_in C) (hŒΩ : ŒΩ.finite_spanning_sets_in D) :
  (Œº.prod ŒΩ).finite_spanning_sets_in (image2 (√óÀ¢) C D) :=
begin
  haveI := hŒΩ.sigma_finite,
  refine ‚ü®Œª n, hŒº.set n.unpair.1 √óÀ¢ hŒΩ.set n.unpair.2,
    Œª n, mem_image2_of_mem (hŒº.set_mem _) (hŒΩ.set_mem _), Œª n, _, _‚ü©,
  { rw [prod_prod],
    exact mul_lt_top (hŒº.finite _).ne (hŒΩ.finite _).ne },
  { simp_rw [Union_unpair_prod, hŒº.spanning, hŒΩ.spanning, univ_prod_univ] }
end
lemma prod_fst_absolutely_continuous : map prod.fst (Œº.prod ŒΩ) ‚â™ Œº :=
begin
  refine absolutely_continuous.mk (Œª s hs h2s, _),
  rw [map_apply measurable_fst hs, ‚Üê prod_univ, prod_prod, h2s, zero_mul],
end
lemma prod_snd_absolutely_continuous : map prod.snd (Œº.prod ŒΩ) ‚â™ ŒΩ :=
begin
  refine absolutely_continuous.mk (Œª s hs h2s, _),
  rw [map_apply measurable_snd hs, ‚Üê univ_prod, prod_prod, h2s, mul_zero]
end
variables [sigma_finite Œº]
instance prod.sigma_finite : sigma_finite (Œº.prod ŒΩ) :=
(Œº.to_finite_spanning_sets_in.prod ŒΩ.to_finite_spanning_sets_in).sigma_finite
lemma prod_eq_generate_from {Œº : measure Œ±} {ŒΩ : measure Œ≤} {C : set (set Œ±)}
  {D : set (set Œ≤)} (hC : generate_from C = ‚Äπ_‚Ä∫)
  (hD : generate_from D = ‚Äπ_‚Ä∫) (h2C : is_pi_system C) (h2D : is_pi_system D)
  (h3C : Œº.finite_spanning_sets_in C) (h3D : ŒΩ.finite_spanning_sets_in D)
  {ŒºŒΩ : measure (Œ± √ó Œ≤)}
  (h‚ÇÅ : ‚àÄ (s ‚àà C) (t ‚àà D), ŒºŒΩ (s √óÀ¢ t) = Œº s * ŒΩ t) : Œº.prod ŒΩ = ŒºŒΩ :=
begin
  refine (h3C.prod h3D).ext
    (generate_from_eq_prod hC hD h3C.is_countably_spanning h3D.is_countably_spanning).symm
    (h2C.prod h2D) _,
  { rintro _ ‚ü®s, t, hs, ht, rfl‚ü©, haveI := h3D.sigma_finite,
    rw [h‚ÇÅ s hs t ht, prod_prod] }
end
lemma prod_eq {ŒºŒΩ : measure (Œ± √ó Œ≤)}
  (h : ‚àÄ s t, measurable_set s ‚Üí measurable_set t ‚Üí ŒºŒΩ (s √óÀ¢ t) = Œº s * ŒΩ t) : Œº.prod ŒΩ = ŒºŒΩ :=
prod_eq_generate_from generate_from_measurable_set generate_from_measurable_set
  is_pi_system_measurable_set is_pi_system_measurable_set
  Œº.to_finite_spanning_sets_in ŒΩ.to_finite_spanning_sets_in (Œª s hs t ht, h s t hs ht)
lemma prod_swap : map prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=
begin
  refine (prod_eq _).symm,
  intros s t hs ht,
  simp_rw [map_apply measurable_swap (hs.prod ht), preimage_swap_prod, prod_prod, mul_comm]
end
lemma prod_apply_symm {s : set (Œ± √ó Œ≤)} (hs : measurable_set s) :
  Œº.prod ŒΩ s = ‚à´‚Åª y, Œº ((Œª x, (x, y)) ‚Åª¬π' s) ‚àÇŒΩ :=
by { rw [‚Üê prod_swap, map_apply measurable_swap hs],
     simp only [prod_apply (measurable_swap hs)], refl }
lemma prod_assoc_prod [sigma_finite œÑ] :
  map measurable_equiv.prod_assoc ((Œº.prod ŒΩ).prod œÑ) = Œº.prod (ŒΩ.prod œÑ) :=
begin
  refine (prod_eq_generate_from generate_from_measurable_set generate_from_prod
    is_pi_system_measurable_set is_pi_system_prod Œº.to_finite_spanning_sets_in
    (ŒΩ.to_finite_spanning_sets_in.prod œÑ.to_finite_spanning_sets_in) _).symm,
  rintro s hs _ ‚ü®t, u, ht, hu, rfl‚ü©, rw [mem_set_of_eq] at hs ht hu,
  simp_rw [map_apply (measurable_equiv.measurable _) (hs.prod (ht.prod hu)),
    measurable_equiv.prod_assoc, measurable_equiv.coe_mk, equiv.prod_assoc_preimage,
    prod_prod, mul_assoc]
end
lemma prod_restrict (s : set Œ±) (t : set Œ≤) :
  (Œº.restrict s).prod (ŒΩ.restrict t) = (Œº.prod ŒΩ).restrict (s √óÀ¢ t) :=
begin
  refine prod_eq (Œª s' t' hs' ht', _),
  rw [restrict_apply (hs'.prod ht'), prod_inter_prod, prod_prod, restrict_apply hs',
    restrict_apply ht']
end
lemma restrict_prod_eq_prod_univ (s : set Œ±) :
  (Œº.restrict s).prod ŒΩ = (Œº.prod ŒΩ).restrict (s √óÀ¢ (univ : set Œ≤)) :=
begin
  have : ŒΩ = ŒΩ.restrict set.univ := measure.restrict_univ.symm,
  rwa [this, measure.prod_restrict, ‚Üê this],
end
lemma prod_dirac (y : Œ≤) : Œº.prod (dirac y) = map (Œª x, (x, y)) Œº :=
begin
  refine prod_eq (Œª s t hs ht, _),
  simp_rw [map_apply measurable_prod_mk_right (hs.prod ht), mk_preimage_prod_left_eq_if, measure_if,
    dirac_apply' _ ht, ‚Üê indicator_mul_right _ (Œª x, Œº s), pi.one_apply, mul_one]
end
lemma dirac_prod (x : Œ±) : (dirac x).prod ŒΩ = map (prod.mk x) ŒΩ :=
begin
  refine prod_eq (Œª s t hs ht, _),
  simp_rw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if,
    dirac_apply' _ hs, ‚Üê indicator_mul_left _ _ (Œª x, ŒΩ t), pi.one_apply, one_mul]
end
lemma dirac_prod_dirac {x : Œ±} {y : Œ≤} : (dirac x).prod (dirac y) = dirac (x, y) :=
by rw [prod_dirac, map_dirac measurable_prod_mk_right]
lemma prod_sum {Œπ : Type*} [fintype Œπ] (ŒΩ : Œπ ‚Üí measure Œ≤) [‚àÄ i, sigma_finite (ŒΩ i)] :
  Œº.prod (sum ŒΩ) = sum (Œª i, Œº.prod (ŒΩ i)) :=
begin
  refine prod_eq (Œª s t hs ht, _),
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ ht, prod_prod, ennreal.tsum_mul_left]
end
lemma sum_prod {Œπ : Type*} [fintype Œπ] (Œº : Œπ ‚Üí measure Œ±) [‚àÄ i, sigma_finite (Œº i)] :
  (sum Œº).prod ŒΩ = sum (Œª i, (Œº i).prod ŒΩ) :=
begin
  refine prod_eq (Œª s t hs ht, _),
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ hs, prod_prod, ennreal.tsum_mul_right]
end
lemma prod_add (ŒΩ' : measure Œ≤) [sigma_finite ŒΩ'] : Œº.prod (ŒΩ + ŒΩ') = Œº.prod ŒΩ + Œº.prod ŒΩ' :=
by { refine prod_eq (Œª s t hs ht, _), simp_rw [add_apply, prod_prod, left_distrib] }
lemma add_prod (Œº' : measure Œ±) [sigma_finite Œº'] : (Œº + Œº').prod ŒΩ = Œº.prod ŒΩ + Œº'.prod ŒΩ :=
by { refine prod_eq (Œª s t hs ht, _), simp_rw [add_apply, prod_prod, right_distrib] }
@[simp] lemma zero_prod (ŒΩ : measure Œ≤) : (0 : measure Œ±).prod ŒΩ = 0 :=
by { rw measure.prod, exact bind_zero_left _ }
@[simp] lemma prod_zero (Œº : measure Œ±) : Œº.prod (0 : measure Œ≤) = 0 :=
by simp [measure.prod]
lemma map_prod_map {Œ¥} [measurable_space Œ¥] {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥}
  {Œºa : measure Œ±} {Œºc : measure Œ≥} (hfa : sigma_finite (map f Œºa))
  (hgc : sigma_finite (map g Œºc)) (hf : measurable f) (hg : measurable g) :
  (map f Œºa).prod (map g Œºc) = map (prod.map f g) (Œºa.prod Œºc) :=
begin
  haveI := hgc.of_map Œºc hg.ae_measurable,
  refine prod_eq (Œª s t hs ht, _),
  rw [map_apply (hf.prod_map hg) (hs.prod ht), map_apply hf hs, map_apply hg ht],
  exact prod_prod (f ‚Åª¬π' s) (g ‚Åª¬π' t)
end
end measure
open measure
namespace measure_preserving
variables {Œ¥ : Type*} [measurable_space Œ¥] {Œºa : measure Œ±} {Œºb : measure Œ≤}
  {Œºc : measure Œ≥} {Œºd : measure Œ¥}
lemma skew_product [sigma_finite Œºb] [sigma_finite Œºd]
  {f : Œ± ‚Üí Œ≤} (hf : measure_preserving f Œºa Œºb) {g : Œ± ‚Üí Œ≥ ‚Üí Œ¥}
  (hgm : measurable (uncurry g)) (hg : ‚àÄ·µê x ‚àÇŒºa, map (g x) Œºc = Œºd) :
  measure_preserving (Œª p : Œ± √ó Œ≥, (f p.1, g p.1 p.2)) (Œºa.prod Œºc) (Œºb.prod Œºd) :=
begin
  classical,
  have : measurable (Œª p : Œ± √ó Œ≥, (f p.1, g p.1 p.2)) := (hf.1.comp measurable_fst).prod_mk hgm,
  rcases eq_or_ne Œºa 0 with (rfl|ha),
  { rw [‚Üê hf.map_eq, zero_prod, measure.map_zero, zero_prod],
    exact ‚ü®this, by simp only [measure.map_zero]‚ü© },
  haveI : sigma_finite Œºc,
  { rcases (ae_ne_bot.2 ha).nonempty_of_mem hg with ‚ü®x, hx : map (g x) Œºc = Œºd‚ü©,
    exact sigma_finite.of_map _ hgm.of_uncurry_left.ae_measurable (by rwa hx) },
protected lemma prod [sigma_finite Œºb] [sigma_finite Œºd] {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥}
  (hf : measure_preserving f Œºa Œºb) (hg : measure_preserving g Œºc Œºd) :
  measure_preserving (prod.map f g) (Œºa.prod Œºc) (Œºb.prod Œºd) :=
have measurable (uncurry $ Œª _ : Œ±, g), from (hg.1.comp measurable_snd),
hf.skew_product this $ filter.eventually_of_forall $ Œª _, hg.map_eq
end measure_preserving
namespace quasi_measure_preserving
lemma prod_of_right {f : Œ± √ó Œ≤ ‚Üí Œ≥} {Œº : measure Œ±} {ŒΩ : measure Œ≤} {œÑ : measure Œ≥}
  (hf : measurable f) [sigma_finite ŒΩ]
  (h2f : ‚àÄ·µê x ‚àÇŒº, quasi_measure_preserving (Œª y, f (x, y)) ŒΩ œÑ) :
  quasi_measure_preserving f (Œº.prod ŒΩ) œÑ :=
begin
  refine ‚ü®hf, _‚ü©,
  refine absolutely_continuous.mk (Œª s hs h2s, _),
  simp_rw [map_apply hf hs, prod_apply (hf hs), preimage_preimage,
    lintegral_congr_ae (h2f.mono (Œª x hx, hx.preimage_null h2s)), lintegral_zero],
end
lemma prod_of_left {Œ± Œ≤ Œ≥} [measurable_space Œ±] [measurable_space Œ≤]
  [measurable_space Œ≥] {f : Œ± √ó Œ≤ ‚Üí Œ≥} {Œº : measure Œ±} {ŒΩ : measure Œ≤} {œÑ : measure Œ≥}
  (hf : measurable f) [sigma_finite Œº] [sigma_finite ŒΩ]
  (h2f : ‚àÄ·µê y ‚àÇŒΩ, quasi_measure_preserving (Œª x, f (x, y)) Œº œÑ) :
  quasi_measure_preserving f (Œº.prod ŒΩ) œÑ :=
begin
  rw [‚Üê prod_swap],
  convert (quasi_measure_preserving.prod_of_right (hf.comp measurable_swap) h2f).comp
    ((measurable_swap.measure_preserving (ŒΩ.prod Œº)).symm measurable_equiv.prod_comm)
    .quasi_measure_preserving,
  ext ‚ü®x, y‚ü©, refl,
end
end quasi_measure_preserving
end measure_theory
open measure_theory.measure
section
lemma ae_measurable.prod_swap [sigma_finite Œº] [sigma_finite ŒΩ] {f : Œ≤ √ó Œ± ‚Üí Œ≥}
  (hf : ae_measurable f (ŒΩ.prod Œº)) : ae_measurable (Œª (z : Œ± √ó Œ≤), f z.swap) (Œº.prod ŒΩ) :=
by { rw ‚Üê prod_swap at hf, exact hf.comp_measurable measurable_swap }
lemma measure_theory.ae_strongly_measurable.prod_swap
  {Œ≥ : Type*} [topological_space Œ≥] [sigma_finite Œº] [sigma_finite ŒΩ] {f : Œ≤ √ó Œ± ‚Üí Œ≥}
  (hf : ae_strongly_measurable f (ŒΩ.prod Œº)) :
  ae_strongly_measurable (Œª (z : Œ± √ó Œ≤), f z.swap) (Œº.prod ŒΩ) :=
by { rw ‚Üê prod_swap at hf, exact hf.comp_measurable measurable_swap }
lemma ae_measurable.fst [sigma_finite ŒΩ] {f : Œ± ‚Üí Œ≥}
  (hf : ae_measurable f Œº) : ae_measurable (Œª (z : Œ± √ó Œ≤), f z.1) (Œº.prod ŒΩ) :=
hf.comp_measurable' measurable_fst prod_fst_absolutely_continuous
lemma ae_measurable.snd [sigma_finite ŒΩ] {f : Œ≤ ‚Üí Œ≥}
  (hf : ae_measurable f ŒΩ) : ae_measurable (Œª (z : Œ± √ó Œ≤), f z.2) (Œº.prod ŒΩ) :=
hf.comp_measurable' measurable_snd prod_snd_absolutely_continuous
lemma measure_theory.ae_strongly_measurable.fst {Œ≥} [topological_space Œ≥] [sigma_finite ŒΩ]
  {f : Œ± ‚Üí Œ≥} (hf : ae_strongly_measurable f Œº) :
  ae_strongly_measurable (Œª (z : Œ± √ó Œ≤), f z.1) (Œº.prod ŒΩ) :=
hf.comp_measurable' measurable_fst prod_fst_absolutely_continuous
lemma measure_theory.ae_strongly_measurable.snd {Œ≥} [topological_space Œ≥] [sigma_finite ŒΩ]
  {f : Œ≤ ‚Üí Œ≥} (hf : ae_strongly_measurable f ŒΩ) :
  ae_strongly_measurable (Œª (z : Œ± √ó Œ≤), f z.2) (Œº.prod ŒΩ) :=
hf.comp_measurable' measurable_snd prod_snd_absolutely_continuous
lemma measure_theory.ae_strongly_measurable.integral_prod_right' [sigma_finite ŒΩ]
  [normed_space ‚Ñù E] [complete_space E]
  ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (hf : ae_strongly_measurable f (Œº.prod ŒΩ)) :
  ae_strongly_measurable (Œª x, ‚à´ y, f (x, y) ‚àÇŒΩ) Œº :=
‚ü®Œª x, ‚à´ y, hf.mk f (x, y) ‚àÇŒΩ, hf.strongly_measurable_mk.integral_prod_right',
  by { filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with _ hx using integral_congr_ae hx }‚ü©
lemma measure_theory.ae_strongly_measurable.prod_mk_left
  {Œ≥ : Type*} [sigma_finite ŒΩ] [topological_space Œ≥] {f : Œ± √ó Œ≤ ‚Üí Œ≥}
  (hf : ae_strongly_measurable f (Œº.prod ŒΩ)) : ‚àÄ·µê x ‚àÇŒº, ae_strongly_measurable (Œª y, f (x, y)) ŒΩ :=
begin
  filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with x hx,
  exact ‚ü®Œª y, hf.mk f (x, y), hf.strongly_measurable_mk.comp_measurable measurable_prod_mk_left, hx‚ü©
end
end
namespace measure_theory
variables [sigma_finite ŒΩ]
lemma lintegral_prod_swap [sigma_finite Œº] (f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû)
  (hf : ae_measurable f (Œº.prod ŒΩ)) : ‚à´‚Åª z, f z.swap ‚àÇ(ŒΩ.prod Œº) = ‚à´‚Åª z, f z ‚àÇ(Œº.prod ŒΩ) :=
by { rw ‚Üê prod_swap at hf, rw [‚Üê lintegral_map' hf measurable_swap.ae_measurable, prod_swap] }
lemma lintegral_prod_of_measurable :
  ‚àÄ (f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (hf : measurable f), ‚à´‚Åª z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´‚Åª x, ‚à´‚Åª y, f (x, y) ‚àÇŒΩ ‚àÇŒº :=
begin
  have m := @measurable_prod_mk_left,
  refine measurable.ennreal_induction _ _ _,
  { intros c s hs, simp only [‚Üê indicator_comp_right],
    simp [lintegral_indicator, m hs, hs, lintegral_const_mul, measurable_measure_prod_mk_left hs,
      prod_apply] },
  { rintro f g - hf hg h2f h2g,
    simp [lintegral_add_left, measurable.lintegral_prod_right', hf.comp m, hf, h2f, h2g] },
  { intros f hf h2f h3f,
    have kf : ‚àÄ x n, measurable (Œª y, f n (x, y)) := Œª x n, (hf n).comp m,
    have k2f : ‚àÄ x, monotone (Œª n y, f n (x, y)) := Œª x i j hij y, h2f hij (x, y),
    have lf : ‚àÄ n, measurable (Œª x, ‚à´‚Åª y, f n (x, y) ‚àÇŒΩ) := Œª n, (hf n).lintegral_prod_right',
    have l2f : monotone (Œª n x, ‚à´‚Åª y, f n (x, y) ‚àÇŒΩ) := Œª i j hij x, lintegral_mono (k2f x hij),
    simp only [lintegral_supr hf h2f, lintegral_supr (kf _), k2f, lintegral_supr lf l2f, h3f] },
end
lemma lintegral_prod (f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (hf : ae_measurable f (Œº.prod ŒΩ)) :
  ‚à´‚Åª z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´‚Åª x, ‚à´‚Åª y, f (x, y) ‚àÇŒΩ ‚àÇŒº :=
begin
  have A : ‚à´‚Åª z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´‚Åª z, hf.mk f z ‚àÇ(Œº.prod ŒΩ) :=
    lintegral_congr_ae hf.ae_eq_mk,
  have B : ‚à´‚Åª x, ‚à´‚Åª y, f (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´‚Åª x, ‚à´‚Åª y, hf.mk f (x, y) ‚àÇŒΩ ‚àÇŒº,
  { apply lintegral_congr_ae,
    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with _ ha using lintegral_congr_ae ha, },
  rw [A, B, lintegral_prod_of_measurable _ hf.measurable_mk],
  apply_instance
end
lemma lintegral_prod_symm [sigma_finite Œº] (f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû)
  (hf : ae_measurable f (Œº.prod ŒΩ)) : ‚à´‚Åª z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´‚Åª y, ‚à´‚Åª x, f (x, y) ‚àÇŒº ‚àÇŒΩ :=
by { simp_rw [‚Üê lintegral_prod_swap f hf], exact lintegral_prod _ hf.prod_swap }
lemma lintegral_prod_symm' [sigma_finite Œº] (f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû)
  (hf : measurable f) : ‚à´‚Åª z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´‚Åª y, ‚à´‚Åª x, f (x, y) ‚àÇŒº ‚àÇŒΩ :=
lintegral_prod_symm f hf.ae_measurable
lemma lintegral_lintegral ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû‚¶Ñ
  (hf : ae_measurable (uncurry f) (Œº.prod ŒΩ)) :
  ‚à´‚Åª x, ‚à´‚Åª y, f x y ‚àÇŒΩ ‚àÇŒº = ‚à´‚Åª z, f z.1 z.2 ‚àÇ(Œº.prod ŒΩ) :=
(lintegral_prod _ hf).symm
lemma lintegral_lintegral_symm [sigma_finite Œº] ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû‚¶Ñ
  (hf : ae_measurable (uncurry f) (Œº.prod ŒΩ)) :
  ‚à´‚Åª x, ‚à´‚Åª y, f x y ‚àÇŒΩ ‚àÇŒº = ‚à´‚Åª z, f z.2 z.1 ‚àÇ(ŒΩ.prod Œº) :=
(lintegral_prod_symm _ hf.prod_swap).symm
lemma lintegral_lintegral_swap [sigma_finite Œº] ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû‚¶Ñ
  (hf : ae_measurable (uncurry f) (Œº.prod ŒΩ)) :
  ‚à´‚Åª x, ‚à´‚Åª y, f x y ‚àÇŒΩ ‚àÇŒº = ‚à´‚Åª y, ‚à´‚Åª x, f x y ‚àÇŒº ‚àÇŒΩ :=
(lintegral_lintegral hf).trans (lintegral_prod_symm _ hf)
lemma lintegral_prod_mul {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ≤ ‚Üí ‚Ñù‚â•0‚àû}
  (hf : ae_measurable f Œº) (hg : ae_measurable g ŒΩ) :
  ‚à´‚Åª z, f z.1 * g z.2 ‚àÇ(Œº.prod ŒΩ) = ‚à´‚Åª x, f x ‚àÇŒº * ‚à´‚Åª y, g y ‚àÇŒΩ :=
by simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]
section
lemma integrable.swap [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (f ‚àò prod.swap) (ŒΩ.prod Œº) :=
‚ü®hf.ae_strongly_measurable.prod_swap,
  (lintegral_prod_swap _ hf.ae_strongly_measurable.ennnorm : _).le.trans_lt hf.has_finite_integral‚ü©
lemma integrable_swap_iff [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ :
  integrable (f ‚àò prod.swap) (ŒΩ.prod Œº) ‚Üî integrable f (Œº.prod ŒΩ) :=
‚ü®Œª hf, by { convert hf.swap, ext ‚ü®x, y‚ü©, refl }, Œª hf, hf.swap‚ü©
lemma has_finite_integral_prod_iff ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (h1f : strongly_measurable f) :
  has_finite_integral f (Œº.prod ŒΩ) ‚Üî (‚àÄ·µê x ‚àÇ Œº, has_finite_integral (Œª y, f (x, y)) ŒΩ) ‚àß
    has_finite_integral (Œª x, ‚à´ y, ‚à•f (x, y)‚à• ‚àÇŒΩ) Œº :=
begin
  simp only [has_finite_integral, lintegral_prod_of_measurable _ h1f.ennnorm],
  have : ‚àÄ x, ‚àÄ·µê y ‚àÇŒΩ, 0 ‚â§ ‚à•f (x, y)‚à• := Œª x, eventually_of_forall (Œª y, norm_nonneg _),
  simp_rw [integral_eq_lintegral_of_nonneg_ae (this _)
    (h1f.norm.comp_measurable measurable_prod_mk_left).ae_strongly_measurable,
    ennnorm_eq_of_real to_real_nonneg, of_real_norm_eq_coe_nnnorm],
lemma integrable_prod_iff ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (h1f : ae_strongly_measurable f (Œº.prod ŒΩ)) :
  integrable f (Œº.prod ŒΩ) ‚Üî
    (‚àÄ·µê x ‚àÇ Œº, integrable (Œª y, f (x, y)) ŒΩ) ‚àß integrable (Œª x, ‚à´ y, ‚à•f (x, y)‚à• ‚àÇŒΩ) Œº :=
by simp [integrable, h1f, has_finite_integral_prod_iff', h1f.norm.integral_prod_right',
         h1f.prod_mk_left]
lemma integrable_prod_iff' [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (h1f : ae_strongly_measurable f (Œº.prod ŒΩ)) :
  integrable f (Œº.prod ŒΩ) ‚Üî
    (‚àÄ·µê y ‚àÇ ŒΩ, integrable (Œª x, f (x, y)) Œº) ‚àß integrable (Œª y, ‚à´ x, ‚à•f (x, y)‚à• ‚àÇŒº) ŒΩ :=
by { convert integrable_prod_iff (h1f.prod_swap) using 1, rw [integrable_swap_iff] }
lemma integrable.prod_left_ae [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : ‚àÄ·µê y ‚àÇ ŒΩ, integrable (Œª x, f (x, y)) Œº :=
((integrable_prod_iff' hf.ae_strongly_measurable).mp hf).1
lemma integrable.prod_right_ae [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : ‚àÄ·µê x ‚àÇ Œº, integrable (Œª y, f (x, y)) ŒΩ :=
hf.swap.prod_left_ae
lemma integrable.integral_norm_prod_left ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (Œª x, ‚à´ y, ‚à•f (x, y)‚à• ‚àÇŒΩ) Œº :=
((integrable_prod_iff hf.ae_strongly_measurable).mp hf).2
lemma integrable.integral_norm_prod_right [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (Œª y, ‚à´ x, ‚à•f (x, y)‚à• ‚àÇŒº) ŒΩ :=
hf.swap.integral_norm_prod_left
lemma integrable_prod_mul {f : Œ± ‚Üí ‚Ñù} {g : Œ≤ ‚Üí ‚Ñù} (hf : integrable f Œº) (hg : integrable g ŒΩ) :
  integrable (Œª (z : Œ± √ó Œ≤), f z.1 * g z.2) (Œº.prod ŒΩ) :=
begin
  refine (integrable_prod_iff _).2 ‚ü®_, _‚ü©,
  { apply ae_strongly_measurable.mul,
    { exact (hf.1.mono' prod_fst_absolutely_continuous).comp_measurable measurable_fst },
    { exact (hg.1.mono' prod_snd_absolutely_continuous).comp_measurable measurable_snd } },
  { exact eventually_of_forall (Œª x, hg.const_mul (f x)) },
  { simpa only [norm_mul, integral_mul_left] using hf.norm.mul_const _ }
end
end
variables [normed_space ‚Ñù E] [complete_space E]
lemma integrable.integral_prod_left ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (Œª x, ‚à´ y, f (x, y) ‚àÇŒΩ) Œº :=
integrable.mono hf.integral_norm_prod_left hf.ae_strongly_measurable.integral_prod_right' $
  eventually_of_forall $ Œª x, (norm_integral_le_integral_norm _).trans_eq $
  (norm_of_nonneg $ integral_nonneg_of_ae $ eventually_of_forall $
  Œª y, (norm_nonneg (f (x, y)) : _)).symm
lemma integrable.integral_prod_right [sigma_finite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) : integrable (Œª y, ‚à´ x, f (x, y) ‚àÇŒº) ŒΩ :=
hf.swap.integral_prod_left
variables [sigma_finite Œº]
lemma integral_prod_swap (f : Œ± √ó Œ≤ ‚Üí E)
  (hf : ae_strongly_measurable f (Œº.prod ŒΩ)) : ‚à´ z, f z.swap ‚àÇ(ŒΩ.prod Œº) = ‚à´ z, f z ‚àÇ(Œº.prod ŒΩ) :=
begin
  rw ‚Üê prod_swap at hf,
  rw [‚Üê integral_map measurable_swap.ae_measurable hf, prod_swap]
end
variables {E' : Type*} [normed_group E'] [complete_space E'] [normed_space ‚Ñù E']
lemma integral_fn_integral_add ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (F : E ‚Üí E')
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, F (‚à´ y, f (x, y) + g (x, y) ‚àÇŒΩ) ‚àÇŒº = ‚à´ x, F (‚à´ y, f (x, y) ‚àÇŒΩ + ‚à´ y, g (x, y) ‚àÇŒΩ) ‚àÇŒº :=
begin
  refine integral_congr_ae _,
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g,
  simp [integral_add h2f h2g],
end
lemma integral_fn_integral_sub ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ (F : E ‚Üí E')
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, F (‚à´ y, f (x, y) - g (x, y) ‚àÇŒΩ) ‚àÇŒº = ‚à´ x, F (‚à´ y, f (x, y) ‚àÇŒΩ - ‚à´ y, g (x, y) ‚àÇŒΩ) ‚àÇŒº :=
begin
  refine integral_congr_ae _,
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g,
  simp [integral_sub h2f h2g],
end
lemma lintegral_fn_integral_sub ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (F : E ‚Üí ‚Ñù‚â•0‚àû) (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´‚Åª x, F (‚à´ y, f (x, y) - g (x, y) ‚àÇŒΩ) ‚àÇŒº = ‚à´‚Åª x, F (‚à´ y, f (x, y) ‚àÇŒΩ - ‚à´ y, g (x, y) ‚àÇŒΩ) ‚àÇŒº :=
begin
  refine lintegral_congr_ae _,
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g,
  simp [integral_sub h2f h2g],
end
lemma integral_integral_add ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f (x, y) + g (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº + ‚à´ x, ‚à´ y, g (x, y) ‚àÇŒΩ ‚àÇŒº :=
(integral_fn_integral_add id hf hg).trans $
  integral_add hf.integral_prod_left hg.integral_prod_left
lemma integral_integral_add' ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, (f + g) (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº + ‚à´ x, ‚à´ y, g (x, y) ‚àÇŒΩ ‚àÇŒº :=
integral_integral_add hf hg
lemma integral_integral_sub ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f (x, y) - g (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº - ‚à´ x, ‚à´ y, g (x, y) ‚àÇŒΩ ‚àÇŒº :=
(integral_fn_integral_sub id hf hg).trans $
  integral_sub hf.integral_prod_left hg.integral_prod_left
lemma integral_integral_sub' ‚¶Éf g : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
  (hf : integrable f (Œº.prod ŒΩ)) (hg : integrable g (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, (f - g) (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº - ‚à´ x, ‚à´ y, g (x, y) ‚àÇŒΩ ‚àÇŒº :=
integral_integral_sub hf hg
lemma continuous_integral_integral :
  continuous (Œª (f : Œ± √ó Œ≤ ‚Üí‚ÇÅ[Œº.prod ŒΩ] E), ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº) :=
begin
  rw [continuous_iff_continuous_at], intro g,
  refine tendsto_integral_of_L1 _ (L1.integrable_coe_fn g).integral_prod_left
    (eventually_of_forall $ Œª h, (L1.integrable_coe_fn h).integral_prod_left) _,
  simp_rw [‚Üê lintegral_fn_integral_sub (Œª x, (‚à•x‚à•‚Çä : ‚Ñù‚â•0‚àû)) (L1.integrable_coe_fn _)
    (L1.integrable_coe_fn g)],
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (Œª i, zero_le _) _,
  { exact Œª i, ‚à´‚Åª x, ‚à´‚Åª y, ‚à•i (x, y) - g (x, y)‚à•‚Çä ‚àÇŒΩ ‚àÇŒº },
  swap, { exact Œª i, lintegral_mono (Œª x, ennnorm_integral_le_lintegral_ennnorm _) },
  show tendsto (Œª (i : Œ± √ó Œ≤ ‚Üí‚ÇÅ[Œº.prod ŒΩ] E),
    ‚à´‚Åª x, ‚à´‚Åª (y : Œ≤), ‚à•i (x, y) - g (x, y)‚à•‚Çä ‚àÇŒΩ ‚àÇŒº) (ùìù g) (ùìù 0),
  have : ‚àÄ (i : Œ± √ó Œ≤ ‚Üí‚ÇÅ[Œº.prod ŒΩ] E), measurable (Œª z, (‚à•i z - g z‚à•‚Çä : ‚Ñù‚â•0‚àû)) :=
  Œª i, ((Lp.strongly_measurable i).sub (Lp.strongly_measurable g)).ennnorm,
  simp_rw [‚Üê lintegral_prod_of_measurable _ (this _), ‚Üê L1.of_real_norm_sub_eq_lintegral,
    ‚Üê of_real_zero],
  refine (continuous_of_real.tendsto 0).comp _,
  rw [‚Üê tendsto_iff_norm_tendsto_zero], exact tendsto_id
end
lemma integral_prod : ‚àÄ (f : Œ± √ó Œ≤ ‚Üí E) (hf : integrable f (Œº.prod ŒΩ)),
  ‚à´ z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´ x, ‚à´ y, f (x, y) ‚àÇŒΩ ‚àÇŒº :=
begin
  apply integrable.induction,
  { intros c s hs h2s,
    simp_rw [integral_indicator hs, ‚Üê indicator_comp_right,
      function.comp, integral_indicator (measurable_prod_mk_left hs),
      set_integral_const, integral_smul_const,
      integral_to_real (measurable_measure_prod_mk_left hs).ae_measurable
      (ae_measure_lt_top hs h2s.ne), prod_apply hs] },
  { intros f g hfg i_f i_g hf hg,
    simp_rw [integral_add' i_f i_g, integral_integral_add' i_f i_g, hf, hg] },
  { exact is_closed_eq continuous_integral continuous_integral_integral },
  { intros f g hfg i_f hf, convert hf using 1,
    { exact integral_congr_ae hfg.symm },
    { refine integral_congr_ae _,
      refine (ae_ae_of_ae_prod hfg).mp _,
      apply eventually_of_forall, intros x hfgx,
      exact integral_congr_ae (ae_eq_symm hfgx) } }
end
lemma integral_prod_symm (f : Œ± √ó Œ≤ ‚Üí E) (hf : integrable f (Œº.prod ŒΩ)) :
  ‚à´ z, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´ y, ‚à´ x, f (x, y) ‚àÇŒº ‚àÇŒΩ :=
by { simp_rw [‚Üê integral_prod_swap f hf.ae_strongly_measurable], exact integral_prod _ hf.swap }
lemma integral_integral {f : Œ± ‚Üí Œ≤ ‚Üí E} (hf : integrable (uncurry f) (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f x y ‚àÇŒΩ ‚àÇŒº = ‚à´ z, f z.1 z.2 ‚àÇ(Œº.prod ŒΩ) :=
(integral_prod _ hf).symm
lemma integral_integral_symm {f : Œ± ‚Üí Œ≤ ‚Üí E} (hf : integrable (uncurry f) (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f x y ‚àÇŒΩ ‚àÇŒº = ‚à´ z, f z.2 z.1 ‚àÇ(ŒΩ.prod Œº) :=
(integral_prod_symm _ hf.swap).symm
lemma integral_integral_swap ‚¶Éf : Œ± ‚Üí Œ≤ ‚Üí E‚¶Ñ (hf : integrable (uncurry f) (Œº.prod ŒΩ)) :
  ‚à´ x, ‚à´ y, f x y ‚àÇŒΩ ‚àÇŒº = ‚à´ y, ‚à´ x, f x y ‚àÇŒº ‚àÇŒΩ :=
(integral_integral hf).trans (integral_prod_symm _ hf)
lemma set_integral_prod (f : Œ± √ó Œ≤ ‚Üí E) {s : set Œ±} {t : set Œ≤}
  (hf : integrable_on f (s √óÀ¢ t) (Œº.prod ŒΩ)) :
  ‚à´ z in s √óÀ¢ t, f z ‚àÇ(Œº.prod ŒΩ) = ‚à´ x in s, ‚à´ y in t, f (x, y) ‚àÇŒΩ ‚àÇŒº :=
begin
  simp only [‚Üê measure.prod_restrict s t, integrable_on] at hf ‚ä¢,
  exact integral_prod f hf
end
lemma integral_prod_mul (f : Œ± ‚Üí ‚Ñù) (g : Œ≤ ‚Üí ‚Ñù) :
  ‚à´ z, f z.1 * g z.2 ‚àÇ(Œº.prod ŒΩ) = (‚à´ x, f x ‚àÇŒº) * (‚à´ y, g y ‚àÇŒΩ) :=
begin
  by_cases h : integrable (Œª (z : Œ± √ó Œ≤), f z.1 * g z.2) (Œº.prod ŒΩ),
  { rw integral_prod _ h,
    simp_rw [integral_mul_left, integral_mul_right] },
  have H : ¬¨(integrable f Œº) ‚à® ¬¨(integrable g ŒΩ),
  { contrapose! h,
    exact integrable_prod_mul h.1 h.2 },
  cases H;
  simp [integral_undef h, integral_undef H],
end
lemma set_integral_prod_mul (f : Œ± ‚Üí ‚Ñù) (g : Œ≤ ‚Üí ‚Ñù) (s : set Œ±) (t : set Œ≤) :
  ‚à´ z in s √óÀ¢ t, f z.1 * g z.2 ‚àÇ(Œº.prod ŒΩ) = (‚à´ x in s, f x ‚àÇŒº) * (‚à´ y in t, g y ‚àÇŒΩ) :=
by simp only [‚Üê measure.prod_restrict s t, integrable_on, integral_prod_mul]
end measure_theory
