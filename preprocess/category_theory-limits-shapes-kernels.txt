import category_theory.limits.preserves.shapes.zero
noncomputable theory
universes v vâ‚‚ u u' uâ‚‚
open category_theory
open category_theory.limits.walking_parallel_pair
namespace category_theory.limits
variables {C : Type u} [category.{v} C]
variables [has_zero_morphisms C]
abbreviation has_kernel {X Y : C} (f : X âŸ¶ Y) : Prop := has_limit (parallel_pair f 0)
abbreviation has_cokernel {X Y : C} (f : X âŸ¶ Y) : Prop := has_colimit (parallel_pair f 0)
variables {X Y : C} (f : X âŸ¶ Y)
section
abbreviation kernel_fork := fork f 0
variables {f}
@[simp, reassoc] lemma kernel_fork.condition (s : kernel_fork f) : fork.Î¹ s â‰« f = 0 :=
by erw [fork.condition, has_zero_morphisms.comp_zero]
@[simp] lemma kernel_fork.app_one (s : kernel_fork f) : s.Ï€.app one = 0 :=
by simp [fork.app_one_eq_Î¹_comp_right]
abbreviation kernel_fork.of_Î¹ {Z : C} (Î¹ : Z âŸ¶ X) (w : Î¹ â‰« f = 0) : kernel_fork f :=
fork.of_Î¹ Î¹ $ by rw [w, has_zero_morphisms.comp_zero]
@[simp] lemma kernel_fork.Î¹_of_Î¹ {X Y P : C} (f : X âŸ¶ Y) (Î¹ : P âŸ¶ X) (w : Î¹ â‰« f = 0) :
  fork.Î¹ (kernel_fork.of_Î¹ Î¹ w) = Î¹ := rfl
section
local attribute [tidy] tactic.case_bash
def iso_of_Î¹ (s : fork f 0) : s â‰… fork.of_Î¹ (fork.Î¹ s) (fork.condition s) :=
cones.ext (iso.refl _) $ by tidy
def of_Î¹_congr {P : C} {Î¹ Î¹' : P âŸ¶ X} {w : Î¹ â‰« f = 0} (h : Î¹ = Î¹') :
  kernel_fork.of_Î¹ Î¹ w â‰… kernel_fork.of_Î¹ Î¹' (by rw [â†h, w]) :=
cones.ext (iso.refl _) $ by tidy
def comp_nat_iso {D : Type u'} [category.{v} D] [has_zero_morphisms D] (F : C â¥¤ D)
  [is_equivalence F] : parallel_pair f 0 â‹™ F â‰… parallel_pair (F.map f) 0 :=
nat_iso.of_components (Î» j, match j with
  | zero := iso.refl _
  | one := iso.refl _
  end) $ by tidy
end
def kernel_fork.is_limit.lift' {s : kernel_fork f} (hs : is_limit s) {W : C} (k : W âŸ¶ X)
  (h : k â‰« f = 0) : {l : W âŸ¶ s.X // l â‰« fork.Î¹ s = k} :=
âŸ¨hs.lift $ kernel_fork.of_Î¹ _ h, hs.fac _ _âŸ©
def is_limit_aux (t : kernel_fork f)
  (lift : Î  (s : kernel_fork f), s.X âŸ¶ t.X)
  (fac : âˆ€ (s : kernel_fork f), lift s â‰« t.Î¹ = s.Î¹)
  (uniq : âˆ€ (s : kernel_fork f) (m : s.X âŸ¶ t.X) (w : m â‰« t.Î¹ = s.Î¹), m = lift s) :
  is_limit t :=
{ lift := lift,
  fac' := Î» s j, by { cases j, { exact fac s, }, { simp, }, },
  uniq' := Î» s m w, uniq s m (w limits.walking_parallel_pair.zero), }
def is_limit.of_Î¹ {W : C} (g : W âŸ¶ X) (eq : g â‰« f = 0)
  (lift : Î  {W' : C} (g' : W' âŸ¶ X) (eq' : g' â‰« f = 0), W' âŸ¶ W)
  (fac : âˆ€ {W' : C} (g' : W' âŸ¶ X) (eq' : g' â‰« f = 0), lift g' eq' â‰« g = g')
  (uniq :
    âˆ€ {W' : C} (g' : W' âŸ¶ X) (eq' : g' â‰« f = 0) (m : W' âŸ¶ W) (w : m â‰« g = g'), m = lift g' eq') :
  is_limit (kernel_fork.of_Î¹ g eq) :=
is_limit_aux _ (Î» s, lift s.Î¹ s.condition) (Î» s, fac s.Î¹ s.condition) (Î» s, uniq s.Î¹ s.condition)
def is_kernel_comp_mono {c : kernel_fork f} (i : is_limit c) {Z} (g : Y âŸ¶ Z) [hg : mono g]
  {h : X âŸ¶ Z} (hh : h = f â‰« g) :
  is_limit (kernel_fork.of_Î¹ c.Î¹ (by simp [hh]) : kernel_fork h) :=
fork.is_limit.mk' _ $ Î» s,
  let s' : kernel_fork f := fork.of_Î¹ s.Î¹ (by rw [â†cancel_mono g]; simp [â†hh, s.condition]) in
  let l := kernel_fork.is_limit.lift' i s'.Î¹ s'.condition in
  âŸ¨l.1, l.2, Î» m hm, by apply fork.is_limit.hom_ext i; rw fork.Î¹_of_Î¹ at hm; rw hm; exact l.2.symmâŸ©
lemma is_kernel_comp_mono_lift {c : kernel_fork f} (i : is_limit c) {Z} (g : Y âŸ¶ Z) [hg : mono g]
  {h : X âŸ¶ Z} (hh : h = f â‰« g) (s : kernel_fork h) :
  (is_kernel_comp_mono i g hh).lift s
  = i.lift (fork.of_Î¹ s.Î¹ (by { rw [â†cancel_mono g, category.assoc, â†hh], simp })) := rfl
def is_kernel_of_comp {W : C} (g : Y âŸ¶ W) (h : X âŸ¶ W) {c : kernel_fork h} (i : is_limit c)
  (hf : c.Î¹ â‰« f = 0) (hfg : f â‰« g = h) : is_limit (kernel_fork.of_Î¹ c.Î¹ hf) :=
fork.is_limit.mk _
  (Î» s, i.lift (kernel_fork.of_Î¹ s.Î¹ (by simp [â† hfg])))
  (Î» s, by simp only [kernel_fork.Î¹_of_Î¹, fork.is_limit.lift_Î¹])
  (Î» s m h, by { apply fork.is_limit.hom_ext i, simpa using h })
end
section
variables [has_kernel f]
abbreviation kernel : C := equalizer f 0
abbreviation kernel.Î¹ : kernel f âŸ¶ X := equalizer.Î¹ f 0
@[simp] lemma equalizer_as_kernel : equalizer.Î¹ f 0 = kernel.Î¹ f := rfl
@[simp, reassoc] lemma kernel.condition : kernel.Î¹ f â‰« f = 0 :=
kernel_fork.condition _
def kernel_is_kernel :
  is_limit (fork.of_Î¹ (kernel.Î¹ f) ((kernel.condition f).trans (comp_zero.symm))) :=
is_limit.of_iso_limit (limit.is_limit _) (fork.ext (iso.refl _) (by tidy))
abbreviation kernel.lift {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) : W âŸ¶ kernel f :=
limit.lift (parallel_pair f 0) (kernel_fork.of_Î¹ k h)
@[simp, reassoc]
lemma kernel.lift_Î¹ {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) : kernel.lift f k h â‰« kernel.Î¹ f = k :=
limit.lift_Ï€ _ _
@[simp]
lemma kernel.lift_zero {W : C} {h} : kernel.lift f (0 : W âŸ¶ X) h = 0 :=
by { ext, simp, }
instance kernel.lift_mono {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) [mono k] : mono (kernel.lift f k h) :=
âŸ¨Î» Z g g' w,
begin
  replace w := w =â‰« kernel.Î¹ f,
  simp only [category.assoc, kernel.lift_Î¹] at w,
  exact (cancel_mono k).1 w,
endâŸ©
def kernel.lift' {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) : {l : W âŸ¶ kernel f // l â‰« kernel.Î¹ f = k} :=
âŸ¨kernel.lift f k h, kernel.lift_Î¹ _ _ _âŸ©
abbreviation kernel.map {X' Y' : C} (f' : X' âŸ¶ Y') [has_kernel f']
  (p : X âŸ¶ X') (q : Y âŸ¶ Y') (w : f â‰« q = p â‰« f') : kernel f âŸ¶ kernel f' :=
kernel.lift f' (kernel.Î¹ f â‰« p) (by simp [â†w])
lemma kernel.lift_map {X Y Z X' Y' Z' : C}
  (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [has_kernel g] (w : f â‰« g = 0)
  (f' : X' âŸ¶ Y') (g' : Y' âŸ¶ Z') [has_kernel g'] (w' : f' â‰« g' = 0)
  (p : X âŸ¶ X') (q : Y âŸ¶ Y') (r : Z âŸ¶ Z') (hâ‚ : f â‰« q = p â‰« f') (hâ‚‚ : g â‰« r = q â‰« g') :
  kernel.lift g f w â‰« kernel.map g g' q r hâ‚‚ = p â‰« kernel.lift g' f' w' :=
by { ext, simp [hâ‚], }
@[simps]
def kernel.map_iso {X' Y' : C} (f' : X' âŸ¶ Y') [has_kernel f']
  (p : X â‰… X') (q : Y â‰… Y') (w : f â‰« q.hom = p.hom â‰« f') : kernel f â‰… kernel f' :=
{ hom := kernel.map f f' p.hom q.hom w,
  inv := kernel.map f' f p.inv q.inv (by { refine (cancel_mono q.hom).1 _, simp [w], }), }
instance kernel.Î¹_zero_is_iso : is_iso (kernel.Î¹ (0 : X âŸ¶ Y)) :=
equalizer.Î¹_of_self _
lemma eq_zero_of_epi_kernel [epi (kernel.Î¹ f)] : f = 0 :=
(cancel_epi (kernel.Î¹ f)).1 (by simp)
def kernel_zero_iso_source : kernel (0 : X âŸ¶ Y) â‰… X :=
equalizer.iso_source_of_self 0
@[simp] lemma kernel_zero_iso_source_hom :
  kernel_zero_iso_source.hom = kernel.Î¹ (0 : X âŸ¶ Y) := rfl
@[simp] lemma kernel_zero_iso_source_inv :
  kernel_zero_iso_source.inv = kernel.lift (0 : X âŸ¶ Y) (ğŸ™ X) (by simp) :=
by { ext, simp [kernel_zero_iso_source], }
def kernel_iso_of_eq {f g : X âŸ¶ Y} [has_kernel f] [has_kernel g] (h : f = g) :
  kernel f â‰… kernel g :=
has_limit.iso_of_nat_iso (by simp[h])
@[simp]
lemma kernel_iso_of_eq_refl {h : f = f} : kernel_iso_of_eq h = iso.refl (kernel f) :=
by { ext, simp [kernel_iso_of_eq], }
@[simp, reassoc]
lemma kernel_iso_of_eq_hom_comp_Î¹ {f g : X âŸ¶ Y} [has_kernel f] [has_kernel g] (h : f = g) :
  (kernel_iso_of_eq h).hom â‰« kernel.Î¹ _ = kernel.Î¹ _ :=
by { unfreezingI { induction h, simp } }
@[simp, reassoc]
lemma kernel_iso_of_eq_inv_comp_Î¹ {f g : X âŸ¶ Y} [has_kernel f] [has_kernel g] (h : f = g) :
  (kernel_iso_of_eq h).inv â‰« kernel.Î¹ _ = kernel.Î¹ _ :=
by { unfreezingI { induction h, simp } }
@[simp, reassoc]
lemma lift_comp_kernel_iso_of_eq_hom {Z} {f g : X âŸ¶ Y} [has_kernel f] [has_kernel g]
  (h : f = g) (e : Z âŸ¶ X) (he) :
  kernel.lift _ e he â‰« (kernel_iso_of_eq h).hom = kernel.lift _ e (by simp [â† h, he]) :=
by { unfreezingI { induction h, simp } }
@[simp, reassoc]
lemma lift_comp_kernel_iso_of_eq_inv {Z} {f g : X âŸ¶ Y} [has_kernel f] [has_kernel g]
  (h : f = g) (e : Z âŸ¶ X) (he) :
  kernel.lift _ e he â‰« (kernel_iso_of_eq h).inv = kernel.lift _ e (by simp [h, he]) :=
by { unfreezingI { induction h, simp } }
@[simp]
lemma kernel_iso_of_eq_trans {f g h : X âŸ¶ Y} [has_kernel f] [has_kernel g] [has_kernel h]
  (wâ‚ : f = g) (wâ‚‚ : g = h) :
  kernel_iso_of_eq wâ‚ â‰ªâ‰« kernel_iso_of_eq wâ‚‚ = kernel_iso_of_eq (wâ‚.trans wâ‚‚) :=
by { unfreezingI { induction wâ‚, induction wâ‚‚, }, ext, simp [kernel_iso_of_eq], }
variables {f}
lemma kernel_not_epi_of_nonzero (w : f â‰  0) : Â¬epi (kernel.Î¹ f) :=
Î» I, by exactI w (eq_zero_of_epi_kernel f)
lemma kernel_not_iso_of_nonzero (w : f â‰  0) : (is_iso (kernel.Î¹ f)) â†’ false :=
Î» I, kernel_not_epi_of_nonzero w $ by { resetI, apply_instance }
instance has_kernel_comp_mono {X Y Z : C} (f : X âŸ¶ Y) [has_kernel f] (g : Y âŸ¶ Z) [mono g] :
  has_kernel (f â‰« g) :=
âŸ¨âŸ¨{ cone := _, is_limit := is_kernel_comp_mono (limit.is_limit _) g rfl }âŸ©âŸ©
@[simps]
def kernel_comp_mono {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [has_kernel f] [mono g] :
  kernel (f â‰« g) â‰… kernel f :=
{ hom := kernel.lift _ (kernel.Î¹ _) (by { rw [â†cancel_mono g], simp, }),
  inv := kernel.lift _ (kernel.Î¹ _) (by simp), }
instance has_kernel_iso_comp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [is_iso f] [has_kernel g] :
  has_kernel (f â‰« g) :=
{ exists_limit :=
  âŸ¨{ cone := kernel_fork.of_Î¹ (kernel.Î¹ g â‰« inv f) (by simp),
     is_limit := is_limit_aux _ (Î» s, kernel.lift _ (s.Î¹ â‰« f) (by tidy)) (by tidy)
       (Î» s m w, by { simp_rw [â†w], ext, simp, }), }âŸ© }
@[simps]
def kernel_is_iso_comp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [is_iso f] [has_kernel g] :
  kernel (f â‰« g) â‰… kernel g :=
{ hom := kernel.lift _ (kernel.Î¹ _ â‰« f) (by simp),
  inv := kernel.lift _ (kernel.Î¹ _ â‰« inv f) (by simp), }
end
section has_zero_object
variables [has_zero_object C]
open_locale zero_object
def kernel.zero_kernel_fork : kernel_fork f :=
{ X := 0,
  Ï€ := { app := Î» j, 0 }}
def kernel.is_limit_cone_zero_cone [mono f] : is_limit (kernel.zero_kernel_fork f) :=
fork.is_limit.mk _ (Î» s, 0)
  (Î» s, by { erw zero_comp,
    convert (zero_of_comp_mono f _).symm,
    exact kernel_fork.condition _ })
  (Î» _ _ _, zero_of_to_zero _)
def kernel.of_mono [has_kernel f] [mono f] : kernel f â‰… 0 :=
functor.map_iso (cones.forget _) $ is_limit.unique_up_to_iso
  (limit.is_limit (parallel_pair f 0)) (kernel.is_limit_cone_zero_cone f)
lemma kernel.Î¹_of_mono [has_kernel f] [mono f] : kernel.Î¹ f = 0 :=
zero_of_source_iso_zero _ (kernel.of_mono f)
def zero_kernel_of_cancel_zero {X Y : C} (f : X âŸ¶ Y)
  (hf : âˆ€ (Z : C) (g : Z âŸ¶ X) (hgf : g â‰« f = 0), g = 0) :
    is_limit (kernel_fork.of_Î¹ (0 : 0 âŸ¶ X) (show 0 â‰« f = 0, by simp)) :=
fork.is_limit.mk _ (Î» s, 0)
  (Î» s, by rw [hf _ _ (kernel_fork.condition s), zero_comp])
  (Î» s m h, by ext)
end has_zero_object
section transport
def is_kernel.of_comp_iso {Z : C} (l : X âŸ¶ Z) (i : Z â‰… Y) (h : l â‰« i.hom = f)
  {s : kernel_fork f} (hs : is_limit s) : is_limit (kernel_fork.of_Î¹ (fork.Î¹ s) $
    show fork.Î¹ s â‰« l = 0, by simp [â†i.comp_inv_eq.2 h.symm]) :=
fork.is_limit.mk _
  (Î» s, hs.lift $ kernel_fork.of_Î¹ (fork.Î¹ s) $ by simp [â†h])
  (Î» s, by simp)
  (Î» s m h, by { apply fork.is_limit.hom_ext hs, simpa using h })
def kernel.of_comp_iso [has_kernel f]
  {Z : C} (l : X âŸ¶ Z) (i : Z â‰… Y) (h : l â‰« i.hom = f) :
  is_limit (kernel_fork.of_Î¹ (kernel.Î¹ f) $
    show kernel.Î¹ f â‰« l = 0, by simp [â†i.comp_inv_eq.2 h.symm]) :=
is_kernel.of_comp_iso f l i h $ limit.is_limit _
def is_kernel.iso_kernel {Z : C} (l : Z âŸ¶ X) {s : kernel_fork f} (hs : is_limit s)
  (i : Z â‰… s.X) (h : i.hom â‰« fork.Î¹ s = l) : is_limit (kernel_fork.of_Î¹ l $
    show l â‰« f = 0, by simp [â†h]) :=
is_limit.of_iso_limit hs $ cones.ext i.symm $ Î» j,
  by { cases j, { exact (iso.eq_inv_comp i).2 h }, { simp } }
def kernel.iso_kernel [has_kernel f]
  {Z : C} (l : Z âŸ¶ X) (i : Z â‰… kernel f) (h : i.hom â‰« kernel.Î¹ f = l) :
  is_limit (kernel_fork.of_Î¹ l $ by simp [â†h]) :=
is_kernel.iso_kernel f l (limit.is_limit _) i h
end transport
section
variables (X Y)
lemma kernel.Î¹_of_zero : is_iso (kernel.Î¹ (0 : X âŸ¶ Y)) :=
equalizer.Î¹_of_self _
end
section
abbreviation cokernel_cofork := cofork f 0
variables {f}
@[simp, reassoc] lemma cokernel_cofork.condition (s : cokernel_cofork f) : f â‰« s.Ï€ = 0 :=
by rw [cofork.condition, zero_comp]
@[simp] lemma cokernel_cofork.Ï€_eq_zero (s : cokernel_cofork f) : s.Î¹.app zero = 0 :=
by simp [cofork.app_zero_eq_comp_Ï€_right]
abbreviation cokernel_cofork.of_Ï€ {Z : C} (Ï€ : Y âŸ¶ Z) (w : f â‰« Ï€ = 0) : cokernel_cofork f :=
cofork.of_Ï€ Ï€ $ by rw [w, zero_comp]
@[simp] lemma cokernel_cofork.Ï€_of_Ï€ {X Y P : C} (f : X âŸ¶ Y) (Ï€ : Y âŸ¶ P) (w : f â‰« Ï€ = 0) :
  cofork.Ï€ (cokernel_cofork.of_Ï€ Ï€ w) = Ï€ := rfl
def iso_of_Ï€ (s : cofork f 0) : s â‰… cofork.of_Ï€ (cofork.Ï€ s) (cofork.condition s) :=
cocones.ext (iso.refl _) $ Î» j, by cases j; tidy
def of_Ï€_congr {P : C} {Ï€ Ï€' : Y âŸ¶ P} {w : f â‰« Ï€ = 0} (h : Ï€ = Ï€') :
  cokernel_cofork.of_Ï€ Ï€ w â‰… cokernel_cofork.of_Ï€ Ï€' (by rw [â†h, w]) :=
cocones.ext (iso.refl _) $ Î» j, by cases j; tidy
def cokernel_cofork.is_colimit.desc' {s : cokernel_cofork f} (hs : is_colimit s) {W : C} (k : Y âŸ¶ W)
  (h : f â‰« k = 0) : {l : s.X âŸ¶ W // cofork.Ï€ s â‰« l = k} :=
âŸ¨hs.desc $ cokernel_cofork.of_Ï€ _ h, hs.fac _ _âŸ©
def is_colimit_aux (t : cokernel_cofork f)
  (desc : Î  (s : cokernel_cofork f), t.X âŸ¶ s.X)
  (fac : âˆ€ (s : cokernel_cofork f), t.Ï€ â‰« desc s = s.Ï€)
  (uniq : âˆ€ (s : cokernel_cofork f) (m : t.X âŸ¶ s.X) (w : t.Ï€ â‰« m = s.Ï€), m = desc s) :
  is_colimit t :=
{ desc := desc,
  fac' := Î» s j, by { cases j, { simp, }, { exact fac s, }, },
  uniq' := Î» s m w, uniq s m (w limits.walking_parallel_pair.one), }
def is_colimit.of_Ï€ {Z : C} (g : Y âŸ¶ Z) (eq : f â‰« g = 0)
  (desc : Î  {Z' : C} (g' : Y âŸ¶ Z') (eq' : f â‰« g' = 0), Z âŸ¶ Z')
  (fac : âˆ€ {Z' : C} (g' : Y âŸ¶ Z') (eq' : f â‰« g' = 0), g â‰« desc g' eq' = g')
  (uniq :
    âˆ€ {Z' : C} (g' : Y âŸ¶ Z') (eq' : f â‰« g' = 0) (m : Z âŸ¶ Z') (w : g â‰« m = g'), m = desc g' eq') :
  is_colimit (cokernel_cofork.of_Ï€ g eq) :=
is_colimit_aux _ (Î» s, desc s.Ï€ s.condition) (Î» s, fac s.Ï€ s.condition) (Î» s, uniq s.Ï€ s.condition)
def is_cokernel_epi_comp  {c : cokernel_cofork f} (i : is_colimit c) {W} (g : W âŸ¶ X) [hg : epi g]
  {h : W âŸ¶ Y} (hh : h = g â‰« f) :
  is_colimit (cokernel_cofork.of_Ï€ c.Ï€ (by rw [hh]; simp) : cokernel_cofork h) :=
cofork.is_colimit.mk' _ $ Î» s,
  let s' : cokernel_cofork f := cofork.of_Ï€ s.Ï€
    (by { apply hg.left_cancellation, rw [â†category.assoc, â†hh, s.condition], simp }) in
  let l := cokernel_cofork.is_colimit.desc' i s'.Ï€ s'.condition in
  âŸ¨l.1, l.2,
    Î» m hm, by apply cofork.is_colimit.hom_ext i; rw cofork.Ï€_of_Ï€ at hm; rw hm; exact l.2.symmâŸ©
@[simp]
lemma is_cokernel_epi_comp_desc {c : cokernel_cofork f} (i : is_colimit c) {W}
  (g : W âŸ¶ X) [hg : epi g] {h : W âŸ¶ Y} (hh : h = g â‰« f) (s : cokernel_cofork h) :
  (is_cokernel_epi_comp i g hh).desc s
  = i.desc (cofork.of_Ï€ s.Ï€ (by { rw [â†cancel_epi g, â†category.assoc, â†hh], simp })) := rfl
def is_cokernel_of_comp {W : C} (g : W âŸ¶ X) (h : W âŸ¶ Y) {c : cokernel_cofork h} (i : is_colimit c)
  (hf : f â‰« c.Ï€ = 0) (hfg : g â‰« f = h) : is_colimit (cokernel_cofork.of_Ï€ c.Ï€ hf) :=
cofork.is_colimit.mk _
  (Î» s, i.desc (cokernel_cofork.of_Ï€ s.Ï€ (by simp [â† hfg])))
  (Î» s, by simp only [cokernel_cofork.Ï€_of_Ï€, cofork.is_colimit.Ï€_desc])
  (Î» s m h, by { apply cofork.is_colimit.hom_ext i, simpa using h })
end
section
variables [has_cokernel f]
abbreviation cokernel : C := coequalizer f 0
abbreviation cokernel.Ï€ : Y âŸ¶ cokernel f := coequalizer.Ï€ f 0
@[simp] lemma coequalizer_as_cokernel : coequalizer.Ï€ f 0 = cokernel.Ï€ f := rfl
@[simp, reassoc] lemma cokernel.condition : f â‰« cokernel.Ï€ f = 0 :=
cokernel_cofork.condition _
def cokernel_is_cokernel :
  is_colimit (cofork.of_Ï€ (cokernel.Ï€ f) ((cokernel.condition f).trans (zero_comp.symm))) :=
is_colimit.of_iso_colimit (colimit.is_colimit _) (cofork.ext (iso.refl _) (by tidy))
abbreviation cokernel.desc {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) : cokernel f âŸ¶ W :=
colimit.desc (parallel_pair f 0) (cokernel_cofork.of_Ï€ k h)
@[simp, reassoc]
lemma cokernel.Ï€_desc {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) :
  cokernel.Ï€ f â‰« cokernel.desc f k h = k :=
colimit.Î¹_desc _ _
@[simp]
lemma cokernel.desc_zero {W : C} {h} : cokernel.desc f (0 : Y âŸ¶ W) h = 0 :=
by { ext, simp, }
instance cokernel.desc_epi
  {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) [epi k] : epi (cokernel.desc f k h) :=
âŸ¨Î» Z g g' w,
begin
  replace w := cokernel.Ï€ f â‰«= w,
  simp only [cokernel.Ï€_desc_assoc] at w,
  exact (cancel_epi k).1 w,
endâŸ©
def cokernel.desc' {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) :
  {l : cokernel f âŸ¶ W // cokernel.Ï€ f â‰« l = k} :=
âŸ¨cokernel.desc f k h, cokernel.Ï€_desc _ _ _âŸ©
abbreviation cokernel.map {X' Y' : C} (f' : X' âŸ¶ Y') [has_cokernel f']
  (p : X âŸ¶ X') (q : Y âŸ¶ Y') (w : f â‰« q = p â‰« f') : cokernel f âŸ¶ cokernel f' :=
cokernel.desc f (q â‰« cokernel.Ï€ f') (by simp [reassoc_of w])
lemma cokernel.map_desc {X Y Z X' Y' Z' : C}
  (f : X âŸ¶ Y) [has_cokernel f] (g : Y âŸ¶ Z) (w : f â‰« g = 0)
  (f' : X' âŸ¶ Y') [has_cokernel f'] (g' : Y' âŸ¶ Z') (w' : f' â‰« g' = 0)
  (p : X âŸ¶ X') (q : Y âŸ¶ Y') (r : Z âŸ¶ Z') (hâ‚ : f â‰« q = p â‰« f') (hâ‚‚ : g â‰« r = q â‰« g') :
  cokernel.map f f' p q hâ‚ â‰« cokernel.desc f' g' w' = cokernel.desc f g w â‰« r :=
by { ext, simp [hâ‚‚], }
@[simps]
def cokernel.map_iso {X' Y' : C} (f' : X' âŸ¶ Y') [has_cokernel f']
  (p : X â‰… X') (q : Y â‰… Y') (w : f â‰« q.hom = p.hom â‰« f') : cokernel f â‰… cokernel f' :=
{ hom := cokernel.map f f' p.hom q.hom w,
  inv := cokernel.map f' f p.inv q.inv (by { refine (cancel_mono q.hom).1 _, simp [w], }), }
instance cokernel.Ï€_zero_is_iso :
  is_iso (cokernel.Ï€ (0 : X âŸ¶ Y)) :=
coequalizer.Ï€_of_self _
lemma eq_zero_of_mono_cokernel [mono (cokernel.Ï€ f)] : f = 0 :=
(cancel_mono (cokernel.Ï€ f)).1 (by simp)
def cokernel_zero_iso_target : cokernel (0 : X âŸ¶ Y) â‰… Y :=
coequalizer.iso_target_of_self 0
@[simp] lemma cokernel_zero_iso_target_hom :
  cokernel_zero_iso_target.hom = cokernel.desc (0 : X âŸ¶ Y) (ğŸ™ Y) (by simp) :=
by { ext, simp [cokernel_zero_iso_target], }
@[simp] lemma cokernel_zero_iso_target_inv :
  cokernel_zero_iso_target.inv = cokernel.Ï€ (0 : X âŸ¶ Y) := rfl
def cokernel_iso_of_eq {f g : X âŸ¶ Y} [has_cokernel f] [has_cokernel g] (h : f = g) :
  cokernel f â‰… cokernel g :=
has_colimit.iso_of_nat_iso (by simp[h])
@[simp]
lemma cokernel_iso_of_eq_refl {h : f = f} : cokernel_iso_of_eq h = iso.refl (cokernel f) :=
by { ext, simp [cokernel_iso_of_eq], }
@[simp, reassoc]
lemma Ï€_comp_cokernel_iso_of_eq_hom {f g : X âŸ¶ Y} [has_cokernel f] [has_cokernel g] (h : f = g) :
  cokernel.Ï€ _ â‰« (cokernel_iso_of_eq h).hom = cokernel.Ï€ _ :=
by { unfreezingI { induction h, simp } }
@[simp, reassoc]
lemma Ï€_comp_cokernel_iso_of_eq_inv {f g : X âŸ¶ Y} [has_cokernel f] [has_cokernel g] (h : f = g) :
  cokernel.Ï€ _ â‰« (cokernel_iso_of_eq h).inv = cokernel.Ï€ _ :=
by { unfreezingI { induction h, simp } }
@[simp, reassoc]
lemma cokernel_iso_of_eq_hom_comp_desc {Z} {f g : X âŸ¶ Y} [has_cokernel f] [has_cokernel g]
  (h : f = g) (e : Y âŸ¶ Z) (he) :
  (cokernel_iso_of_eq h).hom â‰« cokernel.desc _ e he = cokernel.desc _ e (by simp [h, he]) :=
by { unfreezingI { induction h, simp } }
@[simp, reassoc]
lemma cokernel_iso_of_eq_inv_comp_desc {Z} {f g : X âŸ¶ Y} [has_cokernel f] [has_cokernel g]
  (h : f = g) (e : Y âŸ¶ Z) (he) :
  (cokernel_iso_of_eq h).inv â‰« cokernel.desc _ e he = cokernel.desc _ e (by simp [â† h, he]) :=
by { unfreezingI { induction h, simp } }
@[simp]
lemma cokernel_iso_of_eq_trans {f g h : X âŸ¶ Y} [has_cokernel f] [has_cokernel g] [has_cokernel h]
  (wâ‚ : f = g) (wâ‚‚ : g = h) :
  cokernel_iso_of_eq wâ‚ â‰ªâ‰« cokernel_iso_of_eq wâ‚‚ = cokernel_iso_of_eq (wâ‚.trans wâ‚‚) :=
by { unfreezingI { induction wâ‚, induction wâ‚‚, }, ext, simp [cokernel_iso_of_eq], }
variables {f}
lemma cokernel_not_mono_of_nonzero (w : f â‰  0) : Â¬mono (cokernel.Ï€ f) :=
Î» I, by exactI w (eq_zero_of_mono_cokernel f)
lemma cokernel_not_iso_of_nonzero (w : f â‰  0) : (is_iso (cokernel.Ï€ f)) â†’ false :=
Î» I, cokernel_not_mono_of_nonzero w $ by { resetI, apply_instance }
@[simps]
def cokernel_comp_is_iso {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [has_cokernel f] [is_iso g] :
  cokernel (f â‰« g) â‰… cokernel f :=
{ hom := cokernel.desc _ (inv g â‰« cokernel.Ï€ f) (by simp),
  inv := cokernel.desc _ (g â‰« cokernel.Ï€ (f â‰« g)) (by rw [â†category.assoc, cokernel.condition]), }
instance has_cokernel_epi_comp {X Y : C} (f : X âŸ¶ Y) [has_cokernel f] {W} (g : W âŸ¶ X) [epi g] :
  has_cokernel (g â‰« f) :=
âŸ¨âŸ¨{ cocone := _, is_colimit := is_cokernel_epi_comp (colimit.is_colimit _) g rfl }âŸ©âŸ©
@[simps]
def cokernel_epi_comp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [epi f] [has_cokernel g] :
  cokernel (f â‰« g) â‰… cokernel g :=
{ hom := cokernel.desc _ (cokernel.Ï€ g) (by simp),
  inv := cokernel.desc _ (cokernel.Ï€ (f â‰« g)) (by { rw [â†cancel_epi f, â†category.assoc], simp, }), }
end
section has_zero_object
variables [has_zero_object C]
open_locale zero_object
def cokernel.zero_cokernel_cofork : cokernel_cofork f :=
{ X := 0,
  Î¹ := { app := Î» j, 0 } }
def cokernel.is_colimit_cocone_zero_cocone [epi f] :
  is_colimit (cokernel.zero_cokernel_cofork f) :=
cofork.is_colimit.mk _ (Î» s, 0)
  (Î» s, by { erw zero_comp,
    convert (zero_of_epi_comp f _).symm,
    exact cokernel_cofork.condition _ })
  (Î» _ _ _, zero_of_from_zero _)
def cokernel.of_epi [has_cokernel f] [epi f] : cokernel f â‰… 0 :=
functor.map_iso (cocones.forget _) $ is_colimit.unique_up_to_iso
  (colimit.is_colimit (parallel_pair f 0)) (cokernel.is_colimit_cocone_zero_cocone f)
lemma cokernel.Ï€_of_epi [has_cokernel f] [epi f] : cokernel.Ï€ f = 0 :=
zero_of_target_iso_zero _ (cokernel.of_epi f)
end has_zero_object
section mono_factorisation
variables {f}
@[simp] lemma mono_factorisation.kernel_Î¹_comp [has_kernel f] (F : mono_factorisation f) :
  kernel.Î¹ f â‰« F.e = 0 :=
by rw [â† cancel_mono F.m, zero_comp, category.assoc, F.fac, kernel.condition]
end mono_factorisation
section has_image
@[simps]
def cokernel_image_Î¹ {X Y : C} (f : X âŸ¶ Y)
  [has_image f] [has_cokernel (image.Î¹ f)] [has_cokernel f] [epi (factor_thru_image f)] :
  cokernel (image.Î¹ f) â‰… cokernel f :=
{ hom := cokernel.desc _ (cokernel.Ï€ f)
  begin
    have w := cokernel.condition f,
    conv at w { to_lhs, congr, rw â†image.fac f, },
    rw [â†has_zero_morphisms.comp_zero (limits.factor_thru_image f), category.assoc, cancel_epi]
      at w,
    exact w,
  end,
  inv := cokernel.desc _ (cokernel.Ï€ _)
  begin
    conv { to_lhs, congr, rw â†image.fac f, },
    rw [category.assoc, cokernel.condition, has_zero_morphisms.comp_zero],
  end, }
end has_image
section
variables (X Y)
lemma cokernel.Ï€_of_zero :
  is_iso (cokernel.Ï€ (0 : X âŸ¶ Y)) :=
coequalizer.Ï€_of_self _
end
section has_zero_object
variables [has_zero_object C]
open_locale zero_object
instance kernel.of_cokernel_of_epi [has_cokernel f]
  [has_kernel (cokernel.Ï€ f)] [epi f] : is_iso (kernel.Î¹ (cokernel.Ï€ f)) :=
equalizer.Î¹_of_eq $ cokernel.Ï€_of_epi f
instance cokernel.of_kernel_of_mono [has_kernel f]
  [has_cokernel (kernel.Î¹ f)] [mono f] : is_iso (cokernel.Ï€ (kernel.Î¹ f)) :=
coequalizer.Ï€_of_eq $ kernel.Î¹_of_mono f
def zero_cokernel_of_zero_cancel {X Y : C} (f : X âŸ¶ Y)
  (hf : âˆ€ (Z : C) (g : Y âŸ¶ Z) (hgf : f â‰« g = 0), g = 0) :
    is_colimit (cokernel_cofork.of_Ï€ (0 : Y âŸ¶ 0) (show f â‰« 0 = 0, by simp)) :=
cofork.is_colimit.mk _ (Î» s, 0)
  (Î» s, by rw [hf _ _ (cokernel_cofork.condition s), comp_zero])
  (Î» s m h, by ext)
end has_zero_object
section transport
def is_cokernel.of_iso_comp {Z : C} (l : Z âŸ¶ Y) (i : X â‰… Z) (h : i.hom â‰« l = f)
  {s : cokernel_cofork f} (hs : is_colimit s) : is_colimit (cokernel_cofork.of_Ï€ (cofork.Ï€ s) $
    show l â‰« cofork.Ï€ s = 0, by simp [i.eq_inv_comp.2 h]) :=
cofork.is_colimit.mk _
  (Î» s, hs.desc $ cokernel_cofork.of_Ï€ (cofork.Ï€ s) $ by simp [â†h])
  (Î» s, by simp)
  (Î» s m h, by { apply cofork.is_colimit.hom_ext hs, simpa using h })
def cokernel.of_iso_comp [has_cokernel f]
  {Z : C} (l : Z âŸ¶ Y) (i : X â‰… Z) (h : i.hom â‰« l = f) :
  is_colimit (cokernel_cofork.of_Ï€ (cokernel.Ï€ f) $
    show l â‰« cokernel.Ï€ f = 0, by simp [i.eq_inv_comp.2 h]) :=
is_cokernel.of_iso_comp f l i h $ colimit.is_colimit _
def is_cokernel.cokernel_iso {Z : C} (l : Y âŸ¶ Z) {s : cokernel_cofork f} (hs : is_colimit s)
  (i : s.X â‰… Z) (h : cofork.Ï€ s â‰« i.hom = l) : is_colimit (cokernel_cofork.of_Ï€ l $
    show f â‰« l = 0, by simp [â†h]) :=
is_colimit.of_iso_colimit hs $ cocones.ext i $ Î» j, by { cases j, { simp }, { exact h } }
def cokernel.cokernel_iso [has_cokernel f]
  {Z : C} (l : Y âŸ¶ Z) (i : cokernel f â‰… Z) (h : cokernel.Ï€ f â‰« i.hom = l) :
  is_colimit (cokernel_cofork.of_Ï€ l $ by simp [â†h]) :=
is_cokernel.cokernel_iso f l (colimit.is_colimit _) i h
end transport
section comparison
variables {D : Type uâ‚‚} [category.{vâ‚‚} D] [has_zero_morphisms D]
variables (G : C â¥¤ D) [functor.preserves_zero_morphisms G]
def kernel_comparison [has_kernel f] [has_kernel (G.map f)] :
  G.obj (kernel f) âŸ¶ kernel (G.map f) :=
kernel.lift _ (G.map (kernel.Î¹ f)) (by simp only [â†G.map_comp, kernel.condition, functor.map_zero])
@[simp, reassoc]
lemma kernel_comparison_comp_Î¹ [has_kernel f] [has_kernel (G.map f)] :
  kernel_comparison f G â‰« kernel.Î¹ (G.map f) = G.map (kernel.Î¹ f) :=
kernel.lift_Î¹ _ _ _
@[simp, reassoc]
lemma map_lift_kernel_comparison [has_kernel f] [has_kernel (G.map f)]
  {Z : C} {h : Z âŸ¶ X} (w : h â‰« f = 0) :
    G.map (kernel.lift _ h w) â‰« kernel_comparison f G =
      kernel.lift _ (G.map h) (by simp only [â†G.map_comp, w, functor.map_zero]) :=
by { ext, simp [â† G.map_comp] }
def cokernel_comparison [has_cokernel f] [has_cokernel (G.map f)] :
  cokernel (G.map f) âŸ¶ G.obj (cokernel f) :=
cokernel.desc _ (G.map (coequalizer.Ï€ _ _))
  (by simp only [â†G.map_comp, cokernel.condition, functor.map_zero])
@[simp, reassoc]
lemma Ï€_comp_cokernel_comparison [has_cokernel f] [has_cokernel (G.map f)] :
  cokernel.Ï€ (G.map f) â‰« cokernel_comparison f G = G.map (cokernel.Ï€ _) :=
cokernel.Ï€_desc _ _ _
@[simp, reassoc]
lemma cokernel_comparison_map_desc [has_cokernel f] [has_cokernel (G.map f)]
  {Z : C} {h : Y âŸ¶ Z} (w : f â‰« h = 0) :
  cokernel_comparison f G â‰« G.map (cokernel.desc _ h w) =
    cokernel.desc _ (G.map h) (by simp only [â†G.map_comp, w, functor.map_zero]) :=
by { ext, simp [â† G.map_comp] }
end comparison
end category_theory.limits
namespace category_theory.limits
variables (C : Type u) [category.{v} C]
variables [has_zero_morphisms C]
class has_kernels : Prop :=
(has_limit : Î  {X Y : C} (f : X âŸ¶ Y), has_kernel f . tactic.apply_instance)
class has_cokernels : Prop :=
(has_colimit : Î  {X Y : C} (f : X âŸ¶ Y), has_cokernel f . tactic.apply_instance)
attribute [instance, priority 100] has_kernels.has_limit has_cokernels.has_colimit
@[priority 100]
instance has_kernels_of_has_equalizers [has_equalizers C] : has_kernels C :=
{}
@[priority 100]
instance has_cokernels_of_has_coequalizers [has_coequalizers C] : has_cokernels C :=
{}
end category_theory.limits
