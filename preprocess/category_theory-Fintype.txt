import category_theory.concrete_category.basic
import category_theory.full_subcategory
import category_theory.skeletal
import category_theory.elementwise
import data.fin.basic
import data.fintype.basic
open_locale classical
open category_theory
def Fintype := bundled fintype
namespace Fintype
instance : has_coe_to_sort Fintype Type* := bundled.has_coe_to_sort
def of (X : Type*) [fintype X] : Fintype := bundled.of X
instance : inhabited Fintype := ‚ü®‚ü®pempty‚ü©‚ü©
instance {X : Fintype} : fintype X := X.2
instance : category Fintype := induced_category.category bundled.Œ±
@[derive [full, faithful], simps]
def incl : Fintype ‚•§ Type* := induced_functor _
instance concrete_category_Fintype : concrete_category Fintype := ‚ü®incl‚ü©
@[simp] lemma id_apply (X : Fintype) (x : X) : (ùüô X : X ‚Üí X) x = x := rfl
@[simp] lemma comp_apply {X Y Z : Fintype} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) :
  (f ‚â´ g) x = g (f x) := rfl
def skeleton : Type u := ulift ‚Ñï
namespace skeleton
def mk : ‚Ñï ‚Üí skeleton := ulift.up
instance : inhabited skeleton := ‚ü®mk 0‚ü©
def len : skeleton ‚Üí ‚Ñï := ulift.down
@[ext]
lemma ext (X Y : skeleton) : X.len = Y.len ‚Üí X = Y := ulift.ext _ _
instance : small_category skeleton.{u} :=
{ hom := Œª X Y, ulift.{u} (fin X.len) ‚Üí ulift.{u} (fin Y.len),
  id := Œª _, id,
  comp := Œª _ _ _ f g, g ‚àò f }
lemma is_skeletal : skeletal skeleton.{u} := Œª X Y ‚ü®h‚ü©, ext _ _ $ fin.equiv_iff_eq.mp $
  nonempty.intro $
{ to_fun := Œª x, (h.hom ‚ü®x‚ü©).down,
  inv_fun := Œª x, (h.inv ‚ü®x‚ü©).down,
  left_inv := begin
    intro a,
    change ulift.down _ = _,
    rw ulift.up_down,
    change ((h.hom ‚â´ h.inv) _).down = _,
    simpa,
  end,
  right_inv := begin
    intro a,
    change ulift.down _ = _,
    rw ulift.up_down,
    change ((h.inv ‚â´ h.hom) _).down = _,
    simpa,
  end }
def incl : skeleton.{u} ‚•§ Fintype.{u} :=
{ obj := Œª X, Fintype.of (ulift (fin X.len)),
  map := Œª _ _ f, f }
instance : full incl := { preimage := Œª _ _ f, f }
instance : faithful incl := {}
instance : ess_surj incl :=
ess_surj.mk $ Œª X, let F := fintype.equiv_fin X in ‚ü®mk (fintype.card X), nonempty.intro
  { hom := F.symm ‚àò ulift.down,
    inv := ulift.up ‚àò F }‚ü©
noncomputable instance : is_equivalence incl :=
equivalence.of_fully_faithfully_ess_surj _
noncomputable def equivalence : skeleton ‚âå Fintype := incl.as_equivalence
@[simp] lemma incl_mk_nat_card (n : ‚Ñï) : fintype.card (incl.obj (mk n)) = n :=
begin
  convert finset.card_fin n,
  apply fintype.of_equiv_card,
end
end skeleton
noncomputable def is_skeleton : is_skeleton_of Fintype skeleton skeleton.incl :=
{ skel := skeleton.is_skeletal,
  eqv := by apply_instance }
end Fintype
