import analysis.special_functions.exp
open set filter function
open_locale topological_space
noncomputable theory
namespace real
variables {x y : ‚Ñù}
@[pp_nodot] noncomputable def log (x : ‚Ñù) : ‚Ñù :=
if hx : x = 0 then 0 else exp_order_iso.symm ‚ü®|x|, abs_pos.2 hx‚ü©
lemma log_of_ne_zero (hx : x ‚â† 0) : log x = exp_order_iso.symm ‚ü®|x|, abs_pos.2 hx‚ü© := dif_neg hx
lemma log_of_pos (hx : 0 < x) : log x = exp_order_iso.symm ‚ü®x, hx‚ü© :=
by { rw [log_of_ne_zero hx.ne'], congr, exact abs_of_pos hx }
lemma exp_log_eq_abs (hx : x ‚â† 0) : exp (log x) = |x| :=
by rw [log_of_ne_zero hx, ‚Üê coe_exp_order_iso_apply, order_iso.apply_symm_apply, subtype.coe_mk]
lemma exp_log (hx : 0 < x) : exp (log x) = x :=
by { rw exp_log_eq_abs hx.ne', exact abs_of_pos hx }
lemma exp_log_of_neg (hx : x < 0) : exp (log x) = -x :=
by { rw exp_log_eq_abs (ne_of_lt hx), exact abs_of_neg hx }
@[simp] lemma log_exp (x : ‚Ñù) : log (exp x) = x :=
exp_injective $ exp_log (exp_pos x)
lemma surj_on_log : surj_on log (Ioi 0) univ :=
Œª x _, ‚ü®exp x, exp_pos x, log_exp x‚ü©
lemma log_surjective : surjective log :=
Œª x, ‚ü®exp x, log_exp x‚ü©
@[simp] lemma range_log : range log = univ :=
log_surjective.range_eq
@[simp] lemma log_zero : log 0 = 0 := dif_pos rfl
@[simp] lemma log_one : log 1 = 0 :=
exp_injective $ by rw [exp_log zero_lt_one, exp_zero]
@[simp] lemma log_abs (x : ‚Ñù) : log (|x|) = log x :=
begin
  by_cases h : x = 0,
  { simp [h] },
  { rw [‚Üê exp_eq_exp, exp_log_eq_abs h, exp_log_eq_abs (abs_pos.2 h).ne', abs_abs] }
end
@[simp] lemma log_neg_eq_log (x : ‚Ñù) : log (-x) = log x :=
by rw [‚Üê log_abs x, ‚Üê log_abs (-x), abs_neg]
lemma sinh_log {x : ‚Ñù} (hx : 0 < x) : sinh (log x) = (x - x‚Åª¬π) / 2 :=
by rw [sinh_eq, exp_neg, exp_log hx]
lemma cosh_log {x : ‚Ñù} (hx : 0 < x) : cosh (log x) = (x + x‚Åª¬π) / 2 :=
by rw [cosh_eq, exp_neg, exp_log hx]
lemma surj_on_log' : surj_on log (Iio 0) univ :=
Œª x _, ‚ü®-exp x, neg_lt_zero.2 $ exp_pos x, by rw [log_neg_eq_log, log_exp]‚ü©
lemma log_mul (hx : x ‚â† 0) (hy : y ‚â† 0) : log (x * y) = log x + log y :=
exp_injective $
by rw [exp_log_eq_abs (mul_ne_zero hx hy), exp_add, exp_log_eq_abs hx, exp_log_eq_abs hy, abs_mul]
lemma log_div (hx : x ‚â† 0) (hy : y ‚â† 0) : log (x / y) = log x - log y :=
exp_injective $
by rw [exp_log_eq_abs (div_ne_zero hx hy), exp_sub, exp_log_eq_abs hx, exp_log_eq_abs hy, abs_div]
@[simp] lemma log_inv (x : ‚Ñù) : log (x‚Åª¬π) = -log x :=
begin
  by_cases hx : x = 0, { simp [hx] },
  rw [‚Üê exp_eq_exp, exp_log_eq_abs (inv_ne_zero hx), exp_neg, exp_log_eq_abs hx, abs_inv]
end
lemma log_le_log (h : 0 < x) (h‚ÇÅ : 0 < y) : log x ‚â§ log y ‚Üî x ‚â§ y :=
by rw [‚Üê exp_le_exp, exp_log h, exp_log h‚ÇÅ]
lemma log_lt_log (hx : 0 < x) : x < y ‚Üí log x < log y :=
by { intro h, rwa [‚Üê exp_lt_exp, exp_log hx, exp_log (lt_trans hx h)] }
lemma log_lt_log_iff (hx : 0 < x) (hy : 0 < y) : log x < log y ‚Üî x < y :=
by { rw [‚Üê exp_lt_exp, exp_log hx, exp_log hy] }
lemma log_le_iff_le_exp (hx : 0 < x) : log x ‚â§ y ‚Üî x ‚â§ exp y := by rw [‚Üêexp_le_exp, exp_log hx]
lemma log_lt_iff_lt_exp (hx : 0 < x) : log x < y ‚Üî x < exp y := by rw [‚Üêexp_lt_exp, exp_log hx]
lemma le_log_iff_exp_le (hy : 0 < y) : x ‚â§ log y ‚Üî exp x ‚â§ y := by rw [‚Üêexp_le_exp, exp_log hy]
lemma lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y := by rw [‚Üêexp_lt_exp, exp_log hy]
lemma log_pos_iff (hx : 0 < x) : 0 < log x ‚Üî 1 < x :=
by { rw ‚Üê log_one, exact log_lt_log_iff zero_lt_one hx }
lemma log_pos (hx : 1 < x) : 0 < log x :=
(log_pos_iff (lt_trans zero_lt_one hx)).2 hx
lemma log_neg_iff (h : 0 < x) : log x < 0 ‚Üî x < 1 :=
by { rw ‚Üê log_one, exact log_lt_log_iff h zero_lt_one }
lemma log_neg (h0 : 0 < x) (h1 : x < 1) : log x < 0 := (log_neg_iff h0).2 h1
lemma log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x :=
by rw [‚Üê not_lt, log_neg_iff hx, not_lt]
lemma log_nonneg (hx : 1 ‚â§ x) : 0 ‚â§ log x :=
(log_nonneg_iff (zero_lt_one.trans_le hx)).2 hx
lemma log_nonpos_iff (hx : 0 < x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=
by rw [‚Üê not_lt, log_pos_iff hx, not_lt]
lemma log_nonpos_iff' (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=
begin
  rcases hx.eq_or_lt with (rfl|hx),
  { simp [le_refl, zero_le_one] },
  exact log_nonpos_iff hx
end
lemma log_nonpos (hx : 0 ‚â§ x) (h'x : x ‚â§ 1) : log x ‚â§ 0 :=
(log_nonpos_iff' hx).2 h'x
lemma strict_mono_on_log : strict_mono_on log (set.Ioi 0) :=
Œª x hx y hy hxy, log_lt_log hx hxy
lemma strict_anti_on_log : strict_anti_on log (set.Iio 0) :=
begin
  rintros x (hx : x < 0) y (hy : y < 0) hxy,
  rw [‚Üê log_abs y, ‚Üê log_abs x],
  refine log_lt_log (abs_pos.2 hy.ne) _,
  rwa [abs_of_neg hy, abs_of_neg hx, neg_lt_neg_iff]
end
lemma log_inj_on_pos : set.inj_on log (set.Ioi 0) :=
strict_mono_on_log.inj_on
lemma eq_one_of_pos_of_log_eq_zero {x : ‚Ñù} (h‚ÇÅ : 0 < x) (h‚ÇÇ : log x = 0) : x = 1 :=
log_inj_on_pos (set.mem_Ioi.2 h‚ÇÅ) (set.mem_Ioi.2 zero_lt_one) (h‚ÇÇ.trans real.log_one.symm)
lemma log_ne_zero_of_pos_of_ne_one {x : ‚Ñù} (hx_pos : 0 < x) (hx : x ‚â† 1) : log x ‚â† 0 :=
mt (eq_one_of_pos_of_log_eq_zero hx_pos) hx
@[simp] lemma log_eq_zero {x : ‚Ñù} : log x = 0 ‚Üî x = 0 ‚à® x = 1 ‚à® x = -1 :=
begin
  split,
  { intros h,
    rcases lt_trichotomy x 0 with x_lt_zero | rfl | x_gt_zero,
    { refine or.inr (or.inr (eq_neg_iff_eq_neg.mp _)),
      rw [‚Üêlog_neg_eq_log x] at h,
      exact (eq_one_of_pos_of_log_eq_zero (neg_pos.mpr x_lt_zero) h).symm, },
    { exact or.inl rfl },
    { exact or.inr (or.inl (eq_one_of_pos_of_log_eq_zero x_gt_zero h)), }, },
  { rintro (rfl|rfl|rfl); simp only [log_one, log_zero, log_neg_eq_log], }
end
@[simp] lemma log_pow (x : ‚Ñù) (n : ‚Ñï) : log (x ^ n) = n * log x :=
begin
  induction n with n ih,
  { simp },
  rcases eq_or_ne x 0 with rfl | hx,
  { simp },
  rw [pow_succ', log_mul (pow_ne_zero _ hx) hx, ih, nat.cast_succ, add_mul, one_mul],
end
@[simp] lemma log_zpow (x : ‚Ñù) (n : ‚Ñ§) : log (x ^ n) = n * log x :=
begin
  induction n,
  { rw [int.of_nat_eq_coe, zpow_coe_nat, log_pow, int.cast_coe_nat] },
  rw [zpow_neg_succ_of_nat, log_inv, log_pow, int.cast_neg_succ_of_nat, nat.cast_add_one,
    neg_mul_eq_neg_mul],
end
lemma log_sqrt {x : ‚Ñù} (hx : 0 ‚â§ x) : log (sqrt x) = log x / 2 :=
by { rw [eq_div_iff, mul_comm, ‚Üê nat.cast_two, ‚Üê log_pow, sq_sqrt hx], exact two_ne_zero }
lemma log_le_sub_one_of_pos {x : ‚Ñù} (hx : 0 < x) : log x ‚â§ x - 1 :=
begin
  rw le_sub_iff_add_le,
  convert add_one_le_exp (log x),
  rw exp_log hx,
end
lemma abs_log_mul_self_lt (x: ‚Ñù) (h1 : 0 < x) (h2 : x ‚â§ 1) : |log x * x| < 1 :=
begin
  have : 0 < 1/x := by simpa only [one_div, inv_pos] using h1,
  replace := log_le_sub_one_of_pos this,
  replace : log (1 / x) < 1/x := by linarith,
  rw [log_div one_ne_zero h1.ne', log_one, zero_sub, lt_div_iff h1] at this,
  have aux : 0 ‚â§ -log x * x,
  { refine mul_nonneg _ h1.le, rw ‚Üêlog_inv, apply log_nonneg,
    rw [‚Üê(le_inv h1 zero_lt_one), inv_one], exact h2, },
  rw [‚Üê(abs_of_nonneg aux), neg_mul, abs_neg] at this, exact this,
end
lemma tendsto_log_at_top : tendsto log at_top at_top :=
tendsto_comp_exp_at_top.1 $ by simpa only [log_exp] using tendsto_id
lemma tendsto_log_nhds_within_zero : tendsto log (ùìù[‚â†] 0) at_bot :=
begin
  rw [‚Üê (show _ = log, from funext log_abs)],
  refine tendsto.comp _ tendsto_abs_nhds_within_zero,
  simpa [‚Üê tendsto_comp_exp_at_bot] using tendsto_id
end
lemma continuous_on_log : continuous_on log {0}·∂ú :=
begin
  rw [continuous_on_iff_continuous_restrict, restrict],
  conv in (log _) { rw [log_of_ne_zero (show (x : ‚Ñù) ‚â† 0, from x.2)] },
  exact exp_order_iso.symm.continuous.comp (continuous_subtype_mk _ continuous_subtype_coe.norm)
end
@[continuity] lemma continuous_log : continuous (Œª x : {x : ‚Ñù // x ‚â† 0}, log x) :=
continuous_on_iff_continuous_restrict.1 $ continuous_on_log.mono $ Œª x hx, hx
@[continuity] lemma continuous_log' : continuous (Œª x : {x : ‚Ñù // 0 < x}, log x) :=
continuous_on_iff_continuous_restrict.1 $ continuous_on_log.mono $ Œª x hx, ne_of_gt hx
lemma continuous_at_log (hx : x ‚â† 0) : continuous_at log x :=
(continuous_on_log x hx).continuous_at $ is_open.mem_nhds is_open_compl_singleton hx
@[simp] lemma continuous_at_log_iff : continuous_at log x ‚Üî x ‚â† 0 :=
begin
  refine ‚ü®_, continuous_at_log‚ü©,
  rintros h rfl,
  exact not_tendsto_nhds_of_tendsto_at_bot tendsto_log_nhds_within_zero _
    (h.tendsto.mono_left inf_le_left)
end
open_locale big_operators
lemma log_prod {Œ± : Type*} (s : finset Œ±) (f : Œ± ‚Üí ‚Ñù) (hf : ‚àÄ x ‚àà s, f x ‚â† 0):
  log (‚àè i in s, f i) = ‚àë i in s, log (f i) :=
begin
  induction s using finset.cons_induction_on with a s ha ih,
  { simp },
  { rw [finset.forall_mem_cons] at hf,
    simp [ih hf.2, log_mul hf.1 (finset.prod_ne_zero_iff.2 hf.2)] }
end
lemma log_nat_eq_sum_factorization (n : ‚Ñï) : log n = n.factorization.sum (Œª p t, t * log p) :=
begin
  rcases eq_or_ne n 0 with rfl | hn,
  { simp },
  nth_rewrite 0 [‚Üênat.factorization_prod_pow_eq_self hn],
  rw [finsupp.prod, nat.cast_prod, log_prod _ _ (Œª p hp, _), finsupp.sum],
  { simp_rw [nat.cast_pow, log_pow] },
  { norm_cast,
    exact pow_ne_zero _ (nat.prime_of_mem_factorization hp).ne_zero },
end
lemma tendsto_pow_log_div_mul_add_at_top (a b : ‚Ñù) (n : ‚Ñï) (ha : a ‚â† 0) :
  tendsto (Œª x, log x ^ n / (a * x + b)) at_top (ùìù 0) :=
((tendsto_div_pow_mul_exp_add_at_top a b n ha.symm).comp tendsto_log_at_top).congr'
  (by filter_upwards [eventually_gt_at_top (0 : ‚Ñù)] with x hx using by simp [exp_log hx])
lemma is_o_pow_log_id_at_top {n : ‚Ñï} : (Œª x, log x ^ n) =o[at_top] id :=
begin
  rw asymptotics.is_o_iff_tendsto',
  { simpa using tendsto_pow_log_div_mul_add_at_top 1 0 n one_ne_zero },
  filter_upwards [eventually_ne_at_top (0 : ‚Ñù)] with x h‚ÇÅ h‚ÇÇ using (h‚ÇÅ h‚ÇÇ).elim,
end
lemma is_o_log_id_at_top : log =o[at_top] id := is_o_pow_log_id_at_top.congr_left (Œª x, pow_one _)
end real
section continuity
open real
variables {Œ± : Type*}
lemma filter.tendsto.log {f : Œ± ‚Üí ‚Ñù} {l : filter Œ±} {x : ‚Ñù} (h : tendsto f l (ùìù x)) (hx : x ‚â† 0) :
  tendsto (Œª x, log (f x)) l (ùìù (log x)) :=
(continuous_at_log hx).tendsto.comp h
variables [topological_space Œ±] {f : Œ± ‚Üí ‚Ñù} {s : set Œ±} {a : Œ±}
lemma continuous.log (hf : continuous f) (h‚ÇÄ : ‚àÄ x, f x ‚â† 0) : continuous (Œª x, log (f x)) :=
continuous_on_log.comp_continuous hf h‚ÇÄ
lemma continuous_at.log (hf : continuous_at f a) (h‚ÇÄ : f a ‚â† 0) :
  continuous_at (Œª x, log (f x)) a :=
hf.log h‚ÇÄ
lemma continuous_within_at.log (hf : continuous_within_at f s a) (h‚ÇÄ : f a ‚â† 0) :
  continuous_within_at (Œª x, log (f x)) s a :=
hf.log h‚ÇÄ
lemma continuous_on.log (hf : continuous_on f s) (h‚ÇÄ : ‚àÄ x ‚àà s, f x ‚â† 0) :
  continuous_on (Œª x, log (f x)) s :=
Œª x hx, (hf x hx).log (h‚ÇÄ x hx)
end continuity
