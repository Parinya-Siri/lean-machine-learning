import category_theory.structured_arrow
import category_theory.punit
import category_theory.functor.reflects_isomorphisms
import category_theory.epi_mono
namespace category_theory
@[derive category]
def over (X : T) := costructured_arrow (ùü≠ T) X
@[simps left hom]
def mk {X Y : T} (f : Y ‚ü∂ X) : over X :=
costructured_arrow.mk f
def coe_from_hom {X Y : T} : has_coe (Y ‚ü∂ X) (over X) :=
{ coe := mk }
section
local attribute [instance] coe_from_hom
@[simp] lemma coe_hom {X Y : T} (f : Y ‚ü∂ X) : (f : over X).hom = f := rfl
end
@[simps]
def hom_mk {U V : over X} (f : U.left ‚ü∂ V.left) (w : f ‚â´ V.hom = U.hom . obviously) :
  U ‚ü∂ V :=
costructured_arrow.hom_mk f w
@[simps]
def iso_mk {f g : over X} (hl : f.left ‚âÖ g.left) (hw : hl.hom ‚â´ g.hom = f.hom . obviously) :
  f ‚âÖ g :=
costructured_arrow.iso_mk hl hw
section
variable (X)
def forget : over X ‚•§ T := comma.fst _ _
end
@[simp] lemma forget_obj {U : over X} : (forget X).obj U = U.left := rfl
@[simp] lemma forget_map {U V : over X} {f : U ‚ü∂ V} : (forget X).map f = f.left := rfl
@[simps] def forget_cocone (X : T) : limits.cocone (forget X) :=
{ X := X, Œπ := { app := comma.hom } }
def map {Y : T} (f : X ‚ü∂ Y) : over X ‚•§ over Y := comma.map_right _ $ discrete.nat_trans (Œª _, f)
section
variables {Y : T} {f : X ‚ü∂ Y} {U V : over X} {g : U ‚ü∂ V}
@[simp] lemma map_obj_left : ((map f).obj U).left = U.left := rfl
@[simp] lemma map_obj_hom  : ((map f).obj U).hom  = U.hom ‚â´ f := rfl
@[simp] lemma map_map_left : ((map f).map g).left = g.left := rfl
def map_id : map (ùüô Y) ‚âÖ ùü≠ _ :=
nat_iso.of_components (Œª X, iso_mk (iso.refl _) (by tidy)) (by tidy)
def map_comp {Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : map (f ‚â´ g) ‚âÖ map f ‚ãô map g :=
nat_iso.of_components (Œª X, iso_mk (iso.refl _) (by tidy)) (by tidy)
end
instance forget_reflects_iso : reflects_isomorphisms (forget X) :=
{ reflects := Œª Y Z f t, by exactI
  ‚ü®‚ü®over.hom_mk (inv ((forget X).map f))
      ((as_iso ((forget X).map f)).inv_comp_eq.2 (over.w f).symm),
    by tidy‚ü©‚ü© }
instance forget_faithful : faithful (forget X) := {}.
lemma mono_of_mono_left {f g : over X} (k : f ‚ü∂ g) [hk : mono k.left] : mono k :=
faithful_reflects_mono (forget X) hk
instance mono_left_of_mono {f g : over X} (k : f ‚ü∂ g) [mono k] : mono k.left :=
begin
  refine ‚ü®Œª (Y : T) l m a, _‚ü©,
  let l' : mk (m ‚â´ f.hom) ‚ü∂ f := hom_mk l (by { dsimp, rw [‚Üêover.w k, reassoc_of a] }),
  suffices : l' = hom_mk m,
  { apply congr_arg comma_morphism.left this },
  rw ‚Üê cancel_mono k,
  ext,
  apply a,
end
section iterated_slice
variables (f : over X)
@[simps]
def iterated_slice_forward : over f ‚•§ over f.left :=
{ obj := Œª Œ±, over.mk Œ±.hom.left,
  map := Œª Œ± Œ≤ Œ∫, over.hom_mk Œ∫.left.left (by { rw auto_param_eq, rw ‚Üê over.w Œ∫, refl }) }
@[simps]
def iterated_slice_backward : over f.left ‚•§ over f :=
{ obj := Œª g, mk (hom_mk g.hom : mk (g.hom ‚â´ f.hom) ‚ü∂ f),
  map := Œª g h Œ±, hom_mk (hom_mk Œ±.left (w_assoc Œ± f.hom)) (over_morphism.ext (w Œ±)) }
@[simps]
def iterated_slice_equiv : over f ‚âå over f.left :=
{ functor := iterated_slice_forward f,
  inverse := iterated_slice_backward f,
  unit_iso :=
    nat_iso.of_components
    (Œª g, over.iso_mk (over.iso_mk (iso.refl _) (by tidy)) (by tidy))
    (Œª X Y g, by { ext, dsimp, simp }),
  counit_iso :=
    nat_iso.of_components
    (Œª g, over.iso_mk (iso.refl _) (by tidy))
    (Œª X Y g, by { ext, dsimp, simp }) }
lemma iterated_slice_forward_forget :
  iterated_slice_forward f ‚ãô forget f.left = forget f ‚ãô forget X :=
rfl
lemma iterated_slice_backward_forget_forget :
  iterated_slice_backward f ‚ãô forget f ‚ãô forget X = forget f.left :=
rfl
end iterated_slice
section
variables {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D]
@[simps]
def post (F : T ‚•§ D) : over X ‚•§ over (F.obj X) :=
{ obj := Œª Y, mk $ F.map Y.hom,
  map := Œª Y‚ÇÅ Y‚ÇÇ f,
  { left := F.map f.left,
    w' := by tidy; erw [‚Üê F.map_comp, w] } }
end
end over
@[derive category]
def under (X : T) := structured_arrow X (ùü≠ T)
@[simps right hom]
def mk {X Y : T} (f : X ‚ü∂ Y) : under X :=
structured_arrow.mk f
@[simps]
def hom_mk {U V : under X} (f : U.right ‚ü∂ V.right) (w : U.hom ‚â´ f = V.hom . obviously) :
  U ‚ü∂ V :=
structured_arrow.hom_mk f w
def iso_mk {f g : under X} (hr : f.right ‚âÖ g.right) (hw : f.hom ‚â´ hr.hom = g.hom) : f ‚âÖ g :=
structured_arrow.iso_mk hr hw
@[simp]
lemma iso_mk_hom_right {f g : under X} (hr : f.right ‚âÖ g.right) (hw : f.hom ‚â´ hr.hom = g.hom) :
  (iso_mk hr hw).hom.right = hr.hom := rfl
@[simp]
lemma iso_mk_inv_right {f g : under X} (hr : f.right ‚âÖ g.right) (hw : f.hom ‚â´ hr.hom = g.hom) :
  (iso_mk hr hw).inv.right = hr.inv := rfl
section
variables (X)
def forget : under X ‚•§ T := comma.snd _ _
end
@[simp] lemma forget_obj {U : under X} : (forget X).obj U = U.right := rfl
@[simp] lemma forget_map {U V : under X} {f : U ‚ü∂ V} : (forget X).map f = f.right := rfl
@[simps] def forget_cone (X : T) : limits.cone (forget X) :=
{ X := X, œÄ := { app := comma.hom } }
def map {Y : T} (f : X ‚ü∂ Y) : under Y ‚•§ under X := comma.map_left _ $ discrete.nat_trans (Œª _, f)
section
variables {Y : T} {f : X ‚ü∂ Y} {U V : under Y} {g : U ‚ü∂ V}
@[simp] lemma map_obj_right : ((map f).obj U).right = U.right := rfl
@[simp] lemma map_obj_hom   : ((map f).obj U).hom   = f ‚â´ U.hom := rfl
@[simp] lemma map_map_right : ((map f).map g).right = g.right := rfl
def map_id : map (ùüô Y) ‚âÖ ùü≠ _ :=
nat_iso.of_components (Œª X, iso_mk (iso.refl _) (by tidy)) (by tidy)
def map_comp {Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : map (f ‚â´ g) ‚âÖ map g ‚ãô map f :=
nat_iso.of_components (Œª X, iso_mk (iso.refl _) (by tidy)) (by tidy)
end
instance forget_reflects_iso : reflects_isomorphisms (forget X) :=
{ reflects := Œª Y Z f t, by exactI
  ‚ü®‚ü®under.hom_mk (inv ((under.forget X).map f)) ((is_iso.comp_inv_eq _).2 (under.w f).symm),
    by tidy‚ü©‚ü© }
instance forget_faithful : faithful (forget X) := {}.
section
variables {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D]
@[simps]
def post {X : T} (F : T ‚•§ D) : under X ‚•§ under (F.obj X) :=
{ obj := Œª Y, mk $ F.map Y.hom,
  map := Œª Y‚ÇÅ Y‚ÇÇ f,
  { right := F.map f.right,
    w' := by tidy; erw [‚Üê F.map_comp, w] } }
end
end under
end category_theory
