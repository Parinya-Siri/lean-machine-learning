import analysis.specific_limits.normed
noncomputable theory
open_locale topological_space
variables {R : Type*} [normed_ring R] [complete_space R]
namespace units
@[simps coe]
def one_sub (t : R) (h : âˆ¥tâˆ¥ < 1) : RË£ :=
{ val := 1 - t,
  inv := âˆ‘' n : â„•, t ^ n,
  val_inv := mul_neg_geom_series t h,
  inv_val := geom_series_mul_neg t h }
@[simps coe]
def add (x : RË£) (t : R) (h : âˆ¥tâˆ¥ < âˆ¥(â†‘xâ»Â¹ : R)âˆ¥â»Â¹) : RË£ :=
@[simps coe]
def unit_of_nearby (x : RË£) (y : R) (h : âˆ¥y - xâˆ¥ < âˆ¥(â†‘xâ»Â¹ : R)âˆ¥â»Â¹) : RË£ :=
units.copy (x.add (y - x : R) h) y (by simp) _ rfl
protected lemma is_open : is_open {x : R | is_unit x} :=
begin
  nontriviality R,
  apply metric.is_open_iff.mpr,
  rintros x' âŸ¨x, rflâŸ©,
  refine âŸ¨âˆ¥(â†‘xâ»Â¹ : R)âˆ¥â»Â¹, _root_.inv_pos.mpr (units.norm_pos xâ»Â¹), _âŸ©,
  intros y hy,
  rw [metric.mem_ball, dist_eq_norm] at hy,
  exact (x.unit_of_nearby y hy).is_unit
end
protected lemma nhds (x : RË£) : {x : R | is_unit x} âˆˆ ð“ (x : R) :=
is_open.mem_nhds units.is_open x.is_unit
end units
namespace normed_ring
open_locale classical big_operators
open asymptotics filter metric finset ring
lemma inverse_one_sub (t : R) (h : âˆ¥tâˆ¥ < 1) : inverse (1 - t) = â†‘(units.one_sub t h)â»Â¹ :=
by rw [â† inverse_unit (units.one_sub t h), units.coe_one_sub]
lemma inverse_add (x : RË£) :
  âˆ€á¶  t in (ð“ 0), inverse ((x : R) + t) = inverse (1 + â†‘xâ»Â¹ * t) * â†‘xâ»Â¹ :=
begin
  nontriviality R,
  rw [eventually_iff, metric.mem_nhds_iff],
  have hinv : 0 < âˆ¥(â†‘xâ»Â¹ : R)âˆ¥â»Â¹, by cancel_denoms,
  use [âˆ¥(â†‘xâ»Â¹ : R)âˆ¥â»Â¹, hinv],
  intros t ht,
  simp only [mem_ball, dist_zero_right] at ht,
  have ht' : âˆ¥-â†‘xâ»Â¹ * tâˆ¥ < 1,
  { refine lt_of_le_of_lt (norm_mul_le _ _) _,
    rw norm_neg,
    refine lt_of_lt_of_le (mul_lt_mul_of_pos_left ht xâ»Â¹.norm_pos) _,
    cancel_denoms },
  have hright := inverse_one_sub (-â†‘xâ»Â¹ * t) ht',
  have hleft := inverse_unit (x.add t ht),
  simp only [neg_mul, sub_neg_eq_add] at hright,
  simp only [units.coe_add] at hleft,
  simp [hleft, hright, units.add]
end
lemma inverse_one_sub_nth_order (n : â„•) :
  âˆ€á¶  t in (ð“ 0), inverse ((1:R) - t) = (âˆ‘ i in range n, t ^ i) + (t ^ n) * inverse (1 - t) :=
begin
  simp only [eventually_iff, metric.mem_nhds_iff],
  use [1, by norm_num],
  intros t ht,
  simp only [mem_ball, dist_zero_right] at ht,
  simp only [inverse_one_sub t ht, set.mem_set_of_eq],
  have h : 1 = ((range n).sum (Î» i, t ^ i)) * (units.one_sub t ht) + t ^ n,
  { simp only [units.coe_one_sub],
    rw [geom_sum_mul_neg],
    simp },
  rw [â† one_mul â†‘(units.one_sub t ht)â»Â¹, h, add_mul],
  congr,
  { rw [mul_assoc, (units.one_sub t ht).mul_inv],
    simp },
  { simp only [units.coe_one_sub],
    rw [â† add_mul, geom_sum_mul_neg],
    simp }
end
lemma inverse_add_nth_order (x : RË£) (n : â„•) :
  âˆ€á¶  t in (ð“ 0), inverse ((x : R) + t)
  = (âˆ‘ i in range n, (- â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹ + (- â†‘xâ»Â¹ * t) ^ n * inverse (x + t) :=
begin
  refine (inverse_add x).mp _,
  have hzero : tendsto (Î» (t : R), - â†‘xâ»Â¹ * t) (ð“ 0) (ð“ 0),
  { convert ((mul_left_continuous (- (â†‘xâ»Â¹ : R))).tendsto 0).comp tendsto_id,
    simp },
  refine (hzero.eventually (inverse_one_sub_nth_order n)).mp (eventually_of_forall _),
  simp only [neg_mul, sub_neg_eq_add],
  intros t h1 h2,
  have h := congr_arg (Î» (a : R), a * â†‘xâ»Â¹) h1,
  dsimp at h,
  convert h,
  rw [add_mul, mul_assoc],
  simp [h2.symm]
end
lemma inverse_one_sub_norm : (Î» t : R, inverse (1 - t)) =O[ð“ 0] (Î» t, 1 : R â†’ â„) :=
begin
  simp only [is_O, is_O_with, eventually_iff, metric.mem_nhds_iff],
  refine âŸ¨âˆ¥(1:R)âˆ¥ + 1, (2:â„)â»Â¹, by norm_num, _âŸ©,
  intros t ht,
  simp only [ball, dist_zero_right, set.mem_set_of_eq] at ht,
  have ht' : âˆ¥tâˆ¥ < 1,
  { have : (2:â„)â»Â¹ < 1 := by cancel_denoms,
    linarith },
  simp only [inverse_one_sub t ht', norm_one, mul_one, set.mem_set_of_eq],
  change âˆ¥âˆ‘' n : â„•, t ^ nâˆ¥ â‰¤ _,
  have := normed_ring.tsum_geometric_of_norm_lt_1 t ht',
  have : (1 - âˆ¥tâˆ¥)â»Â¹ â‰¤ 2,
  { rw â† inv_inv (2:â„),
    refine inv_le_inv_of_le (by norm_num) _,
    have : (2:â„)â»Â¹ + (2:â„)â»Â¹ = 1 := by ring,
    linarith },
  linarith
end
lemma inverse_add_norm (x : RË£) : (Î» t : R, inverse (â†‘x + t)) =O[ð“ 0] (Î» t, (1:â„)) :=
begin
  simp only [is_O_iff, norm_one, mul_one],
  cases is_O_iff.mp (@inverse_one_sub_norm R _ _) with C hC,
  use C * âˆ¥((xâ»Â¹:RË£):R)âˆ¥,
  have hzero : tendsto (Î» t, - (â†‘xâ»Â¹ : R) * t) (ð“ 0) (ð“ 0),
  { convert ((mul_left_continuous (-â†‘xâ»Â¹ : R)).tendsto 0).comp tendsto_id,
    simp },
  refine (inverse_add x).mp ((hzero.eventually hC).mp (eventually_of_forall _)),
  intros t bound iden,
  rw iden,
  simp at bound,
  have hmul := norm_mul_le (inverse (1 + â†‘xâ»Â¹ * t)) â†‘xâ»Â¹,
  nlinarith [norm_nonneg (â†‘xâ»Â¹ : R)]
end
lemma inverse_add_norm_diff_nth_order (x : RË£) (n : â„•) :
  (Î» t : R, inverse (â†‘x + t) - (âˆ‘ i in range n, (- â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹) =O[ð“ (0:R)]
  (Î» t, âˆ¥tâˆ¥ ^ n) :=
begin
  by_cases h : n = 0,
  { simpa [h] using inverse_add_norm x },
  have hn : 0 < n := nat.pos_of_ne_zero h,
  simp [is_O_iff],
  cases (is_O_iff.mp (inverse_add_norm x)) with C hC,
  use C * âˆ¥(1:â„)âˆ¥ * âˆ¥(â†‘xâ»Â¹ : R)âˆ¥ ^ n,
  have h : eventually_eq (ð“ (0:R))
    (Î» t, inverse (â†‘x + t) - (âˆ‘ i in range n, (- â†‘xâ»Â¹ * t) ^ i) * â†‘xâ»Â¹)
    (Î» t, ((- â†‘xâ»Â¹ * t) ^ n) * inverse (x + t)),
  { refine (inverse_add_nth_order x n).mp (eventually_of_forall _),
    intros t ht,
    convert congr_arg (Î» a, a - (range n).sum (pow (-â†‘xâ»Â¹ * t)) * â†‘xâ»Â¹) ht,
    simp },
  refine h.mp (hC.mp (eventually_of_forall _)),
  intros t _ hLHS,
  simp only [neg_mul] at hLHS,
  rw hLHS,
  refine le_trans (norm_mul_le _ _ ) _,
  have h' : âˆ¥(-(â†‘xâ»Â¹ * t)) ^ nâˆ¥ â‰¤ âˆ¥(â†‘xâ»Â¹ : R)âˆ¥ ^ n * âˆ¥tâˆ¥ ^ n,
  { calc âˆ¥(-(â†‘xâ»Â¹ * t)) ^ nâˆ¥ â‰¤ âˆ¥(-(â†‘xâ»Â¹ * t))âˆ¥ ^ n : norm_pow_le' _ hn
    ... = âˆ¥â†‘xâ»Â¹ * tâˆ¥ ^ n : by rw norm_neg
    ... â‰¤ (âˆ¥(â†‘xâ»Â¹ : R)âˆ¥ * âˆ¥tâˆ¥) ^ n : _
    ... =  âˆ¥(â†‘xâ»Â¹ : R)âˆ¥ ^ n * âˆ¥tâˆ¥ ^ n : mul_pow _ _ n,
    exact pow_le_pow_of_le_left (norm_nonneg _) (norm_mul_le â†‘xâ»Â¹ t) n },
  have h'' : 0 â‰¤ âˆ¥(â†‘xâ»Â¹ : R)âˆ¥ ^ n * âˆ¥tâˆ¥ ^ n,
  { refine mul_nonneg _ _;
    exact pow_nonneg (norm_nonneg _) n },
  nlinarith [norm_nonneg (inverse (â†‘x + t))],
end
lemma inverse_add_norm_diff_first_order (x : RË£) :
  (Î» t : R, inverse (â†‘x + t) - â†‘xâ»Â¹) =O[ð“ 0] (Î» t, âˆ¥tâˆ¥) :=
by simpa using inverse_add_norm_diff_nth_order x 1
lemma inverse_add_norm_diff_second_order (x : RË£) :
  (Î» t : R, inverse (â†‘x + t) - â†‘xâ»Â¹ + â†‘xâ»Â¹ * t * â†‘xâ»Â¹) =O[ð“ 0] (Î» t, âˆ¥tâˆ¥ ^ 2) :=
begin
  convert inverse_add_norm_diff_nth_order x 2,
  ext t,
  simp only [range_succ, range_one, sum_insert, mem_singleton, sum_singleton, not_false_iff,
    one_ne_zero, pow_zero, add_mul, pow_one, one_mul, neg_mul,
    sub_add_eq_sub_sub_swap, sub_neg_eq_add],
end
lemma inverse_continuous_at (x : RË£) : continuous_at inverse (x : R) :=
begin
  have h_is_o : (Î» t : R, inverse (â†‘x + t) - â†‘xâ»Â¹) =o[ð“ 0] (Î» _, 1 : R â†’ â„) :=
    (inverse_add_norm_diff_first_order x).trans_is_o (is_o.norm_left $ is_o_id_const one_ne_zero),
  have h_lim : tendsto (Î» (y:R), y - x) (ð“ x) (ð“ 0),
  { refine tendsto_zero_iff_norm_tendsto_zero.mpr _,
    exact tendsto_iff_norm_tendsto_zero.mp tendsto_id },
  rw [continuous_at, tendsto_iff_norm_tendsto_zero, inverse_unit],
  simpa [(âˆ˜)] using h_is_o.norm_left.tendsto_div_nhds_zero.comp h_lim
end
end normed_ring
namespace units
open mul_opposite filter normed_ring
lemma is_open_map_coe : is_open_map (coe : RË£ â†’ R) :=
begin
  rw is_open_map_iff_nhds_le,
  intros x s,
  rw [mem_map, mem_nhds_induced],
  rintros âŸ¨t, ht, htsâŸ©,
  obtain âŸ¨u, hu, v, hv, huvtâŸ© :
    âˆƒ (u : set R), u âˆˆ ð“ â†‘x âˆ§ âˆƒ (v : set Ráµáµ’áµ–), v âˆˆ ð“ (op â†‘xâ»Â¹) âˆ§ u Ã—Ë¢ v âŠ† t,
  { simpa [embed_product, mem_nhds_prod_iff] using ht },
  have : u âˆ© (op âˆ˜ ring.inverse) â»Â¹' v âˆ© (set.range (coe : RË£ â†’ R)) âˆˆ ð“ â†‘x,
  { refine inter_mem (inter_mem hu _) (units.nhds x),
    refine (continuous_op.continuous_at.comp (inverse_continuous_at x)).preimage_mem_nhds _,
    simpa using hv },
  refine mem_of_superset this _,
  rintros _ âŸ¨âŸ¨huy, hvyâŸ©, âŸ¨y, rflâŸ©âŸ©,
  have : embed_product R y âˆˆ u Ã—Ë¢ v := âŸ¨huy, by simpa using hvyâŸ©,
  simpa using hts (huvt this)
end
lemma open_embedding_coe : open_embedding (coe : RË£ â†’ R) :=
open_embedding_of_continuous_injective_open continuous_coe ext is_open_map_coe
end units
