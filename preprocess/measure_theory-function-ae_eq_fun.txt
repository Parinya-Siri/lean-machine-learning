import measure_theory.integral.lebesgue
import order.filter.germ
import topology.continuous_function.algebra
import measure_theory.function.strongly_measurable
noncomputable theory
open_locale classical ennreal topological_space
open set filter topological_space ennreal emetric measure_theory function
variables {Î± Î² Î³ Î´ : Type*} [measurable_space Î±] {Î¼ Î½ : measure Î±}
namespace measure_theory
section measurable_space
variables [topological_space Î²]
variable (Î²)
def measure.ae_eq_setoid (Î¼ : measure Î±) : setoid { f : Î± â†’ Î² // ae_strongly_measurable f Î¼ } :=
âŸ¨Î» f g, (f : Î± â†’ Î²) =áµ[Î¼] g, Î» f, ae_eq_refl f, Î» f g, ae_eq_symm, Î» f g h, ae_eq_transâŸ©
variable (Î±)
def ae_eq_fun (Î¼ : measure Î±) : Type* := quotient (Î¼.ae_eq_setoid Î²)
variables {Î± Î²}
notation Î± ` â†’â‚˜[`:25 Î¼ `] ` Î² := ae_eq_fun Î± Î² Î¼
end measurable_space
namespace ae_eq_fun
variables [topological_space Î²] [topological_space Î³] [topological_space Î´]
def mk {Î² : Type*} [topological_space Î²]
  (f : Î± â†’ Î²) (hf : ae_strongly_measurable f Î¼) : Î± â†’â‚˜[Î¼] Î² := quotient.mk' âŸ¨f, hfâŸ©
instance : has_coe_to_fun (Î± â†’â‚˜[Î¼] Î²) (Î» _, Î± â†’ Î²) :=
âŸ¨Î» f, ae_strongly_measurable.mk _ (quotient.out' f : {f : Î± â†’ Î² // ae_strongly_measurable f Î¼}).2âŸ©
protected lemma strongly_measurable (f : Î± â†’â‚˜[Î¼] Î²) : strongly_measurable f :=
ae_strongly_measurable.strongly_measurable_mk _
protected lemma ae_strongly_measurable (f : Î± â†’â‚˜[Î¼] Î²) : ae_strongly_measurable f Î¼ :=
f.strongly_measurable.ae_strongly_measurable
protected lemma measurable [pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²]
  (f : Î± â†’â‚˜[Î¼] Î²) : measurable f :=
ae_strongly_measurable.measurable_mk _
protected lemma ae_measurable [pseudo_metrizable_space Î²] [measurable_space Î²] [borel_space Î²]
  (f : Î± â†’â‚˜[Î¼] Î²) :
  ae_measurable f Î¼ :=
f.measurable.ae_measurable
@[simp] lemma quot_mk_eq_mk (f : Î± â†’ Î²) (hf) :
  (quot.mk (@setoid.r _ $ Î¼.ae_eq_setoid Î²) âŸ¨f, hfâŸ© : Î± â†’â‚˜[Î¼] Î²) = mk f hf :=
rfl
@[simp] lemma mk_eq_mk {f g : Î± â†’ Î²} {hf hg} :
  (mk f hf : Î± â†’â‚˜[Î¼] Î²) = mk g hg â†” f =áµ[Î¼] g :=
quotient.eq'
@[simp] lemma mk_coe_fn (f : Î± â†’â‚˜[Î¼] Î²) : mk f f.ae_strongly_measurable = f :=
begin
  conv_rhs { rw â† quotient.out_eq' f },
  set g : {f : Î± â†’ Î² // ae_strongly_measurable f Î¼} := quotient.out' f with hg,
  have : g = âŸ¨g.1, g.2âŸ© := subtype.eq rfl,
  rw [this, â† mk, mk_eq_mk],
  exact (ae_strongly_measurable.ae_eq_mk _).symm,
end
@[ext] lemma ext {f g : Î± â†’â‚˜[Î¼] Î²} (h : f =áµ[Î¼] g) : f = g :=
by rwa [â† f.mk_coe_fn, â† g.mk_coe_fn, mk_eq_mk]
lemma ext_iff {f g : Î± â†’â‚˜[Î¼] Î²} : f = g â†” f =áµ[Î¼] g :=
âŸ¨Î» h, by rw h, Î» h, ext hâŸ©
lemma coe_fn_mk (f : Î± â†’ Î²) (hf) : (mk f hf : Î± â†’â‚˜[Î¼] Î²) =áµ[Î¼] f :=
begin
  apply (ae_strongly_measurable.ae_eq_mk _).symm.trans,
  exact @quotient.mk_out' _ (Î¼.ae_eq_setoid Î²) (âŸ¨f, hfâŸ© : {f // ae_strongly_measurable f Î¼})
end
@[elab_as_eliminator]
lemma induction_on (f : Î± â†’â‚˜[Î¼] Î²) {p : (Î± â†’â‚˜[Î¼] Î²) â†’ Prop} (H : âˆ€ f hf, p (mk f hf)) : p f :=
quotient.induction_on' f $ subtype.forall.2 H
@[elab_as_eliminator]
lemma induction_onâ‚‚ {Î±' Î²' : Type*} [measurable_space Î±'] [topological_space Î²']
  {Î¼' : measure Î±'}
  (f : Î± â†’â‚˜[Î¼] Î²) (f' : Î±' â†’â‚˜[Î¼'] Î²') {p : (Î± â†’â‚˜[Î¼] Î²) â†’ (Î±' â†’â‚˜[Î¼'] Î²') â†’ Prop}
  (H : âˆ€ f hf f' hf', p (mk f hf) (mk f' hf')) :
  p f f' :=
induction_on f $ Î» f hf, induction_on f' $ H f hf
@[elab_as_eliminator]
lemma induction_onâ‚ƒ {Î±' Î²' : Type*} [measurable_space Î±'] [topological_space Î²']
  {Î¼' : measure Î±'}
  {Î±'' Î²'' : Type*} [measurable_space Î±''] [topological_space Î²'']
  {Î¼'' : measure Î±''}
  (f : Î± â†’â‚˜[Î¼] Î²) (f' : Î±' â†’â‚˜[Î¼'] Î²') (f'' : Î±'' â†’â‚˜[Î¼''] Î²'')
  {p : (Î± â†’â‚˜[Î¼] Î²) â†’ (Î±' â†’â‚˜[Î¼'] Î²') â†’ (Î±'' â†’â‚˜[Î¼''] Î²'') â†’ Prop}
  (H : âˆ€ f hf f' hf' f'' hf'', p (mk f hf) (mk f' hf') (mk f'' hf'')) :
  p f f' f'' :=
induction_on f $ Î» f hf, induction_onâ‚‚ f' f'' $ H f hf
def comp (g : Î² â†’ Î³) (hg : continuous g) (f : Î± â†’â‚˜[Î¼] Î²) : Î± â†’â‚˜[Î¼] Î³ :=
quotient.lift_on' f (Î» f, mk (g âˆ˜ (f : Î± â†’ Î²)) (hg.comp_ae_strongly_measurable f.2)) $
  Î» f f' H, mk_eq_mk.2 $ H.fun_comp g
@[simp] lemma comp_mk (g : Î² â†’ Î³) (hg : continuous g)
  (f : Î± â†’ Î²) (hf) :
  comp g hg (mk f hf : Î± â†’â‚˜[Î¼] Î²) = mk (g âˆ˜ f) (hg.comp_ae_strongly_measurable hf) :=
rfl
lemma comp_eq_mk (g : Î² â†’ Î³) (hg : continuous g) (f : Î± â†’â‚˜[Î¼] Î²) :
  comp g hg f = mk (g âˆ˜ f) (hg.comp_ae_strongly_measurable f.ae_strongly_measurable) :=
by rw [â† comp_mk g hg f f.ae_strongly_measurable, mk_coe_fn]
lemma coe_fn_comp (g : Î² â†’ Î³) (hg : continuous g) (f : Î± â†’â‚˜[Î¼] Î²) :
  comp g hg f =áµ[Î¼] g âˆ˜ f :=
by { rw [comp_eq_mk], apply coe_fn_mk }
section comp_measurable
variables [measurable_space Î²] [pseudo_metrizable_space Î²] [borel_space Î²]
  [measurable_space Î³] [pseudo_metrizable_space Î³] [opens_measurable_space Î³]
  [second_countable_topology Î³]
def comp_measurable
  (g : Î² â†’ Î³) (hg : measurable g) (f : Î± â†’â‚˜[Î¼] Î²) : Î± â†’â‚˜[Î¼] Î³ :=
quotient.lift_on' f (Î» f', mk (g âˆ˜ (f' : Î± â†’ Î²))
  (hg.comp_ae_measurable f'.2.ae_measurable).ae_strongly_measurable) $
  Î» f f' H, mk_eq_mk.2 $ H.fun_comp g
@[simp] lemma comp_measurable_mk (g : Î² â†’ Î³) (hg : measurable g)
  (f : Î± â†’ Î²) (hf : ae_strongly_measurable f Î¼) :
  comp_measurable g hg (mk f hf : Î± â†’â‚˜[Î¼] Î²) =
    mk (g âˆ˜ f) (hg.comp_ae_measurable hf.ae_measurable).ae_strongly_measurable :=
rfl
lemma comp_measurable_eq_mk (g : Î² â†’ Î³) (hg : measurable g) (f : Î± â†’â‚˜[Î¼] Î²) :
  comp_measurable g hg f =
    mk (g âˆ˜ f) (hg.comp_ae_measurable f.ae_measurable).ae_strongly_measurable :=
by rw [â† comp_measurable_mk g hg f f.ae_strongly_measurable, mk_coe_fn]
lemma coe_fn_comp_measurable (g : Î² â†’ Î³) (hg : measurable g) (f : Î± â†’â‚˜[Î¼] Î²) :
  comp_measurable g hg f =áµ[Î¼] g âˆ˜ f :=
by { rw [comp_measurable_eq_mk], apply coe_fn_mk }
end comp_measurable
def pair (f : Î± â†’â‚˜[Î¼] Î²) (g : Î± â†’â‚˜[Î¼] Î³) : Î± â†’â‚˜[Î¼] Î² Ã— Î³ :=
quotient.lift_onâ‚‚' f g (Î» f g, mk (Î» x, (f.1 x, g.1 x)) (f.2.prod_mk g.2)) $
  Î» f g f' g' Hf Hg, mk_eq_mk.2 $ Hf.prod_mk Hg
@[simp] lemma pair_mk_mk (f : Î± â†’ Î²) (hf) (g : Î± â†’ Î³) (hg) :
  (mk f hf : Î± â†’â‚˜[Î¼] Î²).pair (mk g hg) = mk (Î» x, (f x, g x)) (hf.prod_mk hg) :=
rfl
lemma pair_eq_mk (f : Î± â†’â‚˜[Î¼] Î²) (g : Î± â†’â‚˜[Î¼] Î³) :
  f.pair g = mk (Î» x, (f x, g x)) (f.ae_strongly_measurable.prod_mk g.ae_strongly_measurable) :=
by simp only [â† pair_mk_mk, mk_coe_fn]
lemma coe_fn_pair (f : Î± â†’â‚˜[Î¼] Î²) (g : Î± â†’â‚˜[Î¼] Î³) :
  f.pair g =áµ[Î¼] (Î» x, (f x, g x)) :=
by { rw pair_eq_mk, apply coe_fn_mk }
def compâ‚‚ (g : Î² â†’ Î³ â†’ Î´)
  (hg : continuous (uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) : Î± â†’â‚˜[Î¼] Î´ :=
comp _ hg (fâ‚.pair fâ‚‚)
@[simp] lemma compâ‚‚_mk_mk
  (g : Î² â†’ Î³ â†’ Î´) (hg : continuous (uncurry g)) (fâ‚ : Î± â†’ Î²) (fâ‚‚ : Î± â†’ Î³) (hfâ‚ hfâ‚‚) :
  compâ‚‚ g hg (mk fâ‚ hfâ‚ : Î± â†’â‚˜[Î¼] Î²) (mk fâ‚‚ hfâ‚‚) =
    mk (Î» a, g (fâ‚ a) (fâ‚‚ a)) (hg.comp_ae_strongly_measurable (hfâ‚.prod_mk hfâ‚‚)) :=
rfl
lemma compâ‚‚_eq_pair
  (g : Î² â†’ Î³ â†’ Î´) (hg : continuous (uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) :
  compâ‚‚ g hg fâ‚ fâ‚‚ = comp _ hg (fâ‚.pair fâ‚‚) :=
rfl
lemma compâ‚‚_eq_mk
  (g : Î² â†’ Î³ â†’ Î´) (hg : continuous (uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) :
  compâ‚‚ g hg fâ‚ fâ‚‚ = mk (Î» a, g (fâ‚ a) (fâ‚‚ a)) (hg.comp_ae_strongly_measurable
    (fâ‚.ae_strongly_measurable.prod_mk fâ‚‚.ae_strongly_measurable)) :=
by rw [compâ‚‚_eq_pair, pair_eq_mk, comp_mk]; refl
lemma coe_fn_compâ‚‚
  (g : Î² â†’ Î³ â†’ Î´) (hg : continuous (uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) :
  compâ‚‚ g hg fâ‚ fâ‚‚ =áµ[Î¼] Î» a, g (fâ‚ a) (fâ‚‚ a) :=
by { rw compâ‚‚_eq_mk, apply coe_fn_mk }
section
variables
  [measurable_space Î²] [pseudo_metrizable_space Î²] [borel_space Î²] [second_countable_topology Î²]
  [measurable_space Î³] [pseudo_metrizable_space Î³] [borel_space Î³] [second_countable_topology Î³]
  [measurable_space Î´] [pseudo_metrizable_space Î´] [opens_measurable_space Î´]
  [second_countable_topology Î´]
def compâ‚‚_measurable (g : Î² â†’ Î³ â†’ Î´)
  (hg : measurable (uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) : Î± â†’â‚˜[Î¼] Î´ :=
comp_measurable _ hg (fâ‚.pair fâ‚‚)
@[simp] lemma compâ‚‚_measurable_mk_mk
  (g : Î² â†’ Î³ â†’ Î´) (hg : measurable (uncurry g)) (fâ‚ : Î± â†’ Î²) (fâ‚‚ : Î± â†’ Î³) (hfâ‚ hfâ‚‚) :
  compâ‚‚_measurable g hg (mk fâ‚ hfâ‚ : Î± â†’â‚˜[Î¼] Î²) (mk fâ‚‚ hfâ‚‚) =
  mk (Î» a, g (fâ‚ a) (fâ‚‚ a))
    (hg.comp_ae_measurable (hfâ‚.ae_measurable.prod_mk hfâ‚‚.ae_measurable)).ae_strongly_measurable :=
rfl
lemma compâ‚‚_measurable_eq_pair
  (g : Î² â†’ Î³ â†’ Î´) (hg : measurable (uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) :
  compâ‚‚_measurable g hg fâ‚ fâ‚‚ = comp_measurable _ hg (fâ‚.pair fâ‚‚) :=
rfl
lemma compâ‚‚_measurable_eq_mk
  (g : Î² â†’ Î³ â†’ Î´) (hg : measurable (uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) :
  compâ‚‚_measurable g hg fâ‚ fâ‚‚ = mk (Î» a, g (fâ‚ a) (fâ‚‚ a)) (hg.comp_ae_measurable
    (fâ‚.ae_measurable.prod_mk fâ‚‚.ae_measurable)).ae_strongly_measurable :=
by rw [compâ‚‚_measurable_eq_pair, pair_eq_mk, comp_measurable_mk]; refl
lemma coe_fn_compâ‚‚_measurable
  (g : Î² â†’ Î³ â†’ Î´) (hg : measurable (uncurry g)) (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) :
  compâ‚‚_measurable g hg fâ‚ fâ‚‚ =áµ[Î¼] Î» a, g (fâ‚ a) (fâ‚‚ a) :=
by { rw compâ‚‚_measurable_eq_mk, apply coe_fn_mk }
end
def to_germ (f : Î± â†’â‚˜[Î¼] Î²) : germ Î¼.ae Î² :=
quotient.lift_on' f (Î» f, ((f : Î± â†’ Î²) : germ Î¼.ae Î²)) $ Î» f g H, germ.coe_eq.2 H
@[simp] lemma mk_to_germ (f : Î± â†’ Î²) (hf) : (mk f hf : Î± â†’â‚˜[Î¼] Î²).to_germ = f := rfl
lemma to_germ_eq (f : Î± â†’â‚˜[Î¼] Î²) : f.to_germ = (f : Î± â†’ Î²) :=
by rw [â† mk_to_germ, mk_coe_fn]
lemma to_germ_injective : injective (to_germ : (Î± â†’â‚˜[Î¼] Î²) â†’ germ Î¼.ae Î²) :=
Î» f g H, ext $ germ.coe_eq.1 $ by rwa [â† to_germ_eq, â† to_germ_eq]
lemma comp_to_germ (g : Î² â†’ Î³) (hg : continuous g) (f : Î± â†’â‚˜[Î¼] Î²) :
  (comp g hg f).to_germ = f.to_germ.map g :=
induction_on f $ Î» f hf, by simp
lemma comp_measurable_to_germ [measurable_space Î²] [borel_space Î²] [pseudo_metrizable_space Î²]
  [pseudo_metrizable_space Î³] [second_countable_topology Î³] [measurable_space Î³]
  [opens_measurable_space Î³] (g : Î² â†’ Î³) (hg : measurable g) (f : Î± â†’â‚˜[Î¼] Î²) :
  (comp_measurable g hg f).to_germ = f.to_germ.map g :=
induction_on f $ Î» f hf, by simp
lemma compâ‚‚_to_germ (g : Î² â†’ Î³ â†’ Î´) (hg : continuous (uncurry g))
  (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) :
  (compâ‚‚ g hg fâ‚ fâ‚‚).to_germ = fâ‚.to_germ.mapâ‚‚ g fâ‚‚.to_germ :=
induction_onâ‚‚ fâ‚ fâ‚‚ $ Î» fâ‚ hfâ‚ fâ‚‚ hfâ‚‚, by simp
lemma compâ‚‚_measurable_to_germ
  [pseudo_metrizable_space Î²] [second_countable_topology Î²] [measurable_space Î²] [borel_space Î²]
  [pseudo_metrizable_space Î³] [second_countable_topology Î³] [measurable_space Î³] [borel_space Î³]
  [pseudo_metrizable_space Î´] [second_countable_topology Î´] [measurable_space Î´]
  [opens_measurable_space Î´] (g : Î² â†’ Î³ â†’ Î´) (hg : measurable (uncurry g))
  (fâ‚ : Î± â†’â‚˜[Î¼] Î²) (fâ‚‚ : Î± â†’â‚˜[Î¼] Î³) :
  (compâ‚‚_measurable g hg fâ‚ fâ‚‚).to_germ = fâ‚.to_germ.mapâ‚‚ g fâ‚‚.to_germ :=
induction_onâ‚‚ fâ‚ fâ‚‚ $ Î» fâ‚ hfâ‚ fâ‚‚ hfâ‚‚, by simp
def lift_pred (p : Î² â†’ Prop) (f : Î± â†’â‚˜[Î¼] Î²) : Prop := f.to_germ.lift_pred p
def lift_rel (r : Î² â†’ Î³ â†’ Prop) (f : Î± â†’â‚˜[Î¼] Î²) (g : Î± â†’â‚˜[Î¼] Î³) : Prop :=
f.to_germ.lift_rel r g.to_germ
lemma lift_rel_mk_mk {r : Î² â†’ Î³ â†’ Prop} {f : Î± â†’ Î²} {g : Î± â†’ Î³} {hf hg} :
  lift_rel r (mk f hf : Î± â†’â‚˜[Î¼] Î²) (mk g hg) â†” âˆ€áµ a âˆ‚Î¼, r (f a) (g a) :=
iff.rfl
lemma lift_rel_iff_coe_fn {r : Î² â†’ Î³ â†’ Prop} {f : Î± â†’â‚˜[Î¼] Î²} {g : Î± â†’â‚˜[Î¼] Î³} :
  lift_rel r f g â†” âˆ€áµ a âˆ‚Î¼, r (f a) (g a) :=
by rw [â† lift_rel_mk_mk, mk_coe_fn, mk_coe_fn]
section order
instance [preorder Î²] : preorder (Î± â†’â‚˜[Î¼] Î²) := preorder.lift to_germ
@[simp] lemma mk_le_mk [preorder Î²] {f g : Î± â†’ Î²} (hf hg) :
  (mk f hf : Î± â†’â‚˜[Î¼] Î²) â‰¤ mk g hg â†” f â‰¤áµ[Î¼] g :=
iff.rfl
@[simp, norm_cast] lemma coe_fn_le [preorder Î²] {f g : Î± â†’â‚˜[Î¼] Î²} :
  (f : Î± â†’ Î²) â‰¤áµ[Î¼] g â†” f â‰¤ g :=
lift_rel_iff_coe_fn.symm
instance [partial_order Î²] : partial_order (Î± â†’â‚˜[Î¼] Î²) :=
partial_order.lift to_germ to_germ_injective
section lattice
section sup
variables [semilattice_sup Î²] [has_continuous_sup Î²]
instance : has_sup (Î± â†’â‚˜[Î¼] Î²) :=
{ sup := Î» f g, ae_eq_fun.compâ‚‚ (âŠ”) continuous_sup f g }
lemma coe_fn_sup (f g : Î± â†’â‚˜[Î¼] Î²) : â‡‘(f âŠ” g) =áµ[Î¼] Î» x, f x âŠ” g x :=
coe_fn_compâ‚‚ _ _ _ _
protected lemma le_sup_left (f g : Î± â†’â‚˜[Î¼] Î²) : f â‰¤ f âŠ” g :=
by { rw â† coe_fn_le, filter_upwards [coe_fn_sup f g] with _ ha, rw ha, exact le_sup_left, }
protected lemma le_sup_right (f g : Î± â†’â‚˜[Î¼] Î²) : g â‰¤ f âŠ” g :=
by { rw â† coe_fn_le, filter_upwards [coe_fn_sup f g] with _ ha, rw ha, exact le_sup_right, }
protected lemma sup_le (f g f' : Î± â†’â‚˜[Î¼] Î²) (hf : f â‰¤ f') (hg : g â‰¤ f') : f âŠ” g â‰¤ f' :=
begin
  rw â† coe_fn_le at hf hg âŠ¢,
  filter_upwards [hf, hg, coe_fn_sup f g] with _ haf hag ha_sup,
  rw ha_sup,
  exact sup_le haf hag,
end
end sup
section inf
variables [semilattice_inf Î²] [has_continuous_inf Î²]
instance : has_inf (Î± â†’â‚˜[Î¼] Î²) :=
{ inf := Î» f g, ae_eq_fun.compâ‚‚ (âŠ“) continuous_inf f g }
lemma coe_fn_inf (f g : Î± â†’â‚˜[Î¼] Î²) : â‡‘(f âŠ“ g) =áµ[Î¼] Î» x, f x âŠ“ g x :=
coe_fn_compâ‚‚ _ _ _ _
protected lemma inf_le_left (f g : Î± â†’â‚˜[Î¼] Î²) : f âŠ“ g â‰¤ f :=
by { rw â† coe_fn_le, filter_upwards [coe_fn_inf f g] with _ ha, rw ha, exact inf_le_left, }
protected lemma inf_le_right (f g : Î± â†’â‚˜[Î¼] Î²) : f âŠ“ g â‰¤ g :=
by { rw â† coe_fn_le, filter_upwards [coe_fn_inf f g] with _ ha, rw ha, exact inf_le_right, }
protected lemma le_inf (f' f g : Î± â†’â‚˜[Î¼] Î²) (hf : f' â‰¤ f) (hg : f' â‰¤ g) : f' â‰¤ f âŠ“ g :=
begin
  rw â† coe_fn_le at hf hg âŠ¢,
  filter_upwards [hf, hg, coe_fn_inf f g] with _ haf hag ha_inf,
  rw ha_inf,
  exact le_inf haf hag,
end
end inf
instance [lattice Î²] [topological_lattice Î²] : lattice (Î± â†’â‚˜[Î¼] Î²) :=
{ sup           := has_sup.sup,
  le_sup_left   := ae_eq_fun.le_sup_left,
  le_sup_right  := ae_eq_fun.le_sup_right,
  sup_le        := ae_eq_fun.sup_le,
  inf           := has_inf.inf,
  inf_le_left   := ae_eq_fun.inf_le_left,
  inf_le_right  := ae_eq_fun.inf_le_right,
  le_inf        := ae_eq_fun.le_inf,
  ..ae_eq_fun.partial_order}
end lattice
end order
variable (Î±)
def const (b : Î²) : Î± â†’â‚˜[Î¼] Î² := mk (Î» a:Î±, b) ae_strongly_measurable_const
lemma coe_fn_const (b : Î²) : (const Î± b : Î± â†’â‚˜[Î¼] Î²) =áµ[Î¼] function.const Î± b :=
coe_fn_mk _ _
variable {Î±}
instance [inhabited Î²] : inhabited (Î± â†’â‚˜[Î¼] Î²) := âŸ¨const Î± defaultâŸ©
@[to_additive] instance [has_one Î²] : has_one (Î± â†’â‚˜[Î¼] Î²) := âŸ¨const Î± 1âŸ©
@[to_additive] lemma one_def [has_one Î²] :
  (1 : Î± â†’â‚˜[Î¼] Î²) = mk (Î» a:Î±, 1) ae_strongly_measurable_const := rfl
@[to_additive] lemma coe_fn_one [has_one Î²] : â‡‘(1 : Î± â†’â‚˜[Î¼] Î²) =áµ[Î¼] 1 := coe_fn_const _ _
@[simp, to_additive] lemma one_to_germ [has_one Î²] : (1 : Î± â†’â‚˜[Î¼] Î²).to_germ = 1 := rfl
@[to_additive "`ae_eq_fun.to_germ` as an `add_monoid_hom`.", simps]
def to_germ_monoid_hom : (Î± â†’â‚˜[Î¼] Î³) â†’* Î¼.ae.germ Î³ :=
{ to_fun := to_germ,
  map_one' := one_to_germ,
  map_mul' := mul_to_germ }
end monoid
@[to_additive]
instance [comm_monoid Î³] [has_continuous_mul Î³] : comm_monoid (Î± â†’â‚˜[Î¼] Î³) :=
to_germ_injective.comm_monoid to_germ one_to_germ mul_to_germ pow_to_germ
section group
variables [group Î³] [topological_group Î³]
section inv
@[to_additive] instance : has_inv (Î± â†’â‚˜[Î¼] Î³) := âŸ¨comp has_inv.inv continuous_invâŸ©
@[simp, to_additive] lemma inv_mk (f : Î± â†’ Î³) (hf) : (mk f hf : Î± â†’â‚˜[Î¼] Î³)â»Â¹ = mk fâ»Â¹ hf.inv := rfl
@[to_additive] lemma coe_fn_inv (f : Î± â†’â‚˜[Î¼] Î³) : â‡‘(fâ»Â¹) =áµ[Î¼] fâ»Â¹ := coe_fn_comp _ _ _
@[to_additive] lemma inv_to_germ (f : Î± â†’â‚˜[Î¼] Î³) : (fâ»Â¹).to_germ = f.to_germâ»Â¹ := comp_to_germ _ _ _
end inv
section div
@[to_additive] instance : has_div (Î± â†’â‚˜[Î¼] Î³) := âŸ¨compâ‚‚ has_div.div continuous_div'âŸ©
@[simp, to_additive] lemma mk_div (f g : Î± â†’ Î³)
  (hf : ae_strongly_measurable f Î¼) (hg : ae_strongly_measurable g Î¼) :
  mk (f / g) (hf.div hg) = (mk f hf : Î± â†’â‚˜[Î¼] Î³) / (mk g hg) :=
rfl
@[to_additive] lemma coe_fn_div (f g : Î± â†’â‚˜[Î¼] Î³) : â‡‘(f / g) =áµ[Î¼] f / g := coe_fn_compâ‚‚ _ _ _ _
@[to_additive] lemma div_to_germ (f g : Î± â†’â‚˜[Î¼] Î³) : (f / g).to_germ = f.to_germ / g.to_germ :=
compâ‚‚_to_germ _ _ _ _
end div
section zpow
instance has_int_pow : has_pow (Î± â†’â‚˜[Î¼] Î³) â„¤ :=
âŸ¨Î» f n, comp _ (continuous_zpow n) fâŸ©
@[simp] lemma mk_zpow (f : Î± â†’ Î³) (hf) (n : â„¤) :
  (mk f hf : Î± â†’â‚˜[Î¼] Î³) ^ n = mk (f ^ n) ((continuous_zpow n).comp_ae_strongly_measurable hf) :=
rfl
lemma coe_fn_zpow (f : Î± â†’â‚˜[Î¼] Î³) (n : â„¤) : â‡‘(f ^ n) =áµ[Î¼] f ^ n :=
coe_fn_comp _ _ _
@[simp] lemma zpow_to_germ (f : Î± â†’â‚˜[Î¼] Î³) (n : â„¤) :
  (f ^ n).to_germ = f.to_germ ^ n :=
comp_to_germ _ _ _
end zpow
end group
instance [add_group Î³] [topological_add_group Î³] :
  add_group (Î± â†’â‚˜[Î¼] Î³) :=
to_germ_injective.add_group to_germ zero_to_germ add_to_germ neg_to_germ sub_to_germ
  (Î» _ _, smul_to_germ _ _) (Î» _ _, smul_to_germ _ _)
instance [add_comm_group Î³] [topological_add_group Î³] :
  add_comm_group (Î± â†’â‚˜[Î¼] Î³) :=
to_germ_injective.add_comm_group to_germ zero_to_germ add_to_germ neg_to_germ sub_to_germ
  (Î» _ _, smul_to_germ _ _) (Î» _ _, smul_to_germ _ _)
@[to_additive]
instance [group Î³] [topological_group Î³] : group (Î± â†’â‚˜[Î¼] Î³) :=
to_germ_injective.group _ one_to_germ mul_to_germ inv_to_germ div_to_germ pow_to_germ zpow_to_germ
@[to_additive]
instance [comm_group Î³] [topological_group Î³] : comm_group (Î± â†’â‚˜[Î¼] Î³) :=
to_germ_injective.comm_group _
  one_to_germ mul_to_germ inv_to_germ div_to_germ pow_to_germ zpow_to_germ
section module
variables {ğ•œ : Type*}
instance [monoid ğ•œ] [mul_action ğ•œ Î³] [has_continuous_const_smul ğ•œ Î³] :
  mul_action ğ•œ (Î± â†’â‚˜[Î¼] Î³) :=
to_germ_injective.mul_action to_germ smul_to_germ
instance [monoid ğ•œ] [add_monoid Î³] [has_continuous_add Î³]
  [distrib_mul_action ğ•œ Î³] [has_continuous_const_smul ğ•œ Î³] :
  distrib_mul_action ğ•œ (Î± â†’â‚˜[Î¼] Î³) :=
to_germ_injective.distrib_mul_action (to_germ_add_monoid_hom : (Î± â†’â‚˜[Î¼] Î³) â†’+ _)
  (Î» c : ğ•œ, smul_to_germ c)
instance [semiring ğ•œ] [add_comm_monoid Î³] [has_continuous_add Î³] [module ğ•œ Î³]
  [has_continuous_const_smul ğ•œ Î³] :
  module ğ•œ (Î± â†’â‚˜[Î¼] Î³) :=
to_germ_injective.module ğ•œ (to_germ_add_monoid_hom : (Î± â†’â‚˜[Î¼] Î³) â†’+ _) smul_to_germ
end module
open ennreal
def lintegral (f : Î± â†’â‚˜[Î¼] â„â‰¥0âˆ) : â„â‰¥0âˆ :=
quotient.lift_on' f (Î» f, âˆ«â» a, (f : Î± â†’ â„â‰¥0âˆ) a âˆ‚Î¼) (assume f g, lintegral_congr_ae)
@[simp] lemma lintegral_mk (f : Î± â†’ â„â‰¥0âˆ) (hf) :
  (mk f hf : Î± â†’â‚˜[Î¼] â„â‰¥0âˆ).lintegral = âˆ«â» a, f a âˆ‚Î¼ := rfl
lemma lintegral_coe_fn (f : Î± â†’â‚˜[Î¼] â„â‰¥0âˆ) : âˆ«â» a, f a âˆ‚Î¼ = f.lintegral :=
by rw [â† lintegral_mk, mk_coe_fn]
@[simp] lemma lintegral_zero : lintegral (0 : Î± â†’â‚˜[Î¼] â„â‰¥0âˆ) = 0 := lintegral_zero
@[simp] lemma lintegral_eq_zero_iff {f : Î± â†’â‚˜[Î¼] â„â‰¥0âˆ} : lintegral f = 0 â†” f = 0 :=
induction_on f $ Î» f hf, (lintegral_eq_zero_iff' hf.ae_measurable).trans mk_eq_mk.symm
lemma lintegral_add (f g : Î± â†’â‚˜[Î¼] â„â‰¥0âˆ) : lintegral (f + g) = lintegral f + lintegral g :=
induction_onâ‚‚ f g $ Î» f hf g hg, by simp [lintegral_add_left' hf.ae_measurable]
lemma lintegral_mono {f g : Î± â†’â‚˜[Î¼] â„â‰¥0âˆ} : f â‰¤ g â†’ lintegral f â‰¤ lintegral g :=
induction_onâ‚‚ f g $ Î» f hf g hg hfg, lintegral_mono_ae hfg
section abs
lemma coe_fn_abs {Î²} [topological_space Î²] [lattice Î²] [topological_lattice Î²]
  [add_group Î²] [topological_add_group Î²]
  (f : Î± â†’â‚˜[Î¼] Î²) :
  â‡‘|f| =áµ[Î¼] Î» x, |f x| :=
begin
  simp_rw abs_eq_sup_neg,
  filter_upwards [ae_eq_fun.coe_fn_sup f (-f), ae_eq_fun.coe_fn_neg f] with x hx_sup hx_neg,
  rw [hx_sup, hx_neg, pi.neg_apply],
end
end abs
section pos_part
variables [linear_order Î³] [order_closed_topology Î³] [has_zero Î³]
def pos_part (f : Î± â†’â‚˜[Î¼] Î³) : Î± â†’â‚˜[Î¼] Î³ :=
comp (Î» x, max x 0) (continuous_id.max continuous_const) f
@[simp] lemma pos_part_mk (f : Î± â†’ Î³) (hf) :
  pos_part (mk f hf : Î± â†’â‚˜[Î¼] Î³) =
    mk (Î» x, max (f x) 0) ((continuous_id.max continuous_const).comp_ae_strongly_measurable hf) :=
rfl
lemma coe_fn_pos_part (f : Î± â†’â‚˜[Î¼] Î³) : â‡‘(pos_part f) =áµ[Î¼] (Î» a, max (f a) 0) :=
coe_fn_comp _ _ _
end pos_part
end ae_eq_fun
end measure_theory
namespace continuous_map
open measure_theory
variables [topological_space Î±] [borel_space Î±] (Î¼)
variables [topological_space Î²] [second_countable_topology_either Î± Î²] [pseudo_metrizable_space Î²]
def to_ae_eq_fun (f : C(Î±, Î²)) : Î± â†’â‚˜[Î¼] Î² :=
ae_eq_fun.mk f f.continuous.ae_strongly_measurable
lemma coe_fn_to_ae_eq_fun (f : C(Î±, Î²)) : f.to_ae_eq_fun Î¼ =áµ[Î¼] f :=
ae_eq_fun.coe_fn_mk f _
variables [group Î²] [topological_group Î²]
@[to_additive "The `add_hom` from the group of continuous maps from `Î±` to `Î²` to the group of
equivalence classes of `Î¼`-almost-everywhere measurable functions."]
def to_ae_eq_fun_mul_hom : C(Î±, Î²) â†’* Î± â†’â‚˜[Î¼] Î² :=
{ to_fun := continuous_map.to_ae_eq_fun Î¼,
  map_one' := rfl,
  map_mul' := Î» f g, ae_eq_fun.mk_mul_mk _ _
    f.continuous.ae_strongly_measurable g.continuous.ae_strongly_measurable }
variables {ğ•œ : Type*} [semiring ğ•œ]
variables [topological_space Î³] [pseudo_metrizable_space Î³] [add_comm_group Î³]
  [module ğ•œ Î³] [topological_add_group Î³] [has_continuous_const_smul ğ•œ Î³]
  [second_countable_topology_either Î± Î³]
def to_ae_eq_fun_linear_map : C(Î±, Î³) â†’â‚—[ğ•œ] Î± â†’â‚˜[Î¼] Î³ :=
{ map_smul' := Î» c f, ae_eq_fun.smul_mk c f f.continuous.ae_strongly_measurable,
  .. to_ae_eq_fun_add_hom Î¼ }
end continuous_map
