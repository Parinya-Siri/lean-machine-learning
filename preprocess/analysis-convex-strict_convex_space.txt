import analysis.convex.strict
import analysis.convex.topology
import analysis.normed_space.ordered
import analysis.normed_space.pointwise
open set metric
open_locale convex pointwise
class strict_convex_space (ğ•œ E : Type*) [normed_linear_ordered_field ğ•œ] [normed_group E]
  [normed_space ğ•œ E] : Prop :=
(strict_convex_closed_ball : âˆ€ r : â„, 0 < r â†’ strict_convex ğ•œ (closed_ball (0 : E) r))
variables (ğ•œ : Type*) {E : Type*} [normed_linear_ordered_field ğ•œ]
  [normed_group E] [normed_space ğ•œ E]
lemma strict_convex_closed_ball [strict_convex_space ğ•œ E] (x : E) (r : â„) :
  strict_convex ğ•œ (closed_ball x r) :=
begin
  cases le_or_lt r 0 with hr hr,
  { exact (subsingleton_closed_ball x hr).strict_convex },
  rw â† vadd_closed_ball_zero,
  exact (strict_convex_space.strict_convex_closed_ball r hr).vadd _,
end
variables [normed_space â„ E]
lemma strict_convex_space.of_strict_convex_closed_unit_ball
  [linear_map.compatible_smul E E ğ•œ â„] (h : strict_convex ğ•œ (closed_ball (0 : E) 1)) :
  strict_convex_space ğ•œ E :=
âŸ¨Î» r hr, by simpa only [smul_closed_unit_ball_of_nonneg hr.le] using h.smul râŸ©
lemma strict_convex_space.of_norm_add (h : âˆ€ x y : E, âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ â†’ same_ray â„ x y) :
  strict_convex_space â„ E :=
begin
  refine strict_convex_space.of_strict_convex_closed_unit_ball â„ (Î» x hx y hy hne a b ha hb hab, _),
  have hx' := hx, have hy' := hy,
  rw [â† closure_closed_ball, closure_eq_interior_union_frontier,
    frontier_closed_ball (0 : E) one_ne_zero] at hx hy,
  cases hx, { exact (convex_closed_ball _ _).combo_interior_self_mem_interior hx hy' ha hb.le hab },
  cases hy, { exact (convex_closed_ball _ _).combo_self_interior_mem_interior hx' hy ha.le hb hab },
  rw [interior_closed_ball (0 : E) one_ne_zero, mem_ball_zero_iff],
  have hxâ‚ : âˆ¥xâˆ¥ = 1, from mem_sphere_zero_iff_norm.1 hx,
  have hyâ‚ : âˆ¥yâˆ¥ = 1, from mem_sphere_zero_iff_norm.1 hy,
  have ha' : âˆ¥aâˆ¥ = a, from real.norm_of_nonneg ha.le,
  have hb' : âˆ¥bâˆ¥ = b, from real.norm_of_nonneg hb.le,
  calc âˆ¥a â€¢ x + b â€¢ yâˆ¥ < âˆ¥a â€¢ xâˆ¥ + âˆ¥b â€¢ yâˆ¥ : (norm_add_le _ _).lt_of_ne (Î» H, hne _)
  ... = 1 : by simpa only [norm_smul, hxâ‚, hyâ‚, mul_one, ha', hb'],
  simpa only [norm_smul, hxâ‚, hyâ‚, ha', hb', mul_one, smul_comm a, smul_right_inj ha.ne',
    smul_right_inj hb.ne'] using (h _ _ H).norm_smul_eq.symm
end
lemma strict_convex_space.of_norm_add_lt_aux {a b c d : â„} (ha : 0 < a) (hab : a + b = 1)
  (hc : 0 < c) (hd : 0 < d) (hcd : c + d = 1) (hca : c â‰¤ a) {x y : E} (hy : âˆ¥yâˆ¥ â‰¤ 1)
  (hxy : âˆ¥a â€¢ x + b â€¢ yâˆ¥ < 1) :
  âˆ¥c â€¢ x + d â€¢ yâˆ¥ < 1 :=
begin
  have hbd : b â‰¤ d,
  { refine le_of_add_le_add_left (hab.trans_le _),
    rw â†hcd,
    exact add_le_add_right hca _ },
  have hâ‚ : 0 < c / a := div_pos hc ha,
  have hâ‚‚ : 0 â‰¤ d - c / a * b,
  { rw [sub_nonneg, mul_comm_div, â†le_div_iff' hc],
    exact div_le_div hd.le hbd hc hca },
  calc âˆ¥c â€¢ x + d â€¢ yâˆ¥ = âˆ¥(c / a) â€¢ (a â€¢ x + b â€¢ y) + (d - c / a * b) â€¢ yâˆ¥
        : by rw [smul_add, â†mul_smul, â†mul_smul, div_mul_cancel _ ha.ne', sub_smul,
            add_add_sub_cancel]
    ... â‰¤ âˆ¥(c / a) â€¢ (a â€¢ x + b â€¢ y)âˆ¥ + âˆ¥(d - c / a * b) â€¢ yâˆ¥ : norm_add_le _ _
    ... = c / a * âˆ¥a â€¢ x + b â€¢ yâˆ¥ + (d - c / a * b) * âˆ¥yâˆ¥
        : by rw [norm_smul_of_nonneg hâ‚.le, norm_smul_of_nonneg hâ‚‚]
    ... < c / a * 1 + (d - c / a * b) * 1
        : add_lt_add_of_lt_of_le (mul_lt_mul_of_pos_left hxy hâ‚) (mul_le_mul_of_nonneg_left hy hâ‚‚)
    ... = 1 : begin
      nth_rewrite 0 â†hab,
      rw [mul_add, div_mul_cancel _ ha.ne', mul_one, add_add_sub_cancel, hcd],
    end,
end
lemma strict_convex_space.of_norm_add_lt {a b : â„} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1)
  (h : âˆ€ x y : E, âˆ¥xâˆ¥ â‰¤ 1 â†’ âˆ¥yâˆ¥ â‰¤ 1 â†’ x â‰  y â†’ âˆ¥a â€¢ x + b â€¢ yâˆ¥ < 1) :
  strict_convex_space â„ E :=
begin
  refine strict_convex_space.of_strict_convex_closed_unit_ball _ (Î» x hx y hy hxy c d hc hd hcd, _),
  rw [interior_closed_ball (0 : E) one_ne_zero, mem_ball_zero_iff],
  rw mem_closed_ball_zero_iff at hx hy,
  obtain hca | hac := le_total c a,
  { exact strict_convex_space.of_norm_add_lt_aux ha hab hc hd hcd hca hy (h _ _ hx hy hxy) },
  rw add_comm at âŠ¢ hab hcd,
  refine strict_convex_space.of_norm_add_lt_aux hb hab hd hc hcd _ hx _,
  { refine le_of_add_le_add_right (hcd.trans_le _),
    rw â†hab,
    exact add_le_add_left hac _ },
  { rw add_comm,
    exact h _ _ hx hy hxy }
end
variables [strict_convex_space â„ E] {x y z : E} {a b r : â„}
lemma combo_mem_ball_of_ne (hx : x âˆˆ closed_ball z r) (hy : y âˆˆ closed_ball z r) (hne : x â‰  y)
  (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : a â€¢ x + b â€¢ y âˆˆ ball z r :=
begin
  rcases eq_or_ne r 0 with rfl|hr,
  { rw [closed_ball_zero, mem_singleton_iff] at hx hy,
    exact (hne (hx.trans hy.symm)).elim },
  { simp only [â† interior_closed_ball _ hr] at hx hy âŠ¢,
    exact strict_convex_closed_ball â„ z r hx hy hne ha hb hab }
end
lemma open_segment_subset_ball_of_ne (hx : x âˆˆ closed_ball z r) (hy : y âˆˆ closed_ball z r)
  (hne : x â‰  y) : open_segment â„ x y âŠ† ball z r :=
(open_segment_subset_iff _).2 $ Î» a b, combo_mem_ball_of_ne hx hy hne
lemma norm_combo_lt_of_ne (hx : âˆ¥xâˆ¥ â‰¤ r) (hy : âˆ¥yâˆ¥ â‰¤ r) (hne : x â‰  y) (ha : 0 < a) (hb : 0 < b)
  (hab : a + b = 1) : âˆ¥a â€¢ x + b â€¢ yâˆ¥ < r :=
begin
  simp only [â† mem_ball_zero_iff, â† mem_closed_ball_zero_iff] at hx hy âŠ¢,
  exact combo_mem_ball_of_ne hx hy hne ha hb hab
end
lemma norm_add_lt_of_not_same_ray (h : Â¬same_ray â„ x y) : âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥ :=
begin
  simp only [same_ray_iff_inv_norm_smul_eq, not_or_distrib, â† ne.def] at h,
  rcases h with âŸ¨hx, hy, hneâŸ©,
  rw â† norm_pos_iff at hx hy,
  have hxy : 0 < âˆ¥xâˆ¥ + âˆ¥yâˆ¥ := add_pos hx hy,
  have := combo_mem_ball_of_ne (inv_norm_smul_mem_closed_unit_ball x)
    (inv_norm_smul_mem_closed_unit_ball y) hne (div_pos hx hxy) (div_pos hy hxy)
    (by rw [â† add_div, div_self hxy.ne']),
  rwa [mem_ball_zero_iff, div_eq_inv_mul, div_eq_inv_mul, mul_smul, mul_smul,
    smul_inv_smulâ‚€ hx.ne', smul_inv_smulâ‚€ hy.ne', â† smul_add, norm_smul,
    real.norm_of_nonneg (inv_pos.2 hxy).le, â† div_eq_inv_mul, div_lt_one hxy] at this
end
lemma lt_norm_sub_of_not_same_ray (h : Â¬same_ray â„ x y) : âˆ¥xâˆ¥ - âˆ¥yâˆ¥ < âˆ¥x - yâˆ¥ :=
begin
  nth_rewrite 0 â†sub_add_cancel x y at âŠ¢ h,
  exact sub_lt_iff_lt_add.2 (norm_add_lt_of_not_same_ray $ Î» H', h $ H'.add_left same_ray.rfl),
end
lemma abs_lt_norm_sub_of_not_same_ray (h : Â¬same_ray â„ x y) : |âˆ¥xâˆ¥ - âˆ¥yâˆ¥| < âˆ¥x - yâˆ¥ :=
begin
  refine abs_sub_lt_iff.2 âŸ¨lt_norm_sub_of_not_same_ray h, _âŸ©,
  rw norm_sub_rev,
  exact lt_norm_sub_of_not_same_ray (mt same_ray.symm h),
end
lemma same_ray_iff_norm_add : same_ray â„ x y â†” âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ + âˆ¥yâˆ¥ :=
âŸ¨same_ray.norm_add, Î» h, not_not.1 $ Î» h', (norm_add_lt_of_not_same_ray h').ne hâŸ©
lemma not_same_ray_iff_norm_add_lt : Â¬ same_ray â„ x y â†” âˆ¥x + yâˆ¥ < âˆ¥xâˆ¥ + âˆ¥yâˆ¥ :=
same_ray_iff_norm_add.not.trans (norm_add_le _ _).lt_iff_ne.symm
lemma same_ray_iff_norm_sub : same_ray â„ x y â†” âˆ¥x - yâˆ¥ = |âˆ¥xâˆ¥ - âˆ¥yâˆ¥| :=
âŸ¨same_ray.norm_sub, Î» h, not_not.1 $ Î» h', (abs_lt_norm_sub_of_not_same_ray h').ne' hâŸ©
lemma not_same_ray_iff_abs_lt_norm_sub : Â¬ same_ray â„ x y â†” |âˆ¥xâˆ¥ - âˆ¥yâˆ¥| < âˆ¥x - yâˆ¥ :=
same_ray_iff_norm_sub.not.trans $ ne_comm.trans (abs_norm_sub_norm_le _ _).lt_iff_ne.symm
lemma dist_add_dist_eq_iff : dist x y + dist y z = dist x z â†” y âˆˆ [x -[â„] z] :=
by simp only [mem_segment_iff_same_ray, same_ray_iff_norm_add, dist_eq_norm',
  sub_add_sub_cancel', eq_comm]
lemma norm_midpoint_lt_iff (h : âˆ¥xâˆ¥ = âˆ¥yâˆ¥) : âˆ¥(1/2 : â„) â€¢ (x + y)âˆ¥ < âˆ¥xâˆ¥ â†” x â‰  y :=
by rw [norm_smul, real.norm_of_nonneg (one_div_nonneg.2 zero_le_two), â†inv_eq_one_div,
    â†div_eq_inv_mul, div_lt_iff (@zero_lt_two â„ _ _), mul_two, â†not_same_ray_iff_of_norm_eq h,
    not_same_ray_iff_norm_add_lt, h]
variables {F : Type*} [normed_group F] [normed_space â„ F]
variables {PF : Type*} {PE : Type*} [metric_space PF] [metric_space PE]
variables [normed_add_torsor F PF] [normed_add_torsor E PE]
include E
lemma eq_line_map_of_dist_eq_mul_of_dist_eq_mul {x y z : PE} (hxy : dist x y = r * dist x z)
  (hyz : dist y z = (1 - r) * dist x z) :
  y = affine_map.line_map x z r :=
begin
  have : y -áµ¥ x âˆˆ [(0 : E) -[â„] z -áµ¥ x],
  { rw [â† dist_add_dist_eq_iff, dist_zero_left, dist_vsub_cancel_right, â† dist_eq_norm_vsub',
      â† dist_eq_norm_vsub', hxy, hyz, â† add_mul, add_sub_cancel'_right, one_mul] },
  rcases eq_or_ne x z with rfl|hne,
  { obtain rfl : y = x, by simpa,
    simp },
  { rw [â† dist_ne_zero] at hne,
    rcases this with âŸ¨a, b, ha, hb, hab, HâŸ©,
    rw [smul_zero, zero_add] at H,
    have H' := congr_arg norm H,
    rw [norm_smul, real.norm_of_nonneg hb, â† dist_eq_norm_vsub', â† dist_eq_norm_vsub', hxy,
      mul_left_inj' hne] at H',
    rw [affine_map.line_map_apply, â† H', H, vsub_vadd] },
end
lemma eq_midpoint_of_dist_eq_half {x y z : PE} (hx : dist x y = dist x z / 2)
  (hy : dist y z = dist x z / 2) : y = midpoint â„ x z :=
begin
  apply eq_line_map_of_dist_eq_mul_of_dist_eq_mul,
  { rwa [inv_of_eq_inv, â† div_eq_inv_mul] },
  { rwa [inv_of_eq_inv, â† one_div, sub_half, one_div, â† div_eq_inv_mul] }
end
namespace isometry
include F
noncomputable def affine_isometry_of_strict_convex_space {f : PF â†’ PE} (hi : isometry f) :
  PF â†’áµƒâ±[â„] PE :=
{ norm_map := Î» x, by simp [affine_map.of_map_midpoint, â†dist_eq_norm_vsub E, hi.dist_eq],
  ..affine_map.of_map_midpoint f (Î» x y, begin
    apply eq_midpoint_of_dist_eq_half,
    { rw [hi.dist_eq, hi.dist_eq, dist_left_midpoint, real.norm_of_nonneg zero_le_two,
        div_eq_inv_mul] },
    { rw [hi.dist_eq, hi.dist_eq, dist_midpoint_right, real.norm_of_nonneg zero_le_two,
        div_eq_inv_mul] },
  end) hi.continuous }
@[simp] lemma coe_affine_isometry_of_strict_convex_space {f : PF â†’ PE} (hi : isometry f) :
  â‡‘(hi.affine_isometry_of_strict_convex_space) = f :=
rfl
@[simp] lemma affine_isometry_of_strict_convex_space_apply {f : PF â†’ PE} (hi : isometry f)
  (p : PF) :
  hi.affine_isometry_of_strict_convex_space p = f p :=
rfl
end isometry
