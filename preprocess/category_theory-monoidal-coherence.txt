import category_theory.monoidal.free.coherence
import category_theory.bicategory.coherence_tactic
noncomputable theory
universes v u
open category_theory
open category_theory.free_monoidal_category
variables {C : Type u} [category.{v} C] [monoidal_category C]
namespace category_theory.monoidal_category
class lift_obj (X : C) :=
(lift : free_monoidal_category C)
instance lift_obj_unit : lift_obj (ğŸ™_ C) := { lift := unit, }
instance lift_obj_tensor (X Y : C) [lift_obj X] [lift_obj Y] : lift_obj (X âŠ— Y) :=
{ lift := lift_obj.lift X âŠ— lift_obj.lift Y, }
@[priority 100]
instance lift_obj_of (X : C) : lift_obj X := { lift := of X, }
class lift_hom {X Y : C} [lift_obj X] [lift_obj Y] (f : X âŸ¶ Y) :=
(lift : lift_obj.lift X âŸ¶ lift_obj.lift Y)
instance lift_hom_id (X : C) [lift_obj X] : lift_hom (ğŸ™ X) :=
{ lift := ğŸ™ _, }
instance lift_hom_left_unitor_hom (X : C) [lift_obj X] : lift_hom (Î»_ X).hom :=
{ lift := (Î»_ (lift_obj.lift X)).hom, }
instance lift_hom_left_unitor_inv (X : C) [lift_obj X] : lift_hom (Î»_ X).inv :=
{ lift := (Î»_ (lift_obj.lift X)).inv, }
instance lift_hom_right_unitor_hom (X : C) [lift_obj X] : lift_hom (Ï_ X).hom :=
{ lift := (Ï_ (lift_obj.lift X)).hom, }
instance lift_hom_right_unitor_inv (X : C) [lift_obj X] : lift_hom (Ï_ X).inv :=
{ lift := (Ï_ (lift_obj.lift X)).inv, }
instance lift_hom_associator_hom (X Y Z : C) [lift_obj X] [lift_obj Y] [lift_obj Z] :
  lift_hom (Î±_ X Y Z).hom :=
{ lift := (Î±_ (lift_obj.lift X) (lift_obj.lift Y) (lift_obj.lift Z)).hom, }
instance lift_hom_associator_inv (X Y Z : C) [lift_obj X] [lift_obj Y] [lift_obj Z] :
  lift_hom (Î±_ X Y Z).inv :=
{ lift := (Î±_ (lift_obj.lift X) (lift_obj.lift Y) (lift_obj.lift Z)).inv, }
instance lift_hom_comp {X Y Z : C} [lift_obj X] [lift_obj Y] [lift_obj Z] (f : X âŸ¶ Y) (g : Y âŸ¶ Z)
  [lift_hom f] [lift_hom g] : lift_hom (f â‰« g) :=
{ lift := lift_hom.lift f â‰« lift_hom.lift g }
instance lift_hom_tensor {W X Y Z : C} [lift_obj W] [lift_obj X] [lift_obj Y] [lift_obj Z]
  (f : W âŸ¶ X) (g : Y âŸ¶ Z) [lift_hom f] [lift_hom g] : lift_hom (f âŠ— g) :=
{ lift := lift_hom.lift f âŠ— lift_hom.lift g }
def monoidal_iso (X Y : C) [lift_obj X] [lift_obj Y] [monoidal_coherence X Y] : X â‰… Y :=
as_iso (monoidal_coherence.hom X Y)
example (X : C) : X â‰… (X âŠ— (ğŸ™_ C âŠ— ğŸ™_ C)) := monoidal_iso _ _
example (X1 X2 X3 X4 X5 X6 X7 X8 X9 : C) :
  (ğŸ™_ C âŠ— (X1 âŠ— X2 âŠ— ((X3 âŠ— X4) âŠ— X5)) âŠ— X6 âŠ— (X7 âŠ— X8 âŠ— X9)) â‰…
  (X1 âŠ— (X2 âŠ— X3) âŠ— X4 âŠ— (X5 âŠ— (ğŸ™_ C âŠ— X6) âŠ— X7) âŠ— X8 âŠ— X9) :=
monoidal_iso _ _
def monoidal_comp {W X Y Z : C} [lift_obj X] [lift_obj Y]
  [monoidal_coherence X Y] (f : W âŸ¶ X) (g : Y âŸ¶ Z) : W âŸ¶ Z :=
f â‰« monoidal_coherence.hom X Y â‰« g
def monoidal_iso_comp {W X Y Z : C} [lift_obj X] [lift_obj Y]
  [monoidal_coherence X Y] (f : W â‰… X) (g : Y â‰… Z) : W â‰… Z :=
f â‰ªâ‰« as_iso (monoidal_coherence.hom X Y) â‰ªâ‰« g
meta def mk_project_map_expr (e : expr) : tactic expr :=
  to_expr ``(category_theory.free_monoidal_category.project_map _root_.id _ _
    (category_theory.monoidal_category.lift_hom.lift %%e))
meta def monoidal_coherence : tactic unit :=
do
  o â† get_options, set_options $ o.set_nat `class.instance_max_depth 128,
  try `[dsimp],
  `(%%lhs = %%rhs) â† target,
  project_map_lhs â† mk_project_map_expr lhs,
  project_map_rhs â† mk_project_map_expr rhs,
  to_expr  ``(%%project_map_lhs = %%project_map_rhs) >>= tactic.change,
  congr
meta def pure_coherence : tactic unit := monoidal_coherence <|> bicategorical_coherence
example (Xâ‚ Xâ‚‚ : C) :
  ((Î»_ (ğŸ™_ C)).inv âŠ— ğŸ™ (Xâ‚ âŠ— Xâ‚‚)) â‰« (Î±_ (ğŸ™_ C) (ğŸ™_ C) (Xâ‚ âŠ— Xâ‚‚)).hom â‰«
    (ğŸ™ (ğŸ™_ C) âŠ— (Î±_ (ğŸ™_ C) Xâ‚ Xâ‚‚).inv) =
  ğŸ™ (ğŸ™_ C) âŠ— ((Î»_ Xâ‚).inv âŠ— ğŸ™ Xâ‚‚) :=
by pure_coherence
namespace coherence
meta def liftable_prefixes : tactic unit :=
do
  o â† get_options, set_options $ o.set_nat `class.instance_max_depth 128,
  try `[simp only [monoidal_comp, category_theory.category.assoc]] >>
    `[apply (cancel_epi (ğŸ™ _)).1; try { apply_instance }] >>
    try `[simp only [tactic.coherence.assoc_lift_hom, tactic.bicategory.coherence.assoc_lift_homâ‚‚]]
example {W X Y Z : C} (f : Y âŸ¶ Z) (g) (w : false) : (Î»_ _).hom â‰« f = g :=
begin
  liftable_prefixes,
  guard_target (ğŸ™ _ â‰« (Î»_ _).hom) â‰« f = (ğŸ™ _) â‰« g,
  cases w,
end
lemma insert_id_lhs {C : Type*} [category C] {X Y : C} (f g : X âŸ¶ Y) (w : f â‰« ğŸ™ _ = g) : f = g :=
by simpa using w
lemma insert_id_rhs {C : Type*} [category C] {X Y : C} (f g : X âŸ¶ Y) (w : f = g â‰« ğŸ™ _) : f = g :=
by simpa using w
end coherence
open coherence
meta def coherence_loop : tactic unit :=
do
meta def coherence : tactic unit :=
do
  try `[simp only [bicategorical_comp]],
  try `[simp only [monoidal_comp]],
