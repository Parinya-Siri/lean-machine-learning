import category_theory.isomorphism
import category_theory.functor.category
import category_theory.eq_to_hom
namespace category_theory
structure comma (L : A â¥¤ T) (R : B â¥¤ T) : Type (max uâ‚ uâ‚‚ vâ‚ƒ) :=
(left : A . obviously)
(right : B . obviously)
(hom : L.obj left âŸ¶ R.obj right)
@[ext] structure comma_morphism (X Y : comma L R) :=
(left : X.left âŸ¶ Y.left . obviously)
(right : X.right âŸ¶ Y.right . obviously)
(w' : L.map left â‰« Y.hom = X.hom â‰« R.map right . obviously)
@[simps]
def fst : comma L R â¥¤ A :=
{ obj := Î» X, X.left,
  map := Î» _ _ f, f.left }
@[simps]
def snd : comma L R â¥¤ B :=
{ obj := Î» X, X.right,
  map := Î» _ _ f, f.right }
@[simps]
def nat_trans : fst L R â‹™ L âŸ¶ snd L R â‹™ R :=
{ app := Î» X, X.hom }
@[simp] lemma eq_to_hom_left (X Y : comma L R) (H : X = Y) :
  comma_morphism.left (eq_to_hom H) = eq_to_hom (by { cases H, refl }) := by { cases H, refl }
@[simp] lemma eq_to_hom_right (X Y : comma L R) (H : X = Y) :
  comma_morphism.right (eq_to_hom H) = eq_to_hom (by { cases H, refl }) := by { cases H, refl }
section
variables {Lâ‚ Lâ‚‚ Lâ‚ƒ : A â¥¤ T} {Râ‚ Râ‚‚ Râ‚ƒ : B â¥¤ T}
@[simps]
def iso_mk {X Y : comma Lâ‚ Râ‚} (l : X.left â‰… Y.left) (r : X.right â‰… Y.right)
  (h : Lâ‚.map l.hom â‰« Y.hom = X.hom â‰« Râ‚.map r.hom) : X â‰… Y :=
{ hom := { left := l.hom, right := r.hom },
  inv :=
  { left := l.inv,
    right := r.inv,
    w' := begin
      rw [â†Lâ‚.map_iso_inv l, iso.inv_comp_eq, Lâ‚.map_iso_hom, reassoc_of h, â† Râ‚.map_comp],
      simp
    end, } }
@[simps]
def map_left (l : Lâ‚ âŸ¶ Lâ‚‚) : comma Lâ‚‚ R â¥¤ comma Lâ‚ R :=
{ obj := Î» X,
  { left  := X.left,
    right := X.right,
    hom   := l.app X.left â‰« X.hom },
  map := Î» X Y f,
  { left  := f.left,
    right := f.right } }
@[simps]
def map_left_id : map_left R (ğŸ™ L) â‰… ğŸ­ _ :=
{ hom :=
  { app := Î» X, { left := ğŸ™ _, right := ğŸ™ _ } },
  inv :=
  { app := Î» X, { left := ğŸ™ _, right := ğŸ™ _ } } }
@[simps]
def map_left_comp (l : Lâ‚ âŸ¶ Lâ‚‚) (l' : Lâ‚‚ âŸ¶ Lâ‚ƒ) :
  (map_left R (l â‰« l')) â‰… (map_left R l') â‹™ (map_left R l) :=
{ hom :=
  { app := Î» X, { left := ğŸ™ _, right := ğŸ™ _ } },
  inv :=
  { app := Î» X, { left := ğŸ™ _, right := ğŸ™ _ } } }
@[simps]
def map_right (r : Râ‚ âŸ¶ Râ‚‚) : comma L Râ‚ â¥¤ comma L Râ‚‚ :=
{ obj := Î» X,
  { left  := X.left,
    right := X.right,
    hom   := X.hom â‰« r.app X.right },
  map := Î» X Y f,
  { left  := f.left,
    right := f.right } }
@[simps]
def map_right_id : map_right L (ğŸ™ R) â‰… ğŸ­ _ :=
{ hom :=
  { app := Î» X, { left := ğŸ™ _, right := ğŸ™ _ } },
  inv :=
  { app := Î» X, { left := ğŸ™ _, right := ğŸ™ _ } } }
@[simps]
def map_right_comp (r : Râ‚ âŸ¶ Râ‚‚) (r' : Râ‚‚ âŸ¶ Râ‚ƒ) :
  (map_right L (r â‰« r')) â‰… (map_right L r) â‹™ (map_right L r') :=
{ hom :=
  { app := Î» X, { left := ğŸ™ _, right := ğŸ™ _ } },
  inv :=
  { app := Î» X, { left := ğŸ™ _, right := ğŸ™ _ } } }
end
section
variables {C : Type uâ‚„} [category.{vâ‚„} C] {D : Type uâ‚…} [category.{vâ‚…} D]
@[simps] def pre_left (F: C â¥¤ A) (L : A â¥¤ T) (R : B â¥¤ T) : comma (F â‹™ L) R â¥¤ comma L R :=
{ obj := Î» X, { left := F.obj X.left, right := X.right, hom := X.hom },
  map := Î» X Y f, { left := F.map f.left, right := f.right, w' := by simpa using f.w } }
@[simps] def pre_right (L : A â¥¤ T) (F: C â¥¤ B) (R : B â¥¤ T) : comma L (F â‹™ R) â¥¤ comma L R :=
{ obj := Î» X, { left := X.left, right := F.obj X.right, hom := X.hom },
  map := Î» X Y f, { left := f.left, right := F.map f.right, w' := by simp } }
@[simps] def post (L : A â¥¤ T) (R : B â¥¤ T) (F: T â¥¤ C) : comma L R â¥¤ comma (L â‹™ F) (R â‹™ F) :=
{ obj := Î» X, { left := X.left, right := X.right, hom := F.map X.hom },
  map := Î» X Y f, { left := f.left, right := f.right, w' :=
    by { simp only [functor.comp_map, â†F.map_comp, f.w] } } }
end
end comma
end category_theory
