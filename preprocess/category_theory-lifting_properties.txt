import category_theory.limits.shapes.terminal
import category_theory.arrow
open category_theory.limits
namespace category_theory
universes v u vâ‚
variables {C : Type u} [category.{v} C]
variables {D : Type vâ‚}
variables {X Y Z : C}
class has_lifting_property (i p : arrow C) : Prop :=
(sq_has_lift : âˆ€ (sq : i âŸ¶ p), arrow.has_lift sq)
lemma iso_has_right_lifting_property (i : arrow C) (p : X â‰… Y) :
  has_lifting_property i (arrow.mk p.hom) :=
lemma id_has_right_lifting_property (i : arrow C) : has_lifting_property i (arrow.mk (ğŸ™ X)) :=
iso_has_right_lifting_property i (iso.refl _)
lemma right_lifting_property_initial_iff (i p : arrow C) (h : is_initial i.left) :
  has_lifting_property i p â†” âˆ€ {e : i.right âŸ¶ p.right}, âˆƒ l : i.right âŸ¶ p.left, l â‰« p.hom = e :=
begin
  fsplit,
  { introsI hlift e,
    have comm : (is_initial.to h p.left) â‰« p.hom = i.hom â‰« e :=
      is_initial.hom_ext h _ _,
    use arrow.lift (arrow.hom_mk comm),
    simp },
  { refine Î» hlift, âŸ¨Î» sq, _âŸ©,
    obtain âŸ¨l, hlâŸ© : âˆƒ (l : i.right âŸ¶ p.left), l â‰« p.hom = sq.right := hlift,
    exact arrow.has_lift.mk âŸ¨l, is_initial.hom_ext h _ _âŸ©, }
end
lemma has_right_lifting_property_comp {i : arrow C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z}
  (hf : has_lifting_property i (arrow.mk f))
  (hg : has_lifting_property i (arrow.mk g)) :
  has_lifting_property i (arrow.mk (f â‰« g)) :=
{ sq_has_lift := Î» sq1,
def right_lifting_subcat (R : Type u) := R
instance right_lifting_subcat.inhabited  (R : Type u) [inhabited R] :
  inhabited (right_lifting_subcat R) :=
{ default := (default : R) }
def right_lifting_subcat.X {R : Type u} (x : right_lifting_subcat R) : R := x
lemma id_has_right_lifting_property' {F : D â†’ arrow C} (X : C) :
  âˆ€ i : D, has_lifting_property (F i) (arrow.mk (ğŸ™ X)) :=
Î» i, id_has_right_lifting_property (F i)
lemma has_right_lifting_property_comp'
  {F : D â†’ arrow C} {f : X âŸ¶ Y} (hf : âˆ€ i : D, has_lifting_property (F i) (arrow.mk f))
  {g : Y âŸ¶ Z} (hg : âˆ€ i : D, has_lifting_property (F i) (arrow.mk g)) :
  âˆ€ i : D,  has_lifting_property (F i) (arrow.mk (f â‰« g)) :=
Î» i, has_right_lifting_property_comp (hf i) (hg i)
def right_lifting_subcategory (F : D â†’ arrow C) : category (right_lifting_subcat C) :=
{ hom := Î» X Y, { p : X âŸ¶ Y // âˆ€ {i : D}, has_lifting_property (F i) (arrow.mk p) },
  id := Î» X, âŸ¨ğŸ™ X, id_has_right_lifting_property' XâŸ©,
  comp := Î» X Y Z f g, âŸ¨f.val â‰« g.val, has_right_lifting_property_comp' f.property g.propertyâŸ© }
end category_theory
