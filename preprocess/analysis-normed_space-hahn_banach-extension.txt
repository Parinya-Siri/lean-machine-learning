import analysis.convex.cone
import analysis.normed_space.is_R_or_C
import analysis.normed_space.extend
universes u v
namespace real
variables {E : Type*} [semi_normed_group E] [normed_space â„ E]
theorem exists_extension_norm_eq (p : subspace â„ E) (f : p â†’L[â„] â„) :
  âˆƒ g : E â†’L[â„] â„, (âˆ€ x : p, g x = f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥ :=
begin
  rcases exists_extension_of_le_sublinear âŸ¨p, fâŸ© (Î» x, âˆ¥fâˆ¥ * âˆ¥xâˆ¥)
    (Î» c hc x, by simp only [norm_smul c x, real.norm_eq_abs, abs_of_pos hc, mul_left_comm])
    (Î» x y, _) (Î» x, le_trans (le_abs_self _) (f.le_op_norm _))
    with âŸ¨g, g_eq, g_leâŸ©,
  set g' := g.mk_continuous (âˆ¥fâˆ¥)
    (Î» x, abs_le.2 âŸ¨neg_le.1 $ g.map_neg x â–¸ norm_neg x â–¸ g_le (-x), g_le xâŸ©),
  { refine âŸ¨g', g_eq, _âŸ©,
    { apply le_antisymm (g.mk_continuous_norm_le (norm_nonneg f) _),
      refine f.op_norm_le_bound (norm_nonneg _) (Î» x, _),
      dsimp at g_eq,
      rw â† g_eq,
      apply g'.le_op_norm } },
  { simp only [â† mul_add],
    exact mul_le_mul_of_nonneg_left (norm_add_le x y) (norm_nonneg f) }
end
end real
section is_R_or_C
open is_R_or_C
variables {ğ•œ : Type*} [is_R_or_C ğ•œ] {F : Type*} [semi_normed_group F] [normed_space ğ•œ F]
theorem exists_extension_norm_eq (p : subspace ğ•œ F) (f : p â†’L[ğ•œ] ğ•œ) :
  âˆƒ g : F â†’L[ğ•œ] ğ•œ, (âˆ€ x : p, g x = f x) âˆ§ âˆ¥gâˆ¥ = âˆ¥fâˆ¥ :=
begin
  letI : module â„ F := restrict_scalars.module â„ ğ•œ F,
  letI : is_scalar_tower â„ ğ•œ F := restrict_scalars.is_scalar_tower _ _ _,
  letI : normed_space â„ F := normed_space.restrict_scalars _ ğ•œ _,
theorem exists_dual_vector (x : E) (h : x â‰  0) : âˆƒ g : E â†’L[ğ•œ] ğ•œ, âˆ¥gâˆ¥ = 1 âˆ§ g x = âˆ¥xâˆ¥ :=
begin
  let p : submodule ğ•œ E := ğ•œ âˆ™ x,
  let f := (âˆ¥xâˆ¥ : ğ•œ) â€¢ coord ğ•œ x h,
  obtain âŸ¨g, hgâŸ© := exists_extension_norm_eq p f,
  refine âŸ¨g, _, _âŸ©,
  { rw [hg.2, coord_norm'] },
  { calc g x = g (âŸ¨x, mem_span_singleton_self xâŸ© : ğ•œ âˆ™ x) : by rw coe_mk
    ... = ((âˆ¥xâˆ¥ : ğ•œ) â€¢ coord ğ•œ x h) (âŸ¨x, mem_span_singleton_self xâŸ© : ğ•œ âˆ™ x) : by rw â† hg.1
    ... = âˆ¥xâˆ¥ : by simp }
end
theorem exists_dual_vector' [nontrivial E] (x : E) :
  âˆƒ g : E â†’L[ğ•œ] ğ•œ, âˆ¥gâˆ¥ = 1 âˆ§ g x = âˆ¥xâˆ¥ :=
begin
  by_cases hx : x = 0,
  { obtain âŸ¨y, hyâŸ© := exists_ne (0 : E),
    obtain âŸ¨g, hgâŸ© : âˆƒ g : E â†’L[ğ•œ] ğ•œ, âˆ¥gâˆ¥ = 1 âˆ§ g y = âˆ¥yâˆ¥ := exists_dual_vector ğ•œ y hy,
    refine âŸ¨g, hg.left, _âŸ©,
    simp [hx] },
  { exact exists_dual_vector ğ•œ x hx }
end
theorem exists_dual_vector'' (x : E) :
  âˆƒ g : E â†’L[ğ•œ] ğ•œ, âˆ¥gâˆ¥ â‰¤ 1 âˆ§ g x = âˆ¥xâˆ¥ :=
begin
  by_cases hx : x = 0,
  { refine âŸ¨0, by simp, _âŸ©,
    symmetry,
    simp [hx], },
  { rcases exists_dual_vector ğ•œ x hx with âŸ¨g, g_norm, g_eqâŸ©,
    exact âŸ¨g, g_norm.le, g_eqâŸ© }
end
end dual_vector
