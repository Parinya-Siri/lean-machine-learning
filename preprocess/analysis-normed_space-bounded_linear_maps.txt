import analysis.normed_space.multilinear
import analysis.normed_space.units
import analysis.asymptotics.asymptotics
noncomputable theory
open_locale classical big_operators topological_space
open filter (tendsto) metric continuous_linear_map
variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
          {E : Type*} [normed_group E] [normed_space ğ•œ E]
          {F : Type*} [normed_group F] [normed_space ğ•œ F]
          {G : Type*} [normed_group G] [normed_space ğ•œ G]
structure is_bounded_linear_map (ğ•œ : Type*) [normed_field ğ•œ]
  {E : Type*} [normed_group E] [normed_space ğ•œ E]
  {F : Type*} [normed_group F] [normed_space ğ•œ F] (f : E â†’ F)
  extends is_linear_map ğ•œ f : Prop :=
(bound : âˆƒ M, 0 < M âˆ§ âˆ€ x : E, âˆ¥f xâˆ¥ â‰¤ M * âˆ¥xâˆ¥)
lemma is_linear_map.with_bound
  {f : E â†’ F} (hf : is_linear_map ğ•œ f) (M : â„) (h : âˆ€ x : E, âˆ¥f xâˆ¥ â‰¤ M * âˆ¥xâˆ¥) :
  is_bounded_linear_map ğ•œ f :=
âŸ¨ hf, classical.by_cases
  (assume : M â‰¤ 0, âŸ¨1, zero_lt_one, Î» x,
    (h x).trans $ mul_le_mul_of_nonneg_right (this.trans zero_le_one) (norm_nonneg x)âŸ©)
  (assume : Â¬ M â‰¤ 0, âŸ¨M, lt_of_not_ge this, hâŸ©)âŸ©
lemma continuous_linear_map.is_bounded_linear_map (f : E â†’L[ğ•œ] F) : is_bounded_linear_map ğ•œ f :=
{ bound := f.bound,
  ..f.to_linear_map.is_linear }
namespace is_bounded_linear_map
def to_linear_map (f : E â†’ F) (h : is_bounded_linear_map ğ•œ f) : E â†’â‚—[ğ•œ] F :=
(is_linear_map.mk' _ h.to_is_linear_map)
def to_continuous_linear_map {f : E â†’ F} (hf : is_bounded_linear_map ğ•œ f) : E â†’L[ğ•œ] F :=
{ cont := let âŸ¨C, Cpos, hCâŸ© :=
    hf.bound in add_monoid_hom_class.continuous_of_bound (to_linear_map f hf) C hC,
  ..to_linear_map f hf}
lemma zero : is_bounded_linear_map ğ•œ (Î» (x:E), (0:F)) :=
(0 : E â†’â‚—[ğ•œ] F).is_linear.with_bound 0 $ by simp [le_refl]
lemma id : is_bounded_linear_map ğ•œ (Î» (x:E), x) :=
linear_map.id.is_linear.with_bound 1 $ by simp [le_refl]
lemma fst : is_bounded_linear_map ğ•œ (Î» x : E Ã— F, x.1) :=
begin
  refine (linear_map.fst ğ•œ E F).is_linear.with_bound 1 (Î» x, _),
  rw one_mul,
  exact le_max_left _ _
end
lemma snd : is_bounded_linear_map ğ•œ (Î» x : E Ã— F, x.2) :=
begin
  refine (linear_map.snd ğ•œ E F).is_linear.with_bound 1 (Î» x, _),
  rw one_mul,
  exact le_max_right _ _
end
variables {f g : E â†’ F}
lemma smul (c : ğ•œ) (hf : is_bounded_linear_map ğ•œ f) :
  is_bounded_linear_map ğ•œ (c â€¢ f) :=
let âŸ¨hlf, M, hMp, hMâŸ© := hf in
(c â€¢ hlf.mk' f).is_linear.with_bound (âˆ¥câˆ¥ * M) $ Î» x,
  calc âˆ¥c â€¢ f xâˆ¥ = âˆ¥câˆ¥ * âˆ¥f xâˆ¥ : norm_smul c (f x)
  ... â‰¤ âˆ¥câˆ¥ * (M * âˆ¥xâˆ¥)        : mul_le_mul_of_nonneg_left (hM _) (norm_nonneg _)
  ... = (âˆ¥câˆ¥ * M) * âˆ¥xâˆ¥        : (mul_assoc _ _ _).symm
lemma neg (hf : is_bounded_linear_map ğ•œ f) :
  is_bounded_linear_map ğ•œ (Î» e, -f e) :=
begin
  rw show (Î» e, -f e) = (Î» e, (-1 : ğ•œ) â€¢ f e), { funext, simp },
  exact smul (-1) hf
end
lemma add (hf : is_bounded_linear_map ğ•œ f) (hg : is_bounded_linear_map ğ•œ g) :
  is_bounded_linear_map ğ•œ (Î» e, f e + g e) :=
let âŸ¨hlf, Mf, hMfp, hMfâŸ© := hf in
let âŸ¨hlg, Mg, hMgp, hMgâŸ© := hg in
(hlf.mk' _ + hlg.mk' _).is_linear.with_bound (Mf + Mg) $ Î» x,
  calc âˆ¥f x + g xâˆ¥ â‰¤ Mf * âˆ¥xâˆ¥ + Mg * âˆ¥xâˆ¥ : norm_add_le_of_le (hMf x) (hMg x)
               ... â‰¤ (Mf + Mg) * âˆ¥xâˆ¥     : by rw add_mul
lemma sub (hf : is_bounded_linear_map ğ•œ f) (hg : is_bounded_linear_map ğ•œ g) :
  is_bounded_linear_map ğ•œ (Î» e, f e - g e) :=
by simpa [sub_eq_add_neg] using add hf (neg hg)
lemma comp {g : F â†’ G}
  (hg : is_bounded_linear_map ğ•œ g) (hf : is_bounded_linear_map ğ•œ f) :
  is_bounded_linear_map ğ•œ (g âˆ˜ f) :=
(hg.to_continuous_linear_map.comp hf.to_continuous_linear_map).is_bounded_linear_map
protected lemma tendsto (x : E) (hf : is_bounded_linear_map ğ•œ f) :
  tendsto f (ğ“ x) (ğ“ (f x)) :=
let âŸ¨hf, M, hMp, hMâŸ© := hf in
tendsto_iff_norm_tendsto_zero.2 $
  squeeze_zero (Î» e, norm_nonneg _)
    (Î» e,
      calc âˆ¥f e - f xâˆ¥ = âˆ¥hf.mk' f (e - x)âˆ¥ : by rw (hf.mk' _).map_sub e x; refl
                   ... â‰¤ M * âˆ¥e - xâˆ¥        : hM (e - x))
    (suffices tendsto (Î» (e : E), M * âˆ¥e - xâˆ¥) (ğ“ x) (ğ“ (M * 0)), by simpa,
      tendsto_const_nhds.mul (tendsto_norm_sub_self _))
lemma continuous (hf : is_bounded_linear_map ğ•œ f) : continuous f :=
continuous_iff_continuous_at.2 $ Î» _, hf.tendsto _
lemma lim_zero_bounded_linear_map (hf : is_bounded_linear_map ğ•œ f) :
  tendsto f (ğ“ 0) (ğ“ 0) :=
(hf.1.mk' _).map_zero â–¸ continuous_iff_continuous_at.1 hf.continuous 0
section
open asymptotics filter
theorem is_O_id {f : E â†’ F} (h : is_bounded_linear_map ğ•œ f) (l : filter E) :
  f =O[l] (Î» x, x) :=
let âŸ¨M, hMp, hMâŸ© := h.bound in is_O.of_bound _ (mem_of_superset univ_mem (Î» x _, hM x))
theorem is_O_comp {E : Type*} {g : F â†’ G} (hg : is_bounded_linear_map ğ•œ g)
  {f : E â†’ F} (l : filter E) : (Î» x', g (f x')) =O[l] f :=
(hg.is_O_id âŠ¤).comp_tendsto le_top
theorem is_O_sub {f : E â†’ F} (h : is_bounded_linear_map ğ•œ f)
  (l : filter E) (x : E) : (Î» x', f (x' - x)) =O[l] (Î» x', x' - x) :=
is_O_comp h l
end
end is_bounded_linear_map
section
variables {Î¹ : Type*} [decidable_eq Î¹] [fintype Î¹]
lemma is_bounded_linear_map_prod_multilinear
  {E : Î¹ â†’ Type*} [âˆ€ i, normed_group (E i)] [âˆ€ i, normed_space ğ•œ (E i)] :
  is_bounded_linear_map ğ•œ
  (Î» p : (continuous_multilinear_map ğ•œ E F) Ã— (continuous_multilinear_map ğ•œ E G), p.1.prod p.2) :=
{ map_add := Î» pâ‚ pâ‚‚, by { ext1 m, refl },
  map_smul := Î» c p, by { ext1 m, refl },
  bound := âŸ¨1, zero_lt_one, Î» p, begin
    rw one_mul,
    apply continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (Î» m, _),
    rw [continuous_multilinear_map.prod_apply, norm_prod_le_iff],
    split,
    { exact (p.1.le_op_norm m).trans
        (mul_le_mul_of_nonneg_right (norm_fst_le p) (finset.prod_nonneg (Î» i hi, norm_nonneg _))) },
    { exact (p.2.le_op_norm m).trans
        (mul_le_mul_of_nonneg_right (norm_snd_le p) (finset.prod_nonneg (Î» i hi, norm_nonneg _))) },
  endâŸ© }
lemma is_bounded_linear_map_continuous_multilinear_map_comp_linear (g : G â†’L[ğ•œ] E) :
  is_bounded_linear_map ğ•œ (Î» f : continuous_multilinear_map ğ•œ (Î» (i : Î¹), E) F,
    f.comp_continuous_linear_map (Î» _, g)) :=
begin
  refine is_linear_map.with_bound âŸ¨Î» fâ‚ fâ‚‚, by { ext m, refl }, Î» c f, by { ext m, refl }âŸ©
    (âˆ¥gâˆ¥ ^ (fintype.card Î¹)) (Î» f, _),
  apply continuous_multilinear_map.op_norm_le_bound _ _ (Î» m, _),
  { apply_rules [mul_nonneg, pow_nonneg, norm_nonneg] },
  calc âˆ¥f (g âˆ˜ m)âˆ¥ â‰¤
    âˆ¥fâˆ¥ * âˆ i, âˆ¥g (m i)âˆ¥ : f.le_op_norm _
    ... â‰¤ âˆ¥fâˆ¥ * âˆ i, (âˆ¥gâˆ¥ * âˆ¥m iâˆ¥) : begin
      apply mul_le_mul_of_nonneg_left _ (norm_nonneg _),
      exact finset.prod_le_prod (Î» i hi, norm_nonneg _) (Î» i hi, g.le_op_norm _)
    end
    ... = âˆ¥gâˆ¥ ^ fintype.card Î¹ * âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥ :
      by { simp [finset.prod_mul_distrib, finset.card_univ], ring }
end
end
section bilinear_map
namespace continuous_linear_map
variables {R : Type*}
variables {ğ•œâ‚‚ ğ•œ' : Type*} [nondiscrete_normed_field ğ•œ'] [nondiscrete_normed_field ğ•œâ‚‚]
variables {M : Type*} [topological_space M]
variables {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [ring_hom_isometric Ïƒâ‚â‚‚]
variables {G' : Type*} [normed_group G'] [normed_space ğ•œâ‚‚ G'] [normed_space ğ•œ' G']
variables [smul_comm_class ğ•œâ‚‚ ğ•œ' G']
section semiring
variables [semiring R] [add_comm_monoid M] [module R M] {Ïâ‚â‚‚ : R â†’+* ğ•œ'}
lemma map_addâ‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (x x' : M) (y : F) :
  f (x + x') y = f x y + f x' y :=
by rw [f.map_add, add_apply]
lemma map_zeroâ‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (y : F) : f 0 y = 0 :=
by rw [f.map_zero, zero_apply]
lemma map_smulâ‚›â‚—â‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (c : R) (x : M) (y : F) :
  f (c â€¢ x) y = Ïâ‚â‚‚ c â€¢ f x y :=
by rw [f.map_smulâ‚›â‚—, smul_apply]
end semiring
section ring
variables [ring R] [add_comm_group M] [module R M] {Ïâ‚â‚‚ : R â†’+* ğ•œ'}
lemma map_subâ‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (x x' : M) (y : F) :
  f (x - x') y = f x y - f x' y :=
by rw [f.map_sub, sub_apply]
lemma map_negâ‚‚ (f : M â†’SL[Ïâ‚â‚‚] F â†’SL[Ïƒâ‚â‚‚] G') (x : M) (y : F) : f (- x) y = - f x y :=
by rw [f.map_neg, neg_apply]
end ring
lemma map_smulâ‚‚ (f : E â†’L[ğ•œ] F â†’L[ğ•œ] G) (c : ğ•œ) (x : E) (y : F) : f (c â€¢ x) y = c â€¢ f x y :=
by rw [f.map_smul, smul_apply]
end continuous_linear_map
variable (ğ•œ)
structure is_bounded_bilinear_map (f : E Ã— F â†’ G) : Prop :=
(add_left   : âˆ€ (xâ‚ xâ‚‚ : E) (y : F), f (xâ‚ + xâ‚‚, y) = f (xâ‚, y) + f (xâ‚‚, y))
(smul_left  : âˆ€ (c : ğ•œ) (x : E) (y : F), f (c â€¢ x, y) = c â€¢ f (x, y))
(add_right  : âˆ€ (x : E) (yâ‚ yâ‚‚ : F), f (x, yâ‚ + yâ‚‚) = f (x, yâ‚) + f (x, yâ‚‚))
(smul_right : âˆ€ (c : ğ•œ) (x : E) (y : F), f (x, c â€¢ y) = c â€¢ f (x,y))
(bound      : âˆƒ C > 0, âˆ€ (x : E) (y : F), âˆ¥f (x, y)âˆ¥ â‰¤ C * âˆ¥xâˆ¥ * âˆ¥yâˆ¥)
variable {ğ•œ}
variable {f : E Ã— F â†’ G}
lemma continuous_linear_map.is_bounded_bilinear_map (f : E â†’L[ğ•œ] F â†’L[ğ•œ] G) :
  is_bounded_bilinear_map ğ•œ (Î» x : E Ã— F, f x.1 x.2) :=
{ add_left := f.map_addâ‚‚,
  smul_left := f.map_smulâ‚‚,
  add_right := Î» x, (f x).map_add,
  smul_right := Î» c x, (f x).map_smul c,
  bound := âŸ¨max âˆ¥fâˆ¥ 1, zero_lt_one.trans_le (le_max_right _ _),
    Î» x y, (f.le_op_normâ‚‚ x y).trans $
      by apply_rules [mul_le_mul_of_nonneg_right, norm_nonneg, le_max_left]âŸ© }
protected lemma is_bounded_bilinear_map.is_O (h : is_bounded_bilinear_map ğ•œ f) :
  f =O[âŠ¤] (Î» p : E Ã— F, âˆ¥p.1âˆ¥ * âˆ¥p.2âˆ¥) :=
let âŸ¨C, Cpos, hCâŸ© := h.bound in asymptotics.is_O.of_bound _ $
filter.eventually_of_forall $ Î» âŸ¨x, yâŸ©, by simpa [mul_assoc] using hC x y
lemma is_bounded_bilinear_map.is_O_comp {Î± : Type*} (H : is_bounded_bilinear_map ğ•œ f)
  {g : Î± â†’ E} {h : Î± â†’ F} {l : filter Î±} :
  (Î» x, f (g x, h x)) =O[l] (Î» x, âˆ¥g xâˆ¥ * âˆ¥h xâˆ¥) :=
H.is_O.comp_tendsto le_top
protected lemma is_bounded_bilinear_map.is_O' (h : is_bounded_bilinear_map ğ•œ f) :
  f =O[âŠ¤] (Î» p : E Ã— F, âˆ¥pâˆ¥ * âˆ¥pâˆ¥) :=
h.is_O.trans (asymptotics.is_O_fst_prod'.norm_norm.mul asymptotics.is_O_snd_prod'.norm_norm)
lemma is_bounded_bilinear_map.map_sub_left (h : is_bounded_bilinear_map ğ•œ f) {x y : E} {z : F} :
  f (x - y, z) = f (x, z) - f(y, z) :=
calc f (x - y, z) = f (x + (-1 : ğ•œ) â€¢ y, z) : by simp [sub_eq_add_neg]
... = f (x, z) + (-1 : ğ•œ) â€¢ f (y, z) : by simp only [h.add_left, h.smul_left]
... = f (x, z) - f (y, z) : by simp [sub_eq_add_neg]
lemma is_bounded_bilinear_map.map_sub_right (h : is_bounded_bilinear_map ğ•œ f) {x : E} {y z : F} :
  f (x, y - z) = f (x, y) - f (x, z) :=
calc f (x, y - z) = f (x, y + (-1 : ğ•œ) â€¢ z) : by simp [sub_eq_add_neg]
... = f (x, y) + (-1 : ğ•œ) â€¢ f (x, z) : by simp only [h.add_right, h.smul_right]
... = f (x, y) - f (x, z) : by simp [sub_eq_add_neg]
lemma is_bounded_bilinear_map.continuous (h : is_bounded_bilinear_map ğ•œ f) :
  continuous f :=
begin
  have one_ne : (1:â„) â‰  0 := by simp,
  obtain âŸ¨C, (Cpos : 0 < C), hCâŸ© := h.bound,
  rw continuous_iff_continuous_at,
  intros x,
  have H : âˆ€ (a:E) (b:F), âˆ¥f (a, b)âˆ¥ â‰¤ C * âˆ¥âˆ¥aâˆ¥ * âˆ¥bâˆ¥âˆ¥,
  { intros a b,
    simpa [mul_assoc] using hC a b },
  have hâ‚ : (Î» e : E Ã— F, f (e.1 - x.1, e.2)) =o[ğ“ x] (Î» e, (1:â„)),
  { refine (asymptotics.is_O_of_le' (ğ“ x) (Î» e, H (e.1 - x.1) e.2)).trans_is_o _,
    rw asymptotics.is_o_const_iff one_ne,
    convert ((continuous_fst.sub continuous_const).norm.mul continuous_snd.norm).continuous_at,
    { simp },
    apply_instance },
  have hâ‚‚ : (Î» e : E Ã— F, f (x.1, e.2 - x.2)) =o[ğ“ x] (Î» e, (1:â„)),
  { refine (asymptotics.is_O_of_le' (ğ“ x) (Î» e, H x.1 (e.2 - x.2))).trans_is_o _,
    rw asymptotics.is_o_const_iff one_ne,
    convert (continuous_const.mul (continuous_snd.sub continuous_const).norm).continuous_at,
    { simp },
    apply_instance },
  have := hâ‚.add hâ‚‚,
  rw asymptotics.is_o_const_iff one_ne at this,
  change tendsto _ _ _,
  convert this.add_const (f x),
  { ext e,
    simp [h.map_sub_left, h.map_sub_right], },
  { simp }
end
lemma is_bounded_bilinear_map.continuous_left (h : is_bounded_bilinear_map ğ•œ f) {eâ‚‚ : F} :
  continuous (Î»eâ‚, f (eâ‚, eâ‚‚)) :=
h.continuous.comp (continuous_id.prod_mk continuous_const)
lemma is_bounded_bilinear_map.continuous_right (h : is_bounded_bilinear_map ğ•œ f) {eâ‚ : E} :
  continuous (Î»eâ‚‚, f (eâ‚, eâ‚‚)) :=
h.continuous.comp (continuous_const.prod_mk continuous_id)
lemma continuous_linear_map.continuousâ‚‚ (f : E â†’L[ğ•œ] F â†’L[ğ•œ] G) :
  continuous (function.uncurry (Î» x y, f x y)) :=
f.is_bounded_bilinear_map.continuous
lemma is_bounded_bilinear_map.is_bounded_linear_map_left (h : is_bounded_bilinear_map ğ•œ f) (y : F) :
  is_bounded_linear_map ğ•œ (Î» x, f (x, y)) :=
{ map_add  := Î» x x', h.add_left _ _ _,
  map_smul := Î» c x, h.smul_left _ _ _,
  bound    := begin
    rcases h.bound with âŸ¨C, C_pos, hCâŸ©,
    refine âŸ¨C * (âˆ¥yâˆ¥ + 1), mul_pos C_pos (lt_of_lt_of_le (zero_lt_one) (by simp)), Î» x, _âŸ©,
    have : âˆ¥yâˆ¥ â‰¤ âˆ¥yâˆ¥ + 1, by simp [zero_le_one],
    calc âˆ¥f (x, y)âˆ¥ â‰¤ C * âˆ¥xâˆ¥ * âˆ¥yâˆ¥ : hC x y
    ... â‰¤ C * âˆ¥xâˆ¥ * (âˆ¥yâˆ¥ + 1) :
      by apply_rules [norm_nonneg, mul_le_mul_of_nonneg_left, le_of_lt C_pos, mul_nonneg]
    ... = C * (âˆ¥yâˆ¥ + 1) * âˆ¥xâˆ¥ : by ring
  end }
lemma is_bounded_bilinear_map.is_bounded_linear_map_right
  (h : is_bounded_bilinear_map ğ•œ f) (x : E) :
  is_bounded_linear_map ğ•œ (Î» y, f (x, y)) :=
{ map_add  := Î» y y', h.add_right _ _ _,
  map_smul := Î» c y, h.smul_right _ _ _,
  bound    := begin
    rcases h.bound with âŸ¨C, C_pos, hCâŸ©,
    refine âŸ¨C * (âˆ¥xâˆ¥ + 1), mul_pos C_pos (lt_of_lt_of_le (zero_lt_one) (by simp)), Î» y, _âŸ©,
    have : âˆ¥xâˆ¥ â‰¤ âˆ¥xâˆ¥ + 1, by simp [zero_le_one],
    calc âˆ¥f (x, y)âˆ¥ â‰¤ C * âˆ¥xâˆ¥ * âˆ¥yâˆ¥ : hC x y
    ... â‰¤ C * (âˆ¥xâˆ¥ + 1) * âˆ¥yâˆ¥ :
      by apply_rules [mul_le_mul_of_nonneg_right, norm_nonneg, mul_le_mul_of_nonneg_left,
                      le_of_lt C_pos]
  end }
lemma is_bounded_bilinear_map_smul {ğ•œ' : Type*} [normed_field ğ•œ']
  [normed_algebra ğ•œ ğ•œ'] {E : Type*} [normed_group E] [normed_space ğ•œ E] [normed_space ğ•œ' E]
  [is_scalar_tower ğ•œ ğ•œ' E] :
  is_bounded_bilinear_map ğ•œ (Î» (p : ğ•œ' Ã— E), p.1 â€¢ p.2) :=
(lsmul ğ•œ ğ•œ' : ğ•œ' â†’L[ğ•œ] E â†’L[ğ•œ] E).is_bounded_bilinear_map
lemma is_bounded_bilinear_map_mul :
  is_bounded_bilinear_map ğ•œ (Î» (p : ğ•œ Ã— ğ•œ), p.1 * p.2) :=
by simp_rw â† smul_eq_mul; exact is_bounded_bilinear_map_smul
lemma is_bounded_bilinear_map_comp :
  is_bounded_bilinear_map ğ•œ (Î» (p : (F â†’L[ğ•œ] G) Ã— (E â†’L[ğ•œ] F)), p.1.comp p.2) :=
(compL ğ•œ E F G).is_bounded_bilinear_map
lemma continuous_linear_map.is_bounded_linear_map_comp_left (g : F â†’L[ğ•œ] G) :
  is_bounded_linear_map ğ•œ (Î» (f : E â†’L[ğ•œ] F), continuous_linear_map.comp g f) :=
is_bounded_bilinear_map_comp.is_bounded_linear_map_right _
lemma continuous_linear_map.is_bounded_linear_map_comp_right (f : E â†’L[ğ•œ] F) :
  is_bounded_linear_map ğ•œ (Î» (g : F â†’L[ğ•œ] G), continuous_linear_map.comp g f) :=
is_bounded_bilinear_map_comp.is_bounded_linear_map_left _
lemma is_bounded_bilinear_map_apply :
  is_bounded_bilinear_map ğ•œ (Î» p : (E â†’L[ğ•œ] F) Ã— E, p.1 p.2) :=
(continuous_linear_map.flip (apply ğ•œ F : E â†’L[ğ•œ] (E â†’L[ğ•œ] F) â†’L[ğ•œ] F)).is_bounded_bilinear_map
lemma is_bounded_bilinear_map_smul_right :
  is_bounded_bilinear_map ğ•œ
    (Î» p, (continuous_linear_map.smul_right : (E â†’L[ğ•œ] ğ•œ) â†’ F â†’ (E â†’L[ğ•œ] F)) p.1 p.2) :=
(smul_rightL ğ•œ E F).is_bounded_bilinear_map
lemma is_bounded_bilinear_map_comp_multilinear {Î¹ : Type*} {E : Î¹ â†’ Type*}
[decidable_eq Î¹] [fintype Î¹] [âˆ€ i, normed_group (E i)] [âˆ€ i, normed_space ğ•œ (E i)] :
  is_bounded_bilinear_map ğ•œ (Î» p : (F â†’L[ğ•œ] G) Ã— (continuous_multilinear_map ğ•œ E F),
    p.1.comp_continuous_multilinear_map p.2) :=
(comp_continuous_multilinear_mapL ğ•œ E F G).is_bounded_bilinear_map
def is_bounded_bilinear_map.linear_deriv (h : is_bounded_bilinear_map ğ•œ f) (p : E Ã— F) :
  E Ã— F â†’â‚—[ğ•œ] G :=
{ to_fun := Î» q, f (p.1, q.2) + f (q.1, p.2),
  map_add' := Î» qâ‚ qâ‚‚, begin
    change f (p.1, qâ‚.2 + qâ‚‚.2) + f (qâ‚.1 + qâ‚‚.1, p.2) =
      f (p.1, qâ‚.2) + f (qâ‚.1, p.2) + (f (p.1, qâ‚‚.2) + f (qâ‚‚.1, p.2)),
    simp [h.add_left, h.add_right], abel
  end,
  map_smul' := Î» c q, begin
    change f (p.1, c â€¢ q.2) + f (c â€¢ q.1, p.2) = c â€¢ (f (p.1, q.2) + f (q.1, p.2)),
    simp [h.smul_left, h.smul_right, smul_add]
  end }
def is_bounded_bilinear_map.deriv (h : is_bounded_bilinear_map ğ•œ f) (p : E Ã— F) : E Ã— F â†’L[ğ•œ] G :=
(h.linear_deriv p).mk_continuous_of_exists_bound $ begin
  rcases h.bound with âŸ¨C, Cpos, hCâŸ©,
  refine âŸ¨C * âˆ¥p.1âˆ¥ + C * âˆ¥p.2âˆ¥, Î» q, _âŸ©,
  calc âˆ¥f (p.1, q.2) + f (q.1, p.2)âˆ¥
    â‰¤ C * âˆ¥p.1âˆ¥ * âˆ¥q.2âˆ¥ + C * âˆ¥q.1âˆ¥ * âˆ¥p.2âˆ¥ : norm_add_le_of_le (hC _ _) (hC _ _)
  ... â‰¤ C * âˆ¥p.1âˆ¥ * âˆ¥qâˆ¥ + C * âˆ¥qâˆ¥ * âˆ¥p.2âˆ¥ : begin
      apply add_le_add,
      exact mul_le_mul_of_nonneg_left
        (le_max_right _ _) (mul_nonneg (le_of_lt Cpos) (norm_nonneg _)),
      apply mul_le_mul_of_nonneg_right _ (norm_nonneg _),
      exact mul_le_mul_of_nonneg_left (le_max_left _ _) (le_of_lt Cpos),
  end
  ... = (C * âˆ¥p.1âˆ¥ + C * âˆ¥p.2âˆ¥) * âˆ¥qâˆ¥ : by ring
end
@[simp] lemma is_bounded_bilinear_map_deriv_coe (h : is_bounded_bilinear_map ğ•œ f) (p q : E Ã— F) :
  h.deriv p q = f (p.1, q.2) + f (q.1, p.2) := rfl
variables (ğ•œ)
lemma continuous_linear_map.lmul_left_right_is_bounded_bilinear
  (ğ•œ' : Type*) [normed_ring ğ•œ'] [normed_algebra ğ•œ ğ•œ'] :
  is_bounded_bilinear_map ğ•œ (Î» p : ğ•œ' Ã— ğ•œ', continuous_linear_map.lmul_left_right ğ•œ ğ•œ' p.1 p.2) :=
(continuous_linear_map.lmul_left_right ğ•œ ğ•œ').is_bounded_bilinear_map
variables {ğ•œ}
lemma is_bounded_bilinear_map.is_bounded_linear_map_deriv (h : is_bounded_bilinear_map ğ•œ f) :
  is_bounded_linear_map ğ•œ (Î» p : E Ã— F, h.deriv p) :=
begin
  rcases h.bound with âŸ¨C, Cpos : 0 < C, hCâŸ©,
  refine is_linear_map.with_bound âŸ¨Î» pâ‚ pâ‚‚, _, Î» c p, _âŸ© (C + C) (Î» p, _),
  { ext; simp [h.add_left, h.add_right]; abel },
  { ext; simp [h.smul_left, h.smul_right, smul_add] },
  { refine continuous_linear_map.op_norm_le_bound _
      (mul_nonneg (add_nonneg Cpos.le Cpos.le) (norm_nonneg _)) (Î» q, _),
    calc âˆ¥f (p.1, q.2) + f (q.1, p.2)âˆ¥
      â‰¤ C * âˆ¥p.1âˆ¥ * âˆ¥q.2âˆ¥ + C * âˆ¥q.1âˆ¥ * âˆ¥p.2âˆ¥ : norm_add_le_of_le (hC _ _) (hC _ _)
    ... â‰¤ C * âˆ¥pâˆ¥ * âˆ¥qâˆ¥ + C * âˆ¥qâˆ¥ * âˆ¥pâˆ¥ : by apply_rules [add_le_add, mul_le_mul, norm_nonneg,
      Cpos.le, le_refl, le_max_left, le_max_right, mul_nonneg]
    ... = (C + C) * âˆ¥pâˆ¥ * âˆ¥qâˆ¥ : by ring },
end
end bilinear_map
lemma continuous.clm_comp {X} [topological_space X] {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F}
  (hg : continuous g) (hf : continuous f) :
  continuous (Î» x, (g x).comp (f x)) :=
(compL ğ•œ E F G).continuousâ‚‚.compâ‚‚ hg hf
lemma continuous_on.clm_comp {X} [topological_space X] {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F}
  {s : set X} (hg : continuous_on g s) (hf : continuous_on f s) :
  continuous_on (Î» x, (g x).comp (f x)) s :=
(compL ğ•œ E F G).continuousâ‚‚.comp_continuous_on (hg.prod hf)
namespace continuous_linear_equiv
open set
protected lemma is_open [complete_space E] : is_open (range (coe : (E â‰ƒL[ğ•œ] F) â†’ (E â†’L[ğ•œ] F))) :=
begin
  rw [is_open_iff_mem_nhds, forall_range_iff],
  refine Î» e, is_open.mem_nhds _ (mem_range_self _),
  let O : (E â†’L[ğ•œ] F) â†’ (E â†’L[ğ•œ] E) := Î» f, (e.symm : F â†’L[ğ•œ] E).comp f,
  have h_O : continuous O := is_bounded_bilinear_map_comp.continuous_right,
  convert units.is_open.preimage h_O using 1,
  ext f',
  split,
  { rintros âŸ¨e', rflâŸ©,
    exact âŸ¨(e'.trans e.symm).to_unit, rflâŸ© },
  { rintros âŸ¨w, hwâŸ©,
    use (units_equiv ğ•œ E w).trans e,
    ext x,
    simp [coe_fn_coe_base' w, hw] }
end
protected lemma nhds [complete_space E] (e : E â‰ƒL[ğ•œ] F) :
  (range (coe : (E â‰ƒL[ğ•œ] F) â†’ (E â†’L[ğ•œ] F))) âˆˆ ğ“ (e : E â†’L[ğ•œ] F) :=
is_open.mem_nhds continuous_linear_equiv.is_open (by simp)
end continuous_linear_equiv
