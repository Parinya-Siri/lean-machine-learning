import category_theory.preadditive.additive_functor
import category_theory.linear
namespace category_theory
variables (R : Type*) [semiring R]
class functor.linear {C D : Type*} [category C] [category D]
  [preadditive C] [preadditive D] [linear R C] [linear R D] (F : C ‚•§ D) [F.additive] : Prop :=
(map_smul' : Œ† {X Y : C} {f : X ‚ü∂ Y} {r : R}, F.map (r ‚Ä¢ f) = r ‚Ä¢ F.map f . obviously)
section linear
namespace functor
section
variables {R} {C D : Type*} [category C] [category D]
  [preadditive C] [preadditive D] [category_theory.linear R C] [category_theory.linear R D]
  (F : C ‚•§ D) [additive F] [linear R F]
@[simp]
lemma map_smul {X Y : C} (r : R) (f : X ‚ü∂ Y) : F.map (r ‚Ä¢ f) = r ‚Ä¢ F.map f :=
functor.linear.map_smul'
instance : linear R (ùü≠ C) :=
{}
instance {E : Type*} [category E] [preadditive E] [category_theory.linear R E]
  (G : D ‚•§ E) [additive G] [linear R G]:
  linear R (F ‚ãô G) :=
{}
variables (R)
@[simps]
def map_linear_map {X Y : C} : (X ‚ü∂ Y) ‚Üí‚Çó[R] (F.obj X ‚ü∂ F.obj Y) :=
{ map_smul' := Œª r f, F.map_smul r f,
  ..F.map_add_hom }
lemma coe_map_linear_map {X Y : C} : ‚áë(F.map_linear_map R : (X ‚ü∂ Y) ‚Üí‚Çó[R] _) = @map C _ D _ F X Y :=
rfl
end
section induced_category
variables {C : Type*} {D : Type*} [category D] [preadditive D] [category_theory.linear R D]
   (F : C ‚Üí D)
instance induced_functor_linear : functor.linear R (induced_functor F) := {}
end induced_category
section
variables {R} {C D : Type*} [category C] [category D]
  [preadditive C] [preadditive D]
  (F : C ‚•§ D) [additive F]
instance nat_linear : F.linear ‚Ñï :=
{ map_smul' := Œª X Y f r, F.map_add_hom.map_nsmul f r, }
instance int_linear : F.linear ‚Ñ§ :=
{ map_smul' := Œª X Y f r, (F.map_add_hom : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y)).map_zsmul f r, }
variables [category_theory.linear ‚Ñö C] [category_theory.linear ‚Ñö D]
instance rat_linear : F.linear ‚Ñö :=
{ map_smul' := Œª X Y f r, F.map_add_hom.to_rat_linear_map.map_smul r f, }
end
end functor
namespace equivalence
variables {C D : Type*} [category C] [category D]
  [preadditive C] [linear R C] [preadditive D] [linear R D]
instance inverse_linear (e : C ‚âå D) [e.functor.additive] [e.functor.linear R] :
  e.inverse.linear R :=
{ map_smul' := Œª X Y r f, by { apply e.functor.map_injective, simp, }, }
end equivalence
end linear
end category_theory
