import set_theory.cardinal.basic
import topology.metric_space.closeds
import topology.metric_space.completion
import topology.metric_space.gromov_hausdorff_realized
import topology.metric_space.kuratowski
noncomputable theory
open_locale classical topological_space ennreal
local notation `‚Ñì_infty_‚Ñù`:= lp (Œª n : ‚Ñï, ‚Ñù) ‚àû
universes u v w
open classical set function topological_space filter metric quotient
open bounded_continuous_function nat int Kuratowski_embedding
open sum (inl inr)
local attribute [instance] metric_space_sum
namespace Gromov_Hausdorff
section GH_space
private def isometry_rel : nonempty_compacts ‚Ñì_infty_‚Ñù ‚Üí nonempty_compacts ‚Ñì_infty_‚Ñù ‚Üí Prop :=
Œª x y, nonempty (x ‚âÉ·µ¢ y)
private lemma is_equivalence_isometry_rel : equivalence isometry_rel :=
‚ü®Œª x, ‚ü®isometric.refl _‚ü©, Œª x y ‚ü®e‚ü©, ‚ü®e.symm‚ü©, Œª x y z ‚ü®e‚ü© ‚ü®f‚ü©, ‚ü®e.trans f‚ü©‚ü©
instance isometry_rel.setoid : setoid (nonempty_compacts ‚Ñì_infty_‚Ñù) :=
setoid.mk isometry_rel is_equivalence_isometry_rel
definition GH_space : Type := quotient (isometry_rel.setoid)
definition to_GH_space (X : Type u) [metric_space X] [compact_space X] [nonempty X] : GH_space :=
  ‚ü¶nonempty_compacts.Kuratowski_embedding X‚üß
instance : inhabited GH_space := ‚ü®quot.mk _ ‚ü®‚ü®{0}, is_compact_singleton‚ü©, singleton_nonempty _‚ü©‚ü©
@[nolint has_inhabited_instance]
def GH_space.rep (p : GH_space) : Type := (quotient.out p : nonempty_compacts ‚Ñì_infty_‚Ñù)
lemma eq_to_GH_space_iff {X : Type u} [metric_space X] [compact_space X] [nonempty X]
  {p : nonempty_compacts ‚Ñì_infty_‚Ñù} :
  ‚ü¶p‚üß = to_GH_space X ‚Üî ‚àÉ Œ® : X ‚Üí ‚Ñì_infty_‚Ñù, isometry Œ® ‚àß range Œ® = p :=
begin
  simp only [to_GH_space, quotient.eq],
  refine ‚ü®Œª h, _, _‚ü©,
  { rcases setoid.symm h with ‚ü®e‚ü©,
    have f := (Kuratowski_embedding.isometry X).isometric_on_range.trans e,
    use [Œª x, f x, isometry_subtype_coe.comp f.isometry],
    rw [range_comp, f.range_eq_univ, set.image_univ, subtype.range_coe],
    refl },
  { rintros ‚ü®Œ®, ‚ü®isomŒ®, rangeŒ®‚ü©‚ü©,
    have f := ((Kuratowski_embedding.isometry X).isometric_on_range.symm.trans
               isomŒ®.isometric_on_range).symm,
    have E : (range Œ® ‚âÉ·µ¢ nonempty_compacts.Kuratowski_embedding X) =
        (p ‚âÉ·µ¢ range (Kuratowski_embedding X)),
      by { dunfold nonempty_compacts.Kuratowski_embedding, rw [rangeŒ®]; refl },
    exact ‚ü®cast E f‚ü© }
end
lemma eq_to_GH_space {p : nonempty_compacts ‚Ñì_infty_‚Ñù} : ‚ü¶p‚üß = to_GH_space p :=
eq_to_GH_space_iff.2 ‚ü®Œª x, x, isometry_subtype_coe, subtype.range_coe‚ü©
section
local attribute [reducible] GH_space.rep
instance rep_GH_space_metric_space {p : GH_space} : metric_space p.rep := by apply_instance
instance rep_GH_space_compact_space {p : GH_space} : compact_space p.rep := by apply_instance
instance rep_GH_space_nonempty {p : GH_space} : nonempty p.rep := by apply_instance
end
lemma GH_space.to_GH_space_rep (p : GH_space) : to_GH_space p.rep = p :=
begin
  change to_GH_space (quot.out p : nonempty_compacts ‚Ñì_infty_‚Ñù) = p,
  rw ‚Üê eq_to_GH_space,
  exact quot.out_eq p
end
lemma to_GH_space_eq_to_GH_space_iff_isometric {X : Type u} [metric_space X] [compact_space X]
  [nonempty X] {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] :
  to_GH_space X = to_GH_space Y ‚Üî nonempty (X ‚âÉ·µ¢ Y) :=
‚ü®begin
  simp only [to_GH_space, quotient.eq],
  rintro ‚ü®e‚ü©,
  have I : ((nonempty_compacts.Kuratowski_embedding X) ‚âÉ·µ¢
             (nonempty_compacts.Kuratowski_embedding Y))
          = ((range (Kuratowski_embedding X)) ‚âÉ·µ¢ (range (Kuratowski_embedding Y))),
    by { dunfold nonempty_compacts.Kuratowski_embedding, refl },
  have f := (Kuratowski_embedding.isometry X).isometric_on_range,
  have g := (Kuratowski_embedding.isometry Y).isometric_on_range.symm,
  exact ‚ü®f.trans $ (cast I e).trans g‚ü©
end,
begin
  rintro ‚ü®e‚ü©,
  simp only [to_GH_space, quotient.eq],
  have f := (Kuratowski_embedding.isometry X).isometric_on_range.symm,
  have g := (Kuratowski_embedding.isometry Y).isometric_on_range,
  have I : ((range (Kuratowski_embedding X)) ‚âÉ·µ¢ (range (Kuratowski_embedding Y))) =
    ((nonempty_compacts.Kuratowski_embedding X) ‚âÉ·µ¢
      (nonempty_compacts.Kuratowski_embedding Y)),
    by { dunfold nonempty_compacts.Kuratowski_embedding, refl },
  exact ‚ü®cast I ((f.trans e).trans g)‚ü©
end‚ü©
instance : has_dist (GH_space) :=
{ dist := Œª x y, Inf $
    (Œª p : nonempty_compacts ‚Ñì_infty_‚Ñù √ó nonempty_compacts ‚Ñì_infty_‚Ñù,
      Hausdorff_dist (p.1 : set ‚Ñì_infty_‚Ñù) p.2) '' ({a | ‚ü¶a‚üß = x} √óÀ¢ {b | ‚ü¶b‚üß = y}) }
def GH_dist (X : Type u) (Y : Type v) [metric_space X] [nonempty X] [compact_space X]
  [metric_space Y] [nonempty Y] [compact_space Y] : ‚Ñù := dist (to_GH_space X) (to_GH_space Y)
lemma dist_GH_dist (p q : GH_space) : dist p q = GH_dist p.rep (q.rep) :=
by rw [GH_dist, p.to_GH_space_rep, q.to_GH_space_rep]
theorem GH_dist_le_Hausdorff_dist {X : Type u} [metric_space X] [compact_space X] [nonempty X]
  {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y]
  {Œ≥ : Type w} [metric_space Œ≥] {Œ¶ : X ‚Üí Œ≥} {Œ® : Y ‚Üí Œ≥} (ha : isometry Œ¶) (hb : isometry Œ®) :
  GH_dist X Y ‚â§ Hausdorff_dist (range Œ¶) (range Œ®) :=
begin
  rcases exists_mem_of_nonempty X with ‚ü®xX, _‚ü©,
  let s : set Œ≥ := (range Œ¶) ‚à™ (range Œ®),
  let Œ¶' : X ‚Üí subtype s := Œª y, ‚ü®Œ¶ y, mem_union_left _ (mem_range_self _)‚ü©,
  let Œ®' : Y ‚Üí subtype s := Œª y, ‚ü®Œ® y, mem_union_right _ (mem_range_self _)‚ü©,
  have IŒ¶' : isometry Œ¶' := Œª x y, ha x y,
  have IŒ®' : isometry Œ®' := Œª x y, hb x y,
  have : is_compact s, from (is_compact_range ha.continuous).union (is_compact_range hb.continuous),
  letI : metric_space (subtype s) := by apply_instance,
  haveI : compact_space (subtype s) := ‚ü®is_compact_iff_is_compact_univ.1 ‚Äπis_compact s‚Ä∫‚ü©,
  haveI : nonempty (subtype s) := ‚ü®Œ¶' xX‚ü©,
  have Œ¶Œ¶' : Œ¶ = subtype.val ‚àò Œ¶', by { funext, refl },
  have Œ®Œ®' : Œ® = subtype.val ‚àò Œ®', by { funext, refl },
  have : Hausdorff_dist (range Œ¶) (range Œ®) = Hausdorff_dist (range Œ¶') (range Œ®'),
  { rw [Œ¶Œ¶', Œ®Œ®', range_comp, range_comp],
    exact Hausdorff_dist_image (isometry_subtype_coe) },
  rw this,
lemma Hausdorff_dist_optimal {X : Type u} [metric_space X] [compact_space X] [nonempty X]
  {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y] :
  Hausdorff_dist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y)) = GH_dist X Y :=
begin
  inhabit X, inhabit Y,
  have A : ‚àÄ p q : nonempty_compacts ‚Ñì_infty_‚Ñù, ‚ü¶p‚üß = to_GH_space X ‚Üí ‚ü¶q‚üß = to_GH_space Y ‚Üí
        Hausdorff_dist (p : set ‚Ñì_infty_‚Ñù) q < diam (univ : set X) + 1 + diam (univ : set Y) ‚Üí
        Hausdorff_dist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y)) ‚â§
        Hausdorff_dist (p : set ‚Ñì_infty_‚Ñù) q,
  { assume p q hp hq bound,
    rcases eq_to_GH_space_iff.1 hp with ‚ü®Œ¶, ‚ü®Œ¶isom, Œ¶range‚ü©‚ü©,
    rcases eq_to_GH_space_iff.1 hq with ‚ü®Œ®, ‚ü®Œ®isom, Œ®range‚ü©‚ü©,
    have I : diam (range Œ¶ ‚à™ range Œ®) ‚â§ 2 * diam (univ : set X) + 1 + 2 * diam (univ : set Y),
    { rcases exists_mem_of_nonempty X with ‚ü®xX, _‚ü©,
      have : ‚àÉ y ‚àà range Œ®, dist (Œ¶ xX) y < diam (univ : set X) + 1 + diam (univ : set Y),
      { rw Œ®range,
        have : Œ¶ xX ‚àà ‚Üëp := Œ¶range.subst (mem_range_self _),
        exact exists_dist_lt_of_Hausdorff_dist_lt this bound
          (Hausdorff_edist_ne_top_of_nonempty_of_bounded p.nonempty q.nonempty
            p.compact.bounded q.compact.bounded) },
      rcases this with ‚ü®y, hy, dy‚ü©,
      rcases mem_range.1 hy with ‚ü®z, hzy‚ü©,
      rw ‚Üê hzy at dy,
      have DŒ¶ : diam (range Œ¶) = diam (univ : set X) := Œ¶isom.diam_range,
      have DŒ® : diam (range Œ®) = diam (univ : set Y) := Œ®isom.diam_range,
      calc
        diam (range Œ¶ ‚à™ range Œ®) ‚â§ diam (range Œ¶) + dist (Œ¶ xX) (Œ® z) + diam (range Œ®) :
          diam_union (mem_range_self _) (mem_range_self _)
        ... ‚â§ diam (univ : set X) + (diam (univ : set X) + 1 + diam (univ : set Y)) +
              diam (univ : set Y) :
          by { rw [DŒ¶, DŒ®], apply add_le_add (add_le_add le_rfl (le_of_lt dy)) le_rfl }
        ... = 2 * diam (univ : set X) + 1 + 2 * diam (univ : set Y) : by ring },
    let f : X ‚äï Y ‚Üí ‚Ñì_infty_‚Ñù := Œª x, match x with | inl y := Œ¶ y | inr z := Œ® z end,
    let F : (X ‚äï Y) √ó (X ‚äï Y) ‚Üí ‚Ñù := Œª p, dist (f p.1) (f p.2),
  have B : ‚àÄ p q : nonempty_compacts ‚Ñì_infty_‚Ñù, ‚ü¶p‚üß = to_GH_space X ‚Üí ‚ü¶q‚üß = to_GH_space Y ‚Üí
        Hausdorff_dist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y)) ‚â§
        Hausdorff_dist (p : set ‚Ñì_infty_‚Ñù) q,
  { assume p q hp hq,
    by_cases h :
      Hausdorff_dist (p : set ‚Ñì_infty_‚Ñù) q < diam (univ : set X) + 1 + diam (univ : set Y),
    { exact A p q hp hq h },
    { calc Hausdorff_dist (range (optimal_GH_injl X Y)) (range (optimal_GH_injr X Y))
               ‚â§ HD (candidates_b_dist X Y) :
             Hausdorff_dist_optimal_le_HD _ _ (candidates_b_dist_mem_candidates_b)
           ... ‚â§ diam (univ : set X) + 1 + diam (univ : set Y) : HD_candidates_b_dist_le
           ... ‚â§ Hausdorff_dist (p : set ‚Ñì_infty_‚Ñù) q : not_lt.1 h } },
  refine le_antisymm _ _,
  { apply le_cInf,
    { refine (set.nonempty.prod _ _).image _; exact ‚ü®_, rfl‚ü© },
    { rintro b ‚ü®‚ü®p, q‚ü©, ‚ü®hp, hq‚ü©, rfl‚ü©,
      exact B p q hp hq } },
  { exact GH_dist_le_Hausdorff_dist (isometry_optimal_GH_injl X Y) (isometry_optimal_GH_injr X Y) }
end
theorem GH_dist_eq_Hausdorff_dist (X : Type u) [metric_space X] [compact_space X] [nonempty X]
  (Y : Type v) [metric_space Y] [compact_space Y] [nonempty Y] :
  ‚àÉ Œ¶ : X ‚Üí ‚Ñì_infty_‚Ñù, ‚àÉ Œ® : Y ‚Üí ‚Ñì_infty_‚Ñù, isometry Œ¶ ‚àß isometry Œ® ‚àß
  GH_dist X Y = Hausdorff_dist (range Œ¶) (range Œ®) :=
begin
  let F := Kuratowski_embedding (optimal_GH_coupling X Y),
  let Œ¶ := F ‚àò optimal_GH_injl X Y,
  let Œ® := F ‚àò optimal_GH_injr X Y,
  refine ‚ü®Œ¶, Œ®, _, _, _‚ü©,
  { exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injl X Y) },
  { exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injr X Y) },
  { rw [‚Üê image_univ, ‚Üê image_univ, image_comp F, image_univ, image_comp F (optimal_GH_injr X Y),
      image_univ, ‚Üê Hausdorff_dist_optimal],
    exact (Hausdorff_dist_image (Kuratowski_embedding.isometry _)).symm },
end
instance : metric_space GH_space :=
{ dist := dist,
  dist_self := Œª x, begin
    rcases exists_rep x with ‚ü®y, hy‚ü©,
    refine le_antisymm _ _,
    { apply cInf_le,
      { exact ‚ü®0, by { rintro b ‚ü®‚ü®u, v‚ü©, ‚ü®hu, hv‚ü©, rfl‚ü©, exact Hausdorff_dist_nonneg } ‚ü©},
      { simp, existsi [y, y], simpa } },
    { apply le_cInf,
      { exact (nonempty.prod ‚ü®y, hy‚ü© ‚ü®y, hy‚ü©).image _ },
      { rintro b ‚ü®‚ü®u, v‚ü©, ‚ü®hu, hv‚ü©, rfl‚ü©, exact Hausdorff_dist_nonneg } },
  end,
  dist_comm := Œª x y, begin
    have A : (Œª (p : nonempty_compacts ‚Ñì_infty_‚Ñù √ó nonempty_compacts ‚Ñì_infty_‚Ñù),
                 Hausdorff_dist (p.1 : set ‚Ñì_infty_‚Ñù) p.2) ''
             ({a | ‚ü¶a‚üß = x} √óÀ¢ {b | ‚ü¶b‚üß = y})
           = ((Œª (p : nonempty_compacts ‚Ñì_infty_‚Ñù √ó nonempty_compacts ‚Ñì_infty_‚Ñù),
                 Hausdorff_dist (p.1 : set ‚Ñì_infty_‚Ñù) p.2) ‚àò prod.swap) ''
                 ({a | ‚ü¶a‚üß = x} √óÀ¢ {b | ‚ü¶b‚üß = y}) :=
      by { congr, funext, simp, rw Hausdorff_dist_comm },
    simp only [dist, A, image_comp, image_swap_prod],
  end,
  eq_of_dist_eq_zero := Œª x y hxy, begin
    rcases GH_dist_eq_Hausdorff_dist x.rep y.rep with ‚ü®Œ¶, Œ®, Œ¶isom, Œ®isom, DŒ¶Œ®‚ü©,
    rw [‚Üê dist_GH_dist, hxy] at DŒ¶Œ®,
    have : range Œ¶ = range Œ®,
    { have hŒ¶ : is_compact (range Œ¶) := is_compact_range Œ¶isom.continuous,
      have hŒ® : is_compact (range Œ®) := is_compact_range Œ®isom.continuous,
      apply (is_closed.Hausdorff_dist_zero_iff_eq _ _ _).1 (DŒ¶Œ®.symm),
      { exact hŒ¶.is_closed },
      { exact hŒ®.is_closed },
      { exact Hausdorff_edist_ne_top_of_nonempty_of_bounded (range_nonempty _)
          (range_nonempty _) hŒ¶.bounded hŒ®.bounded } },
    have T : ((range Œ®) ‚âÉ·µ¢ y.rep) = ((range Œ¶) ‚âÉ·µ¢ y.rep), by rw this,
    have eŒ® := cast T Œ®isom.isometric_on_range.symm,
    have e := Œ¶isom.isometric_on_range.trans eŒ®,
    rw [‚Üê x.to_GH_space_rep, ‚Üê y.to_GH_space_rep, to_GH_space_eq_to_GH_space_iff_isometric],
    exact ‚ü®e‚ü©
  end,
  dist_triangle := Œª x y z, begin
    let X := x.rep,
    let Y := y.rep,
    let Z := z.rep,
    let Œ≥1 := optimal_GH_coupling X Y,
    let Œ≥2 := optimal_GH_coupling Y Z,
    let Œ¶ : Y ‚Üí Œ≥1 := optimal_GH_injr X Y,
    have hŒ¶ : isometry Œ¶ := isometry_optimal_GH_injr X Y,
    let Œ® : Y ‚Üí Œ≥2 := optimal_GH_injl Y Z,
    have hŒ® : isometry Œ® := isometry_optimal_GH_injl Y Z,
    let Œ≥ := glue_space hŒ¶ hŒ®,
    letI : metric_space Œ≥ := metric.metric_space_glue_space hŒ¶ hŒ®,
    have Comm : (to_glue_l hŒ¶ hŒ®) ‚àò (optimal_GH_injr X Y) =
      (to_glue_r hŒ¶ hŒ®) ‚àò (optimal_GH_injl Y Z) := to_glue_commute hŒ¶ hŒ®,
    calc dist x z = dist (to_GH_space X) (to_GH_space Z) :
        by rw [x.to_GH_space_rep, z.to_GH_space_rep]
      ... ‚â§ Hausdorff_dist (range ((to_glue_l hŒ¶ hŒ®) ‚àò (optimal_GH_injl X Y)))
                       (range ((to_glue_r hŒ¶ hŒ®) ‚àò (optimal_GH_injr Y Z))) :
        GH_dist_le_Hausdorff_dist
          ((to_glue_l_isometry hŒ¶ hŒ®).comp (isometry_optimal_GH_injl X Y))
          ((to_glue_r_isometry hŒ¶ hŒ®).comp (isometry_optimal_GH_injr Y Z))
      ... ‚â§ Hausdorff_dist (range ((to_glue_l hŒ¶ hŒ®) ‚àò (optimal_GH_injl X Y)))
                           (range ((to_glue_l hŒ¶ hŒ®) ‚àò (optimal_GH_injr X Y)))
          + Hausdorff_dist (range ((to_glue_l hŒ¶ hŒ®) ‚àò (optimal_GH_injr X Y)))
                           (range ((to_glue_r hŒ¶ hŒ®) ‚àò (optimal_GH_injr Y Z))) :
        begin
          refine Hausdorff_dist_triangle (Hausdorff_edist_ne_top_of_nonempty_of_bounded
            (range_nonempty _) (range_nonempty _) _ _),
          { exact (is_compact_range (isometry.continuous ((to_glue_l_isometry hŒ¶ hŒ®).comp
              (isometry_optimal_GH_injl X Y)))).bounded },
          { exact (is_compact_range (isometry.continuous ((to_glue_l_isometry hŒ¶ hŒ®).comp
              (isometry_optimal_GH_injr X Y)))).bounded }
        end
      ... = Hausdorff_dist ((to_glue_l hŒ¶ hŒ®) '' (range (optimal_GH_injl X Y)))
                           ((to_glue_l hŒ¶ hŒ®) '' (range (optimal_GH_injr X Y)))
          + Hausdorff_dist ((to_glue_r hŒ¶ hŒ®) '' (range (optimal_GH_injl Y Z)))
                           ((to_glue_r hŒ¶ hŒ®) '' (range (optimal_GH_injr Y Z))) :
        by simp only [‚Üê range_comp, Comm, eq_self_iff_true, add_right_inj]
      ... = Hausdorff_dist (range (optimal_GH_injl X Y))
                           (range (optimal_GH_injr X Y))
          + Hausdorff_dist (range (optimal_GH_injl Y Z))
                           (range (optimal_GH_injr Y Z)) :
        by rw [Hausdorff_dist_image (to_glue_l_isometry hŒ¶ hŒ®),
               Hausdorff_dist_image (to_glue_r_isometry hŒ¶ hŒ®)]
      ... = dist (to_GH_space X) (to_GH_space Y) + dist (to_GH_space Y) (to_GH_space Z) :
        by rw [Hausdorff_dist_optimal, Hausdorff_dist_optimal, GH_dist, GH_dist]
      ... = dist x y + dist y z:
        by rw [x.to_GH_space_rep, y.to_GH_space_rep, z.to_GH_space_rep]
  end }
definition topological_space.nonempty_compacts.to_GH_space {X : Type u} [metric_space X]
  (p : nonempty_compacts X) : Gromov_Hausdorff.GH_space := Gromov_Hausdorff.to_GH_space p
open topological_space
namespace Gromov_Hausdorff
section nonempty_compacts
variables {X : Type u} [metric_space X]
theorem GH_dist_le_nonempty_compacts_dist (p q : nonempty_compacts X) :
  dist p.to_GH_space q.to_GH_space ‚â§ dist p q :=
begin
  have ha : isometry (coe : p ‚Üí X) := isometry_subtype_coe,
  have hb : isometry (coe : q ‚Üí X) := isometry_subtype_coe,
  have A : dist p q = Hausdorff_dist (p : set X) q := rfl,
  have I : ‚Üëp = range (coe : p ‚Üí X) := subtype.range_coe_subtype.symm,
  have J : ‚Üëq = range (coe : q ‚Üí X) := subtype.range_coe_subtype.symm,
  rw [A, I, J],
  exact GH_dist_le_Hausdorff_dist ha hb
end
lemma to_GH_space_lipschitz :
  lipschitz_with 1 (nonempty_compacts.to_GH_space : nonempty_compacts X ‚Üí GH_space) :=
lipschitz_with.mk_one GH_dist_le_nonempty_compacts_dist
lemma to_GH_space_continuous :
  continuous (nonempty_compacts.to_GH_space : nonempty_compacts X ‚Üí GH_space) :=
to_GH_space_lipschitz.continuous
end nonempty_compacts
section
variables {X : Type u} [metric_space X] [compact_space X] [nonempty X]
          {Y : Type v} [metric_space Y] [compact_space Y] [nonempty Y]
theorem GH_dist_le_of_approx_subsets {s : set X} (Œ¶ : s ‚Üí Y) {Œµ‚ÇÅ Œµ‚ÇÇ Œµ‚ÇÉ : ‚Ñù}
  (hs : ‚àÄ x : X, ‚àÉ y ‚àà s, dist x y ‚â§ Œµ‚ÇÅ) (hs' : ‚àÄ x : Y, ‚àÉ y : s, dist x (Œ¶ y) ‚â§ Œµ‚ÇÉ)
  (H : ‚àÄ x y : s, |dist x y - dist (Œ¶ x) (Œ¶ y)| ‚â§ Œµ‚ÇÇ) :
  GH_dist X Y ‚â§ Œµ‚ÇÅ + Œµ‚ÇÇ / 2 + Œµ‚ÇÉ :=
begin
  refine le_of_forall_pos_le_add (Œª Œ¥ Œ¥0, _),
  rcases exists_mem_of_nonempty X with ‚ü®xX, _‚ü©,
  rcases hs xX with ‚ü®xs, hxs, Dxs‚ü©,
  have sne : s.nonempty := ‚ü®xs, hxs‚ü©,
  letI : nonempty s := sne.to_subtype,
  have : 0 ‚â§ Œµ‚ÇÇ := le_trans (abs_nonneg _) (H ‚ü®xs, hxs‚ü© ‚ü®xs, hxs‚ü©),
  have : ‚àÄ p q : s, |dist p q - dist (Œ¶ p) (Œ¶ q)| ‚â§ 2 * (Œµ‚ÇÇ/2 + Œ¥) := Œª p q, calc
    |dist p q - dist (Œ¶ p) (Œ¶ q)| ‚â§ Œµ‚ÇÇ : H p q
    ... ‚â§ 2 * (Œµ‚ÇÇ/2 + Œ¥) : by linarith,
  have : GH_dist X Y ‚â§ Hausdorff_dist (range Fl) (range Fr) :=
    GH_dist_le_Hausdorff_dist Il Ir,
  have : Hausdorff_dist (range Fl) (range Fr) ‚â§ Hausdorff_dist (range Fl) (Fl '' s)
                                              + Hausdorff_dist (Fl '' s) (range Fr),
  { have B : bounded (range Fl) := (is_compact_range Il.continuous).bounded,
    exact Hausdorff_dist_triangle (Hausdorff_edist_ne_top_of_nonempty_of_bounded
      (range_nonempty _) (sne.image _) B (B.mono (image_subset_range _ _))) },
  have : Hausdorff_dist (Fl '' s) (range Fr) ‚â§ Hausdorff_dist (Fl '' s) (Fr '' (range Œ¶))
                                             + Hausdorff_dist (Fr '' (range Œ¶)) (range Fr),
  { have B : bounded (range Fr) := (is_compact_range Ir.continuous).bounded,
    exact Hausdorff_dist_triangle' (Hausdorff_edist_ne_top_of_nonempty_of_bounded
      ((range_nonempty _).image _) (range_nonempty _)
      (bounded.mono (image_subset_range _ _) B) B) },
  have : Hausdorff_dist (range Fl) (Fl '' s) ‚â§ Œµ‚ÇÅ,
  { rw [‚Üê image_univ, Hausdorff_dist_image Il],
    have : 0 ‚â§ Œµ‚ÇÅ := le_trans dist_nonneg Dxs,
    refine Hausdorff_dist_le_of_mem_dist this (Œª x hx, hs x)
      (Œª x hx, ‚ü®x, mem_univ _, by simpa‚ü©) },
  have : Hausdorff_dist (Fl '' s) (Fr '' (range Œ¶)) ‚â§ Œµ‚ÇÇ/2 + Œ¥,
  { refine Hausdorff_dist_le_of_mem_dist (by linarith) _ _,
    { assume x' hx',
      rcases (set.mem_image _ _ _).1 hx' with ‚ü®x, ‚ü®x_in_s, xx'‚ü©‚ü©,
      rw ‚Üê xx',
      use [Fr (Œ¶ ‚ü®x, x_in_s‚ü©), mem_image_of_mem Fr (mem_range_self _)],
      exact le_of_eq (glue_dist_glued_points (Œª x:s, (x:X)) Œ¶ (Œµ‚ÇÇ/2 + Œ¥) ‚ü®x, x_in_s‚ü©) },
    { assume x' hx',
      rcases (set.mem_image _ _ _).1 hx' with ‚ü®y, ‚ü®y_in_s', yx'‚ü©‚ü©,
      rcases mem_range.1 y_in_s' with ‚ü®x, xy‚ü©,
      use [Fl x, mem_image_of_mem _ x.2],
      rw [‚Üê yx', ‚Üê xy, dist_comm],
      exact le_of_eq (glue_dist_glued_points (@subtype.val X s) Œ¶ (Œµ‚ÇÇ/2 + Œ¥) x) } },
  have : Hausdorff_dist (Fr '' (range Œ¶)) (range Fr) ‚â§ Œµ‚ÇÉ,
  { rw [‚Üê @image_univ _ _ Fr, Hausdorff_dist_image Ir],
    rcases exists_mem_of_nonempty Y with ‚ü®xY, _‚ü©,
    rcases hs' xY with ‚ü®xs', Dxs'‚ü©,
    have : 0 ‚â§ Œµ‚ÇÉ := le_trans dist_nonneg Dxs',
    refine Hausdorff_dist_le_of_mem_dist this (Œª x hx, ‚ü®x, mem_univ _, by simpa‚ü©) (Œª x _, _),
    rcases hs' x with ‚ü®y, Dy‚ü©,
    exact ‚ü®Œ¶ y, mem_range_self _, Dy‚ü© },
  linarith
end
instance : second_countable_topology GH_space :=
begin
  refine second_countable_of_countable_discretization (Œª Œ¥ Œ¥pos, _),
  let Œµ := (2/5) * Œ¥,
  have Œµpos : 0 < Œµ := mul_pos (by norm_num) Œ¥pos,
  have : ‚àÄ p:GH_space, ‚àÉ s : set p.rep, s.finite ‚àß (univ ‚äÜ (‚ãÉx‚ààs, ball x Œµ)) :=
    Œª p, by simpa using finite_cover_balls_of_compact (@compact_univ p.rep _ _) Œµpos,
  have Npq : N p = N q := (sigma.mk.inj_iff.1 hpq).1,
  let Œ® : s p ‚Üí s q := Œª x, (E q).symm (fin.cast Npq ((E p) x)),
  let Œ¶ : s p ‚Üí q.rep := Œª x, Œ® x,
      assume x y,
      have : dist (Œ¶ x) (Œ¶ y) = dist (Œ® x) (Œ® y) := rfl,
      rw this,
lemma totally_bounded {t : set GH_space} {C : ‚Ñù} {u : ‚Ñï ‚Üí ‚Ñù} {K : ‚Ñï ‚Üí ‚Ñï}
  (ulim : tendsto u at_top (ùìù 0))
  (hdiam : ‚àÄ p ‚àà t, diam (univ : set (GH_space.rep p)) ‚â§ C)
  (hcov : ‚àÄ p ‚àà t, ‚àÄ n:‚Ñï, ‚àÉ s : set (GH_space.rep p),
    cardinal.mk s ‚â§ K n ‚àß univ ‚äÜ ‚ãÉx‚ààs, ball x (u n)) :
  totally_bounded t :=
begin
  refine metric.totally_bounded_of_finite_discretization (Œª Œ¥ Œ¥pos, _),
  let Œµ := (1/5) * Œ¥,
  have Œµpos : 0 < Œµ := mul_pos (by norm_num) Œ¥pos,
      assume x y,
      have : dist (Œ¶ x) (Œ¶ y) = dist (Œ® x) (Œ® y) := rfl,
      rw this,
variables (X : ‚Ñï ‚Üí Type) [‚àÄ n, metric_space (X n)] [‚àÄ n, compact_space (X n)] [‚àÄ n, nonempty (X n)]
structure aux_gluing_struct (A : Type) [metric_space A] : Type 1 :=
(space  : Type)
(metric : metric_space space)
(embed  : A ‚Üí space)
(isom   : isometry embed)
instance (A : Type) [metric_space A] : inhabited (aux_gluing_struct A) :=
‚ü®{ space := A,
  metric := by apply_instance,
  embed := id,
  isom := Œª x y, rfl }‚ü©
def aux_gluing (n : ‚Ñï) : aux_gluing_struct (X n) := nat.rec_on n
  { space  := X 0,
    metric := by apply_instance,
    embed  := id,
    isom   := Œª x y, rfl }
(Œª n Y, by letI : metric_space Y.space := Y.metric; exact
  { space  := glue_space Y.isom (isometry_optimal_GH_injl (X n) (X (n+1))),
    metric := by apply_instance,
    embed  := (to_glue_r Y.isom (isometry_optimal_GH_injl (X n) (X (n+1))))
              ‚àò (optimal_GH_injr (X n) (X (n+1))),
    isom   := (to_glue_r_isometry _ _).comp (isometry_optimal_GH_injr (X n) (X (n+1))) })
instance : complete_space GH_space :=
begin
  have : ‚àÄ (n : ‚Ñï), 0 < ((1:‚Ñù) / 2) ^ n, by { apply pow_pos, norm_num },
