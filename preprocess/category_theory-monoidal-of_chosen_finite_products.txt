import category_theory.monoidal.braided
import category_theory.limits.shapes.binary_products
import category_theory.limits.shapes.terminal
import category_theory.pempty
universes v u
noncomputable theory
namespace category_theory
variables (C : Type u) [category.{v} C] {X Y : C}
namespace limits
section
variables {C}
def binary_fan.swap {P Q : C} (t : binary_fan P Q) : binary_fan Q P :=
binary_fan.mk t.snd t.fst
@[simp] lemma binary_fan.swap_fst {P Q : C} (t : binary_fan P Q) : t.swap.fst = t.snd := rfl
@[simp] lemma binary_fan.swap_snd {P Q : C} (t : binary_fan P Q) : t.swap.snd = t.fst := rfl
@[simps]
def is_limit.swap_binary_fan {P Q : C} {t : binary_fan P Q} (I : is_limit t) : is_limit t.swap :=
{ lift := Î» s, I.lift (binary_fan.swap s),
  fac' := Î» s, by { rintro âŸ¨âŸ¨âŸ©âŸ©; simp, },
  uniq' := Î» s m w,
  begin
    have h := I.uniq (binary_fan.swap s) m,
    rw h,
    rintro âŸ¨jâŸ©,
    specialize w âŸ¨j.swapâŸ©,
    cases j; exact w,
  end }
lemma has_binary_product.swap (P Q : C) [has_binary_product P Q] : has_binary_product Q P :=
has_limit.mk âŸ¨binary_fan.swap (limit.cone (pair P Q)), (limit.is_limit (pair P Q)).swap_binary_fanâŸ©
def binary_fan.braiding {X Y : C}
  {s : binary_fan X Y} (P : is_limit s) {t : binary_fan Y X} (Q : is_limit t) :
  s.X â‰… t.X :=
is_limit.cone_point_unique_up_to_iso P Q.swap_binary_fan
def binary_fan.assoc {X Y Z : C}
  {sXY : binary_fan X Y} {sYZ : binary_fan Y Z} (Q : is_limit sYZ) (s : binary_fan sXY.X Z) :
  binary_fan X sYZ.X :=
binary_fan.mk (s.fst â‰« sXY.fst) (Q.lift (binary_fan.mk (s.fst â‰« sXY.snd) s.snd))
@[simp] lemma binary_fan.assoc_fst {X Y Z : C}
  {sXY : binary_fan X Y} {sYZ : binary_fan Y Z} (Q : is_limit sYZ) (s : binary_fan sXY.X Z) :
  (s.assoc Q).fst = s.fst â‰« sXY.fst := rfl
@[simp] lemma binary_fan.assoc_snd {X Y Z : C}
  {sXY : binary_fan X Y} {sYZ : binary_fan Y Z} (Q : is_limit sYZ) (s : binary_fan sXY.X Z) :
  (s.assoc Q).snd = Q.lift (binary_fan.mk (s.fst â‰« sXY.snd) s.snd) := rfl
def binary_fan.assoc_inv {X Y Z : C}
  {sXY : binary_fan X Y} (P : is_limit sXY) {sYZ : binary_fan Y Z} (s : binary_fan X sYZ.X) :
  binary_fan sXY.X Z :=
binary_fan.mk (P.lift (binary_fan.mk s.fst (s.snd â‰« sYZ.fst))) (s.snd â‰« sYZ.snd)
@[simp] lemma binary_fan.assoc_inv_fst {X Y Z : C}
  {sXY : binary_fan X Y} (P : is_limit sXY) {sYZ : binary_fan Y Z} (s : binary_fan X sYZ.X) :
  (s.assoc_inv P).fst = P.lift (binary_fan.mk s.fst (s.snd â‰« sYZ.fst)) := rfl
@[simp] lemma binary_fan.assoc_inv_snd {X Y Z : C}
  {sXY : binary_fan X Y} (P : is_limit sXY) {sYZ : binary_fan Y Z} (s : binary_fan X sYZ.X) :
  (s.assoc_inv P).snd = s.snd â‰« sYZ.snd := rfl
@[simps]
def is_limit.assoc {X Y Z : C}
  {sXY : binary_fan X Y} (P : is_limit sXY) {sYZ : binary_fan Y Z} (Q : is_limit sYZ)
  {s : binary_fan sXY.X Z} (R : is_limit s) : is_limit (s.assoc Q) :=
{ lift := Î» t, R.lift (binary_fan.assoc_inv P t),
  fac' := Î» t,
  begin
    rintro âŸ¨âŸ¨âŸ©âŸ©; simp,
    apply Q.hom_ext,
    rintro âŸ¨âŸ¨âŸ©âŸ©; simp,
  end,
  uniq' := Î» t m w,
  begin
    have h := R.uniq (binary_fan.assoc_inv P t) m,
    rw h,
    rintro âŸ¨âŸ¨âŸ©âŸ©; simp,
    apply P.hom_ext,
    rintro âŸ¨âŸ¨âŸ©âŸ©; simp,
    { exact w âŸ¨walking_pair.leftâŸ©, },
    { specialize w âŸ¨walking_pair.rightâŸ©,
      simp at w,
      rw [â†w], simp, },
    { specialize w âŸ¨walking_pair.rightâŸ©,
      simp at w,
      rw [â†w], simp, },
  end, }
@[reducible]
def binary_fan.associator {X Y Z : C}
  {sXY : binary_fan X Y} (P : is_limit sXY) {sYZ : binary_fan Y Z} (Q : is_limit sYZ)
  {s : binary_fan sXY.X Z} (R : is_limit s) {t : binary_fan X sYZ.X} (S : is_limit t) :
  s.X â‰… t.X :=
is_limit.cone_point_unique_up_to_iso (is_limit.assoc P Q R) S
@[reducible]
def binary_fan.associator_of_limit_cone
  (L : Î  X Y : C, limit_cone (pair X Y)) (X Y Z : C) :
  (L (L X Y).cone.X Z).cone.X â‰… (L X (L Y Z).cone.X).cone.X :=
binary_fan.associator
  (L X Y).is_limit (L Y Z).is_limit
  (L (L X Y).cone.X Z).is_limit (L X (L Y Z).cone.X).is_limit
local attribute [tidy] tactic.discrete_cases
@[simps]
def binary_fan.left_unitor {X : C} {s : cone (functor.empty.{v} C)} (P : is_limit s)
  {t : binary_fan s.X X} (Q : is_limit t) : t.X â‰… X :=
{ hom := t.snd,
  inv := Q.lift (binary_fan.mk (P.lift
    { X := X, Ï€ := { app := discrete.rec (pempty.rec _) } }) (ğŸ™ X) ),
  hom_inv_id' :=
  by { apply Q.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©, { apply P.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©, }, { simp, }, }, }
@[simps]
def binary_fan.right_unitor {X : C} {s : cone (functor.empty.{v} C)} (P : is_limit s)
  {t : binary_fan X s.X} (Q : is_limit t) : t.X â‰… X :=
{ hom := t.fst,
  inv := Q.lift (binary_fan.mk (ğŸ™ X) (P.lift
    { X := X, Ï€ := { app := discrete.rec (pempty.rec _) } })),
  hom_inv_id' :=
  by { apply Q.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©, { simp, }, { apply P.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©, }, }, }
end
end limits
open category_theory.limits
section
local attribute [tidy] tactic.case_bash
variables {C}
variables (ğ’¯ : limit_cone (functor.empty.{v} C))
variables (â„¬ : Î  (X Y : C), limit_cone (pair X Y))
namespace monoidal_of_chosen_finite_products
@[reducible]
def tensor_obj (X Y : C) : C := (â„¬ X Y).cone.X
@[reducible]
def tensor_hom {W X Y Z : C} (f : W âŸ¶ X) (g : Y âŸ¶ Z) : tensor_obj â„¬ W Y âŸ¶ tensor_obj â„¬ X Z :=
  (binary_fan.is_limit.lift' (â„¬ X Z).is_limit
    ((â„¬ W Y).cone.Ï€.app âŸ¨walking_pair.leftâŸ© â‰« f)
    (((â„¬ W Y).cone.Ï€.app âŸ¨walking_pair.rightâŸ© : (â„¬ W Y).cone.X âŸ¶ Y) â‰« g)).val
lemma tensor_id (Xâ‚ Xâ‚‚ : C) : tensor_hom â„¬ (ğŸ™ Xâ‚) (ğŸ™ Xâ‚‚) = ğŸ™ (tensor_obj â„¬ Xâ‚ Xâ‚‚) :=
begin
  apply is_limit.hom_ext (â„¬ _ _).is_limit, rintro âŸ¨âŸ¨âŸ©âŸ©;
  { dsimp [tensor_hom], simp, },
end
lemma tensor_comp {Xâ‚ Yâ‚ Zâ‚ Xâ‚‚ Yâ‚‚ Zâ‚‚ : C}
  (fâ‚ : Xâ‚ âŸ¶ Yâ‚) (fâ‚‚ : Xâ‚‚ âŸ¶ Yâ‚‚) (gâ‚ : Yâ‚ âŸ¶ Zâ‚) (gâ‚‚ : Yâ‚‚ âŸ¶ Zâ‚‚) :
  tensor_hom â„¬ (fâ‚ â‰« gâ‚) (fâ‚‚ â‰« gâ‚‚) =
    tensor_hom â„¬ fâ‚ fâ‚‚ â‰« tensor_hom â„¬ gâ‚ gâ‚‚ :=
begin
  apply is_limit.hom_ext (â„¬ _ _).is_limit, rintro âŸ¨âŸ¨âŸ©âŸ©;
  { dsimp [tensor_hom], simp, },
end
lemma pentagon (W X Y Z : C) :
  tensor_hom â„¬ (binary_fan.associator_of_limit_cone â„¬ W X Y).hom (ğŸ™ Z) â‰«
    (binary_fan.associator_of_limit_cone â„¬ W (tensor_obj â„¬ X Y) Z).hom â‰«
      tensor_hom â„¬ (ğŸ™ W) (binary_fan.associator_of_limit_cone â„¬ X Y Z).hom =
  (binary_fan.associator_of_limit_cone â„¬ (tensor_obj â„¬ W X) Y Z).hom â‰«
    (binary_fan.associator_of_limit_cone â„¬ W X (tensor_obj â„¬ Y Z)).hom :=
begin
  dsimp [tensor_hom],
  apply is_limit.hom_ext (â„¬ _ _).is_limit, rintro âŸ¨âŸ¨âŸ©âŸ©,
  { simp, },
  { apply is_limit.hom_ext (â„¬ _ _).is_limit, rintro âŸ¨âŸ¨âŸ©âŸ©,
    { simp, },
    apply is_limit.hom_ext (â„¬ _ _).is_limit, rintro âŸ¨âŸ¨âŸ©âŸ©,
    { simp, },
    { simp, }, }
end
lemma triangle (X Y : C) :
  (binary_fan.associator_of_limit_cone â„¬ X ğ’¯.cone.X Y).hom â‰«
    tensor_hom â„¬ (ğŸ™ X) (binary_fan.left_unitor ğ’¯.is_limit (â„¬ ğ’¯.cone.X Y).is_limit).hom =
  tensor_hom â„¬ (binary_fan.right_unitor ğ’¯.is_limit (â„¬ X ğ’¯.cone.X).is_limit).hom (ğŸ™ Y) :=
begin
  dsimp [tensor_hom],
  apply is_limit.hom_ext (â„¬ _ _).is_limit, rintro âŸ¨âŸ¨âŸ©âŸ©; simp,
end
lemma left_unitor_naturality {Xâ‚ Xâ‚‚ : C} (f : Xâ‚ âŸ¶ Xâ‚‚) :
  tensor_hom â„¬ (ğŸ™ ğ’¯.cone.X) f â‰« (binary_fan.left_unitor ğ’¯.is_limit (â„¬ ğ’¯.cone.X Xâ‚‚).is_limit).hom =
    (binary_fan.left_unitor ğ’¯.is_limit (â„¬ ğ’¯.cone.X Xâ‚).is_limit).hom â‰« f :=
begin
  dsimp [tensor_hom],
  simp,
end
lemma right_unitor_naturality {Xâ‚ Xâ‚‚ : C} (f : Xâ‚ âŸ¶ Xâ‚‚) :
  tensor_hom â„¬ f (ğŸ™ ğ’¯.cone.X) â‰«
    (binary_fan.right_unitor ğ’¯.is_limit (â„¬ Xâ‚‚ ğ’¯.cone.X).is_limit).hom =
    (binary_fan.right_unitor ğ’¯.is_limit (â„¬ Xâ‚ ğ’¯.cone.X).is_limit).hom â‰« f :=
begin
  dsimp [tensor_hom],
  simp,
end
lemma associator_naturality {Xâ‚ Xâ‚‚ Xâ‚ƒ Yâ‚ Yâ‚‚ Yâ‚ƒ : C} (fâ‚ : Xâ‚ âŸ¶ Yâ‚) (fâ‚‚ : Xâ‚‚ âŸ¶ Yâ‚‚) (fâ‚ƒ : Xâ‚ƒ âŸ¶ Yâ‚ƒ) :
  tensor_hom â„¬ (tensor_hom â„¬ fâ‚ fâ‚‚) fâ‚ƒ â‰« (binary_fan.associator_of_limit_cone â„¬ Yâ‚ Yâ‚‚ Yâ‚ƒ).hom =
    (binary_fan.associator_of_limit_cone â„¬ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom â‰«
      tensor_hom â„¬ fâ‚ (tensor_hom â„¬ fâ‚‚ fâ‚ƒ) :=
begin
  dsimp [tensor_hom],
  apply is_limit.hom_ext (â„¬ _ _).is_limit, rintro âŸ¨âŸ¨âŸ©âŸ©,
  { simp, },
  { apply is_limit.hom_ext (â„¬ _ _).is_limit, rintro âŸ¨âŸ¨âŸ©âŸ©,
    { simp, },
    { simp, }, },
end
end monoidal_of_chosen_finite_products
open monoidal_of_chosen_finite_products
def monoidal_of_chosen_finite_products :
  monoidal_category C :=
{ tensor_unit  := ğ’¯.cone.X,
  tensor_obj   := Î» X Y, tensor_obj â„¬ X Y,
  tensor_hom   := Î» _ _ _ _ f g, tensor_hom â„¬ f g,
  tensor_id'   := tensor_id â„¬,
  tensor_comp' := Î» _ _ _ _ _ _ fâ‚ fâ‚‚ gâ‚ gâ‚‚, tensor_comp â„¬ fâ‚ fâ‚‚ gâ‚ gâ‚‚,
  associator   := Î» X Y Z, binary_fan.associator_of_limit_cone â„¬ X Y Z,
  left_unitor  := Î» X, binary_fan.left_unitor (ğ’¯.is_limit) (â„¬ ğ’¯.cone.X X).is_limit,
  right_unitor := Î» X, binary_fan.right_unitor (ğ’¯.is_limit) (â„¬ X ğ’¯.cone.X).is_limit,
  pentagon'    := pentagon â„¬,
  triangle'    := triangle ğ’¯ â„¬,
  left_unitor_naturality' := Î» _ _ f, left_unitor_naturality ğ’¯ â„¬ f,
  right_unitor_naturality' := Î» _ _ f, right_unitor_naturality ğ’¯ â„¬ f,
  associator_naturality' := Î» _ _ _ _ _ _ fâ‚ fâ‚‚ fâ‚ƒ, associator_naturality â„¬ fâ‚ fâ‚‚ fâ‚ƒ, }
namespace monoidal_of_chosen_finite_products
open monoidal_category
@[derive category, nolint unused_arguments has_inhabited_instance]
def monoidal_of_chosen_finite_products_synonym
  (ğ’¯ : limit_cone (functor.empty.{v} C)) (â„¬ : Î  (X Y : C), limit_cone (pair X Y)):= C
instance : monoidal_category (monoidal_of_chosen_finite_products_synonym ğ’¯ â„¬) :=
monoidal_of_chosen_finite_products ğ’¯ â„¬
lemma braiding_naturality {X X' Y Y' : C} (f : X âŸ¶ Y) (g : X' âŸ¶ Y') :
  (tensor_hom â„¬ f g) â‰« (limits.binary_fan.braiding (â„¬ Y Y').is_limit (â„¬ Y' Y).is_limit).hom =
    (limits.binary_fan.braiding (â„¬ X X').is_limit (â„¬ X' X).is_limit).hom â‰« (tensor_hom â„¬ g f) :=
begin
  dsimp [tensor_hom, limits.binary_fan.braiding],
  apply (â„¬ _ _).is_limit.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©;
  { dsimp [limits.is_limit.cone_point_unique_up_to_iso], simp, },
end
lemma hexagon_forward (X Y Z : C) :
  (binary_fan.associator_of_limit_cone â„¬ X Y Z).hom â‰«
    (limits.binary_fan.braiding
      (â„¬ X (tensor_obj â„¬ Y Z)).is_limit
      (â„¬ (tensor_obj â„¬ Y Z) X).is_limit).hom â‰«
    (binary_fan.associator_of_limit_cone â„¬ Y Z X).hom =
    (tensor_hom â„¬ (limits.binary_fan.braiding (â„¬ X Y).is_limit (â„¬ Y X).is_limit).hom (ğŸ™ Z)) â‰«
      (binary_fan.associator_of_limit_cone â„¬ Y X Z).hom â‰«
        (tensor_hom â„¬ (ğŸ™ Y) (limits.binary_fan.braiding (â„¬ X Z).is_limit (â„¬ Z X).is_limit).hom) :=
begin
  dsimp [tensor_hom, limits.binary_fan.braiding],
  apply (â„¬ _ _).is_limit.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©,
  { dsimp [limits.is_limit.cone_point_unique_up_to_iso], simp, },
  { apply (â„¬ _ _).is_limit.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©;
    { dsimp [limits.is_limit.cone_point_unique_up_to_iso], simp, }, }
end
lemma hexagon_reverse (X Y Z : C) :
  (binary_fan.associator_of_limit_cone â„¬ X Y Z).inv â‰«
    (limits.binary_fan.braiding
      (â„¬ (tensor_obj â„¬ X Y) Z).is_limit
      (â„¬ Z (tensor_obj â„¬ X Y)).is_limit).hom â‰«
    (binary_fan.associator_of_limit_cone â„¬ Z X Y).inv =
    (tensor_hom â„¬ (ğŸ™ X) (limits.binary_fan.braiding (â„¬ Y Z).is_limit (â„¬ Z Y).is_limit).hom) â‰«
      (binary_fan.associator_of_limit_cone â„¬ X Z Y).inv â‰«
        (tensor_hom â„¬ (limits.binary_fan.braiding (â„¬ X Z).is_limit (â„¬ Z X).is_limit).hom (ğŸ™ Y)) :=
begin
  dsimp [tensor_hom, limits.binary_fan.braiding],
  apply (â„¬ _ _).is_limit.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©,
  { apply (â„¬ _ _).is_limit.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©;
    { dsimp [binary_fan.associator_of_limit_cone, binary_fan.associator,
        limits.is_limit.cone_point_unique_up_to_iso],
      simp, }, },
  { dsimp [binary_fan.associator_of_limit_cone, binary_fan.associator,
      limits.is_limit.cone_point_unique_up_to_iso],
    simp, },
end
lemma symmetry (X Y : C) :
  (limits.binary_fan.braiding (â„¬ X Y).is_limit (â„¬ Y X).is_limit).hom â‰«
      (limits.binary_fan.braiding (â„¬ Y X).is_limit (â„¬ X Y).is_limit).hom =
    ğŸ™ (tensor_obj â„¬ X Y) :=
begin
  dsimp [tensor_hom, limits.binary_fan.braiding],
  apply (â„¬ _ _).is_limit.hom_ext, rintro âŸ¨âŸ¨âŸ©âŸ©;
  { dsimp [limits.is_limit.cone_point_unique_up_to_iso], simp, },
end
end monoidal_of_chosen_finite_products
open monoidal_of_chosen_finite_products
def symmetric_of_chosen_finite_products :
  symmetric_category (monoidal_of_chosen_finite_products_synonym ğ’¯ â„¬) :=
{ braiding := Î» X Y, limits.binary_fan.braiding (â„¬ _ _).is_limit (â„¬ _ _).is_limit,
  braiding_naturality' := Î» X X' Y Y' f g, braiding_naturality â„¬ f g,
  hexagon_forward' := Î» X Y Z, hexagon_forward â„¬ X Y Z,
  hexagon_reverse' := Î» X Y Z, hexagon_reverse â„¬ X Y Z,
  symmetry' := Î» X Y, symmetry â„¬ X Y, }
end
end category_theory
