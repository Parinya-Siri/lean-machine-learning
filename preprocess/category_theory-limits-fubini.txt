import category_theory.limits.has_limits
import category_theory.products.basic
import category_theory.functor.currying
universes v u
open category_theory
namespace category_theory.limits
variables {J K : Type v} [small_category J] [small_category K]
variables {C : Type u} [category.{v} C]
variables (F : J â¥¤ K â¥¤ C)
@[simps]
def diagram_of_cones.cone_points (D : diagram_of_cones F) :
  J â¥¤ C :=
{ obj := Î» j, (D.obj j).X,
  map := Î» j j' f, (D.map f).hom,
  map_id' := Î» j, D.id j,
  map_comp' := Î» jâ‚ jâ‚‚ jâ‚ƒ f g, D.comp f g, }
@[simps]
def cone_of_cone_uncurry
  {D : diagram_of_cones F} (Q : Î  j, is_limit (D.obj j))
  (c : cone (uncurry.obj F)) :
  cone (D.cone_points) :=
{ X := c.X,
  Ï€ :=
  { app := Î» j, (Q j).lift
    { X := c.X,
      Ï€ :=
      { app := Î» k, c.Ï€.app (j, k),
        naturality' := Î» k k' f,
        begin
          dsimp, simp only [category.id_comp],
          have := @nat_trans.naturality _ _ _ _ _ _ c.Ï€ (j, k) (j, k') (ğŸ™ j, f),
          dsimp at this,
          simp only [category.id_comp, category_theory.functor.map_id, nat_trans.id_app] at this,
          exact this,
        end } },
    naturality' := Î» j j' f, (Q j').hom_ext
    begin
      dsimp,
      intro k,
      simp only [limits.cone_morphism.w, limits.cones.postcompose_obj_Ï€, limits.is_limit.fac_assoc,
        limits.is_limit.fac, nat_trans.comp_app, category.id_comp, category.assoc],
      have := @nat_trans.naturality _ _ _ _ _ _ c.Ï€ (j, k) (j', k) (f, ğŸ™ k),
      dsimp at this,
      simp only [category.id_comp, category.comp_id,
        category_theory.functor.map_id, nat_trans.id_app] at this,
      exact this,
    end, } }.
def cone_of_cone_uncurry_is_limit
  {D : diagram_of_cones F} (Q : Î  j, is_limit (D.obj j))
  {c : cone (uncurry.obj F)} (P : is_limit c) :
  is_limit (cone_of_cone_uncurry Q c) :=
{ lift := Î» s, P.lift
  { X := s.X,
    Ï€ :=
    { app := Î» p, s.Ï€.app p.1 â‰« (D.obj p.1).Ï€.app p.2,
      naturality' := Î» p p' f,
      begin
        dsimp, simp only [category.id_comp, category.assoc],
        rcases p with âŸ¨j, kâŸ©,
        rcases p' with âŸ¨j', k'âŸ©,
        rcases f with âŸ¨fj, fkâŸ©,
        dsimp,
        slice_rhs 3 4 { rw â†nat_trans.naturality, },
        slice_rhs 2 3 { rw â†(D.obj j).Ï€.naturality, },
        simp only [functor.const.obj_map, category.id_comp, category.assoc],
        have w := (D.map fj).w k',
        dsimp at w,
        rw â†w,
        have n := s.Ï€.naturality fj,
        dsimp at n,
        simp only [category.id_comp] at n,
        rw n,
        simp,
      end, } },
  fac' := Î» s j,
  begin
    apply (Q j).hom_ext,
    intro k,
    simp,
  end,
  uniq' := Î» s m w,
  begin
    refine P.uniq { X := s.X, Ï€ := _, } m _,
    rintro âŸ¨j, kâŸ©,
    dsimp,
    rw [â†w j],
    simp,
  end, }
section
variables (F)
variables [has_limits_of_shape K C]
@[simps]
noncomputable def diagram_of_cones.mk_of_has_limits : diagram_of_cones F :=
{ obj := Î» j, limit.cone (F.obj j),
  map := Î» j j' f, { hom := lim.map (F.map f), }, }
noncomputable def limit_uncurry_iso_limit_comp_lim : limit (uncurry.obj F) â‰… limit (F â‹™ lim) :=
begin
  let c := limit.cone (uncurry.obj F),
  let P : is_limit c := limit.is_limit _,
  let G := diagram_of_cones.mk_of_has_limits F,
  let Q : Î  j, is_limit (G.obj j) := Î» j, limit.is_limit _,
  have Q' := cone_of_cone_uncurry_is_limit Q P,
  have Q'' := (limit.is_limit (F â‹™ lim)),
  exact is_limit.cone_point_unique_up_to_iso Q' Q'',
end
@[simp, reassoc]
lemma limit_uncurry_iso_limit_comp_lim_hom_Ï€_Ï€ {j} {k} :
  (limit_uncurry_iso_limit_comp_lim F).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k = limit.Ï€ _ (j, k) :=
begin
  dsimp [limit_uncurry_iso_limit_comp_lim, is_limit.cone_point_unique_up_to_iso,
    is_limit.unique_up_to_iso],
  simp,
end
@[simp, reassoc]
lemma limit_uncurry_iso_limit_comp_lim_inv_Ï€ {j} {k} :
  (limit_uncurry_iso_limit_comp_lim F).inv â‰« limit.Ï€ _ (j, k) = limit.Ï€ _ j â‰« limit.Ï€ _ k :=
begin
  rw [â†cancel_epi (limit_uncurry_iso_limit_comp_lim F).hom],
  simp,
end
end
section
variables (F) [has_limits_of_shape J C] [has_limits_of_shape K C]
noncomputable
def limit_flip_comp_lim_iso_limit_comp_lim : limit (F.flip â‹™ lim) â‰… limit (F â‹™ lim) :=
(limit_uncurry_iso_limit_comp_lim _).symm â‰ªâ‰«
  has_limit.iso_of_nat_iso (uncurry_obj_flip _) â‰ªâ‰«
  (has_limit.iso_of_equivalence (prod.braiding _ _)
    (nat_iso.of_components (Î» _, by refl) (by tidy))) â‰ªâ‰«
  limit_uncurry_iso_limit_comp_lim _
@[simp, reassoc]
lemma limit_flip_comp_lim_iso_limit_comp_lim_hom_Ï€_Ï€ (j) (k) :
  (limit_flip_comp_lim_iso_limit_comp_lim F).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k =
  limit.Ï€ _ k â‰« limit.Ï€ _ j :=
noncomputable def limit_iso_limit_curry_comp_lim : limit G â‰… limit ((curry.obj G) â‹™ lim) :=
begin
  have i : G â‰… uncurry.obj ((@curry J _ K _ C _).obj G) := currying.symm.unit_iso.app G,
  haveI : limits.has_limit (uncurry.obj ((@curry J _ K _ C _).obj G)) :=
    has_limit_of_iso i,
  transitivity limit (uncurry.obj ((@curry J _ K _ C _).obj G)),
  apply has_limit.iso_of_nat_iso i,
  exact limit_uncurry_iso_limit_comp_lim ((@curry J _ K _ C _).obj G),
end
@[simp, reassoc]
lemma limit_iso_limit_curry_comp_lim_hom_Ï€_Ï€ {j} {k} :
  (limit_iso_limit_curry_comp_lim G).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k = limit.Ï€ _ (j, k) :=
by simp [limit_iso_limit_curry_comp_lim, is_limit.cone_point_unique_up_to_iso,
  is_limit.unique_up_to_iso]
@[simp, reassoc]
lemma limit_iso_limit_curry_comp_lim_inv_Ï€ {j} {k} :
  (limit_iso_limit_curry_comp_lim G).inv â‰« limit.Ï€ _ (j, k) = limit.Ï€ _ j â‰« limit.Ï€ _ k :=
begin
  rw [â†cancel_epi (limit_iso_limit_curry_comp_lim G).hom],
  simp,
end
end
section
noncomputable
def limit_curry_swap_comp_lim_iso_limit_curry_comp_lim :
  limit ((curry.obj (swap K J â‹™ G)) â‹™ lim) â‰… limit ((curry.obj G) â‹™ lim) :=
calc
  limit ((curry.obj (swap K J â‹™ G)) â‹™ lim)
      â‰… limit (swap K J â‹™ G) : (limit_iso_limit_curry_comp_lim _).symm
  ... â‰… limit G : has_limit.iso_of_equivalence (braiding K J) (iso.refl _)
  ... â‰… limit ((curry.obj G) â‹™ lim) : limit_iso_limit_curry_comp_lim _
@[simp]
lemma limit_curry_swap_comp_lim_iso_limit_curry_comp_lim_hom_Ï€_Ï€ {j} {k} :
  (limit_curry_swap_comp_lim_iso_limit_curry_comp_lim G).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k =
   limit.Ï€ _ k â‰« limit.Ï€ _ j :=
begin
  dsimp [limit_curry_swap_comp_lim_iso_limit_curry_comp_lim],
  simp only [iso.refl_hom, braiding_counit_iso_hom_app, limits.has_limit.iso_of_equivalence_hom_Ï€,
    iso.refl_inv, limit_iso_limit_curry_comp_lim_hom_Ï€_Ï€, eq_to_iso_refl, category.assoc],
