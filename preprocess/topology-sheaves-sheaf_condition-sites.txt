import category_theory.sites.spaces
import topology.sheaves.sheaf
import category_theory.sites.dense_subsite
noncomputable theory
universes u v w
namespace Top.presheaf
open category_theory topological_space Top category_theory.limits opposite
open Top.presheaf.sheaf_condition_equalizer_products
variables {C : Type u} [category.{v} C] [has_products.{v} C]
variables {X : Top.{v}} (F : presheaf C X)
def covering_of_presieve (U : opens X) (R : presieve U) : (Î£ V, {f : V âŸ¶ U // R f}) â†’ opens X :=
Î» f, f.1
@[simp]
lemma covering_of_presieve_apply (U : opens X) (R : presieve U) (f : Î£ V, {f : V âŸ¶ U // R f}) :
  covering_of_presieve U R f = f.1 := rfl
namespace covering_of_presieve
variables (U : opens X) (R : presieve U)
lemma supr_eq_of_mem_grothendieck (hR : sieve.generate R âˆˆ opens.grothendieck_topology X U) :
  supr (covering_of_presieve U R) = U :=
begin
  apply le_antisymm,
  { refine supr_le _,
    intro f,
    exact f.2.1.le, },
  intros x hxU,
  rw [opens.mem_coe, opens.mem_supr],
  obtain âŸ¨V, iVU, âŸ¨W, iVW, iWU, hiWU, -âŸ©, hxVâŸ© := hR x hxU,
  exact âŸ¨âŸ¨W, âŸ¨iWU, hiWUâŸ©âŸ©, iVW.le hxVâŸ©,
end
def first_obj_iso_pi_opens : presheaf.first_obj R F â‰… pi_opens F (covering_of_presieve U R) :=
eq_to_iso rfl
lemma first_obj_iso_pi_opens_Ï€ (f : Î£ V, {f : V âŸ¶ U // R f}) :
  (first_obj_iso_pi_opens F U R).hom â‰« pi.Ï€ _ f = pi.Ï€ _ f :=
category.id_comp _
def second_obj_iso_pi_inters :
  presheaf.second_obj R F â‰… pi_inters F (covering_of_presieve U R) :=
has_limit.iso_of_nat_iso $ discrete.nat_iso $ Î» i,
  F.map_iso (eq_to_iso (complete_lattice.pullback_eq_inf _ _).symm).op
lemma second_obj_iso_pi_inters_Ï€ (f g : Î£ V, {f : V âŸ¶ U // R f}) :
  (second_obj_iso_pi_inters F U R).hom â‰« pi.Ï€ _ (f, g) =
  pi.Ï€ _ (f, g) â‰« F.map (eq_to_hom (complete_lattice.pullback_eq_inf f.2.1 g.2.1).symm).op :=
begin
  dunfold second_obj_iso_pi_inters,
  rw has_limit.iso_of_nat_iso_hom_Ï€,
  refl,
end
lemma fork_map_comp_first_obj_iso_pi_opens_eq
  (hR : sieve.generate R âˆˆ opens.grothendieck_topology X U) :
  presheaf.fork_map R F â‰« (first_obj_iso_pi_opens F U R).hom =
  F.map (eq_to_hom (supr_eq_of_mem_grothendieck U R hR)).op â‰« res F (covering_of_presieve U R) :=
begin
  ext âŸ¨fâŸ©,
  rw [category.assoc, category.assoc, first_obj_iso_pi_opens_Ï€],
  dunfold presheaf.fork_map res,
  rw [limit.lift_Ï€, fan.mk_Ï€_app, limit.lift_Ï€, fan.mk_Ï€_app, â† F.map_comp],
  congr,
end
lemma first_obj_iso_comp_left_res_eq :
  presheaf.first_map R F â‰« (second_obj_iso_pi_inters F U R).hom =
  (first_obj_iso_pi_opens F U R).hom â‰« left_res F (covering_of_presieve U R) :=
begin
  ext âŸ¨f, gâŸ©,
  rw [category.assoc, category.assoc, second_obj_iso_pi_inters_Ï€],
  dunfold left_res presheaf.first_map,
  rw [limit.lift_Ï€, fan.mk_Ï€_app, limit.lift_Ï€_assoc, fan.mk_Ï€_app, â† category.assoc],
  erw [first_obj_iso_pi_opens_Ï€, category.assoc, â† F.map_comp],
  refl,
end
lemma first_obj_iso_comp_right_res_eq :
  presheaf.second_map R F â‰« (second_obj_iso_pi_inters F U R).hom =
  (first_obj_iso_pi_opens F U R).hom â‰« right_res F (covering_of_presieve U R) :=
begin
  ext âŸ¨f, gâŸ©,
  dunfold right_res presheaf.second_map,
  rw [category.assoc, category.assoc, second_obj_iso_pi_inters_Ï€, limit.lift_Ï€, fan.mk_Ï€_app,
    limit.lift_Ï€_assoc, fan.mk_Ï€_app, â† category.assoc, first_obj_iso_pi_opens_Ï€, category.assoc,
    â† F.map_comp],
  refl,
end
@[simps]
def diagram_nat_iso : parallel_pair (presheaf.first_map R F) (presheaf.second_map R F) â‰…
  diagram F (covering_of_presieve U R) :=
nat_iso.of_components
  (Î» i, walking_parallel_pair.cases_on i
    (first_obj_iso_pi_opens F U R)
    (second_obj_iso_pi_inters F U R)) $
begin
  intros i j f,
  cases i,
  { cases j,
    { cases f, simp },
    { cases f,
      { exact first_obj_iso_comp_left_res_eq F U R, },
      { exact first_obj_iso_comp_right_res_eq F U R, } } },
  { cases j,
    { cases f, },
    { cases f, simp } },
end
@[simps]
def postcompose_diagram_fork_hom (hR : sieve.generate R âˆˆ opens.grothendieck_topology X U) :
  (cones.postcompose (diagram_nat_iso F U R).hom).obj (fork.of_Î¹ _ (presheaf.w R F)) âŸ¶
  fork F (covering_of_presieve U R) :=
fork.mk_hom (F.map (eq_to_hom (supr_eq_of_mem_grothendieck U R hR)).op)
  (fork_map_comp_first_obj_iso_pi_opens_eq F U R hR).symm
instance is_iso_postcompose_diagram_fork_hom_hom
  (hR : sieve.generate R âˆˆ opens.grothendieck_topology X U) :
  is_iso (postcompose_diagram_fork_hom F U R hR).hom :=
begin
  rw [postcompose_diagram_fork_hom_hom, eq_to_hom_map],
  apply eq_to_hom.is_iso,
end
instance is_iso_postcompose_diagram_fork_hom
  (hR : sieve.generate R âˆˆ opens.grothendieck_topology X U) :
  is_iso (postcompose_diagram_fork_hom F U R hR) :=
cones.cone_iso_of_hom_iso _
def postcompose_diagram_fork_iso (hR : sieve.generate R âˆˆ opens.grothendieck_topology X U) :
  (cones.postcompose (diagram_nat_iso F U R).hom).obj (fork.of_Î¹ _ (presheaf.w R F)) â‰…
  fork F (covering_of_presieve U R) :=
as_iso (postcompose_diagram_fork_hom F U R hR)
end covering_of_presieve
lemma is_sheaf_sites_of_is_sheaf_spaces (Fsh : F.is_sheaf) :
  presheaf.is_sheaf (opens.grothendieck_topology X) F :=
begin
  rw presheaf.is_sheaf_iff_is_sheaf',
  intros U R hR,
  refine âŸ¨_âŸ©,
  apply (is_limit.of_cone_equiv (cones.postcompose_equivalence
    (covering_of_presieve.diagram_nat_iso F U R : _))).to_fun,
  apply (is_limit.equiv_iso_limit
    (covering_of_presieve.postcompose_diagram_fork_iso F U R hR)).inv_fun,
  exact (Fsh (covering_of_presieve U R)).some,
end
def presieve_of_covering_aux {Î¹ : Type v} (U : Î¹ â†’ opens X) (Y : opens X) : presieve Y :=
Î» V f, âˆƒ i, V = U i
def presieve_of_covering {Î¹ : Type v} (U : Î¹ â†’ opens X) : presieve (supr U) :=
presieve_of_covering_aux U (supr U)
@[simp] lemma covering_presieve_eq_self {Y : opens X} (R : presieve Y) :
  presieve_of_covering_aux (covering_of_presieve Y R) Y = R :=
by { ext Z f, exact âŸ¨Î» âŸ¨âŸ¨_,_,hâŸ©,rflâŸ©, by convert h, Î» h, âŸ¨âŸ¨Z,f,hâŸ©,rflâŸ©âŸ© }
namespace presieve_of_covering
variables {Î¹ : Type v} (U : Î¹ â†’ opens X)
lemma mem_grothendieck_topology :
  sieve.generate (presieve_of_covering U) âˆˆ opens.grothendieck_topology X (supr U) :=
begin
  intros x hx,
  obtain âŸ¨i, hxiâŸ© := opens.mem_supr.mp hx,
  exact âŸ¨U i, opens.le_supr U i, âŸ¨U i, ğŸ™ _, opens.le_supr U i, âŸ¨i, rflâŸ©, category.id_comp _âŸ©, hxiâŸ©,
end
def hom_of_index (i : Î¹) : Î£ V, {f : V âŸ¶ supr U // presieve_of_covering U f} :=
âŸ¨U i, opens.le_supr U i, i, rflâŸ©
def index_of_hom (f : Î£ V, {f : V âŸ¶ supr U // presieve_of_covering U f}) : Î¹ := f.2.2.some
lemma index_of_hom_spec (f : Î£ V, {f : V âŸ¶ supr U // presieve_of_covering U f}) :
  f.1 = U (index_of_hom U f) := f.2.2.some_spec
def first_obj_to_pi_opens : presheaf.first_obj (presieve_of_covering U) F âŸ¶ pi_opens F U :=
pi.lift (Î» i, pi.Ï€ _ (hom_of_index U i))
def pi_opens_to_first_obj : pi_opens F U âŸ¶
  presheaf.first_obj.{v v u} (presieve_of_covering U) F :=
pi.lift (Î» f, pi.Ï€ _ (index_of_hom U f) â‰« F.map (eq_to_hom (index_of_hom_spec U f)).op)
lemma fork_Î¹_comp_pi_opens_to_first_obj_to_pi_opens_eq
  (s : limits.fork (left_res F U) (right_res F U)) :
  s.Î¹ â‰« pi_opens_to_first_obj F U â‰« first_obj_to_pi_opens F U = s.Î¹ :=
begin
  ext âŸ¨jâŸ©,
  dunfold first_obj_to_pi_opens pi_opens_to_first_obj,
  rw [category.assoc, category.assoc, limit.lift_Ï€, fan.mk_Ï€_app, limit.lift_Ï€, fan.mk_Ï€_app],
def pi_inters_to_second_obj : pi_inters F U âŸ¶
  presheaf.second_obj.{v v u} (presieve_of_covering U) F :=
pi.lift (Î» f, pi.Ï€ _ (index_of_hom U f.fst, index_of_hom U f.snd) â‰«
  F.map (eq_to_hom
    (by rw [complete_lattice.pullback_eq_inf, â† index_of_hom_spec U, â† index_of_hom_spec U])).op)
lemma pi_opens_to_first_obj_comp_fist_map_eq :
  pi_opens_to_first_obj F U â‰« presheaf.first_map (presieve_of_covering U) F =
  left_res F U â‰« pi_inters_to_second_obj F U :=
begin
  ext âŸ¨f, gâŸ©,
  dunfold pi_opens_to_first_obj presheaf.first_map left_res pi_inters_to_second_obj,
  rw [category.assoc, category.assoc, limit.lift_Ï€, fan.mk_Ï€_app, limit.lift_Ï€, fan.mk_Ï€_app,
    â† category.assoc, â† category.assoc, limit.lift_Ï€, fan.mk_Ï€_app, limit.lift_Ï€, fan.mk_Ï€_app,
    category.assoc, category.assoc, â† F.map_comp, â† F.map_comp],
  refl,
end
lemma pi_opens_to_first_obj_comp_second_map_eq :
  pi_opens_to_first_obj F U â‰« presheaf.second_map (presieve_of_covering U) F =
  right_res F U â‰« pi_inters_to_second_obj F U :=
begin
  ext âŸ¨f, gâŸ©,
  dunfold pi_opens_to_first_obj presheaf.second_map right_res pi_inters_to_second_obj,
  rw [category.assoc, category.assoc, limit.lift_Ï€, fan.mk_Ï€_app, limit.lift_Ï€, fan.mk_Ï€_app,
    â† category.assoc, â† category.assoc, limit.lift_Ï€, fan.mk_Ï€_app, limit.lift_Ï€, fan.mk_Ï€_app,
    category.assoc, category.assoc, â† F.map_comp, â† F.map_comp],
  refl,
end
lemma fork_map_comp_first_map_to_pi_opens_eq :
  presheaf.fork_map (presieve_of_covering U) F â‰« first_obj_to_pi_opens F U = res F U :=
begin
  ext i,
  dsimp [presheaf.fork_map, first_obj_to_pi_opens, res],
  rw [category.assoc, limit.lift_Ï€, fan.mk_Ï€_app, limit.lift_Ï€, fan.mk_Ï€_app,
    limit.lift_Ï€, fan.mk_Ï€_app],
  refl,
end
lemma res_comp_pi_opens_to_first_obj_eq :
  res F U â‰« pi_opens_to_first_obj F U = presheaf.fork_map (presieve_of_covering U) F :=
begin
  ext f,
  dunfold res pi_opens_to_first_obj presheaf.fork_map,
  rw [category.assoc, limit.lift_Ï€, fan.mk_Ï€_app, limit.lift_Ï€, fan.mk_Ï€_app, â† category.assoc,
    limit.lift_Ï€, fan.mk_Ï€_app, â† F.map_comp],
  congr,
end
end presieve_of_covering
open presieve_of_covering
lemma is_sheaf_spaces_of_is_sheaf_sites
  (Fsh : presheaf.is_sheaf (opens.grothendieck_topology X) F) :
  F.is_sheaf :=
begin
  intros Î¹ U,
  rw presheaf.is_sheaf_iff_is_sheaf' at Fsh,
@[simps]
def Sheaf_sites_to_sheaf_spaces : Sheaf (opens.grothendieck_topology X) C â¥¤ sheaf C X :=
{ obj := Î» F, âŸ¨F.1, is_sheaf_spaces_of_is_sheaf_sites F.1 F.2âŸ©,
  map := Î» F G f, f.val }
@[simps]
def Sheaf_spaces_to_sheaf_sites : sheaf C X â¥¤ Sheaf (opens.grothendieck_topology X) C :=
{ obj := Î» F, âŸ¨F.1, is_sheaf_sites_of_is_sheaf_spaces F.1 F.2âŸ©,
  map := Î» F G f, âŸ¨fâŸ© }
@[simps]
def Sheaf_spaces_equiv_sheaf_sites : Sheaf (opens.grothendieck_topology X) C â‰Œ sheaf C X :=
{ functor := Sheaf_sites_to_sheaf_spaces C X,
  inverse := Sheaf_spaces_to_sheaf_sites C X,
  unit_iso := nat_iso.of_components (Î» t, âŸ¨âŸ¨ğŸ™ _âŸ©, âŸ¨ğŸ™ _âŸ©, by { ext1, simp }, by { ext1, simp }âŸ©) $
    by { intros, ext1, dsimp, simp },
  counit_iso := nat_iso.of_components (Î» t, âŸ¨ğŸ™ _, ğŸ™ _, by { ext, simp }, by { ext, simp }âŸ©) $
    by { intros, ext, dsimp, simp } }
def Sheaf_spaces_equiv_sheaf_sites_functor_forget :
  (Sheaf_spaces_equiv_sheaf_sites C X).functor â‹™ sheaf.forget C X â‰… Sheaf_to_presheaf _ _ :=
nat_iso.of_components (Î» F, (iso.refl F.1))
  (Î» F G f, by { erw [category.comp_id, category.id_comp], refl })
def Sheaf_spaces_equiv_sheaf_sites_inverse_forget :
  (Sheaf_spaces_equiv_sheaf_sites C X).inverse â‹™ Sheaf_to_presheaf _ _ â‰… sheaf.forget C X :=
nat_iso.of_components (Î» F, (iso.refl F.1))
  (Î» F G f, by { erw [category.comp_id, category.id_comp], refl })
end Top.presheaf
namespace Top.opens
open category_theory topological_space
variables {X : Top} {Î¹ : Type*}
lemma cover_dense_iff_is_basis [category Î¹] (B : Î¹ â¥¤ opens X) :
  cover_dense (opens.grothendieck_topology X) B â†” opens.is_basis (set.range B.obj) :=
begin
  rw opens.is_basis_iff_nbhd,
  split, intros hd U x hx, rcases hd.1 U x hx with âŸ¨V,f,âŸ¨i,fâ‚,fâ‚‚,hcâŸ©,hVâŸ©,
  exact âŸ¨B.obj i, âŸ¨i,rflâŸ©, fâ‚.le hV, fâ‚‚.leâŸ©,
  intro hb, split, intros U x hx, rcases hb hx with âŸ¨_,âŸ¨i,rflâŸ©,hx,hiâŸ©,
  exact âŸ¨B.obj i, âŸ¨âŸ¨hiâŸ©âŸ©, âŸ¨âŸ¨i, ğŸ™ _, âŸ¨âŸ¨hiâŸ©âŸ©, rflâŸ©âŸ©, hxâŸ©,
end
lemma cover_dense_induced_functor {B : Î¹ â†’ opens X} (h : opens.is_basis (set.range B)) :
  cover_dense (opens.grothendieck_topology X) (induced_functor B) :=
(cover_dense_iff_is_basis _).2 h
end Top.opens
namespace Top.sheaf
open category_theory topological_space Top opposite
variables {C : Type u} [category.{v} C] [limits.has_products.{v} C]
variables {X : Top.{v}} {Î¹ : Type*} {B : Î¹ â†’ opens X}
variables (F : presheaf C X) (F' : sheaf C X) (h : opens.is_basis (set.range B))
def is_terminal_of_empty (F : sheaf C X) : limits.is_terminal (F.val.obj (op âˆ…)) :=
((presheaf.Sheaf_spaces_to_sheaf_sites C X).obj F).is_terminal_of_bot_cover âˆ… (by tidy)
def is_terminal_of_eq_empty (F : X.sheaf C) {U : opens X} (h : U = âˆ…) :
  limits.is_terminal (F.val.obj (op U)) :=
by convert F.is_terminal_of_empty
def restrict_hom_equiv_hom :
  ((induced_functor B).op â‹™ F âŸ¶ (induced_functor B).op â‹™ F'.1) â‰ƒ (F âŸ¶ F'.1) :=
@cover_dense.restrict_hom_equiv_hom _ _ _ _ _ _ _ _ (opens.cover_dense_induced_functor h)
  _ F ((presheaf.Sheaf_spaces_to_sheaf_sites C X).obj F')
@[simp] lemma extend_hom_app (Î± : ((induced_functor B).op â‹™ F âŸ¶ (induced_functor B).op â‹™ F'.1))
  (i : Î¹) : (restrict_hom_equiv_hom F F' h Î±).app (op (B i)) = Î±.app (op i) :=
by { nth_rewrite 1 â† (restrict_hom_equiv_hom F F' h).left_inv Î±, refl }
include h
lemma hom_ext {Î± Î² : F âŸ¶ F'.1} (he : âˆ€ i, Î±.app (op (B i)) = Î².app (op (B i))) : Î± = Î² :=
by { apply (restrict_hom_equiv_hom F F' h).symm.injective, ext i, exact he i.unop }
end Top.sheaf
