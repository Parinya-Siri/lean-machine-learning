import topology.subset_properties
import topology.connected
import topology.nhds_set
import topology.inseparable
open function set filter topological_space
open_locale topological_space filter classical
universes u v
variables {Î± : Type u} {Î² : Type v} [topological_space Î±]
section separation
def separated : set Î± â†’ set Î± â†’ Prop :=
  Î» (s t : set Î±), âˆƒ U V : (set Î±), (is_open U) âˆ§ is_open V âˆ§
  (s âŠ† U) âˆ§ (t âŠ† V) âˆ§ disjoint U V
namespace separated
open separated
@[symm] lemma symm {s t : set Î±} : separated s t â†’ separated t s :=
Î» âŸ¨U, V, oU, oV, aU, bV, UVâŸ©, âŸ¨V, U, oV, oU, bV, aU, disjoint.symm UVâŸ©
lemma comm (s t : set Î±) : separated s t â†” separated t s :=
âŸ¨symm, symmâŸ©
lemma preimage [topological_space Î²] {f : Î± â†’ Î²} {s t : set Î²} (h : separated s t)
  (hf : continuous f) : separated (f â»Â¹' s) (f â»Â¹' t) :=
let âŸ¨U, V, oU, oV, sU, tV, UVâŸ© := h in
âŸ¨f â»Â¹' U, f â»Â¹' V, oU.preimage hf, oV.preimage hf, preimage_mono sU, preimage_mono tV,
  UV.preimage fâŸ©
protected lemma disjoint {s t : set Î±} (h : separated s t) : disjoint s t :=
let âŸ¨U, V, hU, hV, hsU, htV, hdâŸ© := h in hd.mono hsU htV
lemma disjoint_closure_left {s t : set Î±} (h : separated s t) : disjoint (closure s) t :=
let âŸ¨U, V, hU, hV, hsU, htV, hdâŸ© := h
in (hd.closure_left hV).mono (closure_mono hsU) htV
lemma disjoint_closure_right {s t : set Î±} (h : separated s t) : disjoint s (closure t) :=
h.symm.disjoint_closure_left.symm
lemma empty_right (a : set Î±) : separated a âˆ… :=
âŸ¨_, _, is_open_univ, is_open_empty, Î» a h, mem_univ a, Î» a h, by cases h, disjoint_empty _âŸ©
lemma empty_left (a : set Î±) : separated âˆ… a :=
(empty_right _).symm
lemma mono {sâ‚ sâ‚‚ tâ‚ tâ‚‚ : set Î±} (h : separated sâ‚‚ tâ‚‚) (hs : sâ‚ âŠ† sâ‚‚) (ht : tâ‚ âŠ† tâ‚‚) :
  separated sâ‚ tâ‚ :=
let âŸ¨U, V, hU, hV, hsU, htV, hdâŸ© := h in âŸ¨U, V, hU, hV, hs.trans hsU, ht.trans htV, hdâŸ©
lemma union_left {a b c : set Î±} : separated a c â†’ separated b c â†’ separated (a âˆª b) c :=
Î» âŸ¨U, V, oU, oV, aU, bV, UVâŸ© âŸ¨W, X, oW, oX, aW, bX, WXâŸ©,
  âŸ¨U âˆª W, V âˆ© X, is_open.union oU oW, is_open.inter oV oX,
    union_subset_union aU aW, subset_inter bV bX, set.disjoint_union_left.mpr
    âŸ¨disjoint_of_subset_right (inter_subset_left _ _) UV,
      disjoint_of_subset_right (inter_subset_right _ _) WXâŸ©âŸ©
lemma union_right {a b c : set Î±} (ab : separated a b) (ac : separated a c) :
  separated a (b âˆª c) :=
(ab.symm.union_left ac.symm).symm
end separated
class t0_space (Î± : Type u) [topological_space Î±] : Prop :=
(t0 : âˆ€ x y, x â‰  y â†’ âˆƒ U:set Î±, is_open U âˆ§ (xor (x âˆˆ U) (y âˆˆ U)))
lemma exists_is_open_xor_mem [t0_space Î±] {x y : Î±} (h : x â‰  y) :
  âˆƒ U:set Î±, is_open U âˆ§ xor (x âˆˆ U) (y âˆˆ U) :=
t0_space.t0 x y h
lemma t0_space_def (Î± : Type u) [topological_space Î±] :
  t0_space Î± â†” âˆ€ x y, x â‰  y â†’ âˆƒ U:set Î±, is_open U âˆ§ (xor (x âˆˆ U) (y âˆˆ U)) :=
by { split, apply @t0_space.t0, apply t0_space.mk }
lemma t0_space_iff_not_inseparable (Î± : Type u) [topological_space Î±] :
  t0_space Î± â†” âˆ€ (x y : Î±), x â‰  y â†’ Â¬inseparable x y :=
by simp only [t0_space_def, xor_iff_not_iff, not_forall, exists_prop, inseparable_iff_forall_open]
lemma t0_space_iff_inseparable (Î± : Type u) [topological_space Î±] :
  t0_space Î± â†” âˆ€ (x y : Î±), inseparable x y â†’ x = y :=
by simp only [t0_space_iff_not_inseparable, ne.def, not_imp_not]
lemma inseparable.eq [t0_space Î±] {x y : Î±} (h : inseparable x y) : x = y :=
(t0_space_iff_inseparable Î±).1 â€¹_â€º x y h
lemma t0_space_iff_nhds_injective (Î± : Type u) [topological_space Î±] :
  t0_space Î± â†” injective (ğ“ : Î± â†’ filter Î±) :=
t0_space_iff_inseparable Î±
lemma nhds_injective [t0_space Î±] : injective (ğ“ : Î± â†’ filter Î±) :=
(t0_space_iff_nhds_injective Î±).1 â€¹_â€º
@[simp] lemma nhds_eq_nhds_iff [t0_space Î±] {a b : Î±} : ğ“ a = ğ“ b â†” a = b :=
nhds_injective.eq_iff
def specialization_order (Î± : Type*) [topological_space Î±] [t0_space Î±] : partial_order Î± :=
{ .. specialization_preorder Î±,
  .. partial_order.lift (order_dual.to_dual âˆ˜ ğ“) nhds_injective }
instance : t0_space (separation_quotient Î±) :=
(t0_space_iff_inseparable _).2 $ Î» x' y', quotient.induction_onâ‚‚' x' y' $
  Î» x y h, separation_quotient.mk_eq_mk.2 $ separation_quotient.inducing_mk.inseparable_iff.1 h
theorem minimal_nonempty_closed_subsingleton [t0_space Î±] {s : set Î±} (hs : is_closed s)
  (hmin : âˆ€ t âŠ† s, t.nonempty â†’ is_closed t â†’ t = s) :
  s.subsingleton :=
begin
  refine Î» x hx y hy, of_not_not (Î» hxy, _),
  rcases exists_is_open_xor_mem hxy with âŸ¨U, hUo, hUâŸ©,
  wlog h : x âˆˆ U âˆ§ y âˆ‰ U := hU using [x y, y x], cases h with hxU hyU,
  have : s \ U = s := hmin (s \ U) (diff_subset _ _) âŸ¨y, hy, hyUâŸ© (hs.sdiff hUo),
  exact (this.symm.subset hx).2 hxU
end
theorem minimal_nonempty_closed_eq_singleton [t0_space Î±] {s : set Î±} (hs : is_closed s)
  (hne : s.nonempty) (hmin : âˆ€ t âŠ† s, t.nonempty â†’ is_closed t â†’ t = s) :
  âˆƒ x, s = {x} :=
exists_eq_singleton_iff_nonempty_subsingleton.2 âŸ¨hne, minimal_nonempty_closed_subsingleton hs hminâŸ©
theorem is_closed.exists_closed_singleton {Î± : Type*} [topological_space Î±]
  [t0_space Î±] [compact_space Î±] {S : set Î±} (hS : is_closed S) (hne : S.nonempty) :
  âˆƒ (x : Î±), x âˆˆ S âˆ§ is_closed ({x} : set Î±) :=
begin
  obtain âŸ¨V, Vsub, Vne, Vcls, hVâŸ© := hS.exists_minimal_nonempty_closed_subset hne,
  rcases minimal_nonempty_closed_eq_singleton Vcls Vne hV with âŸ¨x, rflâŸ©,
  exact âŸ¨x, Vsub (mem_singleton x), VclsâŸ©
end
theorem minimal_nonempty_open_subsingleton [t0_space Î±] {s : set Î±} (hs : is_open s)
  (hmin : âˆ€ t âŠ† s, t.nonempty â†’ is_open t â†’ t = s) :
  s.subsingleton :=
begin
  refine Î» x hx y hy, of_not_not (Î» hxy, _),
  rcases exists_is_open_xor_mem hxy with âŸ¨U, hUo, hUâŸ©,
  wlog h : x âˆˆ U âˆ§ y âˆ‰ U := hU using [x y, y x], cases h with hxU hyU,
  have : s âˆ© U = s := hmin (s âˆ© U) (inter_subset_left _ _) âŸ¨x, hx, hxUâŸ© (hs.inter hUo),
  exact hyU (this.symm.subset hy).2
end
theorem minimal_nonempty_open_eq_singleton [t0_space Î±] {s : set Î±} (hs : is_open s)
  (hne : s.nonempty) (hmin : âˆ€ t âŠ† s, t.nonempty â†’ is_open t â†’ t = s) :
  âˆƒ x, s = {x} :=
exists_eq_singleton_iff_nonempty_subsingleton.2 âŸ¨hne, minimal_nonempty_open_subsingleton hs hminâŸ©
theorem exists_open_singleton_of_open_finite [t0_space Î±] {s : set Î±} (hfin : s.finite)
  (hne : s.nonempty) (ho : is_open s) :
  âˆƒ x âˆˆ s, is_open ({x} : set Î±) :=
begin
  lift s to finset Î± using hfin,
  induction s using finset.strong_induction_on with s ihs,
  rcases em (âˆƒ t âŠ‚ s, t.nonempty âˆ§ is_open (t : set Î±)) with âŸ¨t, hts, htne, htoâŸ©|ht,
  { rcases ihs t hts htne hto with âŸ¨x, hxt, hxoâŸ©,
    exact âŸ¨x, hts.1 hxt, hxoâŸ© },
  { rcases minimal_nonempty_open_eq_singleton ho hne _ with âŸ¨x, hxâŸ©,
    { exact âŸ¨x, hx.symm â–¸ rfl, hx â–¸ hoâŸ© },
    refine Î» t hts htne hto, of_not_not (Î» hts', ht _),
    lift t to finset Î± using s.finite_to_set.subset hts,
    exact âŸ¨t, ssubset_iff_subset_ne.2 âŸ¨hts, mt finset.coe_inj.2 hts'âŸ©, htne, htoâŸ© }
end
theorem exists_open_singleton_of_fintype [t0_space Î±] [fintype Î±] [nonempty Î±] :
  âˆƒ x : Î±, is_open ({x} : set Î±) :=
let âŸ¨x, _, hâŸ© := exists_open_singleton_of_open_finite (finite.of_fintype _) univ_nonempty
  is_open_univ in âŸ¨x, hâŸ©
lemma t0_space_of_injective_of_continuous [topological_space Î²] {f : Î± â†’ Î²}
  (hf : function.injective f) (hf' : continuous f) [t0_space Î²] : t0_space Î± :=
âŸ¨Î» x y hxy, let âŸ¨U, hU, hxyUâŸ© := t0_space.t0 (f x) (f y) (hf.ne hxy) in
  âŸ¨f â»Â¹' U, hU.preimage hf', hxyUâŸ©âŸ©
protected lemma embedding.t0_space [topological_space Î²] [t0_space Î²] {f : Î± â†’ Î²}
  (hf : embedding f) : t0_space Î± :=
t0_space_of_injective_of_continuous hf.inj hf.continuous
instance subtype.t0_space [t0_space Î±] {p : Î± â†’ Prop} : t0_space (subtype p) :=
embedding_subtype_coe.t0_space
theorem t0_space_iff_or_not_mem_closure (Î± : Type u) [topological_space Î±] :
  t0_space Î± â†” (âˆ€ a b : Î±, a â‰  b â†’ (a âˆ‰ closure ({b} : set Î±) âˆ¨ b âˆ‰ closure ({a} : set Î±))) :=
by simp only [t0_space_iff_not_inseparable, inseparable_iff_mem_closure, not_and_distrib]
instance [topological_space Î²] [t0_space Î±] [t0_space Î²] : t0_space (Î± Ã— Î²) :=
(t0_space_iff_inseparable _).2 $
  Î» x y h, prod.ext (h.map continuous_fst).eq (h.map continuous_snd).eq
instance {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [Î  i, topological_space (Ï€ i)] [Î  i, t0_space (Ï€ i)] :
  t0_space (Î  i, Ï€ i) :=
(t0_space_iff_inseparable _).2 $ Î» x y h, funext $ Î» i, (h.map (continuous_apply i)).eq
class t1_space (Î± : Type u) [topological_space Î±] : Prop :=
(t1 : âˆ€x, is_closed ({x} : set Î±))
lemma is_closed_singleton [t1_space Î±] {x : Î±} : is_closed ({x} : set Î±) :=
t1_space.t1 x
lemma is_open_compl_singleton [t1_space Î±] {x : Î±} : is_open ({x}á¶œ : set Î±) :=
is_closed_singleton.is_open_compl
lemma is_open_ne [t1_space Î±] {x : Î±} : is_open {y | y â‰  x} :=
is_open_compl_singleton
lemma ne.nhds_within_compl_singleton [t1_space Î±] {x y : Î±} (h : x â‰  y) :
  ğ“[{y}á¶œ] x = ğ“ x :=
is_open_ne.nhds_within_eq h
lemma ne.nhds_within_diff_singleton [t1_space Î±] {x y : Î±} (h : x â‰  y) (s : set Î±) :
  ğ“[s \ {y}] x = ğ“[s] x :=
begin
  rw [diff_eq, inter_comm, nhds_within_inter_of_mem],
  exact mem_nhds_within_of_mem_nhds (is_open_ne.mem_nhds h)
end
protected lemma set.finite.is_closed [t1_space Î±] {s : set Î±} (hs : set.finite s) :
  is_closed s :=
begin
  rw â† bUnion_of_singleton s,
  exact is_closed_bUnion hs (Î» i hi, is_closed_singleton)
end
lemma topological_space.is_topological_basis.exists_mem_of_ne
  [t1_space Î±] {b : set (set Î±)} (hb : is_topological_basis b) {x y : Î±} (h : x â‰  y) :
  âˆƒ a âˆˆ b, x âˆˆ a âˆ§ y âˆ‰ a :=
begin
  rcases hb.is_open_iff.1 is_open_ne x h with âŸ¨a, ab, xa, haâŸ©,
  exact âŸ¨a, ab, xa, Î» h, ha h rflâŸ©,
end
lemma filter.coclosed_compact_le_cofinite [t1_space Î±] :
  filter.coclosed_compact Î± â‰¤ filter.cofinite :=
Î» s hs, compl_compl s â–¸ hs.is_compact.compl_mem_coclosed_compact_of_is_closed hs.is_closed
variable (Î±)
def bornology.relatively_compact [t1_space Î±] : bornology Î± :=
{ cobounded := filter.coclosed_compact Î±,
  le_cofinite := filter.coclosed_compact_le_cofinite }
variable {Î±}
lemma bornology.relatively_compact.is_bounded_iff [t1_space Î±] {s : set Î±} :
  @bornology.is_bounded _ (bornology.relatively_compact Î±) s â†” is_compact (closure s) :=
begin
  change sá¶œ âˆˆ filter.coclosed_compact Î± â†” _,
  rw filter.mem_coclosed_compact,
  split,
  { rintros âŸ¨t, htâ‚, htâ‚‚, hstâŸ©,
    rw compl_subset_compl at hst,
    exact compact_of_is_closed_subset htâ‚‚ is_closed_closure (closure_minimal hst htâ‚) },
  { intros h,
    exact âŸ¨closure s, is_closed_closure, h, compl_subset_compl.mpr subset_closureâŸ© }
end
protected lemma finset.is_closed [t1_space Î±] (s : finset Î±) : is_closed (s : set Î±) :=
s.finite_to_set.is_closed
lemma t1_space_tfae (Î± : Type u) [topological_space Î±] :
  tfae [t1_space Î±,
    âˆ€ x, is_closed ({x} : set Î±),
    âˆ€ x, is_open ({x}á¶œ : set Î±),
    continuous (@cofinite_topology.of Î±),
    âˆ€ â¦ƒx y : Î±â¦„, x â‰  y â†’ {y}á¶œ âˆˆ ğ“ x,
    âˆ€ â¦ƒx y : Î±â¦„, x â‰  y â†’ âˆƒ s âˆˆ ğ“ x, y âˆ‰ s,
    âˆ€ â¦ƒx y : Î±â¦„, x â‰  y â†’ âˆƒ (U : set Î±) (hU : is_open U), x âˆˆ U âˆ§ y âˆ‰ U,
    âˆ€ â¦ƒx y : Î±â¦„, x â‰  y â†’ disjoint (ğ“ x) (pure y),
    âˆ€ â¦ƒx y : Î±â¦„, x â‰  y â†’ disjoint (pure x) (ğ“ y)] :=
begin
  tfae_have : 1 â†” 2, from âŸ¨Î» h, h.1, Î» h, âŸ¨hâŸ©âŸ©,
  tfae_have : 2 â†” 3, by simp only [is_open_compl_iff],
  tfae_have : 5 â†” 3,
  { refine forall_swap.trans _,
    simp only [is_open_iff_mem_nhds, mem_compl_iff, mem_singleton_iff] },
  tfae_have : 5 â†” 6,
    by simp only [â† subset_compl_singleton_iff, exists_mem_subset_iff],
  tfae_have : 5 â†” 7,
    by simp only [(nhds_basis_opens _).mem_iff, subset_compl_singleton_iff, exists_prop, and.assoc,
      and.left_comm],
  tfae_have : 5 â†” 8,
    by simp only [â† principal_singleton, disjoint_principal_right],
  tfae_have : 8 â†” 9, from forall_swap.trans (by simp only [disjoint.comm, ne_comm]),
  tfae_have : 1 â†’ 4,
  { simp only [continuous_def, cofinite_topology.is_open_iff'],
    rintro H s (rfl|hs),
    exacts [is_open_empty, compl_compl s â–¸ (@set.finite.is_closed _ _ H _ hs).is_open_compl] },
  tfae_have : 4 â†’ 2,
    from Î» h x, (cofinite_topology.is_closed_iff.2 $ or.inr (finite_singleton _)).preimage h,
  tfae_finish
end
lemma t1_space_iff_continuous_cofinite_of {Î± : Type*} [topological_space Î±] :
  t1_space Î± â†” continuous (@cofinite_topology.of Î±) :=
(t1_space_tfae Î±).out 0 3
lemma cofinite_topology.continuous_of [t1_space Î±] : continuous (@cofinite_topology.of Î±) :=
t1_space_iff_continuous_cofinite_of.mp â€¹_â€º
lemma t1_space_iff_exists_open : t1_space Î± â†”
  âˆ€ (x y), x â‰  y â†’ (âˆƒ (U : set Î±) (hU : is_open U), x âˆˆ U âˆ§ y âˆ‰ U) :=
(t1_space_tfae Î±).out 0 6
lemma t1_space_iff_disjoint_pure_nhds : t1_space Î± â†” âˆ€ â¦ƒx y : Î±â¦„, x â‰  y â†’ disjoint (pure x) (ğ“ y) :=
(t1_space_tfae Î±).out 0 8
lemma t1_space_iff_disjoint_nhds_pure : t1_space Î± â†” âˆ€ â¦ƒx y : Î±â¦„, x â‰  y â†’ disjoint (ğ“ x) (pure y) :=
(t1_space_tfae Î±).out 0 7
lemma disjoint_pure_nhds [t1_space Î±] {x y : Î±} (h : x â‰  y) : disjoint (pure x) (ğ“ y) :=
t1_space_iff_disjoint_pure_nhds.mp â€¹_â€º h
lemma disjoint_nhds_pure [t1_space Î±] {x y : Î±} (h : x â‰  y) : disjoint (ğ“ x) (pure y) :=
t1_space_iff_disjoint_nhds_pure.mp â€¹_â€º h
instance {Î± : Type*} : t1_space (cofinite_topology Î±) :=
t1_space_iff_continuous_cofinite_of.mpr continuous_id
lemma t1_space_antitone {Î± : Type*} : antitone (@t1_space Î±) :=
begin
  simp only [antitone, t1_space_iff_continuous_cofinite_of, continuous_iff_le_induced],
  exact Î» tâ‚ tâ‚‚ h, h.trans
end
lemma continuous_within_at_update_of_ne [t1_space Î±] [decidable_eq Î±] [topological_space Î²]
  {f : Î± â†’ Î²} {s : set Î±} {x y : Î±} {z : Î²} (hne : y â‰  x) :
  continuous_within_at (function.update f x z) s y â†” continuous_within_at f s y :=
eventually_eq.congr_continuous_within_at
  (mem_nhds_within_of_mem_nhds $ mem_of_superset (is_open_ne.mem_nhds hne) $
    Î» y' hy', function.update_noteq hy' _ _)
  (function.update_noteq hne _ _)
lemma continuous_at_update_of_ne [t1_space Î±] [decidable_eq Î±] [topological_space Î²]
  {f : Î± â†’ Î²} {x y : Î±} {z : Î²} (hne : y â‰  x) :
  continuous_at (function.update f x z) y â†” continuous_at f y :=
by simp only [â† continuous_within_at_univ, continuous_within_at_update_of_ne hne]
lemma continuous_on_update_iff [t1_space Î±] [decidable_eq Î±] [topological_space Î²]
  {f : Î± â†’ Î²} {s : set Î±} {x : Î±} {y : Î²} :
  continuous_on (function.update f x y) s â†”
    continuous_on f (s \ {x}) âˆ§ (x âˆˆ s â†’ tendsto f (ğ“[s \ {x}] x) (ğ“ y)) :=
begin
  rw [continuous_on, â† and_forall_ne x, and_comm],
  refine and_congr âŸ¨Î» H z hz, _, Î» H z hzx hzs, _âŸ© (forall_congr $ Î» hxs, _),
  { specialize H z hz.2 hz.1,
    rw continuous_within_at_update_of_ne hz.2 at H,
    exact H.mono (diff_subset _ _) },
  { rw continuous_within_at_update_of_ne hzx,
    refine (H z âŸ¨hzs, hzxâŸ©).mono_of_mem (inter_mem_nhds_within _ _),
    exact is_open_ne.mem_nhds hzx },
  { exact continuous_within_at_update_same }
end
lemma t1_space_of_injective_of_continuous [topological_space Î²] {f : Î± â†’ Î²}
  (hf : function.injective f) (hf' : continuous f) [t1_space Î²] : t1_space Î± :=
{ t1 :=
  begin
    intros x,
    rw [â† function.injective.preimage_image hf {x}, image_singleton],
    exact (t1_space.t1 $ f x).preimage hf'
  end }
protected lemma embedding.t1_space [topological_space Î²] [t1_space Î²] {f : Î± â†’ Î²}
  (hf : embedding f) : t1_space Î± :=
t1_space_of_injective_of_continuous hf.inj hf.continuous
instance subtype.t1_space {Î± : Type u} [topological_space Î±] [t1_space Î±] {p : Î± â†’ Prop} :
  t1_space (subtype p) :=
embedding_subtype_coe.t1_space
instance [topological_space Î²] [t1_space Î±] [t1_space Î²] : t1_space (Î± Ã— Î²) :=
âŸ¨Î» âŸ¨a, bâŸ©, @singleton_prod_singleton _ _ a b â–¸ is_closed_singleton.prod is_closed_singletonâŸ©
instance {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [Î  i, topological_space (Ï€ i)] [Î  i, t1_space (Ï€ i)] :
  t1_space (Î  i, Ï€ i) :=
âŸ¨Î» f, univ_pi_singleton f â–¸ is_closed_set_pi (Î» i hi, is_closed_singleton)âŸ©
lemma dense.diff_singleton [t1_space Î±] {s : set Î±} (hs : dense s) (x : Î±) [ne_bot (ğ“[â‰ ] x)] :
  dense (s \ {x}) :=
hs.inter_of_open_right (dense_compl_singleton x) is_open_compl_singleton
lemma dense.diff_finset [t1_space Î±] [âˆ€ (x : Î±), ne_bot (ğ“[â‰ ] x)]
  {s : set Î±} (hs : dense s) (t : finset Î±) :
  dense (s \ t) :=
begin
  induction t using finset.induction_on with x s hxs ih hd,
  { simpa using hs },
  { rw [finset.coe_insert, â† union_singleton, â† diff_diff],
    exact ih.diff_singleton _, }
end
lemma dense.diff_finite [t1_space Î±] [âˆ€ (x : Î±), ne_bot (ğ“[â‰ ] x)]
  {s : set Î±} (hs : dense s) {t : set Î±} (ht : t.finite) :
  dense (s \ t) :=
begin
  convert hs.diff_finset ht.to_finset,
  exact (finite.coe_to_finset _).symm,
end
lemma eq_of_tendsto_nhds [topological_space Î²] [t1_space Î²] {f : Î± â†’ Î²} {a : Î±} {b : Î²}
  (h : tendsto f (ğ“ a) (ğ“ b)) : f a = b :=
by_contra $ assume (hfa : f a â‰  b),
have factâ‚ : {f a}á¶œ âˆˆ ğ“ b := compl_singleton_mem_nhds hfa.symm,
have factâ‚‚ : tendsto f (pure a) (ğ“ b) := h.comp (tendsto_id'.2 $ pure_le_nhds a),
factâ‚‚ factâ‚ (eq.refl $ f a)
lemma continuous_at_of_tendsto_nhds [topological_space Î²] [t1_space Î²] {f : Î± â†’ Î²} {a : Î±} {b : Î²}
  (h : tendsto f (ğ“ a) (ğ“ b)) : continuous_at f a :=
show tendsto f (ğ“ a) (ğ“ $ f a), by rwa eq_of_tendsto_nhds h
lemma tendsto_const_nhds_iff [t1_space Î±] {l : filter Î±} [ne_bot l] {c d : Î±} :
  tendsto (Î» x, c) l (ğ“ d) â†” c = d :=
by simp_rw [tendsto, filter.map_const, pure_le_nhds_iff]
lemma infinite_of_mem_nhds {Î±} [topological_space Î±] [t1_space Î±] (x : Î±) [hx : ne_bot (ğ“[â‰ ] x)]
  {s : set Î±} (hs : s âˆˆ ğ“ x) : set.infinite s :=
begin
  intro hsf,
  have A : {x} âŠ† s, by simp only [singleton_subset_iff, mem_of_mem_nhds hs],
  have B : is_closed (s \ {x}) := (hsf.subset (diff_subset _ _)).is_closed,
  have C : (s \ {x})á¶œ âˆˆ ğ“ x, from B.is_open_compl.mem_nhds (Î» h, h.2 rfl),
  have D : {x} âˆˆ ğ“ x, by simpa only [â† diff_eq, diff_diff_cancel_left A] using inter_mem hs C,
  rwa [â† mem_interior_iff_mem_nhds, interior_singleton] at D
end
lemma discrete_of_t1_of_finite {X : Type*} [topological_space X] [t1_space X] [fintype X] :
  discrete_topology X :=
begin
  apply singletons_open_iff_discrete.mp,
  intros x,
  rw [â† is_closed_compl_iff],
  exact (finite.of_fintype _).is_closed
end
lemma singleton_mem_nhds_within_of_mem_discrete {s : set Î±} [discrete_topology s]
  {x : Î±} (hx : x âˆˆ s) :
  {x} âˆˆ ğ“[s] x :=
begin
  have : ({âŸ¨x, hxâŸ©} : set s) âˆˆ ğ“ (âŸ¨x, hxâŸ© : s), by simp [nhds_discrete],
  simpa only [nhds_within_eq_map_subtype_coe hx, image_singleton]
    using @image_mem_map _ _ _ (coe : s â†’ Î±) _ this
end
lemma nhds_within_of_mem_discrete {s : set Î±} [discrete_topology s] {x : Î±} (hx : x âˆˆ s) :
  ğ“[s] x = pure x :=
le_antisymm (le_pure_iff.2 $ singleton_mem_nhds_within_of_mem_discrete hx) (pure_le_nhds_within hx)
lemma filter.has_basis.exists_inter_eq_singleton_of_mem_discrete
  {Î¹ : Type*} {p : Î¹ â†’ Prop} {t : Î¹ â†’ set Î±} {s : set Î±} [discrete_topology s] {x : Î±}
  (hb : (ğ“ x).has_basis p t) (hx : x âˆˆ s) :
  âˆƒ i (hi : p i), t i âˆ© s = {x} :=
begin
  rcases (nhds_within_has_basis hb s).mem_iff.1 (singleton_mem_nhds_within_of_mem_discrete hx)
    with âŸ¨i, hi, hixâŸ©,
  exact âŸ¨i, hi, subset.antisymm hix $ singleton_subset_iff.2
    âŸ¨mem_of_mem_nhds $ hb.mem_of_mem hi, hxâŸ©âŸ©
end
lemma nhds_inter_eq_singleton_of_mem_discrete {s : set Î±} [discrete_topology s]
  {x : Î±} (hx : x âˆˆ s) :
  âˆƒ U âˆˆ ğ“ x, U âˆ© s = {x} :=
by simpa using (ğ“ x).basis_sets.exists_inter_eq_singleton_of_mem_discrete hx
lemma disjoint_nhds_within_of_mem_discrete {s : set Î±} [discrete_topology s] {x : Î±} (hx : x âˆˆ s) :
  âˆƒ U âˆˆ ğ“[â‰ ] x, disjoint U s :=
let âŸ¨V, h, h'âŸ© := nhds_inter_eq_singleton_of_mem_discrete hx in
  âŸ¨{x}á¶œ âˆ© V, inter_mem_nhds_within _ h,
    (disjoint_iff_inter_eq_empty.mpr (by { rw [inter_assoc, h', compl_inter_self] }))âŸ©
lemma topological_space.subset_trans {X : Type*} [tX : topological_space X]
  {s t : set X} (ts : t âŠ† s) :
  (subtype.topological_space : topological_space t) =
    (subtype.topological_space : topological_space s).induced (set.inclusion ts) :=
begin
  change tX.induced ((coe : s â†’ X) âˆ˜ (set.inclusion ts)) =
    topological_space.induced (set.inclusion ts) (tX.induced _),
  rw â† induced_compose,
end
lemma discrete_topology_iff_nhds {X : Type*} [topological_space X] :
  discrete_topology X â†” (nhds : X â†’ filter X) = pure :=
begin
  split,
  { introI hX,
    exact nhds_discrete X },
  { intro h,
    constructor,
    apply eq_of_nhds_eq_nhds,
    simp [h, nhds_bot] }
end
lemma induced_bot {X Y : Type*} {f : X â†’ Y} (hf : function.injective f) :
  topological_space.induced f âŠ¥ = âŠ¥ :=
eq_of_nhds_eq_nhds (by simp [nhds_induced, â† set.image_singleton, hf.preimage_image, nhds_bot])
lemma discrete_topology_induced {X Y : Type*} [tY : topological_space Y] [discrete_topology Y]
  {f : X â†’ Y} (hf : function.injective f) : @discrete_topology X (topological_space.induced f tY) :=
begin
  constructor,
  rw discrete_topology.eq_bot Y,
  exact induced_bot hf
end
lemma discrete_topology.of_subset {X : Type*} [topological_space X] {s t : set X}
  (ds : discrete_topology s) (ts : t âŠ† s) :
  discrete_topology t :=
begin
  rw [topological_space.subset_trans ts, ds.eq_bot],
  exact {eq_bot := induced_bot (set.inclusion_injective ts)}
end
@[mk_iff] class t2_space (Î± : Type u) [topological_space Î±] : Prop :=
(t2 : âˆ€ x y, x â‰  y â†’ âˆƒ u v : set Î±, is_open u âˆ§ is_open v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ disjoint u v)
lemma t2_separation [t2_space Î±] {x y : Î±} (h : x â‰  y) :
  âˆƒ u v : set Î±, is_open u âˆ§ is_open v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ disjoint u v :=
t2_space.t2 x y h
lemma t2_separation_finset [t2_space Î±] (s : finset Î±) :
  âˆƒ f : Î± â†’ set Î±, set.pairwise_disjoint â†‘s f âˆ§ âˆ€ x âˆˆ s, x âˆˆ f x âˆ§ is_open (f x) :=
finset.induction_on s (by simp) begin
  rintros t s ht âŸ¨f, hf, hf'âŸ©,
  have hty : âˆ€ y : s, t â‰  y := by { rintros y rfl, exact ht y.2 },
  choose u v hu hv htu hxv huv using Î» {x} (h : t â‰  x), t2_separation h,
  refine âŸ¨Î» x, if ht : t = x then â‹‚ y : s, u (hty y) else f x âˆ© v ht, _, _âŸ©,
  { rintros x hxâ‚ y hyâ‚ hxy a âŸ¨hx, hyâŸ©,
    rw [finset.mem_coe, finset.mem_insert, eq_comm] at hxâ‚ hyâ‚,
    rcases eq_or_ne t x with rfl | hxâ‚‚;
    rcases eq_or_ne t y with rfl | hyâ‚‚,
    { exact hxy rfl },
    { simp_rw [dif_pos rfl, mem_Inter] at hx,
      simp_rw [dif_neg hyâ‚‚] at hy,
      exact huv hyâ‚‚ âŸ¨hx âŸ¨y, hyâ‚.resolve_left hyâ‚‚âŸ©, hy.2âŸ© },
    { simp_rw [dif_neg hxâ‚‚] at hx,
      simp_rw [dif_pos rfl, mem_Inter] at hy,
      exact huv hxâ‚‚ âŸ¨hy âŸ¨x, hxâ‚.resolve_left hxâ‚‚âŸ©, hx.2âŸ© },
    { simp_rw [dif_neg hxâ‚‚] at hx,
      simp_rw [dif_neg hyâ‚‚] at hy,
      exact hf (hxâ‚.resolve_left hxâ‚‚) (hyâ‚.resolve_left hyâ‚‚) hxy âŸ¨hx.1, hy.1âŸ© } },
  { intros x hx,
    split_ifs with ht,
    { refine âŸ¨mem_Inter.2 (Î» y, _), is_open_Inter (Î» y, hu (hty y))âŸ©,
      rw â†ht,
      exact htu (hty y) },
    { have hx := hf' x ((finset.mem_insert.1 hx).resolve_left (ne.symm ht)),
      exact âŸ¨âŸ¨hx.1, hxv htâŸ©, is_open.inter hx.2 (hv ht)âŸ© } }
end
lemma t2_iff_nhds : t2_space Î± â†” âˆ€ {x y : Î±}, ne_bot (ğ“ x âŠ“ ğ“ y) â†’ x = y :=
âŸ¨assume h, by exactI Î» x y, eq_of_nhds_ne_bot,
 assume h, âŸ¨assume x y xy,
   have ğ“ x âŠ“ ğ“ y = âŠ¥ := not_ne_bot.1 $ mt h xy,
   let âŸ¨u', hu', v', hv', u'v'âŸ© := empty_mem_iff_bot.mpr this,
       âŸ¨u, uu', uo, huâŸ© := mem_nhds_iff.mp hu',
       âŸ¨v, vv', vo, hvâŸ© := mem_nhds_iff.mp hv' in
   âŸ¨u, v, uo, vo, hu, hv, (disjoint_iff_inter_eq_empty.2 u'v'.symm).mono uu' vv'âŸ©âŸ©âŸ©
lemma t2_space_iff_nhds : t2_space Î± â†” âˆ€ {x y : Î±}, x â‰  y â†’ âˆƒ (U âˆˆ ğ“ x) (V âˆˆ ğ“ y), disjoint U V :=
begin
  split,
  { rintro âŸ¨hâŸ© x y hxy,
    rcases h x y hxy with âŸ¨u, v, u_op, v_op, hx, hy, HâŸ©,
    exact âŸ¨u, u_op.mem_nhds hx, v, v_op.mem_nhds hy, HâŸ© },
  { refine Î» h, âŸ¨Î» x y hxy, _âŸ©,
    rcases h hxy with âŸ¨u, u_in, v, v_in, HâŸ©,
    rcases mem_nhds_iff.mp u_in with âŸ¨U, hUu, U_op, hxUâŸ©,
    rcases mem_nhds_iff.mp v_in with âŸ¨V, hVv, V_op, hyVâŸ©,
    exact âŸ¨U, V, U_op, V_op, hxU, hyV, H.mono hUu hVvâŸ© }
end
lemma t2_separation_nhds [t2_space Î±] {x y : Î±} (h : x â‰  y) :
  âˆƒ u v, u âˆˆ ğ“ x âˆ§ v âˆˆ ğ“ y âˆ§ disjoint u v :=
let âŸ¨u, v, open_u, open_v, x_in, y_in, huvâŸ© := t2_separation h in
âŸ¨u, v, open_u.mem_nhds x_in, open_v.mem_nhds y_in, huvâŸ©
lemma t2_separation_compact_nhds [locally_compact_space Î±] [t2_space Î±] {x y : Î±} (h : x â‰  y) :
  âˆƒ u v, u âˆˆ ğ“ x âˆ§ v âˆˆ ğ“ y âˆ§ is_compact u âˆ§ is_compact v âˆ§ disjoint u v :=
begin
  obtain âŸ¨uâ‚€, vâ‚€, uâ‚€_in, vâ‚€_in, huâ‚€vâ‚€âŸ© := t2_separation_nhds h,
  obtain âŸ¨Kâ‚€, Kâ‚€_in, Kâ‚€_uâ‚€, hKâ‚€âŸ© := local_compact_nhds uâ‚€_in,
  obtain âŸ¨Lâ‚€, Lâ‚€_in, Lâ‚€_vâ‚€, hLâ‚€âŸ© := local_compact_nhds vâ‚€_in,
  exact âŸ¨Kâ‚€, Lâ‚€, Kâ‚€_in, Lâ‚€_in, hKâ‚€, hLâ‚€, huâ‚€vâ‚€.mono Kâ‚€_uâ‚€ Lâ‚€_vâ‚€âŸ©,
end
lemma t2_iff_ultrafilter :
  t2_space Î± â†” âˆ€ {x y : Î±} (f : ultrafilter Î±), â†‘f â‰¤ ğ“ x â†’ â†‘f â‰¤ ğ“ y â†’ x = y :=
t2_iff_nhds.trans $ by simp only [â†exists_ultrafilter_iff, and_imp, le_inf_iff, exists_imp_distrib]
lemma is_closed_diagonal [t2_space Î±] : is_closed (diagonal Î±) :=
begin
  refine is_closed_iff_cluster_pt.mpr _,
  rintro âŸ¨aâ‚, aâ‚‚âŸ© h,
  refine eq_of_nhds_ne_bot âŸ¨Î» this : ğ“ aâ‚ âŠ“ ğ“ aâ‚‚ = âŠ¥, h.ne _âŸ©,
  obtain âŸ¨tâ‚, (htâ‚ : tâ‚ âˆˆ ğ“ aâ‚), tâ‚‚, (htâ‚‚ : tâ‚‚ âˆˆ ğ“ aâ‚‚), (h' : tâ‚ âˆ© tâ‚‚ = âˆ…)âŸ© :=
    inf_eq_bot_iff.1 this,
  rw [inf_principal_eq_bot, nhds_prod_eq],
  apply mem_of_superset (prod_mem_prod htâ‚ htâ‚‚),
  rintro âŸ¨x, yâŸ© âŸ¨x_in, y_inâŸ© (heq : x = y),
  rw â† heq at *,
  have : x âˆˆ tâ‚ âˆ© tâ‚‚ := âŸ¨x_in, y_inâŸ©,
  rwa h' at this
end
lemma t2_iff_is_closed_diagonal : t2_space Î± â†” is_closed (diagonal Î±) :=
begin
  split,
  { introI h,
    exact is_closed_diagonal },
  { intro h,
    constructor,
    intros x y hxy,
    have : (x, y) âˆˆ (diagonal Î±)á¶œ, by rwa [mem_compl_iff],
    obtain âŸ¨t, t_sub, t_op, xytâŸ© : âˆƒ t âŠ† (diagonal Î±)á¶œ, is_open t âˆ§ (x, y) âˆˆ t :=
      is_open_iff_forall_mem_open.mp h.is_open_compl _ this,
    rcases is_open_prod_iff.mp t_op x y xyt with âŸ¨U, V, U_op, V_op, xU, yV, HâŸ©,
    exact âŸ¨U, V, U_op, V_op, xU, yV, prod_subset_compl_diagonal_iff_disjoint.1 (H.trans t_sub)âŸ© }
end
section separated
open separated finset
lemma finset_disjoint_finset_opens_of_t2 [t2_space Î±] :
  âˆ€ (s t : finset Î±), disjoint s t â†’ separated (s : set Î±) t :=
begin
  refine induction_on_union _ (Î» a b hi d, (hi d.symm).symm) (Î» a d, empty_right a) (Î» a b ab, _) _,
  { obtain âŸ¨U, V, oU, oV, aU, bV, UVâŸ© := t2_separation (finset.disjoint_singleton.1 ab),
    refine âŸ¨U, V, oU, oV, _, _, UVâŸ©;
    exact singleton_subset_set_iff.mpr â€¹_â€º },
  { intros a b c ac bc d,
    apply_mod_cast union_left (ac (disjoint_of_subset_left (a.subset_union_left b) d)) (bc _),
    exact disjoint_of_subset_left (a.subset_union_right b) d },
end
lemma point_disjoint_finset_opens_of_t2 [t2_space Î±] {x : Î±} {s : finset Î±} (h : x âˆ‰ s) :
  separated ({x} : set Î±) s :=
by exact_mod_cast finset_disjoint_finset_opens_of_t2 {x} s (finset.disjoint_singleton_left.mpr h)
end separated
lemma tendsto_nhds_unique [t2_space Î±] {f : Î² â†’ Î±} {l : filter Î²} {a b : Î±}
  [ne_bot l] (ha : tendsto f l (ğ“ a)) (hb : tendsto f l (ğ“ b)) : a = b :=
eq_of_nhds_ne_bot $ ne_bot_of_le $ le_inf ha hb
lemma tendsto_nhds_unique' [t2_space Î±] {f : Î² â†’ Î±} {l : filter Î²} {a b : Î±}
  (hl : ne_bot l) (ha : tendsto f l (ğ“ a)) (hb : tendsto f l (ğ“ b)) : a = b :=
eq_of_nhds_ne_bot $ ne_bot_of_le $ le_inf ha hb
lemma tendsto_nhds_unique_of_eventually_eq [t2_space Î±] {f g : Î² â†’ Î±} {l : filter Î²} {a b : Î±}
  [ne_bot l] (ha : tendsto f l (ğ“ a)) (hb : tendsto g l (ğ“ b)) (hfg : f =á¶ [l] g) :
  a = b :=
tendsto_nhds_unique (ha.congr' hfg) hb
lemma tendsto_nhds_unique_of_frequently_eq [t2_space Î±] {f g : Î² â†’ Î±} {l : filter Î²} {a b : Î±}
  (ha : tendsto f l (ğ“ a)) (hb : tendsto g l (ğ“ b)) (hfg : âˆƒá¶  x in l, f x = g x) :
  a = b :=
have âˆƒá¶  z : Î± Ã— Î± in ğ“ (a, b), z.1 = z.2 := (ha.prod_mk_nhds hb).frequently hfg,
not_not.1 $ Î» hne, this (is_closed_diagonal.is_open_compl.mem_nhds hne)
class t2_5_space (Î± : Type u) [topological_space Î±]: Prop :=
(t2_5 : âˆ€ x y  (h : x â‰  y), âˆƒ (U V: set Î±), is_open U âˆ§  is_open V âˆ§
                                            disjoint (closure U) (closure V) âˆ§ x âˆˆ U âˆ§ y âˆˆ V)
lemma Lim_eq {a : Î±} [ne_bot f] (h : f â‰¤ ğ“ a) :
  @Lim _ _ âŸ¨aâŸ© f = a :=
tendsto_nhds_unique (le_nhds_Lim âŸ¨a, hâŸ©) h
lemma Lim_eq_iff [ne_bot f] (h : âˆƒ (a : Î±), f â‰¤ nhds a) {a} : @Lim _ _ âŸ¨aâŸ© f = a â†” f â‰¤ ğ“ a :=
âŸ¨Î» c, c â–¸ le_nhds_Lim h, Lim_eqâŸ©
lemma ultrafilter.Lim_eq_iff_le_nhds [compact_space Î±] {x : Î±} {F : ultrafilter Î±} :
  F.Lim = x â†” â†‘F â‰¤ ğ“ x :=
âŸ¨Î» h, h â–¸ F.le_nhds_Lim, Lim_eqâŸ©
lemma is_open_iff_ultrafilter' [compact_space Î±] (U : set Î±) :
  is_open U â†” (âˆ€ F : ultrafilter Î±, F.Lim âˆˆ U â†’ U âˆˆ F.1) :=
begin
  rw is_open_iff_ultrafilter,
  refine âŸ¨Î» h F hF, h F.Lim hF F F.le_nhds_Lim, _âŸ©,
  intros cond x hx f h,
  rw [â† (ultrafilter.Lim_eq_iff_le_nhds.2 h)] at hx,
  exact cond _ hx
end
lemma filter.tendsto.lim_eq {a : Î±} {f : filter Î²} [ne_bot f] {g : Î² â†’ Î±} (h : tendsto g f (ğ“ a)) :
  @lim _ _ _ âŸ¨aâŸ© f g = a :=
Lim_eq h
lemma filter.lim_eq_iff {f : filter Î²} [ne_bot f] {g : Î² â†’ Î±} (h : âˆƒ a, tendsto g f (ğ“ a)) {a} :
  @lim _ _ _ âŸ¨aâŸ© f g = a â†” tendsto g f (ğ“ a) :=
âŸ¨Î» c, c â–¸ tendsto_nhds_lim h, filter.tendsto.lim_eqâŸ©
lemma continuous.lim_eq [topological_space Î²] {f : Î² â†’ Î±} (h : continuous f) (a : Î²) :
  @lim _ _ _ âŸ¨f aâŸ© (ğ“ a) f = f a :=
(h.tendsto a).lim_eq
@[simp] lemma Lim_nhds (a : Î±) : @Lim _ _ âŸ¨aâŸ© (ğ“ a) = a :=
Lim_eq le_rfl
@[simp] lemma lim_nhds_id (a : Î±) : @lim _ _ _ âŸ¨aâŸ© (ğ“ a) id = a :=
Lim_nhds a
@[simp] lemma Lim_nhds_within {a : Î±} {s : set Î±} (h : a âˆˆ closure s) :
  @Lim _ _ âŸ¨aâŸ© (ğ“[s] a) = a :=
by haveI : ne_bot (ğ“[s] a) := mem_closure_iff_cluster_pt.1 h;
exact Lim_eq inf_le_left
@[simp] lemma lim_nhds_within_id {a : Î±} {s : set Î±} (h : a âˆˆ closure s) :
  @lim _ _ _ âŸ¨aâŸ© (ğ“[s] a) id = a :=
Lim_nhds_within h
end lim
lemma set.eq_on.closure [t2_space Î±] {s : set Î²} {f g : Î² â†’ Î±} (h : eq_on f g s)
  (hf : continuous f) (hg : continuous g) :
  eq_on f g (closure s) :=
closure_minimal h (is_closed_eq hf hg)
lemma continuous.ext_on [t2_space Î±] {s : set Î²} (hs : dense s) {f g : Î² â†’ Î±}
  (hf : continuous f) (hg : continuous g) (h : eq_on f g s) :
  f = g :=
funext $ Î» x, h.closure hf hg (hs x)
lemma set.eq_on.of_subset_closure [t2_space Î±] {s t : set Î²} {f g : Î² â†’ Î±} (h : eq_on f g s)
  (hf : continuous_on f t) (hg : continuous_on g t) (hst : s âŠ† t) (hts : t âŠ† closure s) :
  eq_on f g t :=
begin
  intros x hx,
  haveI : (ğ“[s] x).ne_bot, from mem_closure_iff_cluster_pt.mp (hts hx),
  exact tendsto_nhds_unique_of_eventually_eq ((hf x hx).mono_left $ nhds_within_mono _ hst)
    ((hg x hx).mono_left $ nhds_within_mono _ hst) (h.eventually_eq_of_mem self_mem_nhds_within)
end
lemma function.left_inverse.closed_range [t2_space Î±] {f : Î± â†’ Î²} {g : Î² â†’ Î±}
  (h : function.left_inverse f g) (hf : continuous f) (hg : continuous g) :
  is_closed (range g) :=
have eq_on (g âˆ˜ f) id (closure $ range g),
  from h.right_inv_on_range.eq_on.closure (hg.comp hf) continuous_id,
is_closed_of_closure_subset $ Î» x hx,
calc x = g (f x) : (this hx).symm
   ... âˆˆ _ : mem_range_self _
lemma function.left_inverse.closed_embedding [t2_space Î±] {f : Î± â†’ Î²} {g : Î² â†’ Î±}
  (h : function.left_inverse f g) (hf : continuous f) (hg : continuous g) :
  closed_embedding g :=
âŸ¨h.embedding hf hg, h.closed_range hf hgâŸ©
lemma compact_compact_separated [t2_space Î±] {s t : set Î±}
  (hs : is_compact s) (ht : is_compact t) (hst : disjoint s t) :
  âˆƒ u v, is_open u âˆ§ is_open v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ disjoint u v :=
by simp only [prod_subset_compl_diagonal_iff_disjoint.symm] at âŠ¢ hst;
   exact generalized_tube_lemma hs ht is_closed_diagonal.is_open_compl hst
lemma is_compact.is_closed [t2_space Î±] {s : set Î±} (hs : is_compact s) : is_closed s :=
is_open_compl_iff.1 $ is_open_iff_forall_mem_open.mpr $ assume x hx,
  let âŸ¨u, v, uo, vo, su, xv, uvâŸ© :=
    compact_compact_separated hs is_compact_singleton (disjoint_singleton_right.2 hx) in
âŸ¨v, (uv.mono_left $ show s â‰¤ u, from su).subset_compl_left, vo, by simpa using xvâŸ©
@[simp] lemma filter.coclosed_compact_eq_cocompact [t2_space Î±] :
  coclosed_compact Î± = cocompact Î± :=
by simp [coclosed_compact, cocompact, infi_and', and_iff_right_of_imp is_compact.is_closed]
@[simp] lemma bornology.relatively_compact_eq_in_compact [t2_space Î±] :
  bornology.relatively_compact Î± = bornology.in_compact Î± :=
by rw bornology.ext_iff; exact filter.coclosed_compact_eq_cocompact
lemma exists_subset_nhd_of_compact [t2_space Î±] {Î¹ : Type*} [nonempty Î¹] {V : Î¹ â†’ set Î±}
  (hV : directed (âŠ‡) V) (hV_cpct : âˆ€ i, is_compact (V i)) {U : set Î±}
  (hU : âˆ€ x âˆˆ â‹‚ i, V i, U âˆˆ ğ“ x) : âˆƒ i, V i âŠ† U :=
exists_subset_nhd_of_compact' hV hV_cpct (Î» i, (hV_cpct i).is_closed) hU
lemma compact_exhaustion.is_closed [t2_space Î±] (K : compact_exhaustion Î±) (n : â„•) :
  is_closed (K n) :=
(K.is_compact n).is_closed
lemma is_compact.inter [t2_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_compact t) :
  is_compact (s âˆ© t) :=
hs.inter_right $ ht.is_closed
lemma compact_closure_of_subset_compact [t2_space Î±] {s t : set Î±} (ht : is_compact t) (h : s âŠ† t) :
  is_compact (closure s) :=
compact_of_is_closed_subset ht is_closed_closure (closure_minimal h ht.is_closed)
@[simp]
lemma exists_compact_superset_iff [t2_space Î±] {s : set Î±} :
  (âˆƒ K, is_compact K âˆ§ s âŠ† K) â†” is_compact (closure s) :=
âŸ¨Î» âŸ¨K, hK, hsKâŸ©, compact_closure_of_subset_compact hK hsK, Î» h, âŸ¨closure s, h, subset_closureâŸ©âŸ©
lemma image_closure_of_compact [t2_space Î²]
  {s : set Î±} (hs : is_compact (closure s)) {f : Î± â†’ Î²} (hf : continuous_on f (closure s)) :
  f '' closure s = closure (f '' s) :=
subset.antisymm hf.image_closure $ closure_minimal (image_subset f subset_closure)
  (hs.image_of_continuous_on hf).is_closed
lemma is_compact.binary_compact_cover [t2_space Î±] {K U V : set Î±} (hK : is_compact K)
  (hU : is_open U) (hV : is_open V) (h2K : K âŠ† U âˆª V) :
  âˆƒ Kâ‚ Kâ‚‚ : set Î±, is_compact Kâ‚ âˆ§ is_compact Kâ‚‚ âˆ§ Kâ‚ âŠ† U âˆ§ Kâ‚‚ âŠ† V âˆ§ K = Kâ‚ âˆª Kâ‚‚ :=
begin
  obtain âŸ¨Oâ‚, Oâ‚‚, h1Oâ‚, h1Oâ‚‚, h2Oâ‚, h2Oâ‚‚, hOâŸ© := compact_compact_separated (hK.diff hU) (hK.diff hV)
    (by rwa [disjoint_iff_inter_eq_empty, diff_inter_diff, diff_eq_empty]),
  exact âŸ¨_, _, hK.diff h1Oâ‚, hK.diff h1Oâ‚‚, by rwa [diff_subset_comm], by rwa [diff_subset_comm],
    by rw [â† diff_inter, hO.inter_eq, diff_empty]âŸ©
end
lemma continuous.is_closed_map [compact_space Î±] [t2_space Î²] {f : Î± â†’ Î²} (h : continuous f) :
  is_closed_map f :=
Î» s hs, (hs.is_compact.image h).is_closed
lemma continuous.closed_embedding [compact_space Î±] [t2_space Î²] {f : Î± â†’ Î²} (h : continuous f)
  (hf : function.injective f) : closed_embedding f :=
closed_embedding_of_continuous_injective_closed h hf h.is_closed_map
section
open finset function
lemma is_compact.finite_compact_cover [t2_space Î±] {s : set Î±} (hs : is_compact s)
  {Î¹} (t : finset Î¹) (U : Î¹ â†’ set Î±) (hU : âˆ€ i âˆˆ t, is_open (U i)) (hsC : s âŠ† â‹ƒ i âˆˆ t, U i) :
  âˆƒ K : Î¹ â†’ set Î±, (âˆ€ i, is_compact (K i)) âˆ§ (âˆ€i, K i âŠ† U i) âˆ§ s = â‹ƒ i âˆˆ t, K i :=
begin
  classical,
  induction t using finset.induction with x t hx ih generalizing U hU s hs hsC,
  { refine âŸ¨Î» _, âˆ…, Î» i, is_compact_empty, Î» i, empty_subset _, _âŸ©,
    simpa only [subset_empty_iff, Union_false, Union_empty] using hsC },
  simp only [finset.set_bUnion_insert] at hsC,
  simp only [finset.mem_insert] at hU,
  have hU' : âˆ€ i âˆˆ t, is_open (U i) := Î» i hi, hU i (or.inr hi),
  rcases hs.binary_compact_cover (hU x (or.inl rfl)) (is_open_bUnion hU') hsC
    with âŸ¨Kâ‚, Kâ‚‚, h1Kâ‚, h1Kâ‚‚, h2Kâ‚, h2Kâ‚‚, hKâŸ©,
  rcases ih U hU' h1Kâ‚‚ h2Kâ‚‚ with âŸ¨K, h1K, h2K, h3KâŸ©,
  refine âŸ¨update K x Kâ‚, _, _, _âŸ©,
  { intros i, by_cases hi : i = x,
    { simp only [update_same, hi, h1Kâ‚] },
    { rw [â† ne.def] at hi, simp only [update_noteq hi, h1K] }},
  { intros i, by_cases hi : i = x,
    { simp only [update_same, hi, h2Kâ‚] },
    { rw [â† ne.def] at hi, simp only [update_noteq hi, h2K] }},
  { simp only [set_bUnion_insert_update _ hx, hK, h3K] }
end
end
lemma locally_compact_of_compact_nhds [t2_space Î±] (h : âˆ€ x : Î±, âˆƒ s, s âˆˆ ğ“ x âˆ§ is_compact s) :
  locally_compact_space Î± :=
âŸ¨assume x n hn,
  let âŸ¨u, un, uo, xuâŸ© := mem_nhds_iff.mp hn in
  let âŸ¨k, kx, kcâŸ© := h x in
lemma exists_open_with_compact_closure [locally_compact_space Î±] [t2_space Î±] (x : Î±) :
  âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ is_compact (closure U) :=
begin
  rcases exists_compact_mem_nhds x with âŸ¨K, hKc, hxKâŸ©,
  rcases mem_nhds_iff.1 hxK with âŸ¨t, h1t, h2t, h3tâŸ©,
  exact âŸ¨t, h2t, h3t, compact_closure_of_subset_compact hKc h1tâŸ©
end
lemma exists_open_superset_and_is_compact_closure [locally_compact_space Î±] [t2_space Î±]
  {K : set Î±} (hK : is_compact K) : âˆƒ V, is_open V âˆ§ K âŠ† V âˆ§ is_compact (closure V) :=
begin
  rcases exists_compact_superset hK with âŸ¨K', hK', hKK'âŸ©,
  refine âŸ¨interior K', is_open_interior, hKK',
    compact_closure_of_subset_compact hK' interior_subsetâŸ©,
end
lemma is_preirreducible_iff_subsingleton [t2_space Î±] (S : set Î±) :
  is_preirreducible S â†” S.subsingleton :=
begin
  refine âŸ¨Î» h x hx y hy, _, set.subsingleton.is_preirreducibleâŸ©,
  by_contradiction e,
  obtain âŸ¨U, V, hU, hV, hxU, hyV, h'âŸ© := t2_separation e,
  exact ((h U V hU hV âŸ¨x, hx, hxUâŸ© âŸ¨y, hy, hyVâŸ©).mono $ inter_subset_right _ _).not_disjoint h',
end
lemma is_irreducible_iff_singleton [t2_space Î±] (S : set Î±) :
  is_irreducible S â†” âˆƒ x, S = {x} :=
by rw [is_irreducible, is_preirreducible_iff_subsingleton,
  exists_eq_singleton_iff_nonempty_subsingleton]
end separation
section regularity
class regular_space (Î± : Type u) [topological_space Î±] extends t0_space Î± : Prop :=
(regular : âˆ€{s:set Î±} {a}, is_closed s â†’ a âˆ‰ s â†’ âˆƒt, is_open t âˆ§ s âŠ† t âˆ§ ğ“[t] a = âŠ¥)
lemma disjoint_nested_nhds [regular_space Î±] {x y : Î±} (h : x â‰  y) :
  âˆƒ (Uâ‚ Vâ‚ âˆˆ ğ“ x) (Uâ‚‚ Vâ‚‚ âˆˆ ğ“ y), is_closed Vâ‚ âˆ§ is_closed Vâ‚‚ âˆ§ is_open Uâ‚ âˆ§ is_open Uâ‚‚ âˆ§
  Vâ‚ âŠ† Uâ‚ âˆ§ Vâ‚‚ âŠ† Uâ‚‚ âˆ§ disjoint Uâ‚ Uâ‚‚ :=
begin
  rcases t2_separation h with âŸ¨Uâ‚, Uâ‚‚, Uâ‚_op, Uâ‚‚_op, x_in, y_in, HâŸ©,
  rcases nhds_is_closed (is_open.mem_nhds Uâ‚_op x_in) with âŸ¨Vâ‚, Vâ‚_in, hâ‚, Vâ‚_closedâŸ©,
  rcases nhds_is_closed (is_open.mem_nhds Uâ‚‚_op y_in) with âŸ¨Vâ‚‚, Vâ‚‚_in, hâ‚‚, Vâ‚‚_closedâŸ©,
  use [Uâ‚, mem_of_superset Vâ‚_in hâ‚, Vâ‚, Vâ‚_in,
       Uâ‚‚, mem_of_superset Vâ‚‚_in hâ‚‚, Vâ‚‚, Vâ‚‚_in],
  tauto
end
lemma exists_compact_between [locally_compact_space Î±] [regular_space Î±]
  {K U : set Î±} (hK : is_compact K) (hU : is_open U) (hKU : K âŠ† U) :
  âˆƒ K', is_compact K' âˆ§ K âŠ† interior K' âˆ§ K' âŠ† U :=
begin
  choose C hxC hCU hC using Î» x : K, nhds_is_closed (hU.mem_nhds $ hKU x.2),
  choose L hL hxL using Î» x : K, exists_compact_mem_nhds (x : Î±),
  have : K âŠ† â‹ƒ x, interior (L x) âˆ© interior (C x), from
  Î» x hx, mem_Union.mpr âŸ¨âŸ¨x, hxâŸ©,
    âŸ¨mem_interior_iff_mem_nhds.mpr (hxL _), mem_interior_iff_mem_nhds.mpr (hxC _)âŸ©âŸ©,
  rcases hK.elim_finite_subcover _ _ this with âŸ¨t, htâŸ©,
  { refine âŸ¨â‹ƒ x âˆˆ t, L x âˆ© C x, t.compact_bUnion (Î» x _, (hL x).inter_right (hC x)), Î» x hx, _, _âŸ©,
    { obtain âŸ¨y, hyt, hy : x âˆˆ interior (L y) âˆ© interior (C y)âŸ© := mem_Unionâ‚‚.mp (ht hx),
      rw [â† interior_inter] at hy,
      refine interior_mono (subset_bUnion_of_mem hyt) hy },
    { simp_rw [Union_subset_iff], rintro x -, exact (inter_subset_right _ _).trans (hCU _) } },
  { exact Î» _, is_open_interior.inter is_open_interior }
end
lemma exists_open_between_and_is_compact_closure [locally_compact_space Î±] [regular_space Î±]
  {K U : set Î±} (hK : is_compact K) (hU : is_open U) (hKU : K âŠ† U) :
  âˆƒ V, is_open V âˆ§ K âŠ† V âˆ§ closure V âŠ† U âˆ§ is_compact (closure V) :=
begin
  rcases exists_compact_between hK hU hKU with âŸ¨V, hV, hKV, hVUâŸ©,
  refine âŸ¨interior V, is_open_interior, hKV,
    (closure_minimal interior_subset hV.is_closed).trans hVU,
    compact_closure_of_subset_compact hV interior_subsetâŸ©,
end
end regularity
section normality
class normal_space (Î± : Type u) [topological_space Î±] extends t1_space Î± : Prop :=
(normal : âˆ€ s t : set Î±, is_closed s â†’ is_closed t â†’ disjoint s t â†’
  âˆƒ u v, is_open u âˆ§ is_open v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ disjoint u v)
theorem normal_separation [normal_space Î±] {s t : set Î±}
  (H1 : is_closed s) (H2 : is_closed t) (H3 : disjoint s t) :
  âˆƒ u v, is_open u âˆ§ is_open v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ disjoint u v :=
normal_space.normal s t H1 H2 H3
theorem normal_exists_closure_subset [normal_space Î±] {s t : set Î±} (hs : is_closed s)
  (ht : is_open t) (hst : s âŠ† t) :
  âˆƒ u, is_open u âˆ§ s âŠ† u âˆ§ closure u âŠ† t :=
begin
  have : disjoint s tá¶œ, from Î» x âŸ¨hxs, hxtâŸ©, hxt (hst hxs),
  rcases normal_separation hs (is_closed_compl_iff.2 ht) this
    with âŸ¨s', t', hs', ht', hss', htt', hs't'âŸ©,
  refine âŸ¨s', hs', hss',
    subset.trans (closure_minimal _ (is_closed_compl_iff.2 ht')) (compl_subset_comm.1 htt')âŸ©,
  exact Î» x hxs hxt, hs't' âŸ¨hxs, hxtâŸ©
end
lemma normal_space_of_regular_second_countable [second_countable_topology Î±] [regular_space Î±] :
  normal_space Î± :=
begin
  have key : âˆ€ {s t : set Î±}, is_closed t â†’ disjoint s t â†’
    âˆƒ U : set (countable_basis Î±), (s âŠ† â‹ƒ u âˆˆ U, â†‘u) âˆ§
      (âˆ€ u âˆˆ U, disjoint (closure â†‘u) t) âˆ§
      âˆ€ n : â„•, is_closed (â‹ƒ (u âˆˆ U) (h : encodable.encode u â‰¤ n), closure (u : set Î±)),
  { intros s t hc hd,
    rw disjoint_left at hd,
    have : âˆ€ x âˆˆ s, âˆƒ U âˆˆ countable_basis Î±, x âˆˆ U âˆ§ disjoint (closure U) t,
    { intros x hx,
      rcases (is_basis_countable_basis Î±).exists_closure_subset (hc.is_open_compl.mem_nhds (hd hx))
        with âŸ¨u, hu, hxu, hutâŸ©,
      exact âŸ¨u, hu, hxu, disjoint_left.2 hutâŸ© },
    choose! U hu hxu hd,
    set V : s â†’ countable_basis Î± := maps_to.restrict _ _ _ hu,
    refine âŸ¨range V, _, forall_range_iff.2 $ subtype.forall.2 hd, Î» n, _âŸ©,
    { rw bUnion_range,
      exact Î» x hx, mem_Union.2 âŸ¨âŸ¨x, hxâŸ©, hxu x hxâŸ© },
    { simp only [â† supr_eq_Union, supr_and'],
      exact is_closed_bUnion (((finite_le_nat n).preimage_embedding (encodable.encode' _)).subset $
        inter_subset_right _ _) (Î» u hu, is_closed_closure) } },
  refine âŸ¨Î» s t hs ht hd, _âŸ©,
  rcases key ht hd with âŸ¨U, hsU, hUd, hUcâŸ©,
  rcases key hs hd.symm with âŸ¨V, htV, hVd, hVcâŸ©,
  refine âŸ¨â‹ƒ u âˆˆ U, â†‘u \ â‹ƒ (v âˆˆ V) (hv : encodable.encode v â‰¤ encodable.encode u), closure â†‘v,
    â‹ƒ v âˆˆ V, â†‘v \ â‹ƒ (u âˆˆ U) (hu : encodable.encode u â‰¤ encodable.encode v), closure â†‘u,
    is_open_bUnion $ Î» u hu, (is_open_of_mem_countable_basis u.2).sdiff (hVc _),
    is_open_bUnion $ Î» v hv, (is_open_of_mem_countable_basis v.2).sdiff (hUc _),
    Î» x hx, _, Î» x hx, _, _âŸ©,
  { rcases mem_Unionâ‚‚.1 (hsU hx) with âŸ¨u, huU, hxuâŸ©,
    refine mem_bUnion huU âŸ¨hxu, _âŸ©,
    simp only [mem_Union],
    rintro âŸ¨v, hvV, -, hxvâŸ©,
    exact hVd v hvV âŸ¨hxv, hxâŸ© },
  { rcases mem_Unionâ‚‚.1 (htV hx) with âŸ¨v, hvV, hxvâŸ©,
    refine mem_bUnion hvV âŸ¨hxv, _âŸ©,
    simp only [mem_Union],
    rintro âŸ¨u, huU, -, hxuâŸ©,
    exact hUd u huU âŸ¨hxu, hxâŸ© },
  { simp only [disjoint_left, mem_Union, mem_diff, not_exists, not_and, not_forall, not_not],
    rintro a âŸ¨u, huU, hau, haVâŸ© v hvV hav,
    cases le_total (encodable.encode u) (encodable.encode v) with hle hle,
    exacts [âŸ¨u, huU, hle, subset_closure hauâŸ©, (haV _ hvV hle $ subset_closure hav).elim] }
end
end normality
lemma connected_component_eq_Inter_clopen [t2_space Î±] [compact_space Î±] (x : Î±) :
  connected_component x = â‹‚ Z : {Z : set Î± // is_clopen Z âˆ§ x âˆˆ Z}, Z :=
begin
  apply eq_of_subset_of_subset connected_component_subset_Inter_clopen,
lemma tot_sep_of_zero_dim (h : is_topological_basis {s : set Î± | is_clopen s}) :
  totally_separated_space Î± :=
begin
  constructor,
  rintros x - y - hxy,
  obtain âŸ¨u, v, hu, hv, xu, yv, disjâŸ© := t2_separation hxy,
  obtain âŸ¨w, hw : is_clopen w, xw, wuâŸ© := (is_topological_basis.mem_nhds_iff h).1
    (is_open.mem_nhds hu xu),
  refine âŸ¨w, wá¶œ, hw.1, hw.compl.1, xw, Î» h, disj âŸ¨wu h, yvâŸ©, _, disjoint_compl_rightâŸ©,
  rw set.union_compl_self,
end
variables [compact_space Î±]
theorem compact_t2_tot_disc_iff_tot_sep :
  totally_disconnected_space Î± â†” totally_separated_space Î± :=
begin
  split,
  { intro h, constructor,
    rintros x - y -,
    contrapose!,
    intros hyp,
    suffices : x âˆˆ connected_component y,
      by simpa [totally_disconnected_space_iff_connected_component_singleton.1 h y,
                mem_singleton_iff],
    rw [connected_component_eq_Inter_clopen, mem_Inter],
    rintro âŸ¨w : set Î±, hw : is_clopen w, hy : y âˆˆ wâŸ©,
    by_contra hx,
    exact hyp wá¶œ w hw.2.is_open_compl hw.1 hx hy (@is_compl_compl _ w _).symm.2
      disjoint_compl_left },
  apply totally_separated_space.totally_disconnected_space,
end
variables [totally_disconnected_space Î±]
lemma nhds_basis_clopen (x : Î±) : (ğ“ x).has_basis (Î» s : set Î±, x âˆˆ s âˆ§ is_clopen s) id :=
âŸ¨Î» U, begin
  split,
  { have : connected_component x = {x},
      from totally_disconnected_space_iff_connected_component_singleton.mp â€¹_â€º x,
    rw connected_component_eq_Inter_clopen at this,
    intros hU,
    let N := {Z // is_clopen Z âˆ§ x âˆˆ Z},
    suffices : âˆƒ Z : N, Z.val âŠ† U,
    { rcases this with âŸ¨âŸ¨s, hs, hs'âŸ©, hs''âŸ©,
      exact âŸ¨s, âŸ¨hs', hsâŸ©, hs''âŸ© },
    haveI : nonempty N := âŸ¨âŸ¨univ, is_clopen_univ, mem_univ xâŸ©âŸ©,
    have hNcl : âˆ€ Z : N, is_closed Z.val := (Î» Z, Z.property.1.2),
    have hdir : directed superset (Î» Z : N, Z.val),
    { rintros âŸ¨s, hs, hxsâŸ© âŸ¨t, ht, hxtâŸ©,
      exact âŸ¨âŸ¨s âˆ© t, hs.inter ht, âŸ¨hxs, hxtâŸ©âŸ©, inter_subset_left s t, inter_subset_right s tâŸ© },
    have h_nhd: âˆ€ y âˆˆ (â‹‚ Z : N, Z.val), U âˆˆ ğ“ y,
    { intros y y_in,
      erw [this, mem_singleton_iff] at y_in,
      rwa y_in },
    exact exists_subset_nhd_of_compact_space hdir hNcl h_nhd },
  { rintro âŸ¨V, âŸ¨hxV, V_op, -âŸ©, hUV : V âŠ† UâŸ©,
    rw mem_nhds_iff,
    exact âŸ¨V, hUV, V_op, hxVâŸ© }
endâŸ©
lemma is_topological_basis_clopen : is_topological_basis {s : set Î± | is_clopen s} :=
begin
  apply is_topological_basis_of_open_of_nhds (Î» U (hU : is_clopen U), hU.1),
  intros x U hxU U_op,
  have : U âˆˆ ğ“ x,
  from is_open.mem_nhds U_op hxU,
  rcases (nhds_basis_clopen x).mem_iff.mp this with âŸ¨V, âŸ¨hxV, hVâŸ©, hVU : V âŠ† UâŸ©,
  use V,
  tauto
end
lemma compact_exists_clopen_in_open {x : Î±} {U : set Î±} (is_open : is_open U) (memU : x âˆˆ U) :
    âˆƒ (V : set Î±) (hV : is_clopen V), x âˆˆ V âˆ§ V âŠ† U :=
  (is_topological_basis.mem_nhds_iff is_topological_basis_clopen).1 (is_open.mem_nhds memU)
end profinite
section locally_compact
variables {H : Type*} [topological_space H] [locally_compact_space H] [t2_space H]
lemma loc_compact_Haus_tot_disc_of_zero_dim [totally_disconnected_space H] :
  is_topological_basis {s : set H | is_clopen s} :=
begin
  refine is_topological_basis_of_open_of_nhds (Î» u hu, hu.1) _,
  rintros x U memU hU,
  obtain âŸ¨s, comp, xs, sUâŸ© := exists_compact_subset hU memU,
  obtain âŸ¨t, h, ht, xtâŸ© := mem_interior.1 xs,
  let u : set s := (coe : s â†’ H)â»Â¹' (interior s),
  have u_open_in_s : is_open u := is_open_interior.preimage continuous_subtype_coe,
  let X : s := âŸ¨x, h xtâŸ©,
  have Xu : X âˆˆ u := xs,
  haveI : compact_space s := is_compact_iff_compact_space.1 comp,
  obtain âŸ¨V : set s, clopen_in_s, Vx, V_subâŸ© := compact_exists_clopen_in_open u_open_in_s Xu,
  have V_clopen : is_clopen ((coe : s â†’ H) '' V),
  { refine âŸ¨_, (comp.is_closed.closed_embedding_subtype_coe.closed_iff_image_closed).1
               clopen_in_s.2âŸ©,
    let v : set u := (coe : u â†’ s)â»Â¹' V,
    have : (coe : u â†’ H) = (coe : s â†’ H) âˆ˜ (coe : u â†’ s) := rfl,
    have f0 : embedding (coe : u â†’ H) := embedding_subtype_coe.comp embedding_subtype_coe,
    have f1 : open_embedding (coe : u â†’ H),
    { refine âŸ¨f0, _âŸ©,
      { have : set.range (coe : u â†’ H) = interior s,
        { rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe],
          apply set.inter_eq_self_of_subset_left interior_subset, },
        rw this,
        apply is_open_interior } },
    have f2 : is_open v := clopen_in_s.1.preimage continuous_subtype_coe,
    have f3 : (coe : s â†’ H) '' V = (coe : u â†’ H) '' v,
    { rw [this, image_comp coe coe, subtype.image_preimage_coe,
          inter_eq_self_of_subset_left V_sub] },
    rw f3,
    apply f1.is_open_map v f2 },
  refine âŸ¨coe '' V, V_clopen, by simp [Vx, h xt], _âŸ©,
  transitivity s,
  { simp },
  assumption
end
theorem loc_compact_t2_tot_disc_iff_tot_sep :
  totally_disconnected_space H â†” totally_separated_space H :=
begin
  split,
  { introI h,
    exact tot_sep_of_zero_dim loc_compact_Haus_tot_disc_of_zero_dim, },
  apply totally_separated_space.totally_disconnected_space,
end
end locally_compact
instance connected_components.t2 [t2_space Î±] [compact_space Î±] :
  t2_space (connected_components Î±) :=
begin
