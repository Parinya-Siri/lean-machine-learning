import control.equiv_functor
import category_theory.groupoid
import category_theory.whiskering
import category_theory.types
namespace category_theory
@[nolint has_inhabited_instance]
def core (C : Type u‚ÇÅ) := C
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C]
instance core_category : groupoid.{v‚ÇÅ} (core C) :=
{ hom  := Œª X Y : C, X ‚âÖ Y,
  inv  := Œª X Y f, iso.symm f,
  id   := Œª X, iso.refl X,
  comp := Œª X Y Z f g, iso.trans f g }
namespace core
@[simp] lemma id_hom (X : core C) : iso.hom (ùüô X) = ùüô X := rfl
@[simp] lemma comp_hom {X Y Z : core C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : (f ‚â´ g).hom = f.hom ‚â´ g.hom :=
rfl
variables (C)
def inclusion : core C ‚•§ C :=
{ obj := id,
  map := Œª X Y f, f.hom }
instance : faithful (inclusion C) := {}
variables {C} {G : Type u‚ÇÇ} [groupoid.{v‚ÇÇ} G]
def forget_functor_to_core : (G ‚•§ core C) ‚•§ (G ‚•§ C) := (whiskering_right _ _ _).obj (inclusion C)
end core
def of_equiv_functor (m : Type u‚ÇÅ ‚Üí Type u‚ÇÇ) [equiv_functor m] :
  core (Type u‚ÇÅ) ‚•§ core (Type u‚ÇÇ) :=
{ obj       := m,
  map       := Œª Œ± Œ≤ f, (equiv_functor.map_equiv m f.to_equiv).to_iso,
