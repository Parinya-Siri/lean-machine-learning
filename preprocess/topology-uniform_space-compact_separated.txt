import topology.uniform_space.separation
import topology.uniform_space.uniform_convergence
open_locale classical uniformity topological_space filter
open filter uniform_space set
variables {Î± Î² Î³ : Type*} [uniform_space Î±] [uniform_space Î²]
lemma compact_space_uniformity [compact_space Î±] [separated_space Î±] : ğ“¤ Î± = â¨† x : Î±, ğ“ (x, x) :=
begin
  symmetry, refine le_antisymm supr_nhds_le_uniformity _,
  by_contra H,
  obtain âŸ¨V, hV, hâŸ© : âˆƒ V : set (Î± Ã— Î±), (âˆ€ x : Î±, V âˆˆ ğ“ (x, x)) âˆ§ ğ“¤ Î± âŠ“ ğ“Ÿ Vá¶œ â‰  âŠ¥,
  { simpa [le_iff_forall_inf_principal_compl] using H },
  let F := ğ“¤ Î± âŠ“ ğ“Ÿ Vá¶œ,
  haveI : ne_bot F := âŸ¨hâŸ©,
  obtain âŸ¨âŸ¨x, yâŸ©, hxâŸ© : âˆƒ (p : Î± Ã— Î±), cluster_pt p F :=
    cluster_point_of_compact F,
  have : cluster_pt (x, y) (ğ“¤ Î±) :=
    hx.of_inf_left,
  obtain rfl : x = y := eq_of_uniformity_inf_nhds this,
  have : cluster_pt (x, x) (ğ“Ÿ Vá¶œ) :=
   hx.of_inf_right,
  have : (x, x) âˆ‰ interior V,
  { have : (x, x) âˆˆ closure Vá¶œ, by rwa mem_closure_iff_cluster_pt,
    rwa closure_compl at this },
  have : (x, x) âˆˆ interior V,
  { rw mem_interior_iff_mem_nhds,
    exact hV x },
  contradiction
end
lemma unique_uniformity_of_compact_t2 [t : topological_space Î³] [compact_space Î³]
[t2_space Î³] {u u' : uniform_space Î³}
(h : u.to_topological_space = t) (h' : u'.to_topological_space = t) : u = u' :=
begin
  apply uniform_space_eq,
  change uniformity _ = uniformity _,
  haveI : @compact_space Î³ u.to_topological_space, { rw h ; assumption },
  haveI : @compact_space Î³ u'.to_topological_space, { rw h' ; assumption },
  haveI : @separated_space Î³ u, { rwa [separated_iff_t2, h] },
  haveI : @separated_space Î³ u', { rwa [separated_iff_t2, h'] },
  rw [compact_space_uniformity, compact_space_uniformity, h, h']
end
def uniform_space_of_compact_t2 [topological_space Î³] [compact_space Î³] [t2_space Î³] :
  uniform_space Î³ :=
{ uniformity := â¨† x, ğ“ (x, x),
  refl := begin
    simp_rw [filter.principal_le_iff, mem_supr],
    rintros V V_in âŸ¨x, _âŸ© âŸ¨âŸ©,
    exact mem_of_mem_nhds (V_in x),
  end,
  symm := begin
    refine le_of_eq _,
    rw map_supr,
    congr' with x : 1,
    erw [nhds_prod_eq, â† prod_comm],
  end,
  comp := begin
lemma compact_space.uniform_continuous_of_continuous [compact_space Î±] [separated_space Î±]
  {f : Î± â†’ Î²} (h : continuous f) : uniform_continuous f :=
calc
map (prod.map f f) (ğ“¤ Î±) = map (prod.map f f) (â¨† x, ğ“ (x, x))  : by rw compact_space_uniformity
                     ... =  â¨† x, map (prod.map f f) (ğ“ (x, x)) : by rw map_supr
                     ... â‰¤ â¨† x, ğ“ (f x, f x)     : supr_mono (Î» x, (h.prod_map h).continuous_at)
                     ... â‰¤ â¨† y, ğ“ (y, y)         : supr_comp_le (Î» y, ğ“ (y, y)) f
                     ... â‰¤ ğ“¤ Î²                   : supr_nhds_le_uniformity
lemma is_compact.uniform_continuous_on_of_continuous' {s : set Î±} {f : Î± â†’ Î²}
  (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=
begin
  rw uniform_continuous_on_iff_restrict,
  rw is_separated_iff_induced at hs',
  rw is_compact_iff_compact_space at hs,
  rw continuous_on_iff_continuous_restrict at hf,
  resetI,
  exact compact_space.uniform_continuous_of_continuous hf,
end
lemma is_compact.uniform_continuous_on_of_continuous [separated_space Î±] {s : set Î±} {f : Î± â†’ Î²}
  (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=
hs.uniform_continuous_on_of_continuous' (is_separated_of_separated_space s) hf
lemma continuous_on.tendsto_uniformly [locally_compact_space Î±] [compact_space Î²]
  [separated_space Î²] [uniform_space Î³] {f : Î± â†’ Î² â†’ Î³} {x : Î±} {U : set Î±}
  (hxU : U âˆˆ ğ“ x) (hU : is_separated U) (h : continuous_on â†¿f (U Ã—Ë¢ (univ : set Î²))) :
  tendsto_uniformly f (f x) (ğ“ x) :=
begin
  rcases locally_compact_space.local_compact_nhds _ _ hxU with âŸ¨K, hxK, hKU, hKâŸ©,
  have : uniform_continuous_on â†¿f (K Ã—Ë¢ (univ : set Î²)),
  { refine is_compact.uniform_continuous_on_of_continuous' (hK.prod compact_univ) _
      (h.mono $ prod_mono hKU subset.rfl),
    exact (hU.mono hKU).prod (is_separated_of_separated_space _) },
  exact this.tendsto_uniformly hxK
end
lemma continuous.tendsto_uniformly [separated_space Î±] [locally_compact_space Î±]
  [compact_space Î²] [separated_space Î²] [uniform_space Î³]
  (f : Î± â†’ Î² â†’ Î³) (h : continuous â†¿f) (x : Î±) : tendsto_uniformly f (f x) (ğ“ x) :=
h.continuous_on.tendsto_uniformly univ_mem $ is_separated_of_separated_space _
