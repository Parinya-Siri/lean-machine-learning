import category_theory.adjunction.fully_faithful
import category_theory.functor.reflects_isomorphisms
import category_theory.epi_mono
universes v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÇ u‚ÇÉ
noncomputable theory
namespace category_theory
open category adjunction
variables {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} {E : Type u‚ÇÉ}
variables [category.{v‚ÇÅ} C] [category.{v‚ÇÇ} D] [category.{v‚ÇÉ} E]
class reflective (R : D ‚•§ C) extends is_right_adjoint R, full R, faithful R.
variables {i : D ‚•§ C}
instance is_iso_unit_obj [reflective i] {B : D} :
  is_iso ((of_right_adjoint i).unit.app (i.obj B)) :=
begin
  have : (of_right_adjoint i).unit.app (i.obj B) =
            inv (i.map ((of_right_adjoint i).counit.app B)),
  { rw ‚Üê comp_hom_eq_id,
    apply (of_right_adjoint i).right_triangle_components },
  rw this,
  exact is_iso.inv_is_iso,
end
lemma functor.ess_image.unit_is_iso [reflective i] {A : C} (h : A ‚àà i.ess_image) :
  is_iso ((of_right_adjoint i).unit.app A) :=
begin
  suffices : (of_right_adjoint i).unit.app A =
                h.get_iso.inv ‚â´ (of_right_adjoint i).unit.app (i.obj h.witness) ‚â´
                  (left_adjoint i ‚ãô i).map h.get_iso.hom,
  { rw this,
    apply_instance },
  rw ‚Üê nat_trans.naturality,
  simp,
end
lemma mem_ess_image_of_unit_is_iso [is_right_adjoint i] (A : C)
  [is_iso ((of_right_adjoint i).unit.app A)] : A ‚àà i.ess_image :=
‚ü®(left_adjoint i).obj A, ‚ü®(as_iso ((of_right_adjoint i).unit.app A)).symm‚ü©‚ü©
lemma mem_ess_image_of_unit_split_mono [reflective i] {A : C}
  [split_mono ((of_right_adjoint i).unit.app A)] : A ‚àà i.ess_image :=
begin
  let Œ∑ : ùü≠ C ‚ü∂ left_adjoint i ‚ãô i := (of_right_adjoint i).unit,
  haveI : is_iso (Œ∑.app (i.obj ((left_adjoint i).obj A))) := (i.obj_mem_ess_image _).unit_is_iso,
  have : epi (Œ∑.app A),
  { apply epi_of_epi (retraction (Œ∑.app A)) _,
    rw (show retraction _ ‚â´ Œ∑.app A = _, from Œ∑.naturality (retraction (Œ∑.app A))),
    apply epi_comp (Œ∑.app (i.obj ((left_adjoint i).obj A))) },
  resetI,
  haveI := is_iso_of_epi_of_split_mono (Œ∑.app A),
  exact mem_ess_image_of_unit_is_iso A,
end
instance reflective.comp (F : C ‚•§ D) (G : D ‚•§ E) [Fr : reflective F] [Gr : reflective G] :
  reflective (F ‚ãô G) := { to_faithful := faithful.comp F G, }
def unit_comp_partial_bijective_aux [reflective i] (A : C) (B : D) :
  (A ‚ü∂ i.obj B) ‚âÉ (i.obj ((left_adjoint i).obj A) ‚ü∂ i.obj B) :=
((adjunction.of_right_adjoint i).hom_equiv _ _).symm.trans (equiv_of_fully_faithful i)
lemma unit_comp_partial_bijective_aux_symm_apply [reflective i] {A : C} {B : D}
  (f : i.obj ((left_adjoint i).obj A) ‚ü∂ i.obj B) :
  (unit_comp_partial_bijective_aux _ _).symm f = (of_right_adjoint i).unit.app A ‚â´ f :=
by simp [unit_comp_partial_bijective_aux]
def unit_comp_partial_bijective [reflective i] (A : C) {B : C} (hB : B ‚àà i.ess_image) :
  (A ‚ü∂ B) ‚âÉ (i.obj ((left_adjoint i).obj A) ‚ü∂ B) :=
calc (A ‚ü∂ B) ‚âÉ (A ‚ü∂ i.obj hB.witness) : iso.hom_congr (iso.refl _) hB.get_iso.symm
     ...     ‚âÉ (i.obj _ ‚ü∂ i.obj hB.witness) : unit_comp_partial_bijective_aux _ _
     ...     ‚âÉ (i.obj ((left_adjoint i).obj A) ‚ü∂ B) : iso.hom_congr (iso.refl _) hB.get_iso
@[simp]
lemma unit_comp_partial_bijective_symm_apply [reflective i] (A : C) {B : C}
  (hB : B ‚àà i.ess_image) (f) :
  (unit_comp_partial_bijective A hB).symm f = (of_right_adjoint i).unit.app A ‚â´ f :=
by simp [unit_comp_partial_bijective, unit_comp_partial_bijective_aux_symm_apply]
lemma unit_comp_partial_bijective_symm_natural [reflective i] (A : C) {B B' : C} (h : B ‚ü∂ B')
  (hB : B ‚àà i.ess_image) (hB' : B' ‚àà i.ess_image) (f : i.obj ((left_adjoint i).obj A) ‚ü∂ B) :
  (unit_comp_partial_bijective A hB').symm (f ‚â´ h) =
    (unit_comp_partial_bijective A hB).symm f ‚â´ h :=
by simp
lemma unit_comp_partial_bijective_natural [reflective i] (A : C) {B B' : C} (h : B ‚ü∂ B')
  (hB : B ‚àà i.ess_image) (hB' : B' ‚àà i.ess_image) (f : A ‚ü∂ B) :
  (unit_comp_partial_bijective A hB') (f ‚â´ h) = unit_comp_partial_bijective A hB f ‚â´ h :=
by rw [‚Üêequiv.eq_symm_apply, unit_comp_partial_bijective_symm_natural A h, equiv.symm_apply_apply]
@[simps]
def equiv_ess_image_of_reflective [reflective i] : D ‚âå i.ess_image :=
{ functor := i.to_ess_image,
  inverse := i.ess_image_inclusion ‚ãô (left_adjoint i : _),
  unit_iso := nat_iso.of_components (Œª X, (as_iso $ (of_right_adjoint i).counit.app X).symm)
    (by { intros X Y f, dsimp, simp only [is_iso.eq_inv_comp, is_iso.comp_inv_eq, category.assoc],
      exact ((of_right_adjoint i).counit.naturality _).symm }),
  counit_iso := nat_iso.of_components
    (Œª X, by { refine (iso.symm $ as_iso _), exact (of_right_adjoint i).unit.app X,
      apply_with (is_iso_of_reflects_iso _ i.ess_image_inclusion) { instances := ff },
      exact functor.ess_image.unit_is_iso X.prop })
    (by { intros X Y f, dsimp, simp only [is_iso.eq_inv_comp, is_iso.comp_inv_eq, category.assoc],
      exact ((of_right_adjoint i).unit.naturality f).symm }) }
end category_theory
