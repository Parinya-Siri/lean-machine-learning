import category_theory.eq_to_hom
import data.ulift
namespace category_theory
@[simps] def discrete_equiv {Œ± : Type u‚ÇÅ} : discrete Œ± ‚âÉ Œ± :=
{ to_fun := discrete.as,
  inv_fun := discrete.mk,
  left_inv := by tidy,
  right_inv := by tidy, }
instance {Œ± : Type u‚ÇÅ} [decidable_eq Œ±] : decidable_eq (discrete Œ±) :=
discrete_equiv.decidable_eq
instance discrete_category (Œ± : Type u‚ÇÅ) : small_category (discrete Œ±) :=
{ hom  := Œª X Y, ulift (plift (X.as = Y.as)),
  id   := Œª X, ulift.up (plift.up rfl),
  comp := Œª X Y Z g f, by { cases X, cases Y, cases Z, rcases f with ‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©, exact g } }
namespace discrete
variables {Œ± : Type u‚ÇÅ}
instance [inhabited Œ±] : inhabited (discrete Œ±) :=
‚ü®‚ü®default‚ü©‚ü©
instance [subsingleton Œ±] : subsingleton (discrete Œ±) :=
‚ü®by { intros, ext, apply subsingleton.elim, }‚ü©
meta def _root_.tactic.discrete_cases : tactic unit :=
`[cases_matching* [discrete _, (_ : discrete _) ‚ü∂ (_ : discrete _), plift _]]
run_cmd add_interactive [``tactic.discrete_cases]
local attribute [tidy] tactic.discrete_cases
instance [unique Œ±] : unique (discrete Œ±) :=
unique.mk' (discrete Œ±)
lemma eq_of_hom {X Y : discrete Œ±} (i : X ‚ü∂ Y) : X.as = Y.as := i.down.down
abbreviation eq_to_hom {X Y : discrete Œ±} (h : X.as = Y.as) : X ‚ü∂ Y :=
eq_to_hom (by { ext, exact h, })
abbreviation eq_to_iso {X Y : discrete Œ±} (h : X.as = Y.as) : X ‚âÖ Y :=
eq_to_iso (by { ext, exact h, })
abbreviation eq_to_hom' {a b : Œ±} (h : a = b) : discrete.mk a ‚ü∂ discrete.mk b :=
eq_to_hom h
abbreviation eq_to_iso' {a b : Œ±} (h : a = b) : discrete.mk a ‚âÖ discrete.mk b :=
eq_to_iso h
@[simp] lemma id_def (X : discrete Œ±) : ulift.up (plift.up (eq.refl X.as)) = ùüô X := rfl
variables {C : Type u‚ÇÇ} [category.{v‚ÇÇ} C]
instance {I : Type u‚ÇÅ} {i j : discrete I} (f : i ‚ü∂ j) : is_iso f :=
‚ü®‚ü®eq_to_hom (eq_of_hom f).symm, by tidy‚ü©‚ü©
def functor {I : Type u‚ÇÅ} (F : I ‚Üí C) : discrete I ‚•§ C :=
{ obj := F ‚àò discrete.as,
  map := Œª X Y f, by { discrete_cases, cases f, exact ùüô (F X), } }
@[simp] lemma functor_obj  {I : Type u‚ÇÅ} (F : I ‚Üí C) (i : I) :
  (discrete.functor F).obj (discrete.mk i) = F i := rfl
lemma functor_map  {I : Type u‚ÇÅ} (F : I ‚Üí C) {i : discrete I} (f : i ‚ü∂ i) :
  (discrete.functor F).map f = ùüô (F i.as) :=
by tidy
@[simps]
def functor_comp {I : Type u‚ÇÅ} {J : Type u‚ÇÅ'} (f : J ‚Üí C) (g : I ‚Üí J) :
  discrete.functor (f ‚àò g) ‚âÖ discrete.functor (discrete.mk ‚àò g) ‚ãô discrete.functor f :=
nat_iso.of_components (Œª X, iso.refl _) (by tidy)
@[simps]
def nat_trans {I : Type u‚ÇÅ} {F G : discrete I ‚•§ C}
  (f : Œ† i : discrete I, F.obj i ‚ü∂ G.obj i) : F ‚ü∂ G :=
{ app := f,
  naturality' := Œª X Y g, by { discrete_cases, cases g, simp, } }
@[simps]
def nat_iso {I : Type u‚ÇÅ} {F G : discrete I ‚•§ C}
  (f : Œ† i : discrete I, F.obj i ‚âÖ G.obj i) : F ‚âÖ G :=
nat_iso.of_components f (Œª X Y g, by { discrete_cases, cases g, simp, })
@[simp]
lemma nat_iso_app {I : Type u‚ÇÅ} {F G : discrete I ‚•§ C}
  (f : Œ† i : discrete I, F.obj i ‚âÖ G.obj i) (i : discrete I) :
  (discrete.nat_iso f).app i = f i :=
by tidy
@[simp]
def nat_iso_functor {I : Type u‚ÇÅ} {F : discrete I ‚•§ C} :
  F ‚âÖ discrete.functor (F.obj ‚àò discrete.mk) :=
nat_iso $ Œª i, by { discrete_cases, refl, }
@[simp]
def comp_nat_iso_discrete {I : Type u‚ÇÅ} {D : Type u‚ÇÉ} [category.{v‚ÇÉ} D]
 (F : I ‚Üí C) (G : C ‚•§ D) : discrete.functor F ‚ãô G ‚âÖ discrete.functor (G.obj ‚àò F) :=
nat_iso $ Œª i, iso.refl _
@[simps]
def equivalence {I : Type u‚ÇÅ} {J : Type u‚ÇÇ} (e : I ‚âÉ J) : discrete I ‚âå discrete J :=
{ functor := discrete.functor (discrete.mk ‚àò (e : I ‚Üí J)),
  inverse := discrete.functor (discrete.mk ‚àò (e.symm : J ‚Üí I)),
  unit_iso := discrete.nat_iso (Œª i, eq_to_iso (by { discrete_cases, simp })),
  counit_iso := discrete.nat_iso (Œª j, eq_to_iso (by { discrete_cases, simp })), }
@[simps]
def equiv_of_equivalence {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} (h : discrete Œ± ‚âå discrete Œ≤) : Œ± ‚âÉ Œ≤ :=
{ to_fun := discrete.as ‚àò h.functor.obj ‚àò discrete.mk,
  inv_fun := discrete.as ‚àò h.inverse.obj ‚àò discrete.mk,
  left_inv := Œª a, by simpa using eq_of_hom (h.unit_iso.app (discrete.mk a)).2,
  right_inv := Œª a, by simpa using eq_of_hom (h.counit_iso.app (discrete.mk a)).1, }
end discrete
namespace discrete
variables {J : Type v‚ÇÅ}
open opposite
@[simps functor_obj_as inverse_obj]
protected def opposite (Œ± : Type u‚ÇÅ) : (discrete Œ±)·µí·µñ ‚âå discrete Œ± :=
let F : discrete Œ± ‚•§ (discrete Œ±)·µí·µñ := discrete.functor (Œª x, op (discrete.mk x)) in
begin
  refine equivalence.mk (functor.left_op F) F _
    (discrete.nat_iso $ Œª X, by { discrete_cases, simp [F] }),
  refine nat_iso.of_components (Œª X, by { tactic.op_induction', discrete_cases, simp [F], }) _,
  tidy
end
variables {C : Type u‚ÇÇ} [category.{v‚ÇÇ} C]
@[simp] lemma functor_map_id
  (F : discrete J ‚•§ C) {j : discrete J} (f : j ‚ü∂ j) : F.map f = ùüô (F.obj j) :=
begin
  have h : f = ùüô j, { cases f, cases f, ext, },
  rw h,
  simp,
end
end discrete
end category_theory
