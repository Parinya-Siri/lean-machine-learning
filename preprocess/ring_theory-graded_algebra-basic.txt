import algebra.direct_sum.algebra
import algebra.direct_sum.decomposition
import algebra.direct_sum.internal
import algebra.direct_sum.ring
import group_theory.subgroup.basic
open_locale direct_sum big_operators
variables {Î¹ R A Ïƒ : Type*}
section graded_ring
variables [decidable_eq Î¹] [add_monoid Î¹] [comm_semiring R] [semiring A] [algebra R A]
variables [set_like Ïƒ A] [add_submonoid_class Ïƒ A] (ğ’œ : Î¹ â†’ Ïƒ)
include A
open direct_sum
class graded_ring (ğ’œ : Î¹ â†’ Ïƒ) extends set_like.graded_monoid ğ’œ, direct_sum.decomposition ğ’œ.
variables [graded_ring ğ’œ]
namespace direct_sum
def decompose_ring_equiv : A â‰ƒ+* â¨ i, ğ’œ i := ring_equiv.symm
{ map_mul' := (coe_ring_hom ğ’œ).map_mul,
  map_add' := (coe_ring_hom ğ’œ).map_add,
  ..(decompose_add_equiv ğ’œ).symm }
@[simp] lemma decompose_one : decompose ğ’œ (1 : A) = 1 := map_one (decompose_ring_equiv ğ’œ)
@[simp] lemma decompose_symm_one : (decompose ğ’œ).symm 1 = (1 : A) :=
map_one (decompose_ring_equiv ğ’œ).symm
@[simp] lemma decompose_mul (x y : A) : decompose ğ’œ (x * y) = decompose ğ’œ x * decompose ğ’œ y :=
map_mul (decompose_ring_equiv ğ’œ) x y
@[simp] lemma decompose_symm_mul (x y : â¨ i, ğ’œ i) :
  (decompose ğ’œ).symm (x * y) = (decompose ğ’œ).symm x * (decompose ğ’œ).symm y :=
map_mul (decompose_ring_equiv ğ’œ).symm x y
end direct_sum
def graded_ring.proj (i : Î¹) : A â†’+ A :=
(add_submonoid_class.subtype (ğ’œ i)).comp $
  (dfinsupp.eval_add_monoid_hom i).comp $
  ring_hom.to_add_monoid_hom $ ring_equiv.to_ring_hom $ direct_sum.decompose_ring_equiv ğ’œ
@[simp] lemma graded_ring.proj_apply (i : Î¹) (r : A) :
  graded_ring.proj ğ’œ i r = (decompose ğ’œ r : â¨ i, ğ’œ i) i := rfl
lemma graded_ring.proj_recompose (a : â¨ i, ğ’œ i) (i : Î¹) :
  graded_ring.proj ğ’œ i ((decompose ğ’œ).symm a) =
  (decompose ğ’œ).symm (direct_sum.of _ i (a i)) :=
by rw [graded_ring.proj_apply, decompose_symm_of, equiv.apply_symm_apply]
lemma graded_ring.mem_support_iff [Î  i (x : ğ’œ i), decidable (x â‰  0)] (r : A) (i : Î¹) :
  i âˆˆ (decompose ğ’œ r).support â†” graded_ring.proj ğ’œ i r â‰  0 :=
dfinsupp.mem_support_iff.trans add_submonoid_class.coe_eq_zero.not.symm
end graded_ring
section graded_algebra
variables [decidable_eq Î¹] [add_monoid Î¹] [comm_semiring R] [semiring A] [algebra R A]
variables (ğ’œ : Î¹ â†’ submodule R A)
@[reducible]
def graded_algebra := graded_ring ğ’œ
@[reducible]
def graded_algebra.of_alg_hom [set_like.graded_monoid ğ’œ] (decompose : A â†’â‚[R] â¨ i, ğ’œ i)
  (right_inv : (direct_sum.coe_alg_hom ğ’œ).comp decompose = alg_hom.id R A)
  (left_inv : âˆ€ i (x : ğ’œ i), decompose (x : A) = direct_sum.of (Î» i, â†¥(ğ’œ i)) i x) :
  graded_algebra ğ’œ :=
{ decompose' := decompose,
  left_inv := alg_hom.congr_fun right_inv,
  right_inv := begin
    suffices : decompose.comp (direct_sum.coe_alg_hom ğ’œ) = alg_hom.id _ _,
    from alg_hom.congr_fun this,
    ext i x : 2,
    exact (decompose.congr_arg $ direct_sum.coe_alg_hom_of _ _ _).trans (left_inv i x),
  end}
variable [graded_algebra ğ’œ]
namespace direct_sum
@[simps]
def decompose_alg_equiv : A â‰ƒâ‚[R] â¨ i, ğ’œ i := alg_equiv.symm
{ map_mul' := (coe_alg_hom ğ’œ).map_mul,
  map_add' := (coe_alg_hom ğ’œ).map_add,
  commutes' := (coe_alg_hom ğ’œ).commutes,
  ..(decompose_add_equiv ğ’œ).symm }
end direct_sum
open direct_sum
def graded_algebra.proj (ğ’œ : Î¹ â†’ submodule R A) [graded_algebra ğ’œ] (i : Î¹) : A â†’â‚—[R] A :=
(ğ’œ i).subtype.comp $
  (dfinsupp.lapply i).comp $
  (decompose_alg_equiv ğ’œ).to_alg_hom.to_linear_map
@[simp] lemma graded_algebra.proj_apply (i : Î¹) (r : A) :
  graded_algebra.proj ğ’œ i r = (decompose ğ’œ r : â¨ i, ğ’œ i) i := rfl
lemma graded_algebra.proj_recompose (a : â¨ i, ğ’œ i) (i : Î¹) :
  graded_algebra.proj ğ’œ i ((decompose ğ’œ).symm a) =
  (decompose ğ’œ).symm (of _ i (a i)) :=
by rw [graded_algebra.proj_apply, decompose_symm_of, equiv.apply_symm_apply]
lemma graded_algebra.mem_support_iff [decidable_eq A] (r : A) (i : Î¹) :
  i âˆˆ (decompose ğ’œ r).support â†” graded_algebra.proj ğ’œ i r â‰  0 :=
dfinsupp.mem_support_iff.trans submodule.coe_eq_zero.not.symm
end graded_algebra
section canonical_order
open graded_ring set_like.graded_monoid direct_sum
variables [semiring A] [decidable_eq Î¹]
variables [canonically_ordered_add_monoid Î¹]
variables [set_like Ïƒ A] [add_submonoid_class Ïƒ A] (ğ’œ : Î¹ â†’ Ïƒ) [graded_ring ğ’œ]
@[simps]
def graded_ring.proj_zero_ring_hom : A â†’+* A :=
{ to_fun := Î» a, decompose ğ’œ a 0,
  map_one' := decompose_of_mem_same ğ’œ one_mem,
  map_zero' := by simp,
  map_add' := Î» _ _, by simp,
  map_mul' := Î» x y, begin
