import algebra.category.Group.preadditive
import category_theory.limits.shapes.kernels
import category_theory.linear
import category_theory.elementwise
import linear_algebra.basic
import category_theory.conj
import category_theory.preadditive.additive_functor
open category_theory
open category_theory.limits
open category_theory.limits.walking_parallel_pair
universes v u
variables (R : Type u) [ring R]
structure Module :=
(carrier : Type v)
[is_add_comm_group : add_comm_group carrier]
[is_module : module R carrier]
attribute [instance] Module.is_add_comm_group Module.is_module
namespace Module
instance : has_coe_to_sort (Module.{v} R) (Type v) := ‚ü®Module.carrier‚ü©
instance Module_category : category (Module.{v} R) :=
{ hom   := Œª M N, M ‚Üí‚Çó[R] N,
  id    := Œª M, 1,
  comp  := Œª A B C f g, g.comp f,
  id_comp' := Œª X Y f, linear_map.id_comp _,
  comp_id' := Œª X Y f, linear_map.comp_id _,
  assoc' := Œª W X Y Z f g h, linear_map.comp_assoc _ _ _ }
instance Module_concrete_category : concrete_category.{v} (Module.{v} R) :=
{ forget := { obj := Œª R, R, map := Œª R S f, (f : R ‚Üí S) },
  forget_faithful := { } }
instance has_forget_to_AddCommGroup : has_forget‚ÇÇ (Module R) AddCommGroup :=
{ forget‚ÇÇ :=
  { obj := Œª M, AddCommGroup.of M,
    map := Œª M‚ÇÅ M‚ÇÇ f, linear_map.to_add_monoid_hom f } }
instance (M N : Module R) : linear_map_class (M ‚ü∂ N) R M N :=
{ coe := Œª f, f,
  .. linear_map.semilinear_map_class }
def of (X : Type v) [add_comm_group X] [module R X] : Module R := ‚ü®X‚ü©
@[simp] lemma forget‚ÇÇ_obj (X : Module R) :
  (forget‚ÇÇ (Module R) AddCommGroup).obj X = AddCommGroup.of X :=
rfl
@[simp] lemma forget‚ÇÇ_obj_Module_of (X : Type v) [add_comm_group X] [module R X] :
  (forget‚ÇÇ (Module R) AddCommGroup).obj (of R X) = AddCommGroup.of X :=
rfl
@[simp] lemma forget‚ÇÇ_map (X Y : Module R) (f : X ‚ü∂ Y) :
  (forget‚ÇÇ (Module R) AddCommGroup).map f = linear_map.to_add_monoid_hom f :=
rfl
def of_hom {R : Type u} [ring R] {X Y : Type v} [add_comm_group X] [module R X] [add_comm_group Y]
  [module R Y] (f : X ‚Üí‚Çó[R] Y) : of R X ‚ü∂ of R Y := f
@[simp] lemma of_hom_apply {R : Type u} [ring R]
  {X Y : Type v} [add_comm_group X] [module R X] [add_comm_group Y] [module R Y] (f : X ‚Üí‚Çó[R] Y)
  (x : X) : of_hom f x = f x := rfl
instance : inhabited (Module R) := ‚ü®of R punit‚ü©
instance of_unique {X : Type v} [add_comm_group X] [module R X] [i : unique X] :
  unique (of R X) := i
@[simp]
lemma coe_of (X : Type v) [add_comm_group X] [module R X] : (of R X : Type v) = X := rfl
variables {R}
@[simps]
def of_self_iso (M : Module R) : Module.of R M ‚âÖ M :=
{ hom := ùüô M, inv := ùüô M }
lemma is_zero_of_subsingleton (M : Module R) [subsingleton M] :
  is_zero M :=
begin
  refine ‚ü®Œª X, ‚ü®‚ü®‚ü®0‚ü©, Œª f, _‚ü©‚ü©, Œª X, ‚ü®‚ü®‚ü®0‚ü©, Œª f, _‚ü©‚ü©‚ü©,
  { ext, have : x = 0 := subsingleton.elim _ _, rw [this, map_zero, map_zero], },
  { ext, apply subsingleton.elim }
end
instance : has_zero_object (Module.{v} R) :=
‚ü®‚ü®of R punit, is_zero_of_subsingleton _‚ü©‚ü©
variables {R} {M N U : Module.{v} R}
@[simp] lemma id_apply (m : M) : (ùüô M : M ‚Üí M) m = m := rfl
@[simp] lemma coe_comp (f : M ‚ü∂ N) (g : N ‚ü∂ U) :
  ((f ‚â´ g) : M ‚Üí U) = g ‚àò f := rfl
lemma comp_def (f : M ‚ü∂ N) (g : N ‚ü∂ U) : f ‚â´ g = g.comp f := rfl
end Module
variables {R}
variables {X‚ÇÅ X‚ÇÇ : Type v}
def Module.as_hom [add_comm_group X‚ÇÅ] [module R X‚ÇÅ] [add_comm_group X‚ÇÇ] [module R X‚ÇÇ] :
  (X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ) ‚Üí (Module.of R X‚ÇÅ ‚ü∂ Module.of R X‚ÇÇ) := id
localized "notation `‚Üü` f : 1024 := Module.as_hom f" in Module
def Module.as_hom_right [add_comm_group X‚ÇÅ] [module R X‚ÇÅ] {X‚ÇÇ : Module.{v} R} :
  (X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ) ‚Üí (Module.of R X‚ÇÅ ‚ü∂ X‚ÇÇ) := id
localized "notation `‚Üæ` f : 1024 := Module.as_hom_right f" in Module
def Module.as_hom_left {X‚ÇÅ : Module.{v} R} [add_comm_group X‚ÇÇ] [module R X‚ÇÇ] :
  (X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ) ‚Üí (X‚ÇÅ ‚ü∂ Module.of R X‚ÇÇ) := id
localized "notation `‚Üø` f : 1024 := Module.as_hom_left f" in Module
@[simps]
def linear_equiv.to_Module_iso
  {g‚ÇÅ : add_comm_group X‚ÇÅ} {g‚ÇÇ : add_comm_group X‚ÇÇ} {m‚ÇÅ : module R X‚ÇÅ} {m‚ÇÇ : module R X‚ÇÇ}
  (e : X‚ÇÅ ‚âÉ‚Çó[R] X‚ÇÇ) :
  Module.of R X‚ÇÅ ‚âÖ Module.of R X‚ÇÇ :=
{ hom := (e : X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ),
  inv := (e.symm : X‚ÇÇ ‚Üí‚Çó[R] X‚ÇÅ),
  hom_inv_id' := begin ext, exact e.left_inv x, end,
  inv_hom_id' := begin ext, exact e.right_inv x, end, }
@[simps]
def linear_equiv.to_Module_iso' {M N : Module.{v} R} (i : M ‚âÉ‚Çó[R] N) : M ‚âÖ N :=
{ hom := i,
  inv := i.symm,
  hom_inv_id' := linear_map.ext $ Œª x, by simp,
  inv_hom_id' := linear_map.ext $ Œª x, by simp }
@[simps]
def linear_equiv.to_Module_iso'_left {X‚ÇÅ : Module.{v} R} {g‚ÇÇ : add_comm_group X‚ÇÇ} {m‚ÇÇ : module R X‚ÇÇ}
  (e : X‚ÇÅ ‚âÉ‚Çó[R] X‚ÇÇ) : X‚ÇÅ ‚âÖ Module.of R X‚ÇÇ :=
{ hom := (e : X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ),
  inv := (e.symm : X‚ÇÇ ‚Üí‚Çó[R] X‚ÇÅ),
  hom_inv_id' := linear_map.ext $ Œª x, by simp,
  inv_hom_id' := linear_map.ext $ Œª x, by simp }
@[simps]
def linear_equiv.to_Module_iso'_right {g‚ÇÅ : add_comm_group X‚ÇÅ} {m‚ÇÅ : module R X‚ÇÅ}
  {X‚ÇÇ : Module.{v} R} (e : X‚ÇÅ ‚âÉ‚Çó[R] X‚ÇÇ) : Module.of R X‚ÇÅ ‚âÖ X‚ÇÇ :=
{ hom := (e : X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ),
  inv := (e.symm : X‚ÇÇ ‚Üí‚Çó[R] X‚ÇÅ),
  hom_inv_id' := linear_map.ext $ Œª x, by simp,
  inv_hom_id' := linear_map.ext $ Œª x, by simp }
namespace category_theory.iso
@[simps]
def to_linear_equiv {X Y : Module R} (i : X ‚âÖ Y) : X ‚âÉ‚Çó[R] Y :=
{ to_fun    := i.hom,
  inv_fun   := i.inv,
  left_inv  := by tidy,
  right_inv := by tidy,
  map_add'  := by tidy,
  map_smul' := by tidy, }.
end category_theory.iso
@[simps]
def linear_equiv_iso_Module_iso {X Y : Type u} [add_comm_group X] [add_comm_group Y] [module R X]
  [module R Y] :
  (X ‚âÉ‚Çó[R] Y) ‚âÖ (Module.of R X ‚âÖ Module.of R Y) :=
{ hom := Œª e, e.to_Module_iso,
  inv := Œª i, i.to_linear_equiv, }
namespace Module
instance : preadditive (Module.{v} R) :=
{ add_comp' := Œª P Q R f f' g,
    show (f + f') ‚â´ g = f ‚â´ g + f' ‚â´ g, by { ext, simp },
  comp_add' := Œª P Q R f g g',
    show f ‚â´ (g + g') = f ‚â´ g + f ‚â´ g', by { ext, simp } }
instance forget‚ÇÇ_AddCommGroup_additive : (forget‚ÇÇ (Module.{v} R) AddCommGroup).additive := {}
section
variables {S : Type u} [comm_ring S]
instance : linear S (Module.{v} S) :=
{ hom_module := Œª X Y, linear_map.module,
  smul_comp' := by { intros, ext, simp },
  comp_smul' := by { intros, ext, simp }, }
variables {X Y X' Y' : Module.{v} S}
lemma iso.hom_congr_eq_arrow_congr (i : X ‚âÖ X') (j : Y ‚âÖ Y') (f : X ‚ü∂ Y) :
  iso.hom_congr i j f = linear_equiv.arrow_congr i.to_linear_equiv j.to_linear_equiv f := rfl
lemma iso.conj_eq_conj (i : X ‚âÖ X') (f : End X) :
  iso.conj i f = linear_equiv.conj i.to_linear_equiv f := rfl
end
end Module
instance (M : Type u) [add_comm_group M] [module R M] : has_coe (submodule R M) (Module R) :=
‚ü® Œª N, Module.of R N ‚ü©
