import category_theory.full_subcategory
import category_theory.limits.shapes.equalizers
import category_theory.limits.shapes.products
import topology.sheaves.presheaf
universes v' v u
noncomputable theory
open category_theory
open category_theory.limits
open topological_space
open opposite
open topological_space.opens
namespace Top
variables {C : Type u} [category.{v} C] [has_products.{v} C]
variables {X : Top.{v'}} (F : presheaf C X) {Î¹ : Type v} (U : Î¹ â†’ opens X)
namespace presheaf
namespace sheaf_condition_equalizer_products
def pi_opens : C := âˆ (Î» i : Î¹, F.obj (op (U i)))
def pi_inters : C := âˆ (Î» p : Î¹ Ã— Î¹, F.obj (op (U p.1 âŠ“ U p.2)))
def left_res : pi_opens F U âŸ¶ pi_inters F U :=
pi.lift (Î» p : Î¹ Ã— Î¹, pi.Ï€ _ p.1 â‰« F.map (inf_le_left (U p.1) (U p.2)).op)
def right_res : pi_opens F U âŸ¶ pi_inters F U :=
pi.lift (Î» p : Î¹ Ã— Î¹, pi.Ï€ _ p.2 â‰« F.map (inf_le_right (U p.1) (U p.2)).op)
def res : F.obj (op (supr U)) âŸ¶ pi_opens F U :=
pi.lift (Î» i : Î¹, F.map (topological_space.opens.le_supr U i).op)
@[simp, elementwise]
lemma res_Ï€ (i : Î¹) : res F U â‰« limit.Ï€ _ âŸ¨iâŸ© = F.map (opens.le_supr U i).op :=
by rw [res, limit.lift_Ï€, fan.mk_Ï€_app]
@[elementwise]
lemma w : res F U â‰« left_res F U = res F U â‰« right_res F U :=
begin
  dsimp [res, left_res, right_res],
  ext,
  simp only [limit.lift_Ï€, limit.lift_Ï€_assoc, fan.mk_Ï€_app, category.assoc],
  rw [â†F.map_comp],
  rw [â†F.map_comp],
  congr,
end
@[reducible]
def diagram : walking_parallel_pair â¥¤ C :=
parallel_pair (left_res F U) (right_res F U)
def fork : fork.{v} (left_res F U) (right_res F U) := fork.of_Î¹ _ (w F U)
@[simp]
lemma fork_X : (fork F U).X = F.obj (op (supr U)) := rfl
@[simp]
lemma fork_Î¹ : (fork F U).Î¹ = res F U := rfl
@[simp]
lemma fork_Ï€_app_walking_parallel_pair_zero :
  (fork F U).Ï€.app walking_parallel_pair.zero = res F U := rfl
@[simp]
lemma fork_Ï€_app_walking_parallel_pair_one :
  (fork F U).Ï€.app walking_parallel_pair.one = res F U â‰« left_res F U := rfl
variables {F} {G : presheaf C X}
@[simp]
def pi_opens.iso_of_iso (Î± : F â‰… G) : pi_opens F U â‰… pi_opens G U :=
pi.map_iso (Î» X, Î±.app _)
@[simp]
def pi_inters.iso_of_iso (Î± : F â‰… G) : pi_inters F U â‰… pi_inters G U :=
pi.map_iso (Î» X, Î±.app _)
def diagram.iso_of_iso (Î± : F â‰… G) : diagram F U â‰… diagram G U :=
nat_iso.of_components
  begin rintro âŸ¨âŸ©, exact pi_opens.iso_of_iso U Î±, exact pi_inters.iso_of_iso U Î± end
  begin
    rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©,
    { simp, },
    { ext, simp [left_res], },
    { ext, simp [right_res], },
    { simp, },
  end.
def fork.iso_of_iso (Î± : F â‰… G) :
  fork F U â‰… (cones.postcompose (diagram.iso_of_iso U Î±).inv).obj (fork G U) :=
begin
  fapply fork.ext,
  { apply Î±.app, },
  { ext,
@[simp]
def cover.of_open_embedding : Î¹ â†’ opens X := (Î» i, oe.is_open_map.functor.obj (ğ’° i))
@[simp]
def pi_opens.iso_of_open_embedding :
  pi_opens (oe.is_open_map.functor.op â‹™ F) ğ’° â‰… pi_opens F (cover.of_open_embedding oe ğ’°) :=
pi.map_iso (Î» X, F.map_iso (iso.refl _))
@[simp]
def pi_inters.iso_of_open_embedding :
  pi_inters (oe.is_open_map.functor.op â‹™ F) ğ’° â‰… pi_inters F (cover.of_open_embedding oe ğ’°) :=
pi.map_iso (Î» X, F.map_iso
  begin
    dsimp [is_open_map.functor],
    exact iso.op
    { hom := hom_of_le (by
      { simp only [oe.to_embedding.inj, set.image_inter],
        exact le_rfl, }),
      inv := hom_of_le (by
      { simp only [oe.to_embedding.inj, set.image_inter],
        exact le_rfl, }), },
  end)
def diagram.iso_of_open_embedding :
  diagram (oe.is_open_map.functor.op â‹™ F) ğ’° â‰… diagram F (cover.of_open_embedding oe ğ’°) :=
nat_iso.of_components
  begin
    rintro âŸ¨âŸ©,
    exact pi_opens.iso_of_open_embedding oe ğ’°,
    exact pi_inters.iso_of_open_embedding oe ğ’°
  end
  begin
    rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©,
    { simp, },
    { ext,
      dsimp [left_res, is_open_map.functor],
      simp only [limit.lift_Ï€, cones.postcompose_obj_Ï€, iso.op_hom, discrete.nat_iso_hom_app,
        functor.map_iso_refl, functor.map_iso_hom, lim_map_Ï€_assoc, limit.lift_map, fan.mk_Ï€_app,
        nat_trans.comp_app, category.assoc],
      dsimp,
      rw [category.id_comp, â†F.map_comp],
      refl, },
    { ext,
      dsimp [right_res, is_open_map.functor],
      simp only [limit.lift_Ï€, cones.postcompose_obj_Ï€, iso.op_hom, discrete.nat_iso_hom_app,
        functor.map_iso_refl, functor.map_iso_hom, lim_map_Ï€_assoc, limit.lift_map, fan.mk_Ï€_app,
        nat_trans.comp_app, category.assoc],
      dsimp,
      rw [category.id_comp, â†F.map_comp],
      refl, },
    { simp, },
  end.
def fork.iso_of_open_embedding :
  fork (oe.is_open_map.functor.op â‹™ F) ğ’° â‰…
    (cones.postcompose (diagram.iso_of_open_embedding oe ğ’°).inv).obj
      (fork F (cover.of_open_embedding oe ğ’°)) :=
begin
  fapply fork.ext,
  { dsimp [is_open_map.functor],
    exact
    F.map_iso (iso.op
    { hom := hom_of_le
      (by simp only [supr_s, supr_mk, le_def, subtype.coe_mk, set.le_eq_subset, set.image_Union]),
      inv := hom_of_le
      (by simp only [supr_s, supr_mk, le_def, subtype.coe_mk, set.le_eq_subset,
                     set.image_Union]) }), },
  { ext âŸ¨jâŸ©,
