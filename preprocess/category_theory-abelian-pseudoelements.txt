import category_theory.abelian.exact
import category_theory.over
import algebra.category.Module.abelian
open category_theory
open category_theory.limits
open category_theory.abelian
open category_theory.preadditive
universes v u
namespace category_theory.abelian
variables {C : Type u} [category.{v} C]
local attribute [instance] over.coe_from_hom
def app {P Q : C} (f : P ‚ü∂ Q) (a : over P) : over Q :=
a.hom ‚â´ f
@[simp] lemma app_hom {P Q : C} (f : P ‚ü∂ Q) (a : over P) : (app f a).hom = a.hom ‚â´ f := rfl
def pseudo_equal (P : C) (f g : over P) : Prop :=
‚àÉ (R : C) (p : R ‚ü∂ f.1) (q : R ‚ü∂ g.1) (_ : epi p) (_ : epi q), p ‚â´ f.hom = q ‚â´ g.hom
lemma pseudo_equal_refl {P : C} : reflexive (pseudo_equal P) :=
Œª f, ‚ü®f.1, ùüô f.1, ùüô f.1, by apply_instance, by apply_instance, by simp‚ü©
lemma pseudo_equal_symm {P : C} : symmetric (pseudo_equal P) :=
Œª f g ‚ü®R, p, q, ep, eq, comm‚ü©, ‚ü®R, q, p, eq, ep, comm.symm‚ü©
variables [abelian.{v} C]
section
lemma pseudo_equal_trans {P : C} : transitive (pseudo_equal P) :=
Œª f g h ‚ü®R, p, q, ep, eq, comm‚ü© ‚ü®R', p', q', ep', eq', comm'‚ü©,
begin
  refine ‚ü®pullback q p', pullback.fst ‚â´ p, pullback.snd ‚â´ q', _, _, _‚ü©,
  { resetI, exact epi_comp _ _ },
  { resetI, exact epi_comp _ _ },
  { rw [category.assoc, comm, ‚Üêcategory.assoc, pullback.condition,
      category.assoc, comm', category.assoc] }
end
end
def pseudoelement.setoid (P : C) : setoid (over P) :=
‚ü®_, ‚ü®pseudo_equal_refl, pseudo_equal_symm, pseudo_equal_trans‚ü©‚ü©
local attribute [instance] pseudoelement.setoid
def pseudoelement (P : C) : Type (max u v) := quotient (pseudoelement.setoid P)
namespace pseudoelement
def object_to_sort : has_coe_to_sort C (Type (max u v)) :=
‚ü®Œª P, pseudoelement P‚ü©
local attribute [instance] object_to_sort
localized "attribute [instance] category_theory.abelian.pseudoelement.object_to_sort"
  in pseudoelement
def over_to_sort {P : C} : has_coe (over P) (pseudoelement P) :=
‚ü®quot.mk (pseudo_equal P)‚ü©
local attribute [instance] over_to_sort
lemma over_coe_def {P Q : C} (a : Q ‚ü∂ P) : (a : pseudoelement P) = ‚ü¶a‚üß := rfl
lemma pseudo_apply_aux {P Q : C} (f : P ‚ü∂ Q) (a b : over P) :
  a ‚âà b ‚Üí app f a ‚âà app f b :=
Œª ‚ü®R, p, q, ep, eq, comm‚ü©,
  ‚ü®R, p, q, ep, eq, show p ‚â´ a.hom ‚â´ f = q ‚â´ b.hom ‚â´ f, by rw reassoc_of comm‚ü©
def pseudo_apply {P Q : C} (f : P ‚ü∂ Q) : P ‚Üí Q :=
quotient.map (Œª (g : over P), app f g) (pseudo_apply_aux f)
def hom_to_fun {P Q : C} : has_coe_to_fun (P ‚ü∂ Q) (Œª _, P ‚Üí Q) := ‚ü®pseudo_apply‚ü©
local attribute [instance] hom_to_fun
localized "attribute [instance] category_theory.abelian.pseudoelement.hom_to_fun" in pseudoelement
lemma pseudo_apply_mk {P Q : C} (f : P ‚ü∂ Q) (a : over P) : f ‚ü¶a‚üß = ‚ü¶a.hom ‚â´ f‚üß :=
rfl
theorem comp_apply {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) (a : P) : (f ‚â´ g) a = g (f a) :=
quotient.induction_on a $ Œª x, quotient.sound $
by { unfold app, rw [‚Üêcategory.assoc, over.coe_hom] }
theorem comp_comp {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) : g ‚àò f = f ‚â´ g :=
funext $ Œª x, (comp_apply _ _ _).symm
section zero
section
local attribute [instance] has_binary_biproducts.of_has_binary_products
lemma pseudo_zero_aux {P : C} (Q : C) (f : over P) : f ‚âà (0 : Q ‚ü∂ P) ‚Üî f.hom = 0 :=
‚ü®Œª ‚ü®R, p, q, ep, eq, comm‚ü©, by exactI zero_of_epi_comp p (by simp [comm]),
  Œª hf, ‚ü®biprod f.1 Q, biprod.fst, biprod.snd, by apply_instance, by apply_instance,
    by rw [hf, over.coe_hom, has_zero_morphisms.comp_zero, has_zero_morphisms.comp_zero]‚ü©‚ü©
end
lemma zero_eq_zero' {P Q R : C} :
  ‚ü¶((0 : Q ‚ü∂ P) : over P)‚üß = ‚ü¶((0 : R ‚ü∂ P) : over P)‚üß :=
quotient.sound $ (pseudo_zero_aux R _).2 rfl
def pseudo_zero {P : C} : P := ‚ü¶(0 : P ‚ü∂ P)‚üß
def has_zero {P : C} : has_zero P := ‚ü®pseudo_zero‚ü©
localized "attribute [instance] category_theory.abelian.pseudoelement.has_zero" in pseudoelement
instance {P : C} : inhabited (pseudoelement P) := ‚ü®0‚ü©
lemma pseudo_zero_def {P : C} : (0 : pseudoelement P) = ‚ü¶(0 : P ‚ü∂ P)‚üß := rfl
@[simp] lemma zero_eq_zero {P Q : C} : ‚ü¶((0 : Q ‚ü∂ P) : over P)‚üß = (0 : pseudoelement P) :=
zero_eq_zero'
lemma pseudo_zero_iff {P : C} (a : over P) : (a : P) = 0 ‚Üî a.hom = 0 :=
by { rw ‚Üêpseudo_zero_aux P a, exact quotient.eq }
end zero
open_locale pseudoelement
@[simp] theorem apply_zero {P Q : C} (f : P ‚ü∂ Q) : f 0 = 0 :=
by { rw [pseudo_zero_def, pseudo_apply_mk], simp }
@[simp] theorem zero_apply {P : C} (Q : C) (a : P) : (0 : P ‚ü∂ Q) a = 0 :=
quotient.induction_on a $ Œª a',
  by { rw [pseudo_zero_def, pseudo_apply_mk], simp }
theorem zero_morphism_ext {P Q : C} (f : P ‚ü∂ Q) : (‚àÄ a, f a = 0) ‚Üí f = 0 :=
Œª h, by { rw ‚Üêcategory.id_comp f, exact (pseudo_zero_iff ((ùüô P ‚â´ f) : over Q)).1 (h (ùüô P)) }
theorem zero_morphism_ext' {P Q : C} (f : P ‚ü∂ Q) : (‚àÄ a, f a = 0) ‚Üí 0 = f :=
eq.symm ‚àò zero_morphism_ext f
localized "attribute [ext] category_theory.abelian.pseudoelement.zero_morphism_ext
  category_theory.abelian.pseudoelement.zero_morphism_ext'" in pseudoelement
theorem eq_zero_iff {P Q : C} (f : P ‚ü∂ Q) : f = 0 ‚Üî ‚àÄ a, f a = 0 :=
‚ü®Œª h a, by simp [h], zero_morphism_ext _‚ü©
theorem pseudo_injective_of_mono {P Q : C} (f : P ‚ü∂ Q) [mono f] : function.injective f :=
Œª abar abar', quotient.induction_on‚ÇÇ abar abar' $ Œª a a' ha, quotient.sound $
  have ‚ü¶(a.hom ‚â´ f : over Q)‚üß = ‚ü¶a'.hom ‚â´ f‚üß, by convert ha,
  match quotient.exact this with ‚ü®R, p, q, ep, eq, comm‚ü© :=
    ‚ü®R, p, q, ep, eq, (cancel_mono f).1 $ by { simp only [category.assoc], exact comm }‚ü©
  end
lemma zero_of_map_zero {P Q : C} (f : P ‚ü∂ Q) : function.injective f ‚Üí ‚àÄ a, f a = 0 ‚Üí a = 0 :=
Œª h a ha, by { rw ‚Üêapply_zero f at ha, exact h ha }
theorem mono_of_zero_of_map_zero {P Q : C} (f : P ‚ü∂ Q) : (‚àÄ a, f a = 0 ‚Üí a = 0) ‚Üí mono f :=
Œª h, (mono_iff_cancel_zero _).2 $ Œª R g hg, (pseudo_zero_iff (g : over P)).1 $ h _ $
  show f g = 0, from (pseudo_zero_iff (g ‚â´ f : over Q)).2 hg
section
theorem pseudo_surjective_of_epi {P Q : C} (f : P ‚ü∂ Q) [epi f] : function.surjective f :=
Œª qbar, quotient.induction_on qbar $ Œª q, ‚ü®((pullback.fst : pullback f q.hom ‚ü∂ P) : over P),
  quotient.sound $ ‚ü®pullback f q.hom, ùüô (pullback f q.hom), pullback.snd, by apply_instance,
    by apply_instance, by rw [category.id_comp, ‚Üêpullback.condition, app_hom, over.coe_hom]‚ü©‚ü©
end
theorem epi_of_pseudo_surjective {P Q : C} (f : P ‚ü∂ Q) : function.surjective f ‚Üí epi f :=
Œª h, match h (ùüô Q) with ‚ü®pbar, hpbar‚ü© :=
  match quotient.exists_rep pbar with ‚ü®p, hp‚ü© :=
    have ‚ü¶(p.hom ‚â´ f : over Q)‚üß = ‚ü¶ùüô Q‚üß, by { rw ‚Üêhp at hpbar, exact hpbar },
    match quotient.exact this with ‚ü®R, x, y, ex, ey, comm‚ü© :=
      @epi_of_epi_fac _ _ _ _ _ (x ‚â´ p.hom) f y ey $
        by { dsimp at comm, rw [category.assoc, comm], apply category.comp_id }
    end
  end
end
section
theorem pseudo_exact_of_exact {P Q R : C} {f : P ‚ü∂ Q} {g : Q ‚ü∂ R} (h : exact f g) :
  (‚àÄ a, g (f a) = 0) ‚àß (‚àÄ b, g b = 0 ‚Üí ‚àÉ a, f a = b) :=
‚ü®Œª a, by { rw [‚Üêcomp_apply, h.w], exact zero_apply _ _ },
  Œª b', quotient.induction_on b' $ Œª b hb,
    have hb' : b.hom ‚â´ g = 0, from (pseudo_zero_iff _).1 hb,
    begin
theorem exact_of_pseudo_exact {P Q R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) :
  (‚àÄ a, g (f a) = 0) ‚àß (‚àÄ b, g b = 0 ‚Üí ‚àÉ a, f a = b) ‚Üí exact f g :=
Œª ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, (abelian.exact_iff _ _).2 ‚ü®zero_morphism_ext _ $ Œª a, by rw [comp_apply, h‚ÇÅ a],
begin
theorem sub_of_eq_image {P Q : C} (f : P ‚ü∂ Q) (x y : P) : f x = f y ‚Üí
  ‚àÉ z, f z = 0 ‚àß ‚àÄ (R : C) (g : P ‚ü∂ R), (g : P ‚ü∂ R) y = 0 ‚Üí g z = g x :=
quotient.induction_on‚ÇÇ x y $ Œª a a' h,
match quotient.exact h with ‚ü®R, p, q, ep, eq, comm‚ü© :=
  let a'' : R ‚ü∂ P := p ‚â´ a.hom - q ‚â´ a'.hom in ‚ü®a'',
    ‚ü®show ‚ü¶((p ‚â´ a.hom - q ‚â´ a'.hom) ‚â´ f : over Q)‚üß = ‚ü¶(0 : Q ‚ü∂ Q)‚üß,
      by { dsimp at comm, simp [sub_eq_zero.2 comm] },
      Œª Z g hh,
      begin
        obtain ‚ü®X, p', q', ep', eq', comm'‚ü© := quotient.exact hh,
        have : a'.hom ‚â´ g = 0,
        { apply (epi_iff_cancel_zero _).1 ep' _ (a'.hom ‚â´ g),
          simpa using comm' },
        apply quotient.sound,
theorem pseudo_pullback {P Q R : C} {f : P ‚ü∂ R} {g : Q ‚ü∂ R} {p : P} {q : Q} : f p = g q ‚Üí
  ‚àÉ s, (pullback.fst : pullback f g ‚ü∂ P) s = p ‚àß (pullback.snd : pullback f g ‚ü∂ Q) s = q :=
quotient.induction_on‚ÇÇ p q $ Œª x y h,
begin
  obtain ‚ü®Z, a, b, ea, eb, comm‚ü© := quotient.exact h,
  obtain ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü© := @pullback.lift' _ _ _ _ _ _ f g _ (a ‚â´ x.hom) (b ‚â´ y.hom)
    (by { simp only [category.assoc], exact comm }),
  exact ‚ü®l, ‚ü®quotient.sound ‚ü®Z, ùüô Z, a, by apply_instance, ea, by rwa category.id_comp‚ü©,
    quotient.sound ‚ü®Z, ùüô Z, b, by apply_instance, eb, by rwa category.id_comp‚ü©‚ü©‚ü©
end
section module
local attribute [-instance] hom_to_fun
lemma Module.eq_range_of_pseudoequal {R : Type*} [comm_ring R] {G : Module R} {x y : over G}
  (h : pseudo_equal G x y) : x.hom.range = y.hom.range :=
begin
  obtain ‚ü®P, p, q, hp, hq, H‚ü© := h,
  refine submodule.ext (Œª a, ‚ü®Œª ha, _, Œª ha, _‚ü©),
  { obtain ‚ü®a', ha'‚ü© := ha,
    obtain ‚ü®a'', ha''‚ü© := (Module.epi_iff_surjective p).1 hp a',
    refine ‚ü®q a'', _‚ü©,
    rw [‚Üê linear_map.comp_apply, ‚Üê Module.comp_def, ‚Üê H, Module.comp_def, linear_map.comp_apply,
      ha'', ha'] },
  { obtain ‚ü®a', ha'‚ü© := ha,
    obtain ‚ü®a'', ha''‚ü© := (Module.epi_iff_surjective q).1 hq a',
    refine ‚ü®p a'', _‚ü©,
    rw [‚Üê linear_map.comp_apply, ‚Üê Module.comp_def, H, Module.comp_def, linear_map.comp_apply,
      ha'', ha'] }
end
end module
end pseudoelement
end category_theory.abelian
