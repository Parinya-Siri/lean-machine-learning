import analysis.convex.jensen
import analysis.normed.group.pointwise
import analysis.normed_space.finite_dimension
import analysis.normed_space.ray
import topology.path_connected
import topology.algebra.affine
variables {Î¹ : Type*} {E : Type*}
open metric set
open_locale pointwise convex
lemma real.convex_iff_is_preconnected {s : set â„} : convex â„ s â†” is_preconnected s :=
convex_iff_ord_connected.trans is_preconnected_iff_ord_connected.symm
alias real.convex_iff_is_preconnected â†” convex.is_preconnected is_preconnected.convex
section std_simplex
variables [fintype Î¹]
lemma std_simplex_subset_closed_ball :
  std_simplex â„ Î¹ âŠ† metric.closed_ball 0 1 :=
begin
  assume f hf,
  rw [metric.mem_closed_ball, dist_zero_right],
  refine (nnreal.coe_one â–¸ nnreal.coe_le_coe.2 $ finset.sup_le $ Î» x hx, _),
  change |f x| â‰¤ 1,
  rw [abs_of_nonneg $ hf.1 x],
  exact (mem_Icc_of_mem_std_simplex hf x).2
end
variable (Î¹)
lemma bounded_std_simplex : metric.bounded (std_simplex â„ Î¹) :=
(metric.bounded_iff_subset_ball 0).2 âŸ¨1, std_simplex_subset_closed_ballâŸ©
lemma is_closed_std_simplex : is_closed (std_simplex â„ Î¹) :=
(std_simplex_eq_inter â„ Î¹).symm â–¸ is_closed.inter
  (is_closed_Inter $ Î» i, is_closed_le continuous_const (continuous_apply i))
  (is_closed_eq (continuous_finset_sum _ $ Î» x _, continuous_apply x) continuous_const)
lemma compact_std_simplex : is_compact (std_simplex â„ Î¹) :=
metric.compact_iff_closed_bounded.2 âŸ¨is_closed_std_simplex Î¹, bounded_std_simplex Î¹âŸ©
end std_simplex
section has_continuous_const_smul
variables {ğ•œ : Type*} [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E]
  [topological_add_group E] [has_continuous_const_smul ğ•œ E]
lemma convex.combo_interior_closure_subset_interior {s : set E} (hs : convex ğ•œ s) {a b : ğ•œ}
  (ha : 0 < a) (hb : 0 â‰¤ b) (hab : a + b = 1) :
  a â€¢ interior s + b â€¢ closure s âŠ† interior s :=
interior_smulâ‚€ ha.ne' s â–¸
  calc interior (a â€¢ s) + b â€¢ closure s âŠ† interior (a â€¢ s) + closure (b â€¢ s) :
    add_subset_add subset.rfl (smul_closure_subset b s)
  ... = interior (a â€¢ s) + b â€¢ s : by rw is_open_interior.add_closure (b â€¢ s)
  ... âŠ† interior (a â€¢ s + b â€¢ s) : subset_interior_add_left
  ... âŠ† interior s : interior_mono $ hs.set_combo_subset ha.le hb hab
lemma convex.combo_interior_self_subset_interior {s : set E} (hs : convex ğ•œ s) {a b : ğ•œ}
  (ha : 0 < a) (hb : 0 â‰¤ b) (hab : a + b = 1) :
  a â€¢ interior s + b â€¢ s âŠ† interior s :=
calc a â€¢ interior s + b â€¢ s âŠ† a â€¢ interior s + b â€¢ closure s :
  add_subset_add subset.rfl $ image_subset _ subset_closure
... âŠ† interior s : hs.combo_interior_closure_subset_interior ha hb hab
lemma convex.combo_closure_interior_subset_interior {s : set E} (hs : convex ğ•œ s) {a b : ğ•œ}
  (ha : 0 â‰¤ a) (hb : 0 < b) (hab : a + b = 1) :
  a â€¢ closure s + b â€¢ interior s âŠ† interior s :=
by { rw add_comm, exact hs.combo_interior_closure_subset_interior hb ha (add_comm a b â–¸ hab) }
lemma convex.combo_self_interior_subset_interior {s : set E} (hs : convex ğ•œ s) {a b : ğ•œ}
  (ha : 0 â‰¤ a) (hb : 0 < b) (hab : a + b = 1) :
  a â€¢ s + b â€¢ interior s âŠ† interior s :=
by { rw add_comm, exact hs.combo_interior_self_subset_interior hb ha (add_comm a b â–¸ hab) }
lemma convex.combo_interior_closure_mem_interior {s : set E} (hs : convex ğ•œ s) {x y : E}
  (hx : x âˆˆ interior s) (hy : y âˆˆ closure s) {a b : ğ•œ} (ha : 0 < a) (hb : 0 â‰¤ b) (hab : a + b = 1) :
  a â€¢ x + b â€¢ y âˆˆ interior s :=
hs.combo_interior_closure_subset_interior ha hb hab $
  add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)
lemma convex.combo_interior_self_mem_interior {s : set E} (hs : convex ğ•œ s) {x y : E}
  (hx : x âˆˆ interior s) (hy : y âˆˆ s) {a b : ğ•œ} (ha : 0 < a) (hb : 0 â‰¤ b) (hab : a + b = 1) :
  a â€¢ x + b â€¢ y âˆˆ interior s :=
hs.combo_interior_closure_mem_interior hx (subset_closure hy) ha hb hab
lemma convex.combo_closure_interior_mem_interior {s : set E} (hs : convex ğ•œ s) {x y : E}
  (hx : x âˆˆ closure s) (hy : y âˆˆ interior s) {a b : ğ•œ} (ha : 0 â‰¤ a) (hb : 0 < b) (hab : a + b = 1) :
  a â€¢ x + b â€¢ y âˆˆ interior s :=
hs.combo_closure_interior_subset_interior ha hb hab $
  add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)
lemma convex.combo_self_interior_mem_interior {s : set E} (hs : convex ğ•œ s) {x y : E}
  (hx : x âˆˆ s) (hy : y âˆˆ interior s) {a b : ğ•œ} (ha : 0 â‰¤ a) (hb : 0 < b) (hab : a + b = 1) :
  a â€¢ x + b â€¢ y âˆˆ interior s :=
hs.combo_closure_interior_mem_interior (subset_closure hx) hy ha hb hab
lemma convex.open_segment_interior_closure_subset_interior {s : set E} (hs : convex ğ•œ s) {x y : E}
  (hx : x âˆˆ interior s) (hy : y âˆˆ closure s) : open_segment ğ•œ x y âŠ† interior s :=
begin
  rintro _ âŸ¨a, b, ha, hb, hab, rflâŸ©,
  exact hs.combo_interior_closure_mem_interior hx hy ha hb.le hab
end
lemma convex.open_segment_interior_self_subset_interior {s : set E} (hs : convex ğ•œ s) {x y : E}
  (hx : x âˆˆ interior s) (hy : y âˆˆ s) : open_segment ğ•œ x y âŠ† interior s :=
hs.open_segment_interior_closure_subset_interior hx (subset_closure hy)
lemma convex.open_segment_closure_interior_subset_interior {s : set E} (hs : convex ğ•œ s) {x y : E}
  (hx : x âˆˆ closure s) (hy : y âˆˆ interior s) : open_segment ğ•œ x y âŠ† interior s :=
begin
  rintro _ âŸ¨a, b, ha, hb, hab, rflâŸ©,
  exact hs.combo_closure_interior_mem_interior hx hy ha.le hb hab
end
lemma convex.open_segment_self_interior_subset_interior {s : set E} (hs : convex ğ•œ s) {x y : E}
  (hx : x âˆˆ s) (hy : y âˆˆ interior s) : open_segment ğ•œ x y âŠ† interior s :=
hs.open_segment_closure_interior_subset_interior (subset_closure hx) hy
lemma convex.add_smul_sub_mem_interior' {s : set E} (hs : convex ğ•œ s)
  {x y : E} (hx : x âˆˆ closure s) (hy : y âˆˆ interior s) {t : ğ•œ} (ht : t âˆˆ Ioc (0 : ğ•œ) 1) :
  x + t â€¢ (y - x) âˆˆ interior s :=
by simpa only [sub_smul, smul_sub, one_smul, add_sub, add_comm]
  using hs.combo_interior_closure_mem_interior hy hx ht.1 (sub_nonneg.mpr ht.2)
    (add_sub_cancel'_right _ _)
lemma convex.add_smul_sub_mem_interior {s : set E} (hs : convex ğ•œ s)
  {x y : E} (hx : x âˆˆ s) (hy : y âˆˆ interior s) {t : ğ•œ} (ht : t âˆˆ Ioc (0 : ğ•œ) 1) :
  x + t â€¢ (y - x) âˆˆ interior s :=
hs.add_smul_sub_mem_interior' (subset_closure hx) hy ht
lemma convex.add_smul_mem_interior' {s : set E} (hs : convex ğ•œ s)
  {x y : E} (hx : x âˆˆ closure s) (hy : x + y âˆˆ interior s) {t : ğ•œ} (ht : t âˆˆ Ioc (0 : ğ•œ) 1) :
  x + t â€¢ y âˆˆ interior s :=
by simpa only [add_sub_cancel'] using hs.add_smul_sub_mem_interior' hx hy ht
lemma convex.add_smul_mem_interior {s : set E} (hs : convex ğ•œ s)
  {x y : E} (hx : x âˆˆ s) (hy : x + y âˆˆ interior s) {t : ğ•œ} (ht : t âˆˆ Ioc (0 : ğ•œ) 1) :
  x + t â€¢ y âˆˆ interior s :=
hs.add_smul_mem_interior' (subset_closure hx) hy ht
protected lemma convex.interior {s : set E} (hs : convex ğ•œ s) : convex ğ•œ (interior s) :=
convex_iff_open_segment_subset.mpr $ Î» x y hx hy,
  hs.open_segment_closure_interior_subset_interior (interior_subset_closure hx) hy
protected lemma convex.closure {s : set E} (hs : convex ğ•œ s) : convex ğ•œ (closure s) :=
Î» x y hx hy a b ha hb hab,
let f : E â†’ E â†’ E := Î» x' y', a â€¢ x' + b â€¢ y' in
have hf : continuous (Î» p : E Ã— E, f p.1 p.2), from
  (continuous_fst.const_smul _).add (continuous_snd.const_smul _),
show f x y âˆˆ closure s, from
  mem_closure_of_continuous2 hf hx hy (Î» x' hx' y' hy', subset_closure
  (hs hx' hy' ha hb hab))
end has_continuous_const_smul
section has_continuous_smul
variables [add_comm_group E] [module â„ E] [topological_space E]
  [topological_add_group E] [has_continuous_smul â„ E]
lemma set.finite.compact_convex_hull {s : set E} (hs : s.finite) :
  is_compact (convex_hull â„ s) :=
begin
  rw [hs.convex_hull_eq_image],
  apply (compact_std_simplex _).image,
  haveI := hs.fintype,
  apply linear_map.continuous_on_pi
end
lemma set.finite.is_closed_convex_hull [t2_space E] {s : set E} (hs : s.finite) :
  is_closed (convex_hull â„ s) :=
hs.compact_convex_hull.is_closed
open affine_map
lemma convex.closure_subset_image_homothety_interior_of_one_lt {s : set E} (hs : convex â„ s)
  {x : E} (hx : x âˆˆ interior s) (t : â„) (ht : 1 < t) :
  closure s âŠ† homothety x t '' interior s :=
begin
  intros y hy,
  have hne : t â‰  0, from (one_pos.trans ht).ne',
  refine âŸ¨homothety x tâ»Â¹ y, hs.open_segment_interior_closure_subset_interior hx hy _,
    (affine_equiv.homothety_units_mul_hom x (units.mk0 t hne)).apply_symm_apply yâŸ©,
  rw [open_segment_eq_image_line_map, â† inv_one, â† inv_Ioi (@one_pos â„ _ _), â† image_inv,
    image_image, homothety_eq_line_map],
  exact mem_image_of_mem _ ht
end
lemma convex.closure_subset_interior_image_homothety_of_one_lt {s : set E} (hs : convex â„ s)
  {x : E} (hx : x âˆˆ interior s) (t : â„) (ht : 1 < t) :
  closure s âŠ† interior (homothety x t '' s) :=
(hs.closure_subset_image_homothety_interior_of_one_lt hx t ht).trans $
  (homothety_is_open_map x t (one_pos.trans ht).ne').image_interior_subset _
lemma convex.subset_interior_image_homothety_of_one_lt {s : set E} (hs : convex â„ s)
  {x : E} (hx : x âˆˆ interior s) (t : â„) (ht : 1 < t) :
  s âŠ† interior (homothety x t '' s) :=
subset_closure.trans $ hs.closure_subset_interior_image_homothety_of_one_lt hx t ht
protected lemma convex.is_path_connected {s : set E} (hconv : convex â„ s) (hne : s.nonempty) :
  is_path_connected s :=
begin
  refine is_path_connected_iff.mpr âŸ¨hne, _âŸ©,
  intros x x_in y y_in,
  have H := hconv.segment_subset x_in y_in,
  rw segment_eq_image_line_map at H,
  exact joined_in.of_line affine_map.line_map_continuous.continuous_on (line_map_apply_zero _ _)
    (line_map_apply_one _ _) H
end
protected lemma topological_add_group.path_connected : path_connected_space E :=
path_connected_space_iff_univ.mpr $ convex_univ.is_path_connected âŸ¨(0 : E), trivialâŸ©
end has_continuous_smul
section normed_space
variables [semi_normed_group E] [normed_space â„ E] {s t : set E}
lemma convex_on_norm (hs : convex â„ s) : convex_on â„ s norm :=
âŸ¨hs, Î» x y hx hy a b ha hb hab,
  calc âˆ¥a â€¢ x + b â€¢ yâˆ¥ â‰¤ âˆ¥a â€¢ xâˆ¥ + âˆ¥b â€¢ yâˆ¥ : norm_add_le _ _
    ... = a * âˆ¥xâˆ¥ + b * âˆ¥yâˆ¥
        : by rw [norm_smul, norm_smul, real.norm_of_nonneg ha, real.norm_of_nonneg hb]âŸ©
lemma convex_on_univ_norm : convex_on â„ univ (norm : E â†’ â„) := convex_on_norm convex_univ
lemma convex_on_dist (z : E) (hs : convex â„ s) : convex_on â„ s (Î» z', dist z' z) :=
by simpa [dist_eq_norm, preimage_preimage]
  using (convex_on_norm (hs.translate (-z))).comp_affine_map
    (affine_map.id â„ E - affine_map.const â„ E z)
lemma convex_on_univ_dist (z : E) : convex_on â„ univ (Î»z', dist z' z) :=
convex_on_dist z convex_univ
lemma convex_ball (a : E) (r : â„) : convex â„ (metric.ball a r) :=
by simpa only [metric.ball, sep_univ] using (convex_on_univ_dist a).convex_lt r
lemma convex_closed_ball (a : E) (r : â„) : convex â„ (metric.closed_ball a r) :=
by simpa only [metric.closed_ball, sep_univ] using (convex_on_univ_dist a).convex_le r
lemma convex.thickening (hs : convex â„ s) (Î´ : â„) : convex â„ (thickening Î´ s) :=
by { rw â†add_ball_zero, exact hs.add (convex_ball 0 _) }
lemma convex.cthickening (hs : convex â„ s) (Î´ : â„) : convex â„ (cthickening Î´ s) :=
begin
  obtain hÎ´ | hÎ´ := le_total 0 Î´,
  { rw cthickening_eq_Inter_thickening hÎ´,
    exact convex_Interâ‚‚ (Î» _ _, hs.thickening _) },
  { rw cthickening_of_nonpos hÎ´,
    exact hs.closure }
end
lemma disjoint.exists_open_convexes (disj : disjoint s t) (hsâ‚ : convex â„ s) (hsâ‚‚ : is_compact s)
  (htâ‚ : convex â„ t) (htâ‚‚ : is_closed t) :
  âˆƒ u v, is_open u âˆ§ is_open v âˆ§ convex â„ u âˆ§ convex â„ v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ disjoint u v :=
let âŸ¨Î´, hÎ´, hstâŸ© := disj.exists_thickenings hsâ‚‚ htâ‚‚ in
  âŸ¨_, _, is_open_thickening, is_open_thickening, hsâ‚.thickening _, htâ‚.thickening _,
    self_subset_thickening hÎ´ _, self_subset_thickening hÎ´ _, hstâŸ©
lemma convex_hull_exists_dist_ge {s : set E} {x : E} (hx : x âˆˆ convex_hull â„ s) (y : E) :
  âˆƒ x' âˆˆ s, dist x y â‰¤ dist x' y :=
(convex_on_dist y (convex_convex_hull â„ _)).exists_ge_of_mem_convex_hull hx
lemma convex_hull_exists_dist_ge2 {s t : set E} {x y : E}
  (hx : x âˆˆ convex_hull â„ s) (hy : y âˆˆ convex_hull â„ t) :
  âˆƒ (x' âˆˆ s) (y' âˆˆ t), dist x y â‰¤ dist x' y' :=
begin
  rcases convex_hull_exists_dist_ge hx y with âŸ¨x', hx', Hx'âŸ©,
  rcases convex_hull_exists_dist_ge hy x' with âŸ¨y', hy', Hy'âŸ©,
  use [x', hx', y', hy'],
  exact le_trans Hx' (dist_comm y x' â–¸ dist_comm y' x' â–¸ Hy')
end
@[simp] lemma convex_hull_ediam (s : set E) :
  emetric.diam (convex_hull â„ s) = emetric.diam s :=
begin
  refine (emetric.diam_le $ Î» x hx y hy, _).antisymm (emetric.diam_mono $ subset_convex_hull â„ s),
  rcases convex_hull_exists_dist_ge2 hx hy with âŸ¨x', hx', y', hy', HâŸ©,
  rw edist_dist,
  apply le_trans (ennreal.of_real_le_of_real H),
  rw â† edist_dist,
  exact emetric.edist_le_diam_of_mem hx' hy'
end
@[simp] lemma convex_hull_diam (s : set E) :
  metric.diam (convex_hull â„ s) = metric.diam s :=
by simp only [metric.diam, convex_hull_ediam]
@[simp] lemma bounded_convex_hull {s : set E} :
  metric.bounded (convex_hull â„ s) â†” metric.bounded s :=
by simp only [metric.bounded_iff_ediam_ne_top, convex_hull_ediam]
@[priority 100]
instance normed_space.path_connected : path_connected_space E :=
topological_add_group.path_connected
@[priority 100]
instance normed_space.loc_path_connected : loc_path_connected_space E :=
loc_path_connected_of_bases (Î» x, metric.nhds_basis_ball)
  (Î» x r r_pos, (convex_ball x r).is_path_connected $ by simp [r_pos])
lemma dist_add_dist_of_mem_segment {x y z : E} (h : y âˆˆ [x -[â„] z]) :
  dist x y + dist y z = dist x z :=
begin
  simp only [dist_eq_norm, mem_segment_iff_same_ray] at *,
  simpa only [sub_add_sub_cancel', norm_sub_rev] using h.norm_add.symm
end
end normed_space
