import logic.encodable.basic
import order.atoms
import order.upper_lower
open function set
namespace order
variables {P : Type*}
structure ideal (P) [has_le P] extends lower_set P :=
(nonempty'  : carrier.nonempty)
(directed'  : directed_on (â‰¤) carrier)
@[mk_iff] structure is_ideal {P} [has_le P] (I : set P) : Prop :=
(is_lower_set : is_lower_set I)
(nonempty : I.nonempty)
(directed : directed_on (â‰¤) I)
def is_ideal.to_ideal [has_le P] {I : set P} (h : is_ideal I) : ideal P :=
âŸ¨âŸ¨I, h.is_lower_setâŸ©, h.nonempty, h.directedâŸ©
namespace ideal
section has_le
variables [has_le P]
section
variables {I J s t : ideal P} {x y : P}
lemma to_lower_set_injective : injective (to_lower_set : ideal P â†’ lower_set P) :=
Î» s t h, by { cases s, cases t, congr' }
instance : set_like (ideal P) P :=
{ coe := Î» s, s.carrier,
  coe_injective' := Î» s t h, to_lower_set_injective $ set_like.coe_injective h }
@[ext] lemma ext {s t : ideal P} : (s : set P) = t â†’ s = t := set_like.ext'
@[simp] lemma carrier_eq_coe (s : ideal P) : s.carrier = s := rfl
@[simp] lemma coe_to_lower_set (s : ideal P) : (s.to_lower_set : set P) = s := rfl
protected lemma lower (s : ideal P) : is_lower_set (s : set P) := s.lower'
protected lemma nonempty (s : ideal P) : (s : set P).nonempty := s.nonempty'
protected lemma directed (s : ideal P) : directed_on (â‰¤) (s : set P) := s.directed'
protected lemma is_ideal (s : ideal P) : is_ideal (s : set P) := âŸ¨s.lower, s.nonempty, s.directedâŸ©
lemma mem_compl_of_ge {x y : P} : x â‰¤ y â†’ x âˆˆ (I : set P)á¶œ â†’ y âˆˆ (I : set P)á¶œ := Î» h, mt $ I.lower h
instance : partial_order (ideal P) := partial_order.lift coe set_like.coe_injective
@[simp] lemma coe_subset_coe : (s : set P) âŠ† t â†” s â‰¤ t := iff.rfl
@[simp] lemma coe_ssubset_coe : (s : set P) âŠ‚ t â†” s < t := iff.rfl
@[trans] lemma mem_of_mem_of_le {x : P} {I J : ideal P} : x âˆˆ I â†’ I â‰¤ J â†’ x âˆˆ J :=
@set.mem_of_mem_of_subset P x I J
@[mk_iff] class is_proper (I : ideal P) : Prop := (ne_univ : (I : set P) â‰  univ)
lemma is_proper_of_not_mem {I : ideal P} {p : P} (nmem : p âˆ‰ I) : is_proper I :=
âŸ¨Î» hp, begin
  change p âˆ‰ â†‘I at nmem,
  rw hp at nmem,
  exact nmem (mem_univ p),
endâŸ©
@[mk_iff] class is_maximal (I : ideal P) extends is_proper I : Prop :=
(maximal_proper : âˆ€ â¦ƒJ : ideal Pâ¦„, I < J â†’ (J : set P) = univ)
lemma inter_nonempty [is_directed P (â‰¥)] (I J : ideal P) : (I âˆ© J : set P).nonempty :=
begin
  obtain âŸ¨a, haâŸ© := I.nonempty,
  obtain âŸ¨b, hbâŸ© := J.nonempty,
  obtain âŸ¨c, hac, hbcâŸ© := exists_le_le a b,
  exact âŸ¨c, I.lower hac ha, J.lower hbc hbâŸ©,
end
end
section directed
variables [is_directed P (â‰¤)] [nonempty P] {I : ideal P}
instance : order_top (ideal P) :=
{ top := âŸ¨âŠ¤, univ_nonempty, directed_on_univâŸ©,
  le_top := Î» I, le_top }
@[simp] lemma top_to_lower_set : (âŠ¤ : ideal P).to_lower_set = âŠ¤ := rfl
@[simp] lemma coe_top : ((âŠ¤ : ideal P) : set P) = univ := rfl
lemma is_proper_of_ne_top (ne_top : I â‰  âŠ¤) : is_proper I := âŸ¨Î» h, ne_top $ ext hâŸ©
lemma is_proper.ne_top (hI : is_proper I) : I â‰  âŠ¤ := Î» h, is_proper.ne_univ $ congr_arg coe h
lemma _root_.is_coatom.is_proper (hI : is_coatom I) : is_proper I := is_proper_of_ne_top hI.1
lemma is_proper_iff_ne_top : is_proper I â†” I â‰  âŠ¤ := âŸ¨Î» h, h.ne_top, Î» h, is_proper_of_ne_top hâŸ©
lemma is_maximal.is_coatom (h : is_maximal I) : is_coatom I :=
âŸ¨is_maximal.to_is_proper.ne_top, Î» J h, ext $ is_maximal.maximal_proper hâŸ©
lemma is_maximal.is_coatom' [is_maximal I] : is_coatom I := is_maximal.is_coatom â€¹_â€º
lemma _root_.is_coatom.is_maximal (hI : is_coatom I) : is_maximal I :=
{ maximal_proper := Î» _ _, by simp [hI.2 _ â€¹_â€º],
  ..is_coatom.is_proper â€¹_â€º }
lemma is_maximal_iff_is_coatom : is_maximal I â†” is_coatom I := âŸ¨Î» h, h.is_coatom, Î» h, h.is_maximalâŸ©
end directed
section order_bot
variables [order_bot P]
@[simp] lemma bot_mem (s : ideal P) : âŠ¥ âˆˆ s := s.lower bot_le s.nonempty.some_mem
end order_bot
section order_top
variables [order_top P] {I : ideal P}
lemma top_of_top_mem (h : âŠ¤ âˆˆ I) : I = âŠ¤ := by { ext, exact iff_of_true (I.lower le_top h) trivial }
lemma is_proper.top_not_mem (hI : is_proper I) : âŠ¤ âˆ‰ I := Î» h, hI.ne_top $ top_of_top_mem h
end order_top
end has_le
section preorder
variables [preorder P]
section
variables {I J : ideal P} {x y : P}
@[simps] def principal (p : P) : ideal P :=
{ to_lower_set := lower_set.Iic p,
  nonempty' := nonempty_Iic,
  directed' := Î» x hx y hy, âŸ¨p, le_rfl, hx, hyâŸ© }
instance [inhabited P] : inhabited (ideal P) := âŸ¨ideal.principal defaultâŸ©
@[simp] lemma principal_le_iff : principal x â‰¤ I â†” x âˆˆ I :=
âŸ¨Î» h, h le_rfl, Î» hx y hy, I.lower hy hxâŸ©
@[simp] lemma mem_principal : x âˆˆ principal y â†” x â‰¤ y := iff.rfl
end
section order_bot
variables [order_bot P]
instance : order_bot (ideal P) :=
{ bot := principal âŠ¥,
  bot_le := by simp }
@[simp] lemma principal_bot : principal (âŠ¥ : P) = âŠ¥ := rfl
end order_bot
section order_top
variables [order_top P]
@[simp] lemma principal_top : principal (âŠ¤ : P) = âŠ¤ := to_lower_set_injective $ lower_set.Iic_top
end order_top
end preorder
section semilattice_sup
variables [semilattice_sup P] {x y : P} {I s : ideal P}
lemma sup_mem (hx : x âˆˆ s) (hy : y âˆˆ s) : x âŠ” y âˆˆ s :=
let âŸ¨z, hz, hx, hyâŸ© := s.directed x hx y hy in s.lower (sup_le hx hy) hz
@[simp] lemma sup_mem_iff : x âŠ” y âˆˆ I â†” x âˆˆ I âˆ§ y âˆˆ I :=
âŸ¨Î» h, âŸ¨I.lower le_sup_left h, I.lower le_sup_right hâŸ©, Î» h, sup_mem h.1 h.2âŸ©
end semilattice_sup
section semilattice_sup_directed
variables [semilattice_sup P] [is_directed P (â‰¥)] {x : P} {I J K s t : ideal P}
instance : has_inf (ideal P) :=
âŸ¨Î» I J, { to_lower_set := I.to_lower_set âŠ“ J.to_lower_set,
  nonempty' := inter_nonempty I J,
  directed' := Î» x hx y hy, âŸ¨x âŠ” y, âŸ¨sup_mem hx.1 hy.1, sup_mem hx.2 hy.2âŸ©, by simpâŸ© }âŸ©
instance : has_sup (ideal P) :=
âŸ¨Î» I J, { carrier   := {x | âˆƒ (i âˆˆ I) (j âˆˆ J), x â‰¤ i âŠ” j},
  nonempty' := by { cases inter_nonempty I J, exact âŸ¨w, w, h.1, w, h.2, le_sup_leftâŸ© },
  directed' := Î» x âŸ¨xi, _, xj, _, _âŸ© y âŸ¨yi, _, yj, _, _âŸ©,
    âŸ¨x âŠ” y,
     âŸ¨xi âŠ” yi, sup_mem â€¹_â€º â€¹_â€º,
      xj âŠ” yj, sup_mem â€¹_â€º â€¹_â€º,
      sup_le
        (calc x â‰¤ xi âŠ” xj               : â€¹_â€º
         ...    â‰¤ (xi âŠ” yi) âŠ” (xj âŠ” yj) : sup_le_sup le_sup_left le_sup_left)
        (calc y â‰¤ yi âŠ” yj               : â€¹_â€º
         ...    â‰¤ (xi âŠ” yi) âŠ” (xj âŠ” yj) : sup_le_sup le_sup_right le_sup_right)âŸ©,
     le_sup_left, le_sup_rightâŸ©,
  lower' := Î» x y h âŸ¨yi, _, yj, _, _âŸ©, âŸ¨yi, â€¹_â€º, yj, â€¹_â€º, h.trans â€¹_â€ºâŸ© }âŸ©
instance : lattice (ideal P) :=
{ sup          := (âŠ”),
  le_sup_left  := Î» I J (i âˆˆ I), by { cases J.nonempty, exact âŸ¨i, â€¹_â€º, w, â€¹_â€º, le_sup_leftâŸ© },
  le_sup_right := Î» I J (j âˆˆ J), by { cases I.nonempty, exact âŸ¨w, â€¹_â€º, j, â€¹_â€º, le_sup_rightâŸ© },
  sup_le       := Î» I J K hIK hJK a âŸ¨i, hi, j, hj, haâŸ©,
    K.lower ha $ sup_mem (mem_of_mem_of_le hi hIK) (mem_of_mem_of_le hj hJK),
  inf          := (âŠ“),
  inf_le_left  := Î» I J, inter_subset_left I J,
  inf_le_right := Î» I J, inter_subset_right I J,
  le_inf       := Î» I J K, subset_inter,
  .. ideal.partial_order }
@[simp] lemma coe_sup : â†‘(s âŠ” t) = {x | âˆƒ (a âˆˆ s) (b âˆˆ t), x â‰¤ a âŠ” b} := rfl
@[simp] lemma coe_inf : (â†‘(s âŠ“ t) : set P) = s âˆ© t := rfl
@[simp] lemma mem_inf : x âˆˆ I âŠ“ J â†” x âˆˆ I âˆ§ x âˆˆ J := iff.rfl
@[simp] lemma mem_sup : x âˆˆ I âŠ” J â†” âˆƒ (i âˆˆ I) (j âˆˆ J), x â‰¤ i âŠ” j := iff.rfl
lemma lt_sup_principal_of_not_mem (hx : x âˆ‰ I) : I < I âŠ” principal x :=
le_sup_left.lt_of_ne $ Î» h, hx $ by simpa only [left_eq_sup, principal_le_iff] using h
end semilattice_sup_directed
section semilattice_sup_order_bot
variables [semilattice_sup P] [order_bot P] {x : P} {I J K : ideal P}
instance : has_Inf (ideal P) :=
âŸ¨Î» S, { to_lower_set := â¨… s âˆˆ S, to_lower_set s,
  nonempty' := âŸ¨âŠ¥, begin
    rw [lower_set.carrier_eq_coe, lower_set.coe_infiâ‚‚, set.mem_Interâ‚‚],
    exact Î» s _, s.bot_mem,
  endâŸ©,
  directed' := Î» a ha b hb, âŸ¨a âŠ” b, âŸ¨
    begin
      rw [lower_set.carrier_eq_coe, lower_set.coe_infiâ‚‚, set.mem_Interâ‚‚] at âŠ¢ ha hb,
      exact Î» s hs, sup_mem (ha _ hs) (hb _ hs),
    end,
    le_sup_left, le_sup_rightâŸ©âŸ© }âŸ©
variables {S : set (ideal P)}
@[simp] lemma coe_Inf : (â†‘(Inf S) : set P) = â‹‚ s âˆˆ S, â†‘s := lower_set.coe_infiâ‚‚ _
@[simp] lemma mem_Inf : x âˆˆ Inf S â†” âˆ€ s âˆˆ S, x âˆˆ s :=
by simp_rw [â†set_like.mem_coe, coe_Inf, mem_Interâ‚‚]
instance : complete_lattice (ideal P) :=
{ ..ideal.lattice,
  ..complete_lattice_of_Inf (ideal P) (Î» S, begin
    refine âŸ¨Î» s hs, _, Î» s hs, by rwa [â†coe_subset_coe, coe_Inf, subset_Interâ‚‚_iff]âŸ©,
    rw [â†coe_subset_coe, coe_Inf],
    exact bInter_subset_of_mem hs,
  end) }
end semilattice_sup_order_bot
section distrib_lattice
variables [distrib_lattice P]
variables {I J : ideal P}
lemma eq_sup_of_le_sup {x i j: P} (hi : i âˆˆ I) (hj : j âˆˆ J) (hx : x â‰¤ i âŠ” j) :
  âˆƒ (i' âˆˆ I) (j' âˆˆ J), x = i' âŠ” j' :=
begin
  refine âŸ¨x âŠ“ i, I.lower inf_le_right hi, x âŠ“ j, J.lower inf_le_right hj, _âŸ©,
  calc
  x    = x âŠ“ (i âŠ” j)       : left_eq_inf.mpr hx
  ...  = (x âŠ“ i) âŠ” (x âŠ“ j) : inf_sup_left,
end
lemma coe_sup_eq : â†‘(I âŠ” J) = {x | âˆƒ i âˆˆ I, âˆƒ j âˆˆ J, x = i âŠ” j} :=
set.ext $ Î» _, âŸ¨Î» âŸ¨_, _, _, _, _âŸ©, eq_sup_of_le_sup â€¹_â€º â€¹_â€º â€¹_â€º,
  Î» âŸ¨i, _, j, _, _âŸ©, âŸ¨i, â€¹_â€º, j, â€¹_â€º, le_of_eq â€¹_â€ºâŸ©âŸ©
end distrib_lattice
section boolean_algebra
variables [boolean_algebra P] {x : P} {I : ideal P}
lemma is_proper.not_mem_of_compl_mem (hI : is_proper I) (hxc : xá¶œ âˆˆ I) : x âˆ‰ I :=
begin
  intro hx,
  apply hI.top_not_mem,
  have ht : x âŠ” xá¶œ âˆˆ I := sup_mem â€¹_â€º â€¹_â€º,
  rwa sup_compl_eq_top at ht,
end
lemma is_proper.not_mem_or_compl_not_mem (hI : is_proper I) : x âˆ‰ I âˆ¨ xá¶œ âˆ‰ I :=
have h : xá¶œ âˆˆ I â†’ x âˆ‰ I := hI.not_mem_of_compl_mem, by tauto
end boolean_algebra
end ideal
structure cofinal (P) [preorder P] :=
(carrier : set P)
(mem_gt  : âˆ€ x : P, âˆƒ y âˆˆ carrier, x â‰¤ y)
namespace cofinal
variables [preorder P]
instance : inhabited (cofinal P) :=
âŸ¨{ carrier := univ, mem_gt := Î» x, âŸ¨x, trivial, le_rflâŸ© }âŸ©
instance : has_mem P (cofinal P) := âŸ¨Î» x D, x âˆˆ D.carrierâŸ©
variables (D : cofinal P) (x : P)
noncomputable def above : P := classical.some $ D.mem_gt x
lemma above_mem : D.above x âˆˆ D :=
exists.elim (classical.some_spec $ D.mem_gt x) $ Î» a _, a
lemma le_above : x â‰¤ D.above x :=
exists.elim (classical.some_spec $ D.mem_gt x) $ Î» _ b, b
end cofinal
section ideal_of_cofinals
variables [preorder P] (p : P) {Î¹ : Type*} [encodable Î¹] (ð’Ÿ : Î¹ â†’ cofinal P)
noncomputable def sequence_of_cofinals : â„• â†’ P
| 0 := p
| (n+1) := match encodable.decode Î¹ n with
           | none   := sequence_of_cofinals n
           | some i := (ð’Ÿ i).above (sequence_of_cofinals n)
           end
lemma sequence_of_cofinals.monotone : monotone (sequence_of_cofinals p ð’Ÿ) :=
by { apply monotone_nat_of_le_succ, intros n, dunfold sequence_of_cofinals,
  cases encodable.decode Î¹ n, { refl }, { apply cofinal.le_above }, }
lemma sequence_of_cofinals.encode_mem (i : Î¹) :
  sequence_of_cofinals p ð’Ÿ (encodable.encode i + 1) âˆˆ ð’Ÿ i :=
by { dunfold sequence_of_cofinals, rw encodable.encodek, apply cofinal.above_mem, }
def ideal_of_cofinals : ideal P :=
{ carrier   := { x : P | âˆƒ n, x â‰¤ sequence_of_cofinals p ð’Ÿ n },
  lower'     := Î» x y hxy âŸ¨n, hnâŸ©, âŸ¨n, le_trans hxy hnâŸ©,
  nonempty' := âŸ¨p, 0, le_rflâŸ©,
  directed' := Î» x âŸ¨n, hnâŸ© y âŸ¨m, hmâŸ©,
               âŸ¨_, âŸ¨max n m, le_rflâŸ©,
               le_trans hn $ sequence_of_cofinals.monotone p ð’Ÿ (le_max_left _ _),
               le_trans hm $ sequence_of_cofinals.monotone p ð’Ÿ (le_max_right _ _) âŸ© }
lemma mem_ideal_of_cofinals : p âˆˆ ideal_of_cofinals p ð’Ÿ := âŸ¨0, le_rflâŸ©
lemma cofinal_meets_ideal_of_cofinals (i : Î¹) : âˆƒ x : P, x âˆˆ ð’Ÿ i âˆ§ x âˆˆ ideal_of_cofinals p ð’Ÿ :=
âŸ¨_, sequence_of_cofinals.encode_mem p ð’Ÿ i, _, le_rflâŸ©
end ideal_of_cofinals
end order
