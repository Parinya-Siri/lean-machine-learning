import algebraic_geometry.presheafed_space
import topology.category.Top.limits
import topology.sheaves.limits
import category_theory.limits.concrete_category
noncomputable theory
universes v' u' v u
open category_theory
open Top
open Top.presheaf
open topological_space
open opposite
open category_theory.category
open category_theory.limits
open category_theory.functor
variables {J : Type u'} [category.{v'} J]
variables {C : Type u} [category.{v} C]
namespace algebraic_geometry
namespace PresheafedSpace
local attribute [simp] eq_to_hom_map
@[simp]
lemma map_id_c_app (F : J â¥¤ PresheafedSpace.{v} C) (j) (U) :
  (F.map (ğŸ™ j)).c.app (op U) =
    (pushforward.id (F.obj j).presheaf).inv.app (op U) â‰«
      (pushforward_eq (by { simp, refl }) (F.obj j).presheaf).hom.app (op U) :=
begin
  cases U,
  dsimp,
  simp [PresheafedSpace.congr_app (F.map_id j)],
  refl,
end
@[simp]
lemma map_comp_c_app (F : J â¥¤ PresheafedSpace.{v} C) {jâ‚ jâ‚‚ jâ‚ƒ} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ) (U) :
  (F.map (f â‰« g)).c.app (op U) =
    (F.map g).c.app (op U) â‰«
    (pushforward_map (F.map g).base (F.map f).c).app (op U) â‰«
    (pushforward.comp (F.obj jâ‚).presheaf (F.map f).base (F.map g).base).inv.app (op U) â‰«
    (pushforward_eq (by { rw F.map_comp, refl }) _).hom.app _ :=
begin
  cases U,
  dsimp,
  simp only [PresheafedSpace.congr_app (F.map_comp f g)],
@[simps]
def componentwise_diagram (F : J â¥¤ PresheafedSpace.{v} C)
  [has_colimit F] (U : opens (limits.colimit F).carrier) : Jáµ’áµ– â¥¤ C :=
{ obj := Î» j, (F.obj (unop j)).presheaf.obj (op ((opens.map (colimit.Î¹ F (unop j)).base).obj U)),
  map := Î» j k f, (F.map f.unop).c.app _ â‰« (F.obj (unop k)).presheaf.map
    (eq_to_hom (by { rw [â† colimit.w F f.unop, comp_base], refl })),
  map_comp' := Î» i j k f g,
  begin
    cases U,
    dsimp,
    simp_rw [map_comp_c_app, category.assoc],
    congr' 1,
    rw [Top.presheaf.pushforward.comp_inv_app, Top.presheaf.pushforward_eq_hom_app,
      category_theory.nat_trans.naturality_assoc, Top.presheaf.pushforward_map_app],
    congr' 1,
    rw [category.id_comp, â† (F.obj (unop k)).presheaf.map_comp],
    erw â† (F.obj (unop k)).presheaf.map_comp,
    congr
  end }
variable [has_colimits_of_shape J Top.{v}]
@[simps]
def pushforward_diagram_to_colimit (F : J â¥¤ PresheafedSpace.{v} C) :
  J â¥¤ (presheaf C (colimit (F â‹™ PresheafedSpace.forget C)))áµ’áµ– :=
{ obj := Î» j, op ((colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j) _* (F.obj j).presheaf),
  map := Î» j j' f,
  (pushforward_map (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j') (F.map f).c â‰«
    (pushforward.comp (F.obj j).presheaf ((F â‹™ PresheafedSpace.forget C).map f)
      (colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j')).inv â‰«
    (pushforward_eq (colimit.w (F â‹™ PresheafedSpace.forget C) f) (F.obj j).presheaf).hom).op,
  map_id' := Î» j,
  begin
    apply (op_equiv _ _).injective,
    ext U,
    induction U using opposite.rec,
    cases U,
    dsimp, simp, dsimp, simp,
  end,
  map_comp' := Î» jâ‚ jâ‚‚ jâ‚ƒ f g,
  begin
    apply (op_equiv _ _).injective,
    ext U,
    dsimp,
    simp only [map_comp_c_app, id.def, eq_to_hom_op, pushforward_map_app, eq_to_hom_map, assoc,
      id_comp, pushforward.comp_inv_app, pushforward_eq_hom_app],
    dsimp,
    simp only [eq_to_hom_trans, id_comp],
    congr' 1,
def colimit (F : J â¥¤ PresheafedSpace.{v} C) : PresheafedSpace C :=
{ carrier := colimit (F â‹™ PresheafedSpace.forget C),
  presheaf := limit (pushforward_diagram_to_colimit F).left_op, }
@[simp] lemma colimit_carrier (F : J â¥¤ PresheafedSpace.{v} C) :
  (colimit F).carrier = limits.colimit (F â‹™ PresheafedSpace.forget C) := rfl
@[simp] lemma colimit_presheaf (F : J â¥¤ PresheafedSpace.{v} C) :
  (colimit F).presheaf = limit (pushforward_diagram_to_colimit F).left_op := rfl
@[simps]
def colimit_cocone (F : J â¥¤ PresheafedSpace.{v} C) : cocone F :=
{ X := colimit F,
  Î¹ :=
  { app := Î» j,
    { base := colimit.Î¹ (F â‹™ PresheafedSpace.forget C) j,
      c := limit.Ï€ _ (op j), },
    naturality' := Î» j j' f,
    begin
      fapply PresheafedSpace.ext,
      { ext x,
        exact colimit.w_apply (F â‹™ PresheafedSpace.forget C) f x, },
      { ext U,
        induction U using opposite.rec,
        cases U,
        dsimp,
        simp only [PresheafedSpace.id_c_app, eq_to_hom_op, eq_to_hom_map, assoc,
          pushforward.comp_inv_app],
        rw â† congr_arg nat_trans.app (limit.w (pushforward_diagram_to_colimit F).left_op f.op),
        dsimp,
        simp only [eq_to_hom_op, eq_to_hom_map, assoc, id_comp, pushforward.comp_inv_app],
        congr,
        dsimp,
        simp only [id_comp],
        simpa, }
    end, }, }
variables [has_limits_of_shape Jáµ’áµ– C]
namespace colimit_cocone_is_colimit
def desc_c_app (F : J â¥¤ PresheafedSpace.{v} C) (s : cocone F) (U : (opens â†¥(s.X.carrier))áµ’áµ–) :
  s.X.presheaf.obj U âŸ¶
    (colimit.desc (F â‹™ PresheafedSpace.forget C)
         ((PresheafedSpace.forget C).map_cocone s) _*
       limit (pushforward_diagram_to_colimit F).left_op).obj
      U :=
begin
  refine
    limit.lift _ { X := s.X.presheaf.obj U, Ï€ := { app := Î» j, _, naturality' := Î» j j' f, _, }} â‰«
      (limit_obj_iso_limit_comp_evaluation _ _).inv,
def desc (F : J â¥¤ PresheafedSpace.{v} C) (s : cocone F) : colimit F âŸ¶ s.X :=
{ base := colimit.desc (F â‹™ PresheafedSpace.forget C) ((PresheafedSpace.forget C).map_cocone s),
  c :=
  { app := Î» U, desc_c_app F s U,
    naturality' := Î» U V i, desc_c_naturality F s i } }
lemma desc_fac  (F : J â¥¤ PresheafedSpace.{v} C) (s : cocone F) (j : J) :
  (colimit_cocone F).Î¹.app j â‰« desc F s = s.Î¹.app j :=
begin
  fapply PresheafedSpace.ext,
  { simp [desc] },
  { ext,
    dsimp [desc, desc_c_app],
    simpa }
end
end colimit_cocone_is_colimit
open colimit_cocone_is_colimit
def colimit_cocone_is_colimit (F : J â¥¤ PresheafedSpace.{v} C) : is_colimit (colimit_cocone F) :=
{ desc := Î» s, desc F s,
  fac' := Î» s, desc_fac F s,
  uniq' := Î» s m w,
  begin
instance [has_limits C] : has_colimits (PresheafedSpace.{v} C) :=
{ has_colimits_of_shape := Î» J ğ’¥, by exactI
  { has_colimit := Î» F, has_colimit.mk
    { cocone     := colimit_cocone F,
      is_colimit := colimit_cocone_is_colimit F } } }
instance forget_preserves_colimits [has_limits C] : preserves_colimits (PresheafedSpace.forget C) :=
{ preserves_colimits_of_shape := Î» J ğ’¥, by exactI
  { preserves_colimit := Î» F, preserves_colimit_of_preserves_colimit_cocone
    (colimit_cocone_is_colimit F)
    begin
      apply is_colimit.of_iso_colimit (colimit.is_colimit _),
      fapply cocones.ext,
      { refl, },
      { intro j, dsimp, simp, }
    end } }
def colimit_presheaf_obj_iso_componentwise_limit (F : J â¥¤ PresheafedSpace.{v} C) [has_colimit F]
  (U : opens (limits.colimit F).carrier) :
  (limits.colimit F).presheaf.obj (op U) â‰… limit (componentwise_diagram F U) :=
begin
  refine ((sheaf_iso_of_iso (colimit.iso_colimit_cocone
    âŸ¨_, colimit_cocone_is_colimit FâŸ©).symm).app (op U)).trans _,
  refine (limit_obj_iso_limit_comp_evaluation _ _).trans (limits.lim.map_iso _),
  fapply nat_iso.of_components,
  { intro X,
    refine ((F.obj (unop X)).presheaf.map_iso (eq_to_iso _)),
    dsimp only [functor.op, unop_op, opens.map],
    congr' 2,
    rw set.preimage_preimage,
    simp_rw â† comp_app,
    congr' 2,
    exact Î¹_preserves_colimits_iso_inv (forget C) F (unop X) },
  { intros X Y f,
    change ((F.map f.unop).c.app _ â‰« _ â‰« _) â‰« (F.obj (unop Y)).presheaf.map _ = _ â‰« _,
    rw Top.presheaf.pushforward.comp_inv_app,
    erw category.id_comp,
    rw category.assoc,
    erw [â† (F.obj (unop Y)).presheaf.map_comp, (F.map f.unop).c.naturality_assoc,
      â† (F.obj (unop Y)).presheaf.map_comp],
    congr }
end
@[simp]
lemma colimit_presheaf_obj_iso_componentwise_limit_inv_Î¹_app (F : J â¥¤ PresheafedSpace.{v} C)
  (U : opens (limits.colimit F).carrier) (j : J) :
  (colimit_presheaf_obj_iso_componentwise_limit F U).inv â‰« (colimit.Î¹ F j).c.app (op U) =
    limit.Ï€ _ (op j) :=
begin
  delta colimit_presheaf_obj_iso_componentwise_limit,
  rw [iso.trans_inv, iso.trans_inv, iso.app_inv, sheaf_iso_of_iso_inv, pushforward_to_of_iso_app,
    congr_app (iso.symm_inv _)],
  simp_rw category.assoc,
  rw [â† functor.map_comp_assoc, nat_trans.naturality],
  erw â† comp_c_app_assoc,
  rw congr_app (colimit.iso_colimit_cocone_Î¹_hom _ _),
  simp_rw category.assoc,
  erw [limit_obj_iso_limit_comp_evaluation_inv_Ï€_app_assoc, lim_map_Ï€_assoc],
  convert category.comp_id _,
  erw â† (F.obj j).presheaf.map_id,
  iterate 2 { erw â† (F.obj j).presheaf.map_comp },
  congr
end
@[simp]
lemma colimit_presheaf_obj_iso_componentwise_limit_hom_Ï€ (F : J â¥¤ PresheafedSpace.{v} C)
  (U : opens (limits.colimit F).carrier) (j : J) :
    (colimit_presheaf_obj_iso_componentwise_limit F U).hom â‰« limit.Ï€ _ (op j) =
      (colimit.Î¹ F j).c.app (op U) :=
by rw [â† iso.eq_inv_comp, colimit_presheaf_obj_iso_componentwise_limit_inv_Î¹_app]
end PresheafedSpace
end algebraic_geometry
