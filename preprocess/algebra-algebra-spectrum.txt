import tactic.noncomm_ring
import field_theory.is_alg_closed.basic
import algebra.star.pointwise
open set
universes u v
section defs
variables (R : Type u) {A : Type v}
variables [comm_semiring R] [ring A] [algebra R A]
local notation `â†‘â‚` := algebra_map R A
def resolvent_set (a : A) : set R :=
{ r : R | is_unit (â†‘â‚r - a) }
def spectrum (a : A) : set R :=
(resolvent_set R a)á¶œ
variable {R}
noncomputable def resolvent (a : A) (r : R) : A :=
ring.inverse (â†‘â‚r - a)
@[simps]
noncomputable def is_unit.sub_inv_smul {r : RË£} {s : R} {a : A}
  (h : is_unit $ r â€¢ â†‘â‚s  - a) : AË£ :=
{ val := â†‘â‚s - râ»Â¹ â€¢ a,
  inv := r â€¢ â†‘h.unitâ»Â¹,
  val_inv := by rw [mul_smul_comm, â†smul_mul_assoc, smul_sub, smul_inv_smul, h.mul_coe_inv],
  inv_val := by rw [smul_mul_assoc, â†mul_smul_comm, smul_sub, smul_inv_smul, h.coe_inv_mul], }
end defs
namespace spectrum
open_locale polynomial
section scalar_semiring
variables {R : Type u} {A : Type v}
variables [comm_semiring R] [ring A] [algebra R A]
local notation `Ïƒ` := spectrum R
local notation `â†‘â‚` := algebra_map R A
lemma mem_iff {r : R} {a : A} :
  r âˆˆ Ïƒ a â†” Â¬ is_unit (â†‘â‚r - a) :=
iff.rfl
lemma not_mem_iff {r : R} {a : A} :
  r âˆ‰ Ïƒ a â†” is_unit (â†‘â‚r - a) :=
by { apply not_iff_not.mp, simp [set.not_not_mem, mem_iff] }
lemma mem_resolvent_set_of_left_right_inverse {r : R} {a b c : A}
  (hâ‚ : (â†‘â‚r - a) * b = 1) (hâ‚‚ : c * (â†‘â‚r - a) = 1) :
  r âˆˆ resolvent_set R a :=
units.is_unit âŸ¨â†‘â‚r - a, b, hâ‚, by rwa â†left_inv_eq_right_inv hâ‚‚ hâ‚âŸ©
lemma mem_resolvent_set_iff {r : R} {a : A} :
  r âˆˆ resolvent_set R a â†” is_unit (â†‘â‚r - a) :=
iff.rfl
@[simp] lemma resolvent_set_of_subsingleton [subsingleton A] (a : A) :
  resolvent_set R a = set.univ :=
by simp_rw [resolvent_set, subsingleton.elim (algebra_map R A _ - a) 1, is_unit_one,
  set.set_of_true]
@[simp] lemma of_subsingleton [subsingleton A] (a : A) :
  spectrum R a = âˆ… :=
by rw [spectrum, resolvent_set_of_subsingleton, set.compl_univ]
lemma resolvent_eq {a : A} {r : R} (h : r âˆˆ resolvent_set R a) :
  resolvent a r = â†‘h.unitâ»Â¹ :=
ring.inverse_unit h.unit
lemma units_smul_resolvent {r : RË£} {s : R} {a : A} :
  r â€¢ resolvent a (s : R) = resolvent (râ»Â¹ â€¢ a) (râ»Â¹ â€¢ s : R) :=
begin
  by_cases h : s âˆˆ spectrum R a,
  { rw [mem_iff] at h,
    simp only [resolvent, algebra.algebra_map_eq_smul_one] at *,
    rw [smul_assoc, â†smul_sub],
    have h' : Â¬ is_unit (râ»Â¹ â€¢ (s â€¢ 1 - a)),
      from Î» hu, h (by simpa only [smul_inv_smul] using is_unit.smul r hu),
    simp only [ring.inverse_non_unit _ h, ring.inverse_non_unit _ h', smul_zero] },
  { simp only [resolvent],
    have h' : is_unit (r â€¢ (algebra_map R A (râ»Â¹ â€¢ s)) - a),
      { simpa [algebra.algebra_map_eq_smul_one, smul_assoc] using not_mem_iff.mp h },
    rw [â†h'.coe_sub_inv_smul, â†(not_mem_iff.mp h).unit_spec, ring.inverse_unit, ring.inverse_unit,
      h'.coe_inv_sub_inv_smul],
    simp only [algebra.algebra_map_eq_smul_one, smul_assoc, smul_inv_smul], },
end
lemma units_smul_resolvent_self {r : RË£} {a : A} :
  r â€¢ resolvent a (r : R) = resolvent (râ»Â¹ â€¢ a) (1 : R) :=
by simpa only [units.smul_def, algebra.id.smul_eq_mul, units.inv_mul]
  using @units_smul_resolvent _ _ _ _ _ r r a
lemma is_unit_resolvent {r : R} {a : A} :
  r âˆˆ resolvent_set R a â†” is_unit (resolvent a r) :=
is_unit_ring_inverse.symm
lemma inv_mem_resolvent_set {r : RË£} {a : AË£} (h : (r : R) âˆˆ resolvent_set R (a : A)) :
  (â†‘râ»Â¹ : R) âˆˆ resolvent_set R (â†‘aâ»Â¹ : A) :=
begin
  rw [mem_resolvent_set_iff, algebra.algebra_map_eq_smul_one, â†units.smul_def] at h âŠ¢,
  rw [is_unit.smul_sub_iff_sub_inv_smul, inv_inv, is_unit.sub_iff],
  have hâ‚ : (a : A) * (r â€¢ (â†‘aâ»Â¹ : A) - 1) = r â€¢ 1 - a,
  { rw [mul_sub, mul_smul_comm, a.mul_inv, mul_one], },
  have hâ‚‚ : (r â€¢ (â†‘aâ»Â¹ : A) - 1) * a = r â€¢ 1 - a,
  { rw [sub_mul, smul_mul_assoc, a.inv_mul, one_mul], },
  have hcomm : commute (a : A) (r â€¢ (â†‘aâ»Â¹ : A) - 1), { rwa â†hâ‚‚ at hâ‚ },
  exact (hcomm.is_unit_mul_iff.mp (hâ‚.symm â–¸ h)).2,
end
lemma inv_mem_iff {r : RË£} {a : AË£} :
  (r : R) âˆˆ Ïƒ (a : A) â†” (â†‘râ»Â¹ : R) âˆˆ Ïƒ (â†‘aâ»Â¹ : A) :=
begin
  simp only [mem_iff, not_iff_not, â†mem_resolvent_set_iff],
  exact âŸ¨Î» h, inv_mem_resolvent_set h, Î» h, by simpa using inv_mem_resolvent_set hâŸ©,
end
lemma zero_mem_resolvent_set_of_unit (a : AË£) : 0 âˆˆ resolvent_set R (a : A) :=
by { rw [mem_resolvent_set_iff, is_unit.sub_iff], simp }
lemma ne_zero_of_mem_of_unit {a : AË£} {r : R} (hr : r âˆˆ Ïƒ (a : A)) : r â‰  0 :=
Î» hn, (hn â–¸ hr) (zero_mem_resolvent_set_of_unit a)
lemma add_mem_iff {a : A} {r s : R} :
  r âˆˆ Ïƒ a â†” r + s âˆˆ Ïƒ (â†‘â‚s + a) :=
begin
  apply not_iff_not.mpr,
  simp only [mem_resolvent_set_iff],
  have h_eq : â†‘â‚(r + s) - (â†‘â‚s + a) = â†‘â‚r - a,
    { simp, noncomm_ring },
  rw h_eq,
end
lemma smul_mem_smul_iff {a : A} {s : R} {r : RË£} :
  r â€¢ s âˆˆ Ïƒ (r â€¢ a) â†” s âˆˆ Ïƒ a :=
begin
  apply not_iff_not.mpr,
  simp only [mem_resolvent_set_iff, algebra.algebra_map_eq_smul_one],
  have h_eq : (r â€¢ s) â€¢ (1 : A) = r â€¢ s â€¢ 1, by simp,
  rw [h_eq, â†smul_sub, is_unit_smul_iff],
end
open_locale pointwise polynomial
theorem unit_smul_eq_smul (a : A) (r : RË£) :
  Ïƒ (r â€¢ a) = r â€¢ Ïƒ a :=
begin
  ext,
  have x_eq : x = r â€¢ râ»Â¹ â€¢ x, by simp,
  nth_rewrite 0 x_eq,
  rw smul_mem_smul_iff,
  split,
    { exact Î» h, âŸ¨râ»Â¹ â€¢ x, âŸ¨h, by simpâŸ©âŸ©},
    { rintros âŸ¨_, _, x'_eqâŸ©, simpa [â†x'_eq],}
end
@[simp] lemma zero_eq [nontrivial A] : Ïƒ (0 : A) = {0} :=
begin
  refine set.subset.antisymm _ (by simp [algebra.algebra_map_eq_smul_one, mem_iff]),
  rw [spectrum, set.compl_subset_comm],
  intros k hk,
  rw set.mem_compl_singleton_iff at hk,
  have : is_unit (units.mk0 k hk â€¢ (1 : A)) := is_unit.smul (units.mk0 k hk) is_unit_one,
  simpa [mem_resolvent_set_iff, algebra.algebra_map_eq_smul_one]
end
@[simp] theorem scalar_eq [nontrivial A] (k : ğ•œ) : Ïƒ (â†‘â‚k) = {k} :=
begin
  have coset_eq : left_add_coset k {0} = {k}, by
    { ext, split,
      { intro hx, simp [left_add_coset] at hx, exact hx, },
      { intro hx, simp at hx, exact âŸ¨0, âŸ¨set.mem_singleton 0, by simp [hx]âŸ©âŸ©, }, },
  calc Ïƒ (â†‘â‚k) = Ïƒ (â†‘â‚k + 0)                  : by simp
    ...        = left_add_coset k (Ïƒ (0 : A)) : by rw â†left_add_coset_eq
    ...        = left_add_coset k {0}         : by rw zero_eq
    ...        = {k}                          : coset_eq,
end
@[simp] lemma one_eq [nontrivial A] : Ïƒ (1 : A) = {1} :=
calc Ïƒ (1 : A) = Ïƒ (â†‘â‚1) : by simp [algebra.algebra_map_eq_smul_one]
  ...          = {1}     : scalar_eq 1
open_locale pointwise
theorem smul_eq_smul [nontrivial A] (k : ğ•œ) (a : A) (ha : (Ïƒ a).nonempty) :
  Ïƒ (k â€¢ a) = k â€¢ (Ïƒ a) :=
begin
  rcases eq_or_ne k 0 with rfl | h,
  { simpa [ha, zero_smul_set] },
  { exact unit_smul_eq_smul a (units.mk0 k h) },
end
theorem nonzero_mul_eq_swap_mul (a b : A) : Ïƒ (a * b) \ {0} = Ïƒ (b * a) \ {0} :=
begin
  suffices h : âˆ€ (x y : A), Ïƒ (x * y) \ {0} âŠ† Ïƒ (y * x) \ {0},
  { exact set.eq_of_subset_of_subset (h a b) (h b a) },
  { rintros _ _ k âŸ¨k_mem, k_neqâŸ©,
    change k with â†‘(units.mk0 k k_neq) at k_mem,
    exact âŸ¨unit_mem_mul_iff_mem_swap_mul.mp k_mem, k_neqâŸ© },
end
protected lemma map_inv (a : AË£) : (Ïƒ (a : A))â»Â¹ = Ïƒ (â†‘aâ»Â¹ : A) :=
begin
  refine set.eq_of_subset_of_subset (Î» k hk, _) (Î» k hk, _),
  { rw set.mem_inv at hk,
    have : k â‰  0,
    { simpa only [inv_inv] using inv_ne_zero (ne_zero_of_mem_of_unit hk), },
    lift k to ğ•œË£ using is_unit_iff_ne_zero.mpr this,
    rw â†units.coe_inv k at hk,
    exact inv_mem_iff.mp hk },
  { lift k to ğ•œË£ using is_unit_iff_ne_zero.mpr (ne_zero_of_mem_of_unit hk),
    simpa only [units.coe_inv] using inv_mem_iff.mp hk, }
end
open polynomial
theorem subset_polynomial_aeval (a : A) (p : ğ•œ[X]) :
  (Î» k, eval k p) '' (Ïƒ a) âŠ† Ïƒ (aeval a p) :=
begin
  rintros _ âŸ¨k, hk, rflâŸ©,
  let q := C (eval k p) - p,
  have hroot : is_root q k, by simp only [eval_C, eval_sub, sub_self, is_root.def],
  rw [â†mul_div_eq_iff_is_root, â†neg_mul_neg, neg_sub] at hroot,
  have aeval_q_eq : â†‘â‚(eval k p) - aeval a p = aeval a q,
    by simp only [aeval_C, alg_hom.map_sub, sub_left_inj],
  rw [mem_iff, aeval_q_eq, â†hroot, aeval_mul],
  have hcomm := (commute.all (C k - X) (- (q / (X - C k)))).map (aeval a),
  apply mt (Î» h, (hcomm.is_unit_mul_iff.mp h).1),
  simpa only [aeval_X, aeval_C, alg_hom.map_sub] using hk,
end
theorem map_polynomial_aeval_of_degree_pos [is_alg_closed ğ•œ] (a : A) (p : ğ•œ[X])
  (hdeg : 0 < degree p) : Ïƒ (aeval a p) = (Î» k, eval k p) '' (Ïƒ a) :=
begin
  refine set.eq_of_subset_of_subset (Î» k hk, _) (subset_polynomial_aeval a p),
  have hprod := eq_prod_roots_of_splits_id (is_alg_closed.splits (C k - p)),
  have h_ne : C k - p â‰  0, from ne_zero_of_degree_gt
    (by rwa [degree_sub_eq_right_of_degree_lt (lt_of_le_of_lt degree_C_le hdeg)]),
  have lead_ne := leading_coeff_ne_zero.mpr h_ne,
  have lead_unit := (units.map (â†‘â‚).to_monoid_hom (units.mk0 _ lead_ne)).is_unit,
  have p_a_eq : aeval a (C k - p) = â†‘â‚k - aeval a p,
    by simp only [aeval_C, alg_hom.map_sub, sub_left_inj],
  rw [mem_iff, â†p_a_eq, hprod, aeval_mul,
    ((commute.all _ _).map (aeval a)).is_unit_mul_iff, aeval_C] at hk,
  replace hk := exists_mem_of_not_is_unit_aeval_prod h_ne (not_and.mp hk lead_unit),
  rcases hk with âŸ¨r, r_mem, r_evâŸ©,
  exact âŸ¨r, r_mem, symm (by simpa [eval_sub, eval_C, sub_eq_zero] using r_ev)âŸ©,
end
theorem map_polynomial_aeval_of_nonempty [is_alg_closed ğ•œ] [nontrivial A] (a : A) (p : ğ•œ[X])
  (hnon : (Ïƒ a).nonempty) : Ïƒ (aeval a p) = (Î» k, eval k p) '' (Ïƒ a) :=
begin
  refine or.elim (le_or_gt (degree p) 0) (Î» h, _) (map_polynomial_aeval_of_degree_pos a p),
  { rw eq_C_of_degree_le_zero h,
    simp only [set.image_congr, eval_C, aeval_C, scalar_eq, set.nonempty.image_const hnon] },
end
variable (ğ•œ)
