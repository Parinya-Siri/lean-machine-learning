import category_theory.adjunction.basic
import category_theory.limits.creates
open opposite
namespace category_theory.adjunction
open category_theory
open category_theory.functor
open category_theory.limits
universes v u v‚ÇÅ v‚ÇÇ v‚ÇÄ u‚ÇÅ u‚ÇÇ
section arbitrary_universe
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D]
variables {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G)
include adj
section preservation_colimits
variables {J : Type u} [category.{v} J] (K : J ‚•§ C)
def functoriality_right_adjoint : cocone (K ‚ãô F) ‚•§ cocone K :=
(cocones.functoriality _ G) ‚ãô
  (cocones.precompose (K.right_unitor.inv ‚â´ (whisker_left K adj.unit) ‚â´ (associator _ _ _).inv))
local attribute [reducible] functoriality_right_adjoint
@[simps] def functoriality_unit :
  ùü≠ (cocone K) ‚ü∂ cocones.functoriality _ F ‚ãô functoriality_right_adjoint adj K :=
{ app := Œª c, { hom := adj.unit.app c.X } }
@[simps] def functoriality_counit :
  functoriality_right_adjoint adj K ‚ãô cocones.functoriality _ F ‚ü∂ ùü≠ (cocone (K ‚ãô F)) :=
{ app := Œª c, { hom := adj.counit.app c.X } }
def functoriality_is_left_adjoint :
  is_left_adjoint (cocones.functoriality K F) :=
{ right := functoriality_right_adjoint adj K,
  adj := mk_of_unit_counit
  { unit := functoriality_unit adj K,
    counit := functoriality_counit adj K } }
def left_adjoint_preserves_colimits : preserves_colimits_of_size.{v u} F :=
{ preserves_colimits_of_shape := Œª J ùí•,
  { preserves_colimit := Œª F,
    by exactI
    { preserves := Œª c hc, is_colimit.iso_unique_cocone_morphism.inv
        (Œª s, @equiv.unique _ _ (is_colimit.iso_unique_cocone_morphism.hom hc _)
          (((adj.functoriality_is_left_adjoint _).adj).hom_equiv _ _)) } } }.
omit adj
lemma has_colimits_of_shape_of_equivalence (E : C ‚•§ D) [is_equivalence E]
  [has_colimits_of_shape J D] : has_colimits_of_shape J C :=
‚ü®Œª F, by exactI has_colimit_of_comp_equivalence F E‚ü©
lemma has_colimits_of_equivalence (E : C ‚•§ D) [is_equivalence E] [has_colimits_of_size.{v u} D] :
  has_colimits_of_size.{v u} C :=
‚ü®Œª J hJ, by { exactI has_colimits_of_shape_of_equivalence E }‚ü©
end preservation_colimits
section preservation_limits
variables {J : Type u} [category.{v} J] (K : J ‚•§ D)
def functoriality_left_adjoint : cone (K ‚ãô G) ‚•§ cone K :=
(cones.functoriality _ F) ‚ãô (cones.postcompose
    ((associator _ _ _).hom ‚â´ (whisker_left K adj.counit) ‚â´ K.right_unitor.hom))
local attribute [reducible] functoriality_left_adjoint
@[simps] def functoriality_unit' :
  ùü≠ (cone (K ‚ãô G)) ‚ü∂ functoriality_left_adjoint adj K ‚ãô cones.functoriality _ G :=
{ app := Œª c, { hom := adj.unit.app c.X, } }
@[simps] def functoriality_counit' :
  cones.functoriality _ G ‚ãô functoriality_left_adjoint adj K ‚ü∂ ùü≠ (cone K) :=
{ app := Œª c, { hom := adj.counit.app c.X, } }
def functoriality_is_right_adjoint :
  is_right_adjoint (cones.functoriality K G) :=
{ left := functoriality_left_adjoint adj K,
  adj := mk_of_unit_counit
  { unit := functoriality_unit' adj K,
    counit := functoriality_counit' adj K } }
def right_adjoint_preserves_limits : preserves_limits_of_size.{v u} G :=
{ preserves_limits_of_shape := Œª J ùí•,
  { preserves_limit := Œª K,
    by exactI
    { preserves := Œª c hc, is_limit.iso_unique_cone_morphism.inv
        (Œª s, @equiv.unique _ _ (is_limit.iso_unique_cone_morphism.hom hc _)
          (((adj.functoriality_is_right_adjoint _).adj).hom_equiv _ _).symm) } } }.
omit adj
lemma has_limits_of_shape_of_equivalence (E : D ‚•§ C) [is_equivalence E] [has_limits_of_shape J C] :
  has_limits_of_shape J D :=
‚ü®Œª F, by exactI has_limit_of_comp_equivalence F E‚ü©
lemma has_limits_of_equivalence (E : D ‚•§ C) [is_equivalence E] [has_limits_of_size.{v u} C] :
  has_limits_of_size.{v u} D :=
‚ü®Œª J hJ, by exactI has_limits_of_shape_of_equivalence E‚ü©
end preservation_limits
@[simps]
def cocones_iso_component_hom {J : Type u} [category.{v} J] {K : J ‚•§ C}
  (Y : D) (t : ((cocones J D).obj (op (K ‚ãô F))).obj Y) :
  (G ‚ãô (cocones J C).obj (op K)).obj Y :=
{ app := Œª j, (adj.hom_equiv (K.obj j) Y) (t.app j),
  naturality' := Œª j j' f, by { erw [‚Üê adj.hom_equiv_naturality_left, t.naturality], dsimp, simp } }
@[simps]
def cocones_iso_component_inv {J : Type u} [category.{v} J] {K : J ‚•§ C}
  (Y : D) (t : (G ‚ãô (cocones J C).obj (op K)).obj Y) :
  ((cocones J D).obj (op (K ‚ãô F))).obj Y :=
{ app := Œª j, (adj.hom_equiv (K.obj j) Y).symm (t.app j),
  naturality' := Œª j j' f,
  begin
    erw [‚Üê adj.hom_equiv_naturality_left_symm, ‚Üê adj.hom_equiv_naturality_right_symm, t.naturality],
    dsimp, simp
  end }
@[simps]
def cones_iso_component_hom {J : Type u} [category.{v} J] {K : J ‚•§ D}
  (X : C·µí·µñ) (t : (functor.op F ‚ãô (cones J D).obj K).obj X) :
  ((cones J C).obj (K ‚ãô G)).obj X :=
{ app := Œª j, (adj.hom_equiv (unop X) (K.obj j)) (t.app j),
  naturality' := Œª j j' f,
  begin
    erw [‚Üê adj.hom_equiv_naturality_right, ‚Üê t.naturality, category.id_comp, category.id_comp],
    refl
  end }
@[simps]
def cones_iso_component_inv {J : Type u} [category.{v} J] {K : J ‚•§ D}
  (X : C·µí·µñ) (t : ((cones J C).obj (K ‚ãô G)).obj X) :
  (functor.op F ‚ãô (cones J D).obj K).obj X :=
{ app := Œª j, (adj.hom_equiv (unop X) (K.obj j)).symm (t.app j),
  naturality' := Œª j j' f,
  begin
    erw [‚Üê adj.hom_equiv_naturality_right_symm, ‚Üê t.naturality, category.id_comp, category.id_comp]
  end }
end arbitrary_universe
variables {C : Type u‚ÇÅ} [category.{v‚ÇÄ} C] {D : Type u‚ÇÇ} [category.{v‚ÇÄ} D]
{F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G)
def cones_iso {J : Type u} [category.{v} J] {K : J ‚•§ D} :
  F.op ‚ãô (cones J D).obj K ‚âÖ (cones J C).obj (K ‚ãô G) :=
nat_iso.of_components (Œª X,
{ hom := cones_iso_component_hom adj X,
  inv := cones_iso_component_inv adj X, } )
(by tidy)
end category_theory.adjunction
