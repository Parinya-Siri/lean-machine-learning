import analysis.locally_convex.balanced_core_hull
universes u v w x
noncomputable theory
open set finite_dimensional topological_space filter
open_locale big_operators
section semiring
variables {Î¹ ğ•œ F : Type*} [fintype Î¹] [semiring ğ•œ] [topological_space ğ•œ]
  [add_comm_monoid F] [module ğ•œ F] [topological_space F]
  [has_continuous_add F] [has_continuous_smul ğ•œ F]
lemma linear_map.continuous_on_pi (f : (Î¹ â†’ ğ•œ) â†’â‚—[ğ•œ] F) : continuous f :=
begin
  classical,
instance [finite_dimensional ğ•œ E] [finite_dimensional ğ•œ F] :
  finite_dimensional ğ•œ (E â†’L[ğ•œ] F) :=
finite_dimensional.of_injective
  (continuous_linear_map.coe_lm ğ•œ : (E â†’L[ğ•œ] F) â†’â‚—[ğ•œ] (E â†’â‚—[ğ•œ] F))
  continuous_linear_map.coe_injective
end field
section normed_field
variables {ğ•œ : Type u} [hnorm : nondiscrete_normed_field ğ•œ]
  {E : Type v} [add_comm_group E] [module ğ•œ E] [topological_space E]
  [topological_add_group E] [has_continuous_smul ğ•œ E]
  {F : Type w} [add_comm_group F] [module ğ•œ F] [topological_space F]
  [topological_add_group F] [has_continuous_smul ğ•œ F]
  {F' : Type x} [add_comm_group F'] [module ğ•œ F'] [topological_space F']
  [topological_add_group F'] [has_continuous_smul ğ•œ F']
include hnorm
lemma unique_topology_of_t2 {t : topological_space ğ•œ}
  (hâ‚ : @topological_add_group ğ•œ t _)
  (hâ‚‚ : @has_continuous_smul ğ•œ ğ•œ _ hnorm.to_uniform_space.to_topological_space t)
  (hâ‚ƒ : @t2_space ğ•œ t) :
  t = hnorm.to_uniform_space.to_topological_space :=
begin
lemma linear_map.continuous_of_is_closed_ker (l : E â†’â‚—[ğ•œ] ğ•œ) (hl : is_closed (l.ker : set E)) :
  continuous l :=
begin
lemma linear_map.continuous_iff_is_closed_ker (l : E â†’â‚—[ğ•œ] ğ•œ) :
  continuous l â†” is_closed (l.ker : set E) :=
âŸ¨Î» h, is_closed_singleton.preimage h, l.continuous_of_is_closed_kerâŸ©
variables [complete_space ğ•œ]
private lemma continuous_equiv_fun_basis_aux [ht2 : t2_space E] {Î¹ : Type v} [fintype Î¹]
  (Î¾ : basis Î¹ ğ•œ E) : continuous Î¾.equiv_fun :=
begin
  letI : uniform_space E := topological_add_group.to_uniform_space E,
  letI : uniform_add_group E := topological_add_group_is_uniform,
  letI : separated_space E := separated_iff_t2.mpr ht2,
  unfreezingI { induction hn : fintype.card Î¹ with n IH generalizing Î¹ E },
  { rw fintype.card_eq_zero_iff at hn,
    exact continuous_of_const (Î» x y, funext hn.elim) },
  { haveI : finite_dimensional ğ•œ E := of_fintype_basis Î¾,
theorem linear_map.continuous_of_finite_dimensional [t2_space E] [finite_dimensional ğ•œ E]
  (f : E â†’â‚—[ğ•œ] F') :
  continuous f :=
begin
theorem continuous_equiv_fun_basis [t2_space E] {Î¹ : Type*} [fintype Î¹] (Î¾ : basis Î¹ ğ•œ E) :
  continuous Î¾.equiv_fun :=
begin
  haveI : finite_dimensional ğ•œ E := of_fintype_basis Î¾,
  exact Î¾.equiv_fun.to_linear_map.continuous_of_finite_dimensional
end
namespace linear_map
variables [t2_space E] [finite_dimensional ğ•œ E]
def to_continuous_linear_map : (E â†’â‚—[ğ•œ] F') â‰ƒâ‚—[ğ•œ] E â†’L[ğ•œ] F' :=
{ to_fun := Î» f, âŸ¨f, f.continuous_of_finite_dimensionalâŸ©,
  inv_fun := coe,
  map_add' := Î» f g, rfl,
  map_smul' := Î» c f, rfl,
  left_inv := Î» f, rfl,
  right_inv := Î» f, continuous_linear_map.coe_injective rfl }
@[simp] lemma coe_to_continuous_linear_map' (f : E â†’â‚—[ğ•œ] F') :
  â‡‘f.to_continuous_linear_map = f := rfl
@[simp] lemma coe_to_continuous_linear_map (f : E â†’â‚—[ğ•œ] F') :
  (f.to_continuous_linear_map : E â†’â‚—[ğ•œ] F') = f := rfl
@[simp] lemma coe_to_continuous_linear_map_symm :
  â‡‘(to_continuous_linear_map : (E â†’â‚—[ğ•œ] F') â‰ƒâ‚—[ğ•œ] E â†’L[ğ•œ] F').symm = coe := rfl
end linear_map
namespace linear_equiv
variables [t2_space E] [t2_space F] [finite_dimensional ğ•œ E]
def to_continuous_linear_equiv (e : E â‰ƒâ‚—[ğ•œ] F) : E â‰ƒL[ğ•œ] F :=
{ continuous_to_fun := e.to_linear_map.continuous_of_finite_dimensional,
  continuous_inv_fun := begin
    haveI : finite_dimensional ğ•œ F := e.finite_dimensional,
    exact e.symm.to_linear_map.continuous_of_finite_dimensional
  end,
  ..e }
@[simp] lemma coe_to_continuous_linear_equiv (e : E â‰ƒâ‚—[ğ•œ] F) :
  (e.to_continuous_linear_equiv : E â†’â‚—[ğ•œ] F) = e := rfl
@[simp] lemma coe_to_continuous_linear_equiv' (e : E â‰ƒâ‚—[ğ•œ] F) :
  (e.to_continuous_linear_equiv : E â†’ F) = e := rfl
@[simp] lemma coe_to_continuous_linear_equiv_symm (e : E â‰ƒâ‚—[ğ•œ] F) :
  (e.to_continuous_linear_equiv.symm : F â†’â‚—[ğ•œ] E) = e.symm := rfl
@[simp] lemma coe_to_continuous_linear_equiv_symm' (e : E â‰ƒâ‚—[ğ•œ] F) :
  (e.to_continuous_linear_equiv.symm : F â†’ E) = e.symm := rfl
@[simp] lemma to_linear_equiv_to_continuous_linear_equiv (e : E â‰ƒâ‚—[ğ•œ] F) :
  e.to_continuous_linear_equiv.to_linear_equiv = e :=
by { ext x, refl }
@[simp] lemma to_linear_equiv_to_continuous_linear_equiv_symm (e : E â‰ƒâ‚—[ğ•œ] F) :
  e.to_continuous_linear_equiv.symm.to_linear_equiv = e.symm :=
by { ext x, refl }
end linear_equiv
namespace continuous_linear_map
variables [t2_space E] [finite_dimensional ğ•œ E]
def to_continuous_linear_equiv_of_det_ne_zero
  (f : E â†’L[ğ•œ] E) (hf : f.det â‰  0) : E â‰ƒL[ğ•œ] E :=
((f : E â†’â‚—[ğ•œ] E).equiv_of_det_ne_zero hf).to_continuous_linear_equiv
@[simp] lemma coe_to_continuous_linear_equiv_of_det_ne_zero (f : E â†’L[ğ•œ] E) (hf : f.det â‰  0) :
  (f.to_continuous_linear_equiv_of_det_ne_zero hf : E â†’L[ğ•œ] E) = f :=
by { ext x, refl }
@[simp] lemma to_continuous_linear_equiv_of_det_ne_zero_apply
  (f : E â†’L[ğ•œ] E) (hf : f.det â‰  0) (x : E) :
  f.to_continuous_linear_equiv_of_det_ne_zero hf x = f x :=
rfl
end continuous_linear_map
end normed_field
