import category_theory.category.Cat
import category_theory.elements
universe u
namespace category_theory
variables {C D : Type*} [category C] [category D]
variables (F : C ‚•§ Cat)
@[nolint has_inhabited_instance]
structure grothendieck :=
(base : C)
(fiber : F.obj base)
namespace grothendieck
variables {F}
structure hom (X Y : grothendieck F) :=
(base : X.base ‚ü∂ Y.base)
(fiber : (F.map base).obj X.fiber ‚ü∂ Y.fiber)
@[ext] lemma ext {X Y : grothendieck F} (f g : hom X Y)
  (w_base : f.base = g.base) (w_fiber : eq_to_hom (by rw w_base) ‚â´ f.fiber = g.fiber) : f = g :=
begin
  cases f; cases g,
  congr,
  dsimp at w_base,
  induction w_base,
  refl,
  dsimp at w_base,
  induction w_base,
  simpa using w_fiber,
end
@[simps]
def id (X : grothendieck F) : hom X X :=
{ base := ùüô X.base,
  fiber := eq_to_hom (by erw [category_theory.functor.map_id, functor.id_obj X.fiber]), }
instance (X : grothendieck F) : inhabited (hom X X) := ‚ü®id X‚ü©
@[simps]
def comp {X Y Z : grothendieck F} (f : hom X Y) (g : hom Y Z) : hom X Z :=
{ base := f.base ‚â´ g.base,
  fiber :=
  eq_to_hom (by erw [functor.map_comp, functor.comp_obj]) ‚â´
    (F.map g.base).map f.fiber ‚â´ g.fiber, }
local attribute [simp] eq_to_hom_map
instance : category (grothendieck F) :=
{ hom := Œª X Y, grothendieck.hom X Y,
  id := Œª X, grothendieck.id X,
  comp := Œª X Y Z f g, grothendieck.comp f g,
  comp_id' := Œª X Y f,
  begin
    ext,
    { dsimp,
@[simps]
def forget : grothendieck F ‚•§ C :=
{ obj := Œª X, X.1,
  map := Œª X Y f, f.1, }
end
universe w
variables (G : C ‚•§ Type w)
@[simps]
def grothendieck_Type_to_Cat_functor : grothendieck (G ‚ãô Type_to_Cat) ‚•§ G.elements :=
{ obj := Œª X, ‚ü®X.1, X.2.as‚ü©,
  map := Œª X Y f, ‚ü®f.1, f.2.1.1‚ü© }
@[simps]
def grothendieck_Type_to_Cat_inverse : G.elements ‚•§ grothendieck (G ‚ãô Type_to_Cat) :=
{ obj := Œª X, ‚ü®X.1, ‚ü®X.2‚ü©‚ü©,
  map := Œª X Y f, ‚ü®f.1, ‚ü®‚ü®f.2‚ü©‚ü©‚ü© }
@[simps]
def grothendieck_Type_to_Cat : grothendieck (G ‚ãô Type_to_Cat) ‚âå G.elements :=
{ functor := grothendieck_Type_to_Cat_functor G,
  inverse := grothendieck_Type_to_Cat_inverse G,
  unit_iso := nat_iso.of_components (Œª X, by { rcases X with ‚ü®_, ‚ü®‚ü©‚ü©, exact iso.refl _, })
    (by { rintro ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®_, ‚ü®‚ü©‚ü© ‚ü®base, ‚ü®‚ü®f‚ü©‚ü©‚ü©, dsimp at *, subst f, ext, simp, }),
  counit_iso := nat_iso.of_components (Œª X, by { cases X, exact iso.refl _, })
    (by { rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®f, e‚ü©, dsimp at *, subst e, ext, simp }),
  functor_unit_iso_comp' := by { rintro ‚ü®_, ‚ü®‚ü©‚ü©, dsimp, simp, refl, } }
end grothendieck
end category_theory
