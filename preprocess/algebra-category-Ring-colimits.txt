import algebra.category.Ring.basic
import category_theory.limits.has_limits
import category_theory.limits.concrete_category
universes u v
open category_theory
open category_theory.limits
namespace CommRing.colimits
variables {J : Type v} [small_category J] (F : J ‚•§ CommRing.{v})
inductive prequotient
inductive relation : prequotient F ‚Üí prequotient F ‚Üí Prop
def colimit_setoid : setoid (prequotient F) :=
{ r := relation F, iseqv := ‚ü®relation.refl, relation.symm, relation.trans‚ü© }
attribute [instance] colimit_setoid
@[derive inhabited]
def colimit_type : Type v := quotient (colimit_setoid F)
instance : add_group (colimit_type F) :=
{ zero :=
  begin
    exact quot.mk _ zero
  end,
  neg :=
  begin
    fapply @quot.lift,
    { intro x,
      exact quot.mk _ (neg x) },
    { intros x x' r,
      apply quot.sound,
      exact relation.neg_1 _ _ r },
  end,
  add :=
  begin
    fapply @quot.lift _ _ ((colimit_type F) ‚Üí (colimit_type F)),
    { intro x,
      fapply @quot.lift,
      { intro y,
        exact quot.mk _ (add x y) },
      { intros y y' r,
        apply quot.sound,
        exact relation.add_2 _ _ _ r } },
    { intros x x' r,
      funext y,
      induction y,
      dsimp,
      apply quot.sound,
      { exact relation.add_1 _ _ _ r },
      { refl } },
  end,
  zero_add := Œª x,
  begin
    induction x,
    dsimp,
    apply quot.sound,
    apply relation.zero_add,
    refl,
  end,
  add_zero := Œª x,
  begin
    induction x,
    dsimp,
    apply quot.sound,
    apply relation.add_zero,
    refl,
  end,
  add_left_neg := Œª x,
  begin
    induction x,
    dsimp,
    apply quot.sound,
    apply relation.add_left_neg,
    refl,
  end,
  add_assoc := Œª x y z,
  begin
    induction x,
    induction y,
    induction z,
    dsimp,
    apply quot.sound,
    apply relation.add_assoc,
    refl,
    refl,
    refl,
  end }
instance : add_group_with_one (colimit_type F) :=
{ one :=
  begin
    exact quot.mk _ one
  end,
  .. colimit_type.add_group F }
instance : comm_ring (colimit_type F) :=
{ one :=
  begin
    exact quot.mk _ one
  end,
  mul :=
  begin
    fapply @quot.lift _ _ ((colimit_type F) ‚Üí (colimit_type F)),
    { intro x,
      fapply @quot.lift,
      { intro y,
        exact quot.mk _ (mul x y) },
      { intros y y' r,
        apply quot.sound,
        exact relation.mul_2 _ _ _ r } },
    { intros x x' r,
      funext y,
      induction y,
      dsimp,
      apply quot.sound,
      { exact relation.mul_1 _ _ _ r },
      { refl } },
  end,
  one_mul := Œª x,
  begin
    induction x,
    dsimp,
    apply quot.sound,
    apply relation.one_mul,
    refl,
  end,
  mul_one := Œª x,
  begin
    induction x,
    dsimp,
    apply quot.sound,
    apply relation.mul_one,
    refl,
  end,
  add_comm := Œª x y,
  begin
    induction x,
    induction y,
    dsimp,
    apply quot.sound,
    apply relation.add_comm,
    refl,
    refl,
  end,
  mul_comm := Œª x y,
  begin
    induction x,
    induction y,
    dsimp,
    apply quot.sound,
    apply relation.mul_comm,
    refl,
    refl,
  end,
  add_assoc := Œª x y z,
  begin
    induction x,
    induction y,
    induction z,
    dsimp,
    apply quot.sound,
    apply relation.add_assoc,
    refl,
    refl,
    refl,
  end,
  mul_assoc := Œª x y z,
  begin
    induction x,
    induction y,
    induction z,
    dsimp,
    apply quot.sound,
    apply relation.mul_assoc,
    refl,
    refl,
    refl,
  end,
  left_distrib := Œª x y z,
  begin
    induction x,
    induction y,
    induction z,
    dsimp,
    apply quot.sound,
    apply relation.left_distrib,
    refl,
    refl,
    refl,
  end,
  right_distrib := Œª x y z,
  begin
    induction x,
    induction y,
    induction z,
    dsimp,
    apply quot.sound,
    apply relation.right_distrib,
    refl,
    refl,
    refl,
  end,
  .. colimit_type.add_group_with_one F }
@[simp] lemma quot_zero : quot.mk setoid.r zero = (0 : colimit_type F) := rfl
@[simp] lemma quot_one : quot.mk setoid.r one = (1 : colimit_type F) := rfl
@[simp] lemma quot_neg (x) :
  quot.mk setoid.r (neg x) = (-(quot.mk setoid.r x) : colimit_type F) := rfl
@[simp] lemma quot_add (x y) :
  quot.mk setoid.r (add x y) = ((quot.mk setoid.r x) + (quot.mk setoid.r y) : colimit_type F) := rfl
@[simp] lemma quot_mul (x y) :
  quot.mk setoid.r (mul x y) = ((quot.mk setoid.r x) * (quot.mk setoid.r y) : colimit_type F) := rfl
def colimit : CommRing := CommRing.of (colimit_type F)
def cocone_fun (j : J) (x : F.obj j) : colimit_type F :=
quot.mk _ (of j x)
def cocone_morphism (j : J) : F.obj j ‚ü∂ colimit F :=
{ to_fun := cocone_fun F j,
  map_one' := by apply quot.sound; apply relation.one,
  map_mul' := by intros; apply quot.sound; apply relation.mul,
  map_zero' := by apply quot.sound; apply relation.zero,
  map_add' := by intros; apply quot.sound; apply relation.add }
@[simp] lemma cocone_naturality {j j' : J} (f : j ‚ü∂ j') :
  F.map f ‚â´ (cocone_morphism F j') = cocone_morphism F j :=
begin
  ext,
  apply quot.sound,
  apply relation.map,
end
@[simp] lemma cocone_naturality_components (j j' : J) (f : j ‚ü∂ j') (x : F.obj j):
  (cocone_morphism F j') (F.map f x) = (cocone_morphism F j) x :=
by { rw ‚Üêcocone_naturality F f, refl }
def colimit_cocone : cocone F :=
{ X := colimit F,
  Œπ :=
  { app := cocone_morphism F } }.
@[simp] def desc_fun_lift (s : cocone F) : prequotient F ‚Üí s.X
| (of j x)  := (s.Œπ.app j) x
| zero      := 0
| one       := 1
| (neg x)   := -(desc_fun_lift x)
| (add x y) := desc_fun_lift x + desc_fun_lift y
| (mul x y) := desc_fun_lift x * desc_fun_lift y
def desc_fun (s : cocone F) : colimit_type F ‚Üí s.X :=
begin
  fapply quot.lift,
  { exact desc_fun_lift F s },
  { intros x y r,
    induction r; try { dsimp },
def desc_morphism (s : cocone F) : colimit F ‚ü∂ s.X :=
{ to_fun := desc_fun F s,
  map_one' := rfl,
  map_zero' := rfl,
  map_add' := Œª x y, by { induction x; induction y; refl },
  map_mul' := Œª x y, by { induction x; induction y; refl }, }
def colimit_is_colimit : is_colimit (colimit_cocone F) :=
{ desc := Œª s, desc_morphism F s,
  uniq' := Œª s m w,
  begin
    ext,
    induction x,
    induction x,
    { have w' := congr_fun (congr_arg (Œª f : F.obj x_j ‚ü∂ s.X, (f : F.obj x_j ‚Üí s.X)) (w x_j)) x_x,
      erw w',
      refl, },
    { simp, },
    { simp, },
    { simp *, },
    { simp *, },
    { simp *, },
    refl
  end }.
instance has_colimits_CommRing : has_colimits CommRing :=
{ has_colimits_of_shape := Œª J ùí•, by exactI
  { has_colimit := Œª F, has_colimit.mk
    { cocone := colimit_cocone F,
      is_colimit := colimit_is_colimit F } } }
end CommRing.colimits
