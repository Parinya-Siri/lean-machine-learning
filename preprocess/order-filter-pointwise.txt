import data.set.pointwise
import order.filter.n_ary
import order.filter.ultrafilter
open function set
open_locale filter pointwise
variables {F Œ± Œ≤ Œ≥ Œ¥ Œµ : Type*}
namespace filter
section has_one
variables [has_one Œ±] {f : filter Œ±} {s : set Œ±}
@[to_additive "`0 : filter Œ±` is defined as the filter of sets containing `0 : Œ±` in locale
`pointwise`."]
protected def has_one : has_one (filter Œ±) := ‚ü®pure 1‚ü©
localized "attribute [instance] filter.has_one filter.has_zero" in pointwise
@[simp, to_additive] lemma mem_one : s ‚àà (1 : filter Œ±) ‚Üî (1 : Œ±) ‚àà s := mem_pure
@[to_additive] lemma one_mem_one : (1 : set Œ±) ‚àà (1 : filter Œ±) := mem_pure.2 one_mem_one
@[simp, to_additive] lemma pure_one : pure 1 = (1 : filter Œ±) := rfl
@[simp, to_additive] lemma principal_one : ùìü 1 = (1 : filter Œ±) := principal_singleton _
@[to_additive] lemma one_ne_bot : (1 : filter Œ±).ne_bot := filter.pure_ne_bot
@[simp, to_additive] protected lemma map_one' (f : Œ± ‚Üí Œ≤) : (1 : filter Œ±).map f = pure (f 1) := rfl
@[simp, to_additive] lemma le_one_iff : f ‚â§ 1 ‚Üî (1 : set Œ±) ‚àà f := le_pure_iff
@[to_additive] protected lemma ne_bot.le_one_iff (h : f.ne_bot) : f ‚â§ 1 ‚Üî f = 1 := h.le_pure_iff
@[simp, to_additive] lemma eventually_one {p : Œ± ‚Üí Prop} : (‚àÄ·∂† x in 1, p x) ‚Üî p 1 := eventually_pure
@[simp, to_additive] lemma tendsto_one {a : filter Œ≤} {f : Œ≤ ‚Üí Œ±} :
   tendsto f a 1 ‚Üî ‚àÄ·∂† x in a, f x = 1 :=
tendsto_pure
@[to_additive "`pure` as a `zero_hom`."]
def pure_one_hom : one_hom Œ± (filter Œ±) := ‚ü®pure, pure_one‚ü©
@[simp, to_additive] lemma coe_pure_one_hom : (pure_one_hom : Œ± ‚Üí filter Œ±) = pure := rfl
@[simp, to_additive] lemma pure_one_hom_apply (a : Œ±) : pure_one_hom a = pure a := rfl
variables [has_one Œ≤]
@[simp, to_additive]
protected lemma map_one [one_hom_class F Œ± Œ≤] (œÜ : F) : map œÜ 1 = 1 :=
by rw [filter.map_one', map_one, pure_one]
end has_one
section has_inv
variables [has_inv Œ±] {f g : filter Œ±} {s : set Œ±} {a : Œ±}
@[to_additive "The negation of a filter is the pointwise preimage under `-` of its sets."]
instance : has_inv (filter Œ±) := ‚ü®map has_inv.inv‚ü©
@[simp, to_additive] protected lemma map_inv : f.map has_inv.inv = f‚Åª¬π := rfl
@[to_additive] lemma mem_inv : s ‚àà f‚Åª¬π ‚Üî has_inv.inv ‚Åª¬π' s ‚àà f := iff.rfl
@[to_additive] protected lemma inv_le_inv (hf : f ‚â§ g) : f‚Åª¬π ‚â§ g‚Åª¬π := map_mono hf
@[simp, to_additive] lemma inv_pure : (pure a : filter Œ±)‚Åª¬π = pure a‚Åª¬π := rfl
@[simp, to_additive] lemma inv_eq_bot_iff : f‚Åª¬π = ‚ä• ‚Üî f = ‚ä•  := map_eq_bot_iff
@[simp, to_additive] lemma ne_bot_inv_iff : f‚Åª¬π.ne_bot ‚Üî ne_bot f := map_ne_bot_iff _
@[to_additive] lemma ne_bot.inv : f.ne_bot ‚Üí f‚Åª¬π.ne_bot := Œª h, h.map _
end has_inv
section has_involutive_inv
variables [has_involutive_inv Œ±] {f : filter Œ±} {s : set Œ±}
@[to_additive] lemma inv_mem_inv (hs : s ‚àà f) : s‚Åª¬π ‚àà f‚Åª¬π := by rwa [mem_inv, inv_preimage, inv_inv]
@[to_additive "Negation is involutive on `filter Œ±` if it is on `Œ±`."]
protected def has_involutive_inv : has_involutive_inv (filter Œ±) :=
{ inv_inv := Œª f, map_map.trans $ by rw [inv_involutive.comp_self, map_id],
  ..filter.has_inv }
end has_involutive_inv
section has_mul
variables [has_mul Œ±] [has_mul Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±} {a b : Œ±}
@[to_additive "The filter `f + g` is generated by `{s + t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def has_mul : has_mul (filter Œ±) :=
‚ü®Œª f g, { sets := {s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s}, ..map‚ÇÇ (*) f g }‚ü©
localized "attribute [instance] filter.has_mul filter.has_add" in pointwise
@[simp, to_additive] lemma map‚ÇÇ_mul : map‚ÇÇ (*) f g = f * g := rfl
@[to_additive] lemma mem_mul : s ‚àà f * g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma mul_mem_mul : s ‚àà f ‚Üí t ‚àà g ‚Üí s * t ‚àà f * g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_mul : ‚ä• * g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma mul_bot : f * ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma mul_eq_bot_iff : f * g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma mul_ne_bot_iff : (f * g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.mul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f * g) := ne_bot.map‚ÇÇ
@[to_additive] lemma ne_bot.of_mul_left : (f * g).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
@[to_additive] lemma ne_bot.of_mul_right : (f * g).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp, to_additive] lemma pure_mul : pure a * g = g.map ((*) a)  := map‚ÇÇ_pure_left
@[simp, to_additive] lemma mul_pure : f * pure b = f.map (* b)  := map‚ÇÇ_pure_right
@[simp, to_additive] lemma pure_mul_pure : (pure a : filter Œ±) * pure b = pure (a * b) := map‚ÇÇ_pure
@[simp, to_additive] lemma le_mul_iff : h ‚â§ f * g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s * t ‚àà h :=
le_map‚ÇÇ_iff
@[to_additive] instance covariant_mul : covariant_class (filter Œ±) (filter Œ±) (*) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©
@[to_additive] instance covariant_swap_mul : covariant_class (filter Œ±) (filter Œ±) (swap (*)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©
@[to_additive]
protected lemma map_mul [mul_hom_class F Œ± Œ≤] (m : F) : (f‚ÇÅ * f‚ÇÇ).map m = f‚ÇÅ.map m * f‚ÇÇ.map m :=
map_map‚ÇÇ_distrib $ map_mul m
@[to_additive "The singleton operation as an `add_hom`."]
def pure_mul_hom : Œ± ‚Üí‚Çô* filter Œ± := ‚ü®pure, Œª a b, pure_mul_pure.symm‚ü©
@[simp, to_additive] lemma coe_pure_mul_hom : (pure_mul_hom : Œ± ‚Üí filter Œ±) = pure := rfl
@[simp, to_additive] lemma pure_mul_hom_apply (a : Œ±) : pure_mul_hom a = pure a := rfl
end has_mul
section div
variables [has_div Œ±] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±} {a b : Œ±}
@[to_additive "The filter `f - g` is generated by `{s - t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def has_div : has_div (filter Œ±) :=
‚ü®Œª f g, { sets := {s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ / t‚ÇÇ ‚äÜ s}, ..map‚ÇÇ (/) f g }‚ü©
localized "attribute [instance] filter.has_div filter.has_sub" in pointwise
@[simp, to_additive] lemma map‚ÇÇ_div : map‚ÇÇ (/) f g = f / g := rfl
@[to_additive] lemma mem_div : s ‚àà f / g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ / t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma div_mem_div : s ‚àà f ‚Üí t ‚àà g ‚Üí s / t ‚àà f / g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_div : ‚ä• / g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma div_bot : f / ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma div_eq_bot_iff : f / g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma div_ne_bot_iff : (f / g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.div : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f / g) := ne_bot.map‚ÇÇ
@[to_additive] lemma ne_bot.of_div_left : (f / g).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
@[to_additive] lemma ne_bot.of_div_right : (f / g).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp, to_additive] lemma pure_div : pure a / g = g.map ((/) a)  := map‚ÇÇ_pure_left
@[simp, to_additive] lemma div_pure : f / pure b = f.map (/ b)  := map‚ÇÇ_pure_right
@[simp, to_additive] lemma pure_div_pure : (pure a : filter Œ±) / pure b = pure (a / b) := map‚ÇÇ_pure
@[to_additive] protected lemma div_le_div : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ / g‚ÇÅ ‚â§ f‚ÇÇ / g‚ÇÇ := map‚ÇÇ_mono
@[to_additive] protected lemma div_le_div_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f / g‚ÇÅ ‚â§ f / g‚ÇÇ := map‚ÇÇ_mono_left
@[to_additive] protected lemma div_le_div_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ / g ‚â§ f‚ÇÇ / g := map‚ÇÇ_mono_right
@[simp, to_additive] protected lemma le_div_iff :
  h ‚â§ f / g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s / t ‚àà h :=
le_map‚ÇÇ_iff
@[to_additive] instance covariant_div : covariant_class (filter Œ±) (filter Œ±) (/) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©
@[to_additive] instance covariant_swap_div : covariant_class (filter Œ±) (filter Œ±) (swap (/)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©
end div
open_locale pointwise
protected def has_nsmul [has_zero Œ±] [has_add Œ±] : has_smul ‚Ñï (filter Œ±) := ‚ü®nsmul_rec‚ü©
@[to_additive]
protected def has_npow [has_one Œ±] [has_mul Œ±] : has_pow (filter Œ±) ‚Ñï := ‚ü®Œª s n, npow_rec n s‚ü©
protected def has_zsmul [has_zero Œ±] [has_add Œ±] [has_neg Œ±] : has_smul ‚Ñ§ (filter Œ±) :=
‚ü®zsmul_rec‚ü©
@[to_additive] protected def has_zpow [has_one Œ±] [has_mul Œ±] [has_inv Œ±] : has_pow (filter Œ±) ‚Ñ§ :=
‚ü®Œª s n, zpow_rec n s‚ü©
localized "attribute [instance] filter.has_nsmul filter.has_npow filter.has_zsmul filter.has_zpow"
  in pointwise
@[to_additive "`filter Œ±` is an `add_semigroup` under pointwise operations if `Œ±` is."]
protected def semigroup [semigroup Œ±] : semigroup (filter Œ±) :=
{ mul := (*),
  mul_assoc := Œª f g h, map‚ÇÇ_assoc mul_assoc }
@[to_additive "`filter Œ±` is an `add_comm_semigroup` under pointwise operations if `Œ±` is."]
protected def comm_semigroup [comm_semigroup Œ±] : comm_semigroup (filter Œ±) :=
{ mul_comm := Œª f g, map‚ÇÇ_comm mul_comm,
  ..filter.semigroup }
section mul_one_class
variables [mul_one_class Œ±] [mul_one_class Œ≤]
@[to_additive "`filter Œ±` is an `add_zero_class` under pointwise operations if `Œ±` is."]
protected def mul_one_class : mul_one_class (filter Œ±) :=
{ one := 1,
  mul := (*),
  one_mul := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_left, one_mul, map_id'],
  mul_one := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_right, mul_one, map_id'] }
localized "attribute [instance] filter.semigroup filter.add_semigroup filter.comm_semigroup
  filter.add_comm_semigroup filter.mul_one_class filter.add_zero_class" in pointwise
@[to_additive "If `œÜ : Œ± ‚Üí+ Œ≤` then `map_add_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí+ filter Œ≤` induced by `map œÜ`."]
def map_monoid_hom [monoid_hom_class F Œ± Œ≤] (œÜ : F) : filter Œ± ‚Üí* filter Œ≤ :=
{ to_fun := map œÜ,
  map_one' := filter.map_one œÜ,
  map_mul' := Œª _ _, filter.map_mul œÜ }
@[to_additive "`pure` as an `add_monoid_hom`."]
def pure_monoid_hom : Œ± ‚Üí* filter Œ± := { ..pure_mul_hom, ..pure_one_hom }
@[simp, to_additive] lemma coe_pure_monoid_hom : (pure_monoid_hom : Œ± ‚Üí filter Œ±) = pure := rfl
@[simp, to_additive] lemma pure_monoid_hom_apply (a : Œ±) : pure_monoid_hom a = pure a := rfl
end mul_one_class
section monoid
variables [monoid Œ±] {f g : filter Œ±} {s : set Œ±} {a : Œ±} {m n : ‚Ñï}
@[to_additive "`filter Œ±` is an `add_monoid` under pointwise operations if `Œ±` is."]
protected def monoid : monoid (filter Œ±) :=
{ ..filter.mul_one_class, ..filter.semigroup, ..filter.has_npow }
localized "attribute [instance] filter.monoid filter.add_monoid" in pointwise
@[to_additive] lemma pow_mem_pow (hs : s ‚àà f) : ‚àÄ n : ‚Ñï, s ^ n ‚àà f ^ n
| 0 := by { rw pow_zero, exact one_mem_one }
| (n + 1) := by { rw pow_succ, exact mul_mem_mul hs (pow_mem_pow _) }
@[simp, to_additive nsmul_bot] lemma bot_pow {n : ‚Ñï} (hn : n ‚â† 0) : (‚ä•  : filter Œ±) ^ n = ‚ä• :=
by rw [‚Üêtsub_add_cancel_of_le (nat.succ_le_of_lt $ nat.pos_of_ne_zero hn), pow_succ, bot_mul]
@[to_additive] lemma mul_top_of_one_le (hf : 1 ‚â§ f) : f * ‚ä§ = ‚ä§ :=
begin
  refine top_le_iff.1 (Œª s, _),
  simp only [mem_mul, mem_top, exists_and_distrib_left, exists_eq_left],
  rintro ‚ü®t, ht, hs‚ü©,
  rwa [mul_univ_of_one_mem (mem_one.1 $ hf ht), univ_subset_iff] at hs,
end
@[to_additive] lemma top_mul_of_one_le (hf : 1 ‚â§ f) : ‚ä§ * f = ‚ä§ :=
begin
  refine top_le_iff.1 (Œª s, _),
  simp only [mem_mul, mem_top, exists_and_distrib_left, exists_eq_left],
  rintro ‚ü®t, ht, hs‚ü©,
  rwa [univ_mul_of_one_mem (mem_one.1 $ hf ht), univ_subset_iff] at hs,
end
@[simp, to_additive] lemma top_mul_top : (‚ä§ : filter Œ±) * ‚ä§ = ‚ä§ := mul_top_of_one_le le_top
@[to_additive "`filter Œ±` is an `add_comm_monoid` under pointwise operations if `Œ±` is."]
protected def comm_monoid [comm_monoid Œ±] : comm_monoid (filter Œ±) :=
{ ..filter.mul_one_class, ..filter.comm_semigroup }
open_locale pointwise
section division_monoid
variables [division_monoid Œ±] {f g : filter Œ±}
@[to_additive]
protected lemma mul_eq_one_iff : f * g = 1 ‚Üî ‚àÉ a b, f = pure a ‚àß g = pure b ‚àß a * b = 1 :=
begin
  refine ‚ü®Œª hfg, _, _‚ü©,
  { obtain ‚ü®t‚ÇÅ, t‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ü© : (1 : set Œ±) ‚àà f * g := hfg.symm.subst one_mem_one,
    have hfg : (f * g).ne_bot := hfg.symm.subst one_ne_bot,
    rw [(hfg.nonempty_of_mem $ mul_mem_mul h‚ÇÅ h‚ÇÇ).subset_one_iff, set.mul_eq_one_iff] at h,
    obtain ‚ü®a, b, rfl, rfl, h‚ü© := h,
    refine ‚ü®a, b, _, _, h‚ü©,
    { rwa [‚Üêhfg.of_mul_left.le_pure_iff, le_pure_iff] },
    { rwa [‚Üêhfg.of_mul_right.le_pure_iff, le_pure_iff] } },
  { rintro ‚ü®a, b, rfl, rfl, h‚ü©,
    rw [pure_mul_pure, h, pure_one] }
end
@[to_additive subtraction_monoid "`filter Œ±` is a subtraction monoid under pointwise
operations if `Œ±` is."]
protected def division_monoid : division_monoid (filter Œ±) :=
{ mul_inv_rev := Œª s t, map_map‚ÇÇ_antidistrib mul_inv_rev,
  inv_eq_of_mul := Œª s t h, begin
    obtain ‚ü®a, b, rfl, rfl, hab‚ü© := filter.mul_eq_one_iff.1 h,
    rw [inv_pure, inv_eq_of_mul_eq_one_right hab],
  end,
  div_eq_mul_inv := Œª f g, map_map‚ÇÇ_distrib_right div_eq_mul_inv,
  ..filter.monoid, ..filter.has_involutive_inv, ..filter.has_div, ..filter.has_zpow }
@[to_additive] lemma is_unit_iff : is_unit f ‚Üî ‚àÉ a, f = pure a ‚àß is_unit a :=
begin
  split,
  { rintro ‚ü®u, rfl‚ü©,
    obtain ‚ü®a, b, ha, hb, h‚ü© := filter.mul_eq_one_iff.1 u.mul_inv,
    refine ‚ü®a, ha, ‚ü®a, b, h, pure_injective _‚ü©, rfl‚ü©,
    rw [‚Üêpure_mul_pure, ‚Üêha, ‚Üêhb],
    exact u.inv_mul },
  { rintro ‚ü®a, rfl, ha‚ü©,
    exact ha.filter }
end
end division_monoid
@[to_additive subtraction_comm_monoid "`filter Œ±` is a commutative subtraction monoid under
pointwise operations if `Œ±` is."]
protected def division_comm_monoid [division_comm_monoid Œ±] : division_comm_monoid (filter Œ±) :=
{ ..filter.division_monoid, ..filter.comm_semigroup }
protected def has_distrib_neg [has_mul Œ±] [has_distrib_neg Œ±] : has_distrib_neg (filter Œ±) :=
{ neg_mul := Œª _ _, map‚ÇÇ_map_left_comm neg_mul,
  mul_neg := Œª _ _, map_map‚ÇÇ_right_comm mul_neg,
  ..filter.has_involutive_neg }
localized "attribute [instance] filter.comm_monoid filter.add_comm_monoid filter.division_monoid
  filter.subtraction_monoid filter.division_comm_monoid filter.subtraction_comm_monoid
  filter.has_distrib_neg" in pointwise
section distrib
variables [distrib Œ±] {f g h : filter Œ±}
lemma mul_add_subset : f * (g + h) ‚â§ f * g + f * h := map‚ÇÇ_distrib_le_left mul_add
lemma add_mul_subset : (f + g) * h ‚â§ f * h + g * h := map‚ÇÇ_distrib_le_right add_mul
end distrib
section mul_zero_class
variables [mul_zero_class Œ±] {f g : filter Œ±}
lemma ne_bot.mul_zero_nonneg (hf : f.ne_bot) : 0 ‚â§ f * 0 :=
le_mul_iff.2 $ Œª t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ, let ‚ü®a, ha‚ü© := hf.nonempty_of_mem h‚ÇÅ in ‚ü®_, _, ha, h‚ÇÇ, mul_zero _‚ü©
lemma ne_bot.zero_mul_nonneg (hg : g.ne_bot) : 0 ‚â§ 0 * g :=
le_mul_iff.2 $ Œª t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ, let ‚ü®b, hb‚ü© := hg.nonempty_of_mem h‚ÇÇ in ‚ü®_, _, h‚ÇÅ, hb, zero_mul _‚ü©
end mul_zero_class
section group
variables [group Œ±] [division_monoid Œ≤] [monoid_hom_class F Œ± Œ≤] (m : F) {f g f‚ÇÅ g‚ÇÅ : filter Œ±}
  {f‚ÇÇ g‚ÇÇ : filter Œ≤}
@[simp, to_additive] protected lemma one_le_div_iff : 1 ‚â§ f / g ‚Üî ¬¨ disjoint f g :=
begin
  refine ‚ü®Œª h hfg, _, _‚ü©,
  { obtain ‚ü®s, hs, t, ht, hst‚ü© := hfg (mem_bot : ‚àÖ ‚àà ‚ä•),
    exact set.one_mem_div_iff.1 (h $ div_mem_div hs ht) (disjoint_iff.2 hst.symm) },
  { rintro h s ‚ü®t‚ÇÅ, t‚ÇÇ, h‚ÇÅ, h‚ÇÇ, hs‚ü©,
    exact hs (set.one_mem_div_iff.2 $ Œª ht, h $ disjoint_of_disjoint_of_mem ht h‚ÇÅ h‚ÇÇ) }
end
@[to_additive] lemma not_one_le_div_iff : ¬¨ 1 ‚â§ f / g ‚Üî disjoint f g :=
filter.one_le_div_iff.not_left
@[to_additive] lemma ne_bot.one_le_div (h : f.ne_bot) : 1 ‚â§ f / f :=
begin
  rintro s ‚ü®t‚ÇÅ, t‚ÇÇ, h‚ÇÅ, h‚ÇÇ, hs‚ü©,
  obtain ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© := set.not_disjoint_iff.1 (h.not_disjoint h‚ÇÅ h‚ÇÇ),
  rw [mem_one, ‚Üêdiv_self' a],
  exact hs (set.div_mem_div ha‚ÇÅ ha‚ÇÇ),
end
@[to_additive] lemma is_unit_pure (a : Œ±) : is_unit (pure a : filter Œ±) := (group.is_unit a).filter
@[simp] lemma is_unit_iff_singleton : is_unit f ‚Üî ‚àÉ a, f = pure a :=
by simp only [is_unit_iff, group.is_unit, and_true]
include Œ≤
@[to_additive] lemma map_inv' : f‚Åª¬π.map m = (f.map m)‚Åª¬π := map_comm (funext $ map_inv m) _
@[to_additive] lemma tendsto.inv_inv : tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m f‚ÇÅ‚Åª¬π f‚ÇÇ‚Åª¬π :=
Œª hf, (filter.map_inv' m).trans_le $ filter.inv_le_inv hf
@[to_additive] protected lemma map_div : (f / g).map m = f.map m / g.map m :=
map_map‚ÇÇ_distrib $ map_div m
@[to_additive]
lemma tendsto.div_div : tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ / g‚ÇÅ) (f‚ÇÇ / g‚ÇÇ) :=
Œª hf hg, (filter.map_div m).trans_le $ filter.div_le_div hf hg
end group
open_locale pointwise
section group_with_zero
variables [group_with_zero Œ±] {f g : filter Œ±}
lemma ne_bot.div_zero_nonneg (hf : f.ne_bot) : 0 ‚â§ f / 0 :=
filter.le_div_iff.2 $ Œª t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ, let ‚ü®a, ha‚ü© := hf.nonempty_of_mem h‚ÇÅ in
  ‚ü®_, _, ha, h‚ÇÇ, div_zero _‚ü©
lemma ne_bot.zero_div_nonneg (hg : g.ne_bot) : 0 ‚â§ 0 / g :=
filter.le_div_iff.2 $ Œª t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ, let ‚ü®b, hb‚ü© := hg.nonempty_of_mem h‚ÇÇ in
  ‚ü®_, _, h‚ÇÅ, hb, zero_div _‚ü©
end group_with_zero
section smul
variables [has_smul Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ±} {g g‚ÇÅ g‚ÇÇ h : filter Œ≤} {s : set Œ±} {t : set Œ≤}
  {a : Œ±} {b : Œ≤}
@[to_additive filter.has_vadd
"The filter `f +·µ• g` is generated by `{s +·µ• t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def has_smul : has_smul (filter Œ±) (filter Œ≤) :=
‚ü®Œª f g, { sets := {s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ s}, ..map‚ÇÇ (‚Ä¢) f g }‚ü©
localized "attribute [instance] filter.has_smul filter.has_vadd" in pointwise
@[simp, to_additive] lemma map‚ÇÇ_smul : map‚ÇÇ (‚Ä¢) f g = f ‚Ä¢ g := rfl
@[to_additive] lemma mem_smul : t ‚àà f ‚Ä¢ g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ t := iff.rfl
@[to_additive] lemma smul_mem_smul : s ‚àà f ‚Üí t ‚àà g ‚Üí s ‚Ä¢ t ‚àà f ‚Ä¢ g :=  image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_smul : (‚ä• : filter Œ±) ‚Ä¢ g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma smul_bot : f ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma smul_eq_bot_iff : f ‚Ä¢ g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma smul_ne_bot_iff : (f ‚Ä¢ g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.smul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f ‚Ä¢ g) := ne_bot.map‚ÇÇ
@[to_additive] lemma ne_bot.of_smul_left : (f ‚Ä¢ g).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
@[to_additive] lemma ne_bot.of_smul_right : (f ‚Ä¢ g).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp, to_additive] lemma pure_smul : (pure a : filter Œ±) ‚Ä¢ g = g.map ((‚Ä¢) a)  := map‚ÇÇ_pure_left
@[simp, to_additive] lemma smul_pure : f ‚Ä¢ pure b = f.map (‚Ä¢ b)  := map‚ÇÇ_pure_right
@[simp, to_additive] lemma pure_smul_pure :
  (pure a : filter Œ±) ‚Ä¢ (pure b : filter Œ≤) = pure (a ‚Ä¢ b) := map‚ÇÇ_pure
@[to_additive] lemma smul_le_smul : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g‚ÇÅ ‚â§ f‚ÇÇ ‚Ä¢ g‚ÇÇ := map‚ÇÇ_mono
@[to_additive] lemma smul_le_smul_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f ‚Ä¢ g‚ÇÅ ‚â§ f ‚Ä¢ g‚ÇÇ := map‚ÇÇ_mono_left
@[to_additive] lemma smul_le_smul_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g ‚â§ f‚ÇÇ ‚Ä¢ g := map‚ÇÇ_mono_right
@[simp, to_additive] lemma le_smul_iff : h ‚â§ f ‚Ä¢ g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s ‚Ä¢ t ‚àà h :=
le_map‚ÇÇ_iff
@[to_additive] instance covariant_smul : covariant_class (filter Œ±) (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©
end smul
section vsub
variables [has_vsub Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : filter Œ≤} {h : filter Œ±} {s t : set Œ≤} {a b : Œ≤}
include Œ±
protected def has_vsub : has_vsub (filter Œ±) (filter Œ≤) :=
‚ü®Œª f g, { sets := {s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s}, ..map‚ÇÇ (-·µ•) f g }‚ü©
localized "attribute [instance] filter.has_vsub" in pointwise
@[simp] lemma map‚ÇÇ_vsub : map‚ÇÇ (-·µ•) f g = f -·µ• g := rfl
lemma mem_vsub {s : set Œ±} : s ‚àà f -·µ• g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s := iff.rfl
lemma vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=  image2_mem_map‚ÇÇ
@[simp] lemma bot_vsub : (‚ä• : filter Œ≤) -·µ• g = ‚ä• := map‚ÇÇ_bot_left
@[simp] lemma vsub_bot : f -·µ• (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp] lemma vsub_eq_bot_iff : f -·µ• g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp] lemma vsub_ne_bot_iff : (f -·µ• g : filter Œ±).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
lemma ne_bot.vsub : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f -·µ• g) := ne_bot.map‚ÇÇ
lemma ne_bot.of_vsub_left : (f -·µ• g : filter Œ±).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
lemma ne_bot.of_vsub_right : (f -·µ• g : filter Œ±).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp] lemma pure_vsub : (pure a : filter Œ≤) -·µ• g = g.map ((-·µ•) a)  := map‚ÇÇ_pure_left
@[simp] lemma vsub_pure : f -·µ• pure b = f.map (-·µ• b)  := map‚ÇÇ_pure_right
@[simp] lemma pure_vsub_pure : (pure a : filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : filter Œ±) :=
map‚ÇÇ_pure
lemma vsub_le_vsub : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ -·µ• g‚ÇÅ ‚â§ f‚ÇÇ -·µ• g‚ÇÇ := map‚ÇÇ_mono
lemma vsub_le_vsub_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f -·µ• g‚ÇÅ ‚â§ f -·µ• g‚ÇÇ := map‚ÇÇ_mono_left
lemma vsub_le_vsub_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ -·µ• g ‚â§ f‚ÇÇ -·µ• g := map‚ÇÇ_mono_right
@[simp] lemma le_vsub_iff : h ‚â§ f -·µ• g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s -·µ• t ‚àà h := le_map‚ÇÇ_iff
end vsub
section smul
variables [has_smul Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ≤} {s : set Œ≤} {a : Œ±}
@[to_additive filter.has_vadd_filter
"`a +·µ• f` is the map of `f` under `a +·µ•` in locale `pointwise`."]
protected def has_smul_filter : has_smul Œ± (filter Œ≤) := ‚ü®Œª a, map ((‚Ä¢) a)‚ü©
localized "attribute [instance] filter.has_smul_filter filter.has_vadd_filter" in pointwise
@[simp, to_additive] lemma map_smul : map (Œª b, a ‚Ä¢ b) f = a ‚Ä¢ f := rfl
@[to_additive] lemma mem_smul_filter : s ‚àà a ‚Ä¢ f ‚Üî (‚Ä¢) a ‚Åª¬π' s ‚àà f := iff.rfl
@[to_additive] lemma smul_set_mem_smul_filter : s ‚àà f ‚Üí a ‚Ä¢ s ‚àà a ‚Ä¢ f := image_mem_map
@[simp, to_additive] lemma smul_filter_bot : a ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map_bot
@[simp, to_additive] lemma smul_filter_eq_bot_iff : a ‚Ä¢ f = ‚ä• ‚Üî f = ‚ä• := map_eq_bot_iff
@[simp, to_additive] lemma smul_filter_ne_bot_iff : (a ‚Ä¢ f).ne_bot ‚Üî f.ne_bot := map_ne_bot_iff _
@[to_additive] lemma ne_bot.smul_filter : f.ne_bot ‚Üí (a ‚Ä¢ f).ne_bot := Œª h, h.map _
@[to_additive] lemma ne_bot.of_smul_filter : (a ‚Ä¢ f).ne_bot ‚Üí f.ne_bot := ne_bot.of_map
@[to_additive] lemma smul_filter_le_smul_filter (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : a ‚Ä¢ f‚ÇÅ ‚â§ a ‚Ä¢ f‚ÇÇ :=
map_mono hf
@[to_additive] instance covariant_smul_filter : covariant_class Œ± (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f, map_mono‚ü©
end smul
open_locale pointwise
@[to_additive]
instance smul_comm_class_filter [has_smul Œ± Œ≥] [has_smul Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class Œ± Œ≤ (filter Œ≥) :=
‚ü®Œª _ _ _,  map_comm (funext $ smul_comm _ _) _‚ü©
@[to_additive]
instance smul_comm_class_filter' [has_smul Œ± Œ≥] [has_smul Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, map_map‚ÇÇ_distrib_right $ smul_comm a‚ü©
@[to_additive]
instance smul_comm_class_filter'' [has_smul Œ± Œ≥] [has_smul Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) Œ≤ (filter Œ≥) :=
by haveI := smul_comm_class.symm Œ± Œ≤ Œ≥; exact smul_comm_class.symm _ _ _
@[to_additive]
instance smul_comm_class [has_smul Œ± Œ≥] [has_smul Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_left_comm smul_comm‚ü©
instance is_scalar_tower [has_smul Œ± Œ≤] [has_smul Œ± Œ≥] [has_smul Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± Œ≤ (filter Œ≥) :=
‚ü®Œª a b f, by simp only [‚Üêmap_smul, map_map, smul_assoc]‚ü©
instance is_scalar_tower' [has_smul Œ± Œ≤] [has_smul Œ± Œ≥] [has_smul Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, by { refine (map_map‚ÇÇ_distrib_left $ Œª _ _, _).symm, exact (smul_assoc a _ _).symm }‚ü©
instance is_scalar_tower'' [has_smul Œ± Œ≤] [has_smul Œ± Œ≥] [has_smul Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_assoc smul_assoc‚ü©
instance is_central_scalar [has_smul Œ± Œ≤] [has_smul Œ±·µê·µí·µñ Œ≤] [is_central_scalar Œ± Œ≤] :
  is_central_scalar Œ± (filter Œ≤) :=
‚ü®Œª a f, congr_arg (Œª m, map m f) $ by exact funext (Œª _, op_smul_eq_smul _ _)‚ü©
@[to_additive "An additive action of an additive monoid `Œ±` on a type `Œ≤` gives an additive action
of `filter Œ±` on `filter Œ≤`"]
protected def mul_action [monoid Œ±] [mul_action Œ± Œ≤] : mul_action (filter Œ±) (filter Œ≤) :=
{ one_smul := Œª f, map‚ÇÇ_pure_left.trans $ by simp_rw [one_smul, map_id'],
  mul_smul := Œª f g h, map‚ÇÇ_assoc mul_smul }
@[to_additive "An additive action of an additive monoid on a type `Œ≤` gives an additive action on
`filter Œ≤`."]
protected def mul_action_filter [monoid Œ±] [mul_action Œ± Œ≤] : mul_action Œ± (filter Œ≤) :=
{ mul_smul := Œª a b f, by simp only [‚Üêmap_smul, map_map, function.comp, ‚Üêmul_smul],
  one_smul := Œª f, by simp only [‚Üêmap_smul, one_smul, map_id'] }
localized "attribute [instance] filter.mul_action filter.add_action filter.mul_action_filter
  filter.add_action_filter" in pointwise
protected def distrib_mul_action_filter [monoid Œ±] [add_monoid Œ≤] [distrib_mul_action Œ± Œ≤] :
  distrib_mul_action Œ± (filter Œ≤) :=
{ smul_add := Œª _ _ _, map_map‚ÇÇ_distrib $ smul_add _,
  smul_zero := Œª _, (map_pure _ _).trans $ by rw [smul_zero, pure_zero] }
protected def mul_distrib_mul_action_filter [monoid Œ±] [monoid Œ≤] [mul_distrib_mul_action Œ± Œ≤] :
  mul_distrib_mul_action Œ± (set Œ≤) :=
{ smul_mul := Œª _ _ _, image_image2_distrib $ smul_mul' _,
  smul_one := Œª _, image_singleton.trans $ by rw [smul_one, singleton_one] }
localized "attribute [instance] filter.distrib_mul_action_filter
  filter.mul_distrib_mul_action_filter" in pointwise
section smul_with_zero
variables [has_zero Œ±] [has_zero Œ≤] [smul_with_zero Œ± Œ≤] {f : filter Œ±} {g : filter Œ≤}
lemma ne_bot.smul_zero_nonneg (hf : f.ne_bot) : 0 ‚â§ f ‚Ä¢ (0 : filter Œ≤) :=
le_smul_iff.2 $ Œª t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ, let ‚ü®a, ha‚ü© := hf.nonempty_of_mem h‚ÇÅ in
  ‚ü®_, _, ha, h‚ÇÇ, smul_zero' _ _‚ü©
lemma ne_bot.zero_smul_nonneg (hg : g.ne_bot) : 0 ‚â§ (0 : filter Œ±) ‚Ä¢ g :=
le_smul_iff.2 $ Œª t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ, let ‚ü®b, hb‚ü© := hg.nonempty_of_mem h‚ÇÇ in ‚ü®_, _, h‚ÇÅ, hb, zero_smul _ _‚ü©
lemma zero_smul_filter_nonpos : (0 : Œ±) ‚Ä¢ g ‚â§ 0 :=
begin
  refine Œª s hs, mem_smul_filter.2 _,
  convert univ_mem,
  refine eq_univ_iff_forall.2 (Œª a, _),
  rwa [mem_preimage, zero_smul],
end
lemma zero_smul_filter (hg : g.ne_bot) : (0 : Œ±) ‚Ä¢ g = 0 :=
zero_smul_filter_nonpos.antisymm $ le_map_iff.2 $ Œª s hs, begin
  simp_rw [set.image_eta, zero_smul, (hg.nonempty_of_mem hs).image_const],
  exact zero_mem_zero,
end
end smul_with_zero
end filter
