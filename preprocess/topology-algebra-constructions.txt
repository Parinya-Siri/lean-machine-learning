import topology.homeomorph
variables {M X : Type*}
open filter
open_locale topological_space
namespace mul_opposite
@[to_additive] instance [topological_space M] : topological_space Mрхљрхњрхќ :=
topological_space.induced (unop : Mрхљрхњрхќ Рєњ M) Рђ╣_Рђ║
variables [topological_space M]
@[continuity, to_additive] lemma continuous_unop : continuous (unop : Mрхљрхњрхќ Рєњ M) :=
continuous_induced_dom
@[continuity, to_additive] lemma continuous_op : continuous (op : M Рєњ Mрхљрхњрхќ) :=
continuous_induced_rng continuous_id
@[to_additive] instance [t2_space M] : t2_space Mрхљрхњрхќ :=
РЪе╬╗ x y h, separated_by_continuous mul_opposite.continuous_unop $ unop_injective.ne hРЪЕ
@[to_additive "`add_opposite.op` as a homeomorphism."]
def op_homeomorph : M РЅЃРѓю Mрхљрхњрхќ :=
{ to_equiv := op_equiv,
  continuous_to_fun := continuous_op,
  continuous_inv_fun := continuous_unop }
@[simp, to_additive] lemma map_op_nhds (x : M) : map (op : M Рєњ Mрхљрхњрхќ) (­ЮЊЮ x) = ­ЮЊЮ (op x) :=
op_homeomorph.map_nhds_eq x
@[simp, to_additive] lemma map_unop_nhds (x : Mрхљрхњрхќ) : map (unop : Mрхљрхњрхќ Рєњ M) (­ЮЊЮ x) = ­ЮЊЮ (unop x) :=
op_homeomorph.symm.map_nhds_eq x
@[simp, to_additive] lemma comap_op_nhds (x : Mрхљрхњрхќ) : comap (op : M Рєњ Mрхљрхњрхќ) (­ЮЊЮ x) = ­ЮЊЮ (unop x) :=
op_homeomorph.comap_nhds_eq x
@[simp, to_additive] lemma comap_unop_nhds (x : M) : comap (unop : Mрхљрхњрхќ Рєњ M) (­ЮЊЮ x) = ­ЮЊЮ (op x) :=
op_homeomorph.symm.comap_nhds_eq x
end mul_opposite
namespace units
open mul_opposite
variables [topological_space M] [monoid M]
@[to_additive] instance : topological_space M╦Б :=
topological_space.induced (embed_product M) prod.topological_space
@[to_additive] lemma continuous_embed_product : continuous (embed_product M) :=
continuous_induced_dom
@[to_additive] lemma continuous_coe : continuous (coe : M╦Б Рєњ M) :=
(@continuous_embed_product M _ _).fst
end units
