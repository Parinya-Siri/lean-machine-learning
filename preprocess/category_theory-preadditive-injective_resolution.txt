import category_theory.preadditive.injective
import algebra.homology.single
noncomputable theory
open category_theory
open category_theory.limits
universes v u
namespace category_theory
variables {C : Type u} [category.{v} C]
open injective
variables [has_zero_object C] [has_zero_morphisms C] [has_equalizers C] [has_images C]
@[nolint has_inhabited_instance]
structure InjectiveResolution (Z : C) :=
(cocomplex : cochain_complex C ‚Ñï)
(Œπ: ((cochain_complex.single‚ÇÄ C).obj Z) ‚ü∂ cocomplex)
(injective : ‚àÄ n, injective (cocomplex.X n) . tactic.apply_instance)
(exact‚ÇÄ : exact (Œπ.f 0) (cocomplex.d 0 1) . tactic.apply_instance)
(exact : ‚àÄ n, exact (cocomplex.d n (n+1)) (cocomplex.d (n+1) (n+2)) . tactic.apply_instance)
(mono : mono (Œπ.f 0) . tactic.apply_instance)
attribute [instance] InjectiveResolution.injective InjectiveResolution.mono
class has_injective_resolution (Z : C) : Prop :=
(out [] : nonempty (InjectiveResolution Z))
section
variables (C)
class has_injective_resolutions : Prop :=
(out : ‚àÄ Z : C, has_injective_resolution Z)
attribute [instance, priority 100] has_injective_resolutions.out
end
namespace InjectiveResolution
@[simp] lemma Œπ_f_succ {Z : C} (I : InjectiveResolution Z) (n : ‚Ñï) :
  I.Œπ.f (n+1) = 0 :=
begin
  apply zero_of_source_iso_zero,
  dsimp, refl,
end
@[simp] lemma Œπ_f_zero_comp_complex_d {Z : C} (I : InjectiveResolution Z) :
  I.Œπ.f 0 ‚â´ I.cocomplex.d 0 1 = 0 :=
I.exact‚ÇÄ.w
@[simp] lemma complex_d_comp {Z : C} (I : InjectiveResolution Z) (n : ‚Ñï) :
  I.cocomplex.d n (n + 1) ‚â´ I.cocomplex.d (n + 1) (n + 2) = 0 :=
(I.exact _).w
instance {Z : C} (I : InjectiveResolution Z) (n : ‚Ñï) : category_theory.mono (I.Œπ.f n) :=
by cases n; apply_instance
def self (Z : C) [category_theory.injective Z] : InjectiveResolution Z :=
{ cocomplex := (cochain_complex.single‚ÇÄ C).obj Z,
  Œπ := ùüô ((cochain_complex.single‚ÇÄ C).obj Z),
  injective := Œª n, begin
    cases n;
    { dsimp, apply_instance },
  end,
  exact‚ÇÄ := by { dsimp, exact exact_epi_zero _ },
  exact := Œª n, by { dsimp, exact exact_of_zero _ _ },
  mono := by { dsimp, apply_instance, }, }
end InjectiveResolution
end category_theory
