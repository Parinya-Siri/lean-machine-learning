import category_theory.subobject.mono_over
import category_theory.skeletal
import tactic.elementwise
import tactic.apply_fun
universes v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ
noncomputable theory
namespace category_theory
open category_theory category_theory.category category_theory.limits
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] {X Y Z : C}
variables {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D]
@[derive [partial_order, category]]
def subobject (X : C) := thin_skeleton (mono_over X)
namespace subobject
abbreviation mk {X A : C} (f : A ‚ü∂ X) [mono f] : subobject X :=
(to_thin_skeleton _).obj (mono_over.mk' f)
noncomputable def equiv_mono_over (X : C) : subobject X ‚âå mono_over X :=
thin_skeleton.equivalence _
noncomputable
def representative {X : C} : subobject X ‚•§ mono_over X :=
(equiv_mono_over X).functor
noncomputable
def representative_iso {X : C} (A : mono_over X) :
  representative.obj ((to_thin_skeleton _).obj A) ‚âÖ A :=
(equiv_mono_over X).counit_iso.app A
noncomputable
def underlying {X : C} : subobject X ‚•§ C :=
representative ‚ãô mono_over.forget _ ‚ãô over.forget _
instance : has_coe (subobject X) C :=
{ coe := Œª Y, underlying.obj Y, }
@[simp] lemma underlying_as_coe {X : C} (P : subobject X) : underlying.obj P = P := rfl
noncomputable
def underlying_iso {X Y : C} (f : X ‚ü∂ Y) [mono f] : (subobject.mk f : C) ‚âÖ X :=
(mono_over.forget _ ‚ãô over.forget _).map_iso (representative_iso (mono_over.mk' f))
noncomputable
def arrow {X : C} (Y : subobject X) : (Y : C) ‚ü∂ X :=
(representative.obj Y).val.hom
instance arrow_mono {X : C} (Y : subobject X) : mono (Y.arrow) :=
(representative.obj Y).property
@[simp]
lemma arrow_congr {A : C} (X Y : subobject A) (h : X = Y) :
  eq_to_hom (congr_arg (Œª X : subobject A, (X : C)) h) ‚â´ Y.arrow = X.arrow :=
by { induction h, simp, }
@[simp]
lemma representative_coe (Y : subobject X) :
  (representative.obj Y : C) = (Y : C) :=
rfl
@[simp]
lemma representative_arrow (Y : subobject X) :
  (representative.obj Y).arrow = Y.arrow :=
rfl
@[simp, reassoc]
lemma underlying_arrow {X : C} {Y Z : subobject X} (f : Y ‚ü∂ Z) :
  underlying.map f ‚â´ arrow Z = arrow Y :=
over.w (representative.map f)
@[simp, reassoc, elementwise]
lemma underlying_iso_arrow {X Y : C} (f : X ‚ü∂ Y) [mono f] :
  (underlying_iso f).inv ‚â´ (subobject.mk f).arrow = f :=
over.w _
@[simp, reassoc]
lemma underlying_iso_hom_comp_eq_mk {X Y : C} (f : X ‚ü∂ Y) [mono f] :
  (underlying_iso f).hom ‚â´ f = (mk f).arrow :=
(iso.eq_inv_comp _).1 (underlying_iso_arrow f).symm
@[ext]
lemma eq_of_comp_arrow_eq {X Y : C} {P : subobject Y}
  {f g : X ‚ü∂ P} (h : f ‚â´ P.arrow = g ‚â´ P.arrow) : f = g :=
(cancel_mono P.arrow).mp h
lemma mk_le_mk_of_comm {B A‚ÇÅ A‚ÇÇ : C} {f‚ÇÅ : A‚ÇÅ ‚ü∂ B} {f‚ÇÇ : A‚ÇÇ ‚ü∂ B} [mono f‚ÇÅ] [mono f‚ÇÇ] (g : A‚ÇÅ ‚ü∂ A‚ÇÇ)
  (w : g ‚â´ f‚ÇÇ = f‚ÇÅ) : mk f‚ÇÅ ‚â§ mk f‚ÇÇ :=
‚ü®mono_over.hom_mk _ w‚ü©
@[simp] lemma mk_arrow (P : subobject X) : mk P.arrow = P :=
quotient.induction_on' P $ Œª Q,
begin
  obtain ‚ü®e‚ü© := @quotient.mk_out' _ (is_isomorphic_setoid _) Q,
  refine quotient.sound' ‚ü®mono_over.iso_mk _ _ ‚â™‚â´ e‚ü©;
  tidy
end
lemma le_of_comm {B : C} {X Y : subobject B} (f : (X : C) ‚ü∂ (Y : C)) (w : f ‚â´ Y.arrow = X.arrow) :
  X ‚â§ Y :=
by convert mk_le_mk_of_comm _ w; simp
lemma le_mk_of_comm {B A : C} {X : subobject B} {f : A ‚ü∂ B} [mono f] (g : (X : C) ‚ü∂ A)
  (w : g ‚â´ f = X.arrow) : X ‚â§ mk f :=
le_of_comm (g ‚â´ (underlying_iso f).inv) $ by simp [w]
lemma mk_le_of_comm {B A : C} {X : subobject B} {f : A ‚ü∂ B} [mono f] (g : A ‚ü∂ (X : C))
  (w : g ‚â´ X.arrow = f) : mk f ‚â§ X :=
le_of_comm ((underlying_iso f).hom ‚â´ g) $ by simp [w]
@[ext] lemma eq_of_comm {B : C} {X Y : subobject B} (f : (X : C) ‚âÖ (Y : C))
  (w : f.hom ‚â´ Y.arrow = X.arrow) : X = Y :=
le_antisymm (le_of_comm f.hom w) $ le_of_comm f.inv $ f.inv_comp_eq.2 w.symm
@[ext] lemma eq_mk_of_comm {B A : C} {X : subobject B} (f : A ‚ü∂ B) [mono f] (i : (X : C) ‚âÖ A)
  (w : i.hom ‚â´ f = X.arrow) : X = mk f :=
eq_of_comm (i.trans (underlying_iso f).symm) $ by simp [w]
@[ext] lemma mk_eq_of_comm {B A : C} {X : subobject B} (f : A ‚ü∂ B) [mono f] (i : A ‚âÖ (X : C))
  (w : i.hom ‚â´ X.arrow = f) : mk f = X :=
eq.symm $ eq_mk_of_comm _ i.symm $ by rw [iso.symm_hom, iso.inv_comp_eq, w]
@[ext] lemma mk_eq_mk_of_comm {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [mono f] [mono g]
  (i : A‚ÇÅ ‚âÖ A‚ÇÇ) (w : i.hom ‚â´ g = f) : mk f = mk g :=
eq_mk_of_comm _ ((underlying_iso f).trans i) $ by simp [w]
@[derive mono]
def of_le_mk {B A : C} (X : subobject B) (f : A ‚ü∂ B) [mono f] (h : X ‚â§ mk f) : (X : C) ‚ü∂ A :=
of_le X (mk f) h ‚â´ (underlying_iso f).hom
@[simp] lemma of_le_mk_comp {B A : C} {X : subobject B} {f : A ‚ü∂ B} [mono f] (h : X ‚â§ mk f) :
  of_le_mk X f h ‚â´ f = X.arrow :=
by simp [of_le_mk]
@[derive mono]
def of_mk_le {B A : C} (f : A ‚ü∂ B) [mono f] (X : subobject B) (h : mk f ‚â§ X) : A ‚ü∂ (X : C) :=
(underlying_iso f).inv ‚â´ of_le (mk f) X h
@[simp] lemma of_mk_le_arrow {B A : C} {f : A ‚ü∂ B} [mono f] {X : subobject B} (h : mk f ‚â§ X) :
  of_mk_le f X h ‚â´ X.arrow = f :=
by simp [of_mk_le]
@[derive mono]
def of_mk_le_mk {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [mono f] [mono g] (h : mk f ‚â§ mk g) :
  A‚ÇÅ ‚ü∂ A‚ÇÇ :=
(underlying_iso f).inv ‚â´ of_le (mk f) (mk g) h ‚â´ (underlying_iso g).hom
@[simp] lemma of_mk_le_mk_comp {B A‚ÇÅ A‚ÇÇ : C} {f : A‚ÇÅ ‚ü∂ B} {g : A‚ÇÇ ‚ü∂ B} [mono f] [mono g]
  (h : mk f ‚â§ mk g) : of_mk_le_mk f g h ‚â´ g = f :=
by simp [of_mk_le_mk]
@[simp, reassoc] lemma of_le_comp_of_le {B : C} (X Y Z : subobject B) (h‚ÇÅ : X ‚â§ Y) (h‚ÇÇ : Y ‚â§ Z) :
  of_le X Y h‚ÇÅ ‚â´ of_le Y Z h‚ÇÇ = of_le X Z (h‚ÇÅ.trans h‚ÇÇ) :=
by simp [of_le, ‚Üêfunctor.map_comp underlying]
@[simp, reassoc] lemma of_le_comp_of_le_mk {B A : C} (X Y : subobject B) (f : A ‚ü∂ B) [mono f]
  (h‚ÇÅ : X ‚â§ Y) (h‚ÇÇ : Y ‚â§ mk f) : of_le X Y h‚ÇÅ ‚â´ of_le_mk Y f h‚ÇÇ = of_le_mk X f (h‚ÇÅ.trans h‚ÇÇ) :=
by simp [of_mk_le, of_le_mk, of_le, ‚Üêfunctor.map_comp_assoc underlying]
@[simp, reassoc] lemma of_le_mk_comp_of_mk_le {B A : C} (X : subobject B) (f : A ‚ü∂ B) [mono f]
  (Y : subobject B) (h‚ÇÅ : X ‚â§ mk f) (h‚ÇÇ : mk f ‚â§ Y) :
  of_le_mk X f h‚ÇÅ ‚â´ of_mk_le f Y h‚ÇÇ = of_le X Y (h‚ÇÅ.trans h‚ÇÇ) :=
by simp [of_mk_le, of_le_mk, of_le, ‚Üêfunctor.map_comp underlying]
@[simp, reassoc] lemma of_le_mk_comp_of_mk_le_mk {B A‚ÇÅ A‚ÇÇ : C} (X : subobject B) (f : A‚ÇÅ ‚ü∂ B)
  [mono f] (g : A‚ÇÇ ‚ü∂ B) [mono g] (h‚ÇÅ : X ‚â§ mk f) (h‚ÇÇ : mk f ‚â§ mk g) :
  of_le_mk X f h‚ÇÅ ‚â´ of_mk_le_mk f g h‚ÇÇ = of_le_mk X g (h‚ÇÅ.trans h‚ÇÇ) :=
by simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp_assoc underlying]
@[simp, reassoc] lemma of_mk_le_comp_of_le {B A‚ÇÅ : C} (f : A‚ÇÅ ‚ü∂ B) [mono f] (X Y : subobject B)
  (h‚ÇÅ : mk f ‚â§ X) (h‚ÇÇ : X ‚â§ Y) :
  of_mk_le f X h‚ÇÅ ‚â´ of_le X Y h‚ÇÇ = of_mk_le f Y (h‚ÇÅ.trans h‚ÇÇ) :=
by simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp underlying]
@[simp, reassoc] lemma of_mk_le_comp_of_le_mk {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) [mono f] (X : subobject B)
  (g : A‚ÇÇ ‚ü∂ B) [mono g] (h‚ÇÅ : mk f ‚â§ X) (h‚ÇÇ : X ‚â§ mk g) :
  of_mk_le f X h‚ÇÅ ‚â´ of_le_mk X g h‚ÇÇ = of_mk_le_mk f g (h‚ÇÅ.trans h‚ÇÇ) :=
by simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp_assoc underlying]
@[simp, reassoc] lemma of_mk_le_mk_comp_of_mk_le {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) [mono f] (g : A‚ÇÇ ‚ü∂ B)
  [mono g] (X : subobject B) (h‚ÇÅ : mk f ‚â§ mk g) (h‚ÇÇ : mk g ‚â§ X) :
  of_mk_le_mk f g h‚ÇÅ ‚â´ of_mk_le g X h‚ÇÇ = of_mk_le f X (h‚ÇÅ.trans h‚ÇÇ) :=
by simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp underlying]
@[simp, reassoc] lemma of_mk_le_mk_comp_of_mk_le_mk {B A‚ÇÅ A‚ÇÇ A‚ÇÉ : C} (f : A‚ÇÅ ‚ü∂ B) [mono f]
  (g : A‚ÇÇ ‚ü∂ B) [mono g] (h : A‚ÇÉ ‚ü∂ B) [mono h] (h‚ÇÅ : mk f ‚â§ mk g) (h‚ÇÇ : mk g ‚â§ mk h) :
  of_mk_le_mk f g h‚ÇÅ ‚â´ of_mk_le_mk g h h‚ÇÇ = of_mk_le_mk f h (h‚ÇÅ.trans h‚ÇÇ) :=
by simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp_assoc underlying]
@[simp] lemma of_le_refl {B : C} (X : subobject B) :
  of_le X X le_rfl = ùüô _ :=
by { apply (cancel_mono X.arrow).mp, simp }
@[simp] lemma of_mk_le_mk_refl {B A‚ÇÅ : C} (f : A‚ÇÅ ‚ü∂ B) [mono f] :
  of_mk_le_mk f f le_rfl = ùüô _ :=
by { apply (cancel_mono f).mp, simp }
@[simps]
def iso_of_eq_mk {B A : C} (X : subobject B) (f : A ‚ü∂ B) [mono f] (h : X = mk f) : (X : C) ‚âÖ A :=
{ hom := of_le_mk X f h.le,
  inv := of_mk_le f X h.ge }
@[simps]
def iso_of_mk_eq {B A : C} (f : A ‚ü∂ B) [mono f] (X : subobject B) (h : mk f = X) : A ‚âÖ (X : C) :=
{ hom := of_mk_le f X h.le,
  inv := of_le_mk X f h.ge, }
@[simps]
def iso_of_mk_eq_mk {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B) [mono f] [mono g] (h : mk f = mk g) :
  A‚ÇÅ ‚âÖ A‚ÇÇ :=
{ hom := of_mk_le_mk f g h.le,
  inv := of_mk_le_mk g f h.ge, }
end subobject
open category_theory.limits
namespace subobject
def lower {Y : D} (F : mono_over X ‚•§ mono_over Y) : subobject X ‚•§ subobject Y :=
thin_skeleton.map F
lemma lower_iso (F‚ÇÅ F‚ÇÇ : mono_over X ‚•§ mono_over Y) (h : F‚ÇÅ ‚âÖ F‚ÇÇ) :
  lower F‚ÇÅ = lower F‚ÇÇ :=
thin_skeleton.map_iso_eq h
def lower‚ÇÇ (F : mono_over X ‚•§ mono_over Y ‚•§ mono_over Z) :
  subobject X ‚•§ subobject Y ‚•§ subobject Z :=
thin_skeleton.map‚ÇÇ F
@[simp]
lemma lower_comm (F : mono_over Y ‚•§ mono_over X) :
  to_thin_skeleton _ ‚ãô lower F = F ‚ãô to_thin_skeleton _ :=
rfl
def lower_adjunction {A : C} {B : D}
  {L : mono_over A ‚•§ mono_over B} {R : mono_over B ‚•§ mono_over A} (h : L ‚ä£ R) :
  lower L ‚ä£ lower R :=
thin_skeleton.lower_adjunction _ _ h
@[simps]
def lower_equivalence {A : C} {B : D} (e : mono_over A ‚âå mono_over B) : subobject A ‚âå subobject B :=
{ functor := lower e.functor,
  inverse := lower e.inverse,
  unit_iso :=
  begin
    apply eq_to_iso,
    convert thin_skeleton.map_iso_eq e.unit_iso,
    { exact thin_skeleton.map_id_eq.symm },
    { exact (thin_skeleton.map_comp_eq _ _).symm },
  end,
  counit_iso :=
  begin
    apply eq_to_iso,
    convert thin_skeleton.map_iso_eq e.counit_iso,
    { exact (thin_skeleton.map_comp_eq _ _).symm },
    { exact thin_skeleton.map_id_eq.symm },
  end }
section pullback
variables [has_pullbacks C]
def pullback (f : X ‚ü∂ Y) : subobject Y ‚•§ subobject X :=
lower (mono_over.pullback f)
lemma pullback_id (x : subobject X) : (pullback (ùüô X)).obj x = x :=
begin
  apply quotient.induction_on' x,
  intro f,
  apply quotient.sound,
  exact ‚ü®mono_over.pullback_id.app f‚ü©,
end
lemma pullback_comp (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : subobject Z) :
  (pullback (f ‚â´ g)).obj x = (pullback f).obj ((pullback g).obj x) :=
begin
  apply quotient.induction_on' x,
  intro t,
  apply quotient.sound,
  refine ‚ü®(mono_over.pullback_comp _ _).app t‚ü©,
end
instance (f : X ‚ü∂ Y) : faithful (pullback f) := {}
end pullback
section map
def map (f : X ‚ü∂ Y) [mono f] : subobject X ‚•§ subobject Y :=
lower (mono_over.map f)
lemma map_id (x : subobject X) : (map (ùüô X)).obj x = x :=
begin
  apply quotient.induction_on' x,
  intro f,
  apply quotient.sound,
  exact ‚ü®mono_over.map_id.app f‚ü©,
end
lemma map_comp (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [mono f] [mono g] (x : subobject X) :
  (map (f ‚â´ g)).obj x = (map g).obj ((map f).obj x) :=
begin
  apply quotient.induction_on' x,
  intro t,
  apply quotient.sound,
  refine ‚ü®(mono_over.map_comp _ _).app t‚ü©,
end
def map_iso {A B : C} (e : A ‚âÖ B) : subobject A ‚âå subobject B :=
lower_equivalence (mono_over.map_iso e)
def map_pullback_adj [has_pullbacks C] (f : X ‚ü∂ Y) [mono f] : map f ‚ä£ pullback f :=
lower_adjunction (mono_over.map_pullback_adj f)
@[simp]
lemma pullback_map_self [has_pullbacks C] (f : X ‚ü∂ Y) [mono f] (g : subobject X) :
  (pullback f).obj ((map f).obj g) = g :=
begin
  revert g,
  apply quotient.ind,
  intro g',
  apply quotient.sound,
  exact ‚ü®(mono_over.pullback_map_self f).app _‚ü©,
end
lemma map_pullback [has_pullbacks C]
  {X Y Z W : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} {h : Y ‚ü∂ W} {k : Z ‚ü∂ W} [mono h] [mono g]
  (comm : f ‚â´ h = g ‚â´ k) (t : is_limit (pullback_cone.mk f g comm)) (p : subobject Y) :
  (map g).obj ((pullback f).obj p) = (pullback k).obj ((map h).obj p) :=
begin
  revert p,
  apply quotient.ind',
  intro a,
  apply quotient.sound,
  apply thin_skeleton.equiv_of_both_ways,
  { refine mono_over.hom_mk (pullback.lift pullback.fst _ _) (pullback.lift_snd _ _ _),
    change _ ‚â´ a.arrow ‚â´ h = (pullback.snd ‚â´ g) ‚â´ _,
    rw [assoc, ‚Üê comm, pullback.condition_assoc] },
  { refine mono_over.hom_mk (pullback.lift pullback.fst
                        (pullback_cone.is_limit.lift' t (pullback.fst ‚â´ a.arrow) pullback.snd _).1
                        (pullback_cone.is_limit.lift' _ _ _ _).2.1.symm) _,
    { rw [‚Üê pullback.condition, assoc], refl },
    { dsimp, rw [pullback.lift_snd_assoc],
      apply (pullback_cone.is_limit.lift' _ _ _ _).2.2 } }
end
end map
section ¬´exists¬ª
variables [has_images C]
def ¬´exists¬ª (f : X ‚ü∂ Y) : subobject X ‚•§ subobject Y :=
lower (mono_over.exists f)
lemma exists_iso_map (f : X ‚ü∂ Y) [mono f] : ¬´exists¬ª f = map f :=
lower_iso _ _ (mono_over.exists_iso_map f)
def exists_pullback_adj (f : X ‚ü∂ Y) [has_pullbacks C] : ¬´exists¬ª f ‚ä£ pullback f :=
lower_adjunction (mono_over.exists_pullback_adj f)
end  ¬´exists¬ª
end subobject
end category_theory
