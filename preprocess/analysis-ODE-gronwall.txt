import analysis.special_functions.exp_deriv
variables {E : Type*} [normed_group E] [normed_space ‚Ñù E]
          {F : Type*} [normed_group F] [normed_space ‚Ñù F]
open metric set asymptotics filter real
open_locale classical topological_space nnreal
noncomputable def gronwall_bound (Œ¥ K Œµ x : ‚Ñù) : ‚Ñù :=
if K = 0 then Œ¥ + Œµ * x else Œ¥ * exp (K * x) + (Œµ / K) * (exp (K * x) - 1)
lemma gronwall_bound_K0 (Œ¥ Œµ : ‚Ñù) : gronwall_bound Œ¥ 0 Œµ = Œª x, Œ¥ + Œµ * x :=
funext $ Œª x, if_pos rfl
lemma gronwall_bound_of_K_ne_0 {Œ¥ K Œµ : ‚Ñù} (hK : K ‚â† 0) :
  gronwall_bound Œ¥ K Œµ = Œª x, Œ¥ * exp (K * x) + (Œµ / K) * (exp (K * x) - 1) :=
funext $ Œª x, if_neg hK
lemma has_deriv_at_gronwall_bound (Œ¥ K Œµ x : ‚Ñù) :
  has_deriv_at (gronwall_bound Œ¥ K Œµ) (K * (gronwall_bound Œ¥ K Œµ x) + Œµ) x :=
begin
  by_cases hK : K = 0,
  { subst K,
    simp only [gronwall_bound_K0, zero_mul, zero_add],
    convert ((has_deriv_at_id x).const_mul Œµ).const_add Œ¥,
    rw [mul_one] },
  { simp only [gronwall_bound_of_K_ne_0 hK],
    convert (((has_deriv_at_id x).const_mul K).exp.const_mul Œ¥).add
      ((((has_deriv_at_id x).const_mul K).exp.sub_const 1).const_mul (Œµ / K)) using 1,
    simp only [id, mul_add, (mul_assoc _ _ _).symm, mul_comm _ K, mul_div_cancel' _ hK],
    ring }
end
lemma has_deriv_at_gronwall_bound_shift (Œ¥ K Œµ x a : ‚Ñù) :
  has_deriv_at (Œª y, gronwall_bound Œ¥ K Œµ (y - a)) (K * (gronwall_bound Œ¥ K Œµ (x - a)) + Œµ) x :=
begin
  convert (has_deriv_at_gronwall_bound Œ¥ K Œµ _).comp x ((has_deriv_at_id x).sub_const a),
  rw [id, mul_one]
end
lemma gronwall_bound_x0 (Œ¥ K Œµ : ‚Ñù) : gronwall_bound Œ¥ K Œµ 0 = Œ¥ :=
begin
  by_cases hK : K = 0,
  { simp only [gronwall_bound, if_pos hK, mul_zero, add_zero] },
  { simp only [gronwall_bound, if_neg hK, mul_zero, exp_zero, sub_self, mul_one, add_zero] }
end
lemma gronwall_bound_Œµ0 (Œ¥ K x : ‚Ñù) : gronwall_bound Œ¥ K 0 x = Œ¥ * exp (K * x) :=
begin
  by_cases hK : K = 0,
  { simp only [gronwall_bound_K0, hK, zero_mul, exp_zero, add_zero, mul_one] },
  { simp only [gronwall_bound_of_K_ne_0 hK, zero_div, zero_mul, add_zero] }
end
lemma gronwall_bound_Œµ0_Œ¥0 (K x : ‚Ñù) : gronwall_bound 0 K 0 x = 0 :=
by simp only [gronwall_bound_Œµ0, zero_mul]
lemma gronwall_bound_continuous_Œµ (Œ¥ K x : ‚Ñù) : continuous (Œª Œµ, gronwall_bound Œ¥ K Œµ x) :=
begin
  by_cases hK : K = 0,
  { simp only [gronwall_bound_K0, hK],
    exact continuous_const.add (continuous_id.mul continuous_const) },
  { simp only [gronwall_bound_of_K_ne_0 hK],
    exact continuous_const.add ((continuous_id.mul continuous_const).mul continuous_const) }
end
theorem le_gronwall_bound_of_liminf_deriv_right_le {f f' : ‚Ñù ‚Üí ‚Ñù} {Œ¥ K Œµ : ‚Ñù} {a b : ‚Ñù}
  (hf : continuous_on f (Icc a b))
  (hf' : ‚àÄ x ‚àà Ico a b, ‚àÄ r, f' x < r ‚Üí
    ‚àÉ·∂† z in ùìù[>] x, (z - x)‚Åª¬π * (f z - f x) < r)
  (ha : f a ‚â§ Œ¥) (bound : ‚àÄ x ‚àà Ico a b, f' x ‚â§ K * f x + Œµ) :
  ‚àÄ x ‚àà Icc a b, f x ‚â§ gronwall_bound Œ¥ K Œµ (x - a) :=
begin
  have H : ‚àÄ x ‚àà Icc a b, ‚àÄ Œµ' ‚àà Ioi Œµ, f x ‚â§ gronwall_bound Œ¥ K Œµ' (x - a),
  { assume x hx Œµ' hŒµ',
    apply image_le_of_liminf_slope_right_lt_deriv_boundary hf hf',
    { rwa [sub_self, gronwall_bound_x0] },
    { exact Œª x, has_deriv_at_gronwall_bound_shift Œ¥ K Œµ' x a },
    { assume x hx hfB,
      rw [‚Üê hfB],
      apply lt_of_le_of_lt (bound x hx),
      exact add_lt_add_left hŒµ' _ },
    { exact hx } },
  assume x hx,
  change f x ‚â§ (Œª Œµ', gronwall_bound Œ¥ K Œµ' (x - a)) Œµ,
  convert continuous_within_at_const.closure_le _ _ (H x hx),
  { simp only [closure_Ioi, left_mem_Ici] },
  exact (gronwall_bound_continuous_Œµ Œ¥ K (x - a)).continuous_within_at
end
theorem norm_le_gronwall_bound_of_norm_deriv_right_le {f f' : ‚Ñù ‚Üí E} {Œ¥ K Œµ : ‚Ñù} {a b : ‚Ñù}
  (hf : continuous_on f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, has_deriv_within_at f (f' x) (Ici x) x)
  (ha : ‚à•f a‚à• ‚â§ Œ¥) (bound : ‚àÄ x ‚àà Ico a b, ‚à•f' x‚à• ‚â§ K * ‚à•f x‚à• + Œµ) :
  ‚àÄ x ‚àà Icc a b, ‚à•f x‚à• ‚â§ gronwall_bound Œ¥ K Œµ (x - a) :=
le_gronwall_bound_of_liminf_deriv_right_le (continuous_norm.comp_continuous_on hf)
  (Œª x hx r hr, (hf' x hx).liminf_right_slope_norm_le hr) ha bound
theorem dist_le_of_approx_trajectories_ODE_of_mem_set {v : ‚Ñù ‚Üí E ‚Üí E} {s : ‚Ñù ‚Üí set E}
  {K : ‚Ñù} (hv : ‚àÄ t, ‚àÄ x y ‚àà s t, dist (v t x) (v t y) ‚â§ K * dist x y)
  {f g f' g' : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œµf Œµg Œ¥ : ‚Ñù}
  (hf : continuous_on f (Icc a b))
  (hf' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at f (f' t) (Ici t) t)
  (f_bound : ‚àÄ t ‚àà Ico a b, dist (f' t) (v t (f t)) ‚â§ Œµf)
  (hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà s t)
  (hg : continuous_on g (Icc a b))
  (hg' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at g (g' t) (Ici t) t)
  (g_bound : ‚àÄ t ‚àà Ico a b, dist (g' t) (v t (g t)) ‚â§ Œµg)
  (hgs : ‚àÄ t ‚àà Ico a b, g t ‚àà s t)
  (ha : dist (f a) (g a) ‚â§ Œ¥) :
  ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ gronwall_bound Œ¥ K (Œµf + Œµg) (t - a) :=
begin
  simp only [dist_eq_norm] at ha ‚ä¢,
  have h_deriv : ‚àÄ t ‚àà Ico a b, has_deriv_within_at (Œª t, f t - g t) (f' t - g' t) (Ici t) t,
    from Œª t ht, (hf' t ht).sub (hg' t ht),
  apply norm_le_gronwall_bound_of_norm_deriv_right_le (hf.sub hg) h_deriv ha,
  assume t ht,
  have := dist_triangle4_right (f' t) (g' t) (v t (f t)) (v t (g t)),
  rw [dist_eq_norm] at this,
  refine this.trans ((add_le_add (add_le_add (f_bound t ht) (g_bound t ht))
    (hv t (f t) (hfs t ht) (g t) (hgs t ht))).trans _),
  rw [dist_eq_norm, add_comm]
end
theorem dist_le_of_approx_trajectories_ODE {v : ‚Ñù ‚Üí E ‚Üí E}
  {K : ‚Ñù‚â•0} (hv : ‚àÄ t, lipschitz_with K (v t))
  {f g f' g' : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œµf Œµg Œ¥ : ‚Ñù}
  (hf : continuous_on f (Icc a b))
  (hf' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at f (f' t) (Ici t) t)
  (f_bound : ‚àÄ t ‚àà Ico a b, dist (f' t) (v t (f t)) ‚â§ Œµf)
  (hg : continuous_on g (Icc a b))
  (hg' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at g (g' t) (Ici t) t)
  (g_bound : ‚àÄ t ‚àà Ico a b, dist (g' t) (v t (g t)) ‚â§ Œµg)
  (ha : dist (f a) (g a) ‚â§ Œ¥) :
  ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ gronwall_bound Œ¥ K (Œµf + Œµg) (t - a) :=
have hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà (@univ E), from Œª t ht, trivial,
dist_le_of_approx_trajectories_ODE_of_mem_set (Œª t x hx y hy, (hv t).dist_le_mul x y)
  hf hf' f_bound hfs hg hg' g_bound (Œª t ht, trivial) ha
theorem dist_le_of_trajectories_ODE_of_mem_set {v : ‚Ñù ‚Üí E ‚Üí E} {s : ‚Ñù ‚Üí set E}
  {K : ‚Ñù} (hv : ‚àÄ t, ‚àÄ x y ‚àà s t, dist (v t x) (v t y) ‚â§ K * dist x y)
  {f g : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œ¥ : ‚Ñù}
  (hf : continuous_on f (Icc a b))
  (hf' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at f (v t (f t)) (Ici t) t)
  (hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà s t)
  (hg : continuous_on g (Icc a b))
  (hg' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at g (v t (g t)) (Ici t) t)
  (hgs : ‚àÄ t ‚àà Ico a b, g t ‚àà s t)
  (ha : dist (f a) (g a) ‚â§ Œ¥) :
  ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ Œ¥ * exp (K * (t - a)) :=
begin
  have f_bound : ‚àÄ t ‚àà Ico a b, dist (v t (f t)) (v t (f t)) ‚â§ 0,
    by { intros, rw [dist_self] },
  have g_bound : ‚àÄ t ‚àà Ico a b, dist (v t (g t)) (v t (g t)) ‚â§ 0,
    by { intros, rw [dist_self] },
  assume t ht,
  have := dist_le_of_approx_trajectories_ODE_of_mem_set hv hf hf' f_bound hfs hg hg' g_bound
    hgs ha t ht,
  rwa [zero_add, gronwall_bound_Œµ0] at this,
end
theorem dist_le_of_trajectories_ODE {v : ‚Ñù ‚Üí E ‚Üí E}
  {K : ‚Ñù‚â•0} (hv : ‚àÄ t, lipschitz_with K (v t))
  {f g : ‚Ñù ‚Üí E} {a b : ‚Ñù} {Œ¥ : ‚Ñù}
  (hf : continuous_on f (Icc a b))
  (hf' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at f (v t (f t)) (Ici t) t)
  (hg : continuous_on g (Icc a b))
  (hg' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at g (v t (g t)) (Ici t) t)
  (ha : dist (f a) (g a) ‚â§ Œ¥) :
  ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ Œ¥ * exp (K * (t - a)) :=
have hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà (@univ E), from Œª t ht, trivial,
dist_le_of_trajectories_ODE_of_mem_set (Œª t x hx y hy, (hv t).dist_le_mul x y)
  hf hf' hfs hg hg' (Œª t ht, trivial) ha
theorem ODE_solution_unique_of_mem_set {v : ‚Ñù ‚Üí E ‚Üí E} {s : ‚Ñù ‚Üí set E}
  {K : ‚Ñù} (hv : ‚àÄ t, ‚àÄ x y ‚àà s t, dist (v t x) (v t y) ‚â§ K * dist x y)
  {f g : ‚Ñù ‚Üí E} {a b : ‚Ñù}
  (hf : continuous_on f (Icc a b))
  (hf' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at f (v t (f t)) (Ici t) t)
  (hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà s t)
  (hg : continuous_on g (Icc a b))
  (hg' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at g (v t (g t)) (Ici t) t)
  (hgs : ‚àÄ t ‚àà Ico a b, g t ‚àà s t)
  (ha : f a = g a) :
  ‚àÄ t ‚àà Icc a b, f t = g t :=
begin
  assume t ht,
  have := dist_le_of_trajectories_ODE_of_mem_set hv hf hf' hfs hg hg' hgs
    (dist_le_zero.2 ha) t ht,
  rwa [zero_mul, dist_le_zero] at this
end
theorem ODE_solution_unique {v : ‚Ñù ‚Üí E ‚Üí E}
  {K : ‚Ñù‚â•0} (hv : ‚àÄ t, lipschitz_with K (v t))
  {f g : ‚Ñù ‚Üí E} {a b : ‚Ñù}
  (hf : continuous_on f (Icc a b))
  (hf' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at f (v t (f t)) (Ici t) t)
  (hg : continuous_on g (Icc a b))
  (hg' : ‚àÄ t ‚àà Ico a b, has_deriv_within_at g (v t (g t)) (Ici t) t)
  (ha : f a = g a) :
  ‚àÄ t ‚àà Icc a b, f t = g t :=
have hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà (@univ E), from Œª t ht, trivial,
ODE_solution_unique_of_mem_set (Œª t x hx y hy, (hv t).dist_le_mul x y)
  hf hf' hfs hg hg' (Œª t ht, trivial) ha
