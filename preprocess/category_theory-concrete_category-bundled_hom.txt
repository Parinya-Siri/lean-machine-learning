import category_theory.concrete_category.basic
import category_theory.concrete_category.bundled
universes u
namespace category_theory
variables {c : Type u â†’ Type u} (hom : Î  â¦ƒÎ± Î² : Type uâ¦„ (IÎ± : c Î±) (IÎ² : c Î²), Type u)
structure bundled_hom :=
(to_fun : Î  {Î± Î² : Type u} (IÎ± : c Î±) (IÎ² : c Î²), hom IÎ± IÎ² â†’ Î± â†’ Î²)
(id : Î  {Î± : Type u} (I : c Î±), hom I I)
(comp : Î  {Î± Î² Î³ : Type u} (IÎ± : c Î±) (IÎ² : c Î²) (IÎ³ : c Î³),
  hom IÎ² IÎ³ â†’ hom IÎ± IÎ² â†’ hom IÎ± IÎ³)
(hom_ext : âˆ€ {Î± Î² : Type u} (IÎ± : c Î±) (IÎ² : c Î²), function.injective (to_fun IÎ± IÎ²) . obviously)
(id_to_fun : âˆ€ {Î± : Type u} (I : c Î±), to_fun I I (id I) = _root_.id . obviously)
(comp_to_fun : âˆ€ {Î± Î² Î³ : Type u} (IÎ± : c Î±) (IÎ² : c Î²) (IÎ³ : c Î³)
  (f : hom IÎ± IÎ²) (g : hom IÎ² IÎ³),
  to_fun IÎ± IÎ³ (comp IÎ± IÎ² IÎ³ g f) = (to_fun IÎ² IÎ³ g) âˆ˜ (to_fun IÎ± IÎ² f) . obviously)
attribute [class] bundled_hom
attribute [simp] bundled_hom.id_to_fun bundled_hom.comp_to_fun
namespace bundled_hom
variable [ğ’ : bundled_hom hom]
include ğ’
@[nolint dangerous_instance] instance category : category (bundled c) :=
by refine
{ hom := Î» X Y, @hom X Y X.str Y.str,
  id := Î» X, @bundled_hom.id c hom ğ’ X X.str,
  comp := Î» X Y Z f g, @bundled_hom.comp c hom ğ’ X Y Z X.str Y.str Z.str g f,
  comp_id' := _,
  id_comp' := _,
  assoc' := _};
intros; apply ğ’.hom_ext;
  simp only [ğ’.id_to_fun, ğ’.comp_to_fun, function.left_id, function.right_id]
@[nolint dangerous_instance] instance concrete_category : concrete_category.{u} (bundled c) :=
{ forget := { obj := Î» X, X,
              map := Î» X Y f, ğ’.to_fun X.str Y.str f,
              map_id' := Î» X, ğ’.id_to_fun X.str,
              map_comp' := by intros; erw ğ’.comp_to_fun; refl },
  forget_faithful := { map_injective' := by intros; apply ğ’.hom_ext } }
variables {hom}
local attribute [instance] concrete_category.has_coe_to_fun
def mk_has_forgetâ‚‚ {d : Type u â†’ Type u} {hom_d : Î  â¦ƒÎ± Î² : Type uâ¦„ (IÎ± : d Î±) (IÎ² : d Î²), Type u}
  [bundled_hom hom_d] (obj : Î  â¦ƒÎ±â¦„, c Î± â†’ d Î±)
  (map : Î  {X Y : bundled c}, (X âŸ¶ Y) â†’ ((bundled.map obj X) âŸ¶ (bundled.map obj Y)))
  (h_map : âˆ€ {X Y : bundled c} (f : X âŸ¶ Y), (map f : X â†’ Y) = f)
  : has_forgetâ‚‚ (bundled c) (bundled d) :=
has_forgetâ‚‚.mk'
  (bundled.map @obj)
  (Î» _, rfl)
  @map
  (by intros; apply heq_of_eq; apply h_map)
variables {d : Type u â†’ Type u}
variables (hom)
section
omit ğ’
@[reducible] def map_hom (F : Î  {Î±}, d Î± â†’ c Î±) : Î  â¦ƒÎ± Î² : Type uâ¦„ (IÎ± : d Î±) (IÎ² : d Î²), Type u :=
Î» Î± Î² iÎ± iÎ², hom (F iÎ±) (F iÎ²)
end
def map (F : Î  {Î±}, d Î± â†’ c Î±) : bundled_hom (map_hom hom @F) :=
{ to_fun := Î» Î± Î² iÎ± iÎ² f, ğ’.to_fun (F iÎ±) (F iÎ²) f,
  id := Î» Î± iÎ±, ğ’.id (F iÎ±),
  comp := Î» Î± Î² Î³ iÎ± iÎ² iÎ³ f g, ğ’.comp (F iÎ±) (F iÎ²) (F iÎ³) f g,
  hom_ext := Î» Î± Î² iÎ± iÎ² f g h, ğ’.hom_ext (F iÎ±) (F iÎ²) h }
section
omit ğ’
class parent_projection (F : Î  {Î±}, d Î± â†’ c Î±)
end
