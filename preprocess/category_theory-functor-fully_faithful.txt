import category_theory.natural_isomorphism
import logic.equiv.basic
class full (F : C ‚•§ D) :=
(preimage : ‚àÄ {X Y : C} (f : (F.obj X) ‚ü∂ (F.obj Y)), X ‚ü∂ Y)
(witness' : ‚àÄ {X Y : C} (f : (F.obj X) ‚ü∂ (F.obj Y)), F.map (preimage f) = f . obviously)
restate_axiom full.witness'
attribute [simp] full.witness
class faithful (F : C ‚•§ D) : Prop :=
(map_injective' [] : ‚àÄ {X Y : C}, function.injective (@functor.map _ _ _ _ F X Y) . obviously)
restate_axiom faithful.map_injective'
namespace functor
variables {X Y : C}
lemma map_injective (F : C ‚•§ D) [faithful F] :
  function.injective $ @functor.map _ _ _ _ F X Y :=
faithful.map_injective F
lemma map_iso_injective (F : C ‚•§ D) [faithful F] :
  function.injective $ @functor.map_iso _ _ _ _ F X Y :=
Œª i j h, iso.ext (map_injective F (congr_arg iso.hom h : _))
def preimage (F : C ‚•§ D) [full F] (f : F.obj X ‚ü∂ F.obj Y) : X ‚ü∂ Y :=
full.preimage.{v‚ÇÅ v‚ÇÇ} f
@[simp] lemma image_preimage (F : C ‚•§ D) [full F] {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) :
  F.map (preimage F f) = f :=
by unfold preimage; obviously
end functor
section
variables {F : C ‚•§ D} [full F] [faithful F] {X Y Z : C}
@[simp] lemma preimage_id : F.preimage (ùüô (F.obj X)) = ùüô X :=
F.map_injective (by simp)
@[simp] lemma preimage_comp (f : F.obj X ‚ü∂ F.obj Y) (g : F.obj Y ‚ü∂ F.obj Z) :
  F.preimage (f ‚â´ g) = F.preimage f ‚â´ F.preimage g :=
F.map_injective (by simp)
@[simp] lemma preimage_map (f : X ‚ü∂ Y) :
  F.preimage (F.map f) = f :=
F.map_injective (by simp)
variables (F)
namespace functor
@[simps]
def preimage_iso (f : (F.obj X) ‚âÖ (F.obj Y)) : X ‚âÖ Y :=
{ hom := F.preimage f.hom,
  inv := F.preimage f.inv,
  hom_inv_id' := F.map_injective (by simp),
  inv_hom_id' := F.map_injective (by simp), }
@[simp] lemma preimage_iso_map_iso (f : X ‚âÖ Y) :
  F.preimage_iso (F.map_iso f) = f :=
by { ext, simp, }
end functor
lemma is_iso_of_fully_faithful (f : X ‚ü∂ Y) [is_iso (F.map f)] : is_iso f :=
‚ü®‚ü®F.preimage (inv (F.map f)),
  ‚ü®F.map_injective (by simp), F.map_injective (by simp)‚ü©‚ü©‚ü©
@[simps]
def equiv_of_fully_faithful {X Y} : (X ‚ü∂ Y) ‚âÉ (F.obj X ‚ü∂ F.obj Y) :=
{ to_fun := Œª f, F.map f,
  inv_fun := Œª f, F.preimage f,
  left_inv := Œª f, by simp,
  right_inv := Œª f, by simp }
@[simps]
def iso_equiv_of_fully_faithful {X Y} : (X ‚âÖ Y) ‚âÉ (F.obj X ‚âÖ F.obj Y) :=
{ to_fun := Œª f, F.map_iso f,
  inv_fun := Œª f, F.preimage_iso f,
  left_inv := Œª f, by simp,
  right_inv := Œª f, by { ext, simp, } }
end
section
variables {E : Type*} [category E] {F G : C ‚•§ D} (H : D ‚•§ E) [full H] [faithful H]
@[simps]
def nat_trans_of_comp_fully_faithful (Œ± : F ‚ãô H ‚ü∂ G ‚ãô H) : F ‚ü∂ G :=
{ app := Œª X, (equiv_of_fully_faithful H).symm (Œ±.app X),
  naturality' := Œª X Y f, by { dsimp, apply H.map_injective, simpa using Œ±.naturality f, } }
@[simps]
def nat_iso_of_comp_fully_faithful (i : F ‚ãô H ‚âÖ G ‚ãô H) : F ‚âÖ G :=
nat_iso.of_components
  (Œª X, (iso_equiv_of_fully_faithful H).symm (i.app X))
  (Œª X Y f, by { dsimp, apply H.map_injective, simpa using i.hom.naturality f, })
lemma nat_iso_of_comp_fully_faithful_hom (i : F ‚ãô H ‚âÖ G ‚ãô H) :
  (nat_iso_of_comp_fully_faithful H i).hom = nat_trans_of_comp_fully_faithful H i.hom :=
by { ext, simp [nat_iso_of_comp_fully_faithful], }
lemma nat_iso_of_comp_fully_faithful_inv (i : F ‚ãô H ‚âÖ G ‚ãô H) :
  (nat_iso_of_comp_fully_faithful H i).inv = nat_trans_of_comp_fully_faithful H i.inv :=
by { ext, simp [‚Üêpreimage_comp], dsimp, simp, }
end
end category_theory
namespace category_theory
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C]
instance full.id : full (ùü≠ C) :=
{ preimage := Œª _ _ f, f }
instance faithful.id : faithful (ùü≠ C) := by obviously
variables {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] {E : Type u‚ÇÉ} [category.{v‚ÇÉ} E]
variables (F F' : C ‚•§ D) (G : D ‚•§ E)
instance faithful.comp [faithful F] [faithful G] : faithful (F ‚ãô G) :=
{ map_injective' := Œª _ _ _ _ p, F.map_injective (G.map_injective p) }
lemma faithful.of_comp [faithful $ F ‚ãô G] : faithful F :=
{ map_injective' := Œª X Y, (F ‚ãô G).map_injective.of_comp }
section
variables {F F'}
def full.of_iso [full F] (Œ± : F ‚âÖ F') : full F' :=
{ preimage := Œª X Y f, F.preimage ((Œ±.app X).hom ‚â´ f ‚â´ (Œ±.app Y).inv),
  witness' := Œª X Y f, by simp [‚Üênat_iso.naturality_1 Œ±], }
lemma faithful.of_iso [faithful F] (Œ± : F ‚âÖ F') : faithful F' :=
{ map_injective' := Œª X Y f f' h, F.map_injective
  (by rw [‚Üênat_iso.naturality_1 Œ±.symm, h, nat_iso.naturality_1 Œ±.symm]) }
end
variables {F G}
lemma faithful.of_comp_iso {H : C ‚•§ E} [‚Ñã : faithful H] (h : F ‚ãô G ‚âÖ H) : faithful F :=
@faithful.of_comp _ _ _ _ _ _ F G (faithful.of_iso h.symm)
alias faithful.of_comp_iso ‚Üê _root_.category_theory.iso.faithful_of_comp
protected def faithful.div (F : C ‚•§ E) (G : D ‚•§ E) [faithful G]
  (obj : C ‚Üí D) (h_obj : ‚àÄ X, G.obj (obj X) = F.obj X)
  (map : Œ† {X Y}, (X ‚ü∂ Y) ‚Üí (obj X ‚ü∂ obj Y))
  (h_map : ‚àÄ {X Y} {f : X ‚ü∂ Y}, G.map (map f) == F.map f) :
  C ‚•§ D :=
{ obj := obj,
  map := @map,
  map_id' :=
  begin
    assume X,
    apply G.map_injective,
    apply eq_of_heq,
    transitivity F.map (ùüô X), from h_map,
    rw [F.map_id, G.map_id, h_obj X]
  end,
  map_comp' :=
  begin
    assume X Y Z f g,
    apply G.map_injective,
    apply eq_of_heq,
    transitivity F.map (f ‚â´ g), from h_map,
    rw [F.map_comp, G.map_comp],
    congr' 1;
      try { exact (h_obj _).symm };
      exact h_map.symm
  end }
def full.of_comp_faithful [full $ F ‚ãô G] [faithful G] : full F :=
{ preimage := Œª X Y f, (F ‚ãô G).preimage (G.map f),
  witness' := Œª X Y f, G.map_injective ((F ‚ãô G).image_preimage _) }
def full.of_comp_faithful_iso {F : C ‚•§ D} {G : D ‚•§ E} {H : C ‚•§ E} [full H] [faithful G]
  (h : F ‚ãô G ‚âÖ H) : full F :=
@full.of_comp_faithful _ _ _ _ _ _ F G (full.of_iso h.symm) _
def fully_faithful_cancel_right {F G : C ‚•§ D} (H : D ‚•§ E)
  [full H] [faithful H] (comp_iso: F ‚ãô H ‚âÖ G ‚ãô H) : F ‚âÖ G :=
nat_iso.of_components
  (Œª X, H.preimage_iso (comp_iso.app X))
  (Œª X Y f, H.map_injective (by simpa using comp_iso.hom.naturality f))
@[simp]
lemma fully_faithful_cancel_right_hom_app {F G : C ‚•§ D} {H : D ‚•§ E}
  [full H] [faithful H] (comp_iso: F ‚ãô H ‚âÖ G ‚ãô H) (X : C) :
  (fully_faithful_cancel_right H comp_iso).hom.app X = H.preimage (comp_iso.hom.app X) :=
rfl
@[simp]
lemma fully_faithful_cancel_right_inv_app {F G : C ‚•§ D} {H : D ‚•§ E}
  [full H] [faithful H] (comp_iso: F ‚ãô H ‚âÖ G ‚ãô H) (X : C) :
  (fully_faithful_cancel_right H comp_iso).inv.app X = H.preimage (comp_iso.inv.app X) :=
rfl
end category_theory
