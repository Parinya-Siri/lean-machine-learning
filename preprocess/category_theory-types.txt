import category_theory.epi_mono
import category_theory.functor.fully_faithful
import logic.equiv.basic
namespace category_theory
@[to_additive category_theory.types]
instance types : large_category (Type u) :=
{ hom     := Œª a b, (a ‚Üí b),
  id      := Œª a, id,
  comp    := Œª _ _ _ f g, g ‚àò f }
lemma types_hom {Œ± Œ≤ : Type u} : (Œ± ‚ü∂ Œ≤) = (Œ± ‚Üí Œ≤) := rfl
lemma types_id (X : Type u) : ùüô X = id := rfl
lemma types_comp {X Y Z : Type u} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : f ‚â´ g = g ‚àò f := rfl
@[simp]
lemma types_id_apply (X : Type u) (x : X) : ((ùüô X) : X ‚Üí X) x = x := rfl
@[simp]
lemma types_comp_apply {X Y Z : Type u} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) := rfl
@[simp]
lemma hom_inv_id_apply {X Y : Type u} (f : X ‚âÖ Y) (x : X) : f.inv (f.hom x) = x :=
congr_fun f.hom_inv_id x
@[simp]
lemma inv_hom_id_apply {X Y : Type u} (f : X ‚âÖ Y) (y : Y) : f.hom (f.inv y) = y :=
congr_fun f.inv_hom_id y
def sections (F : J ‚•§ Type w) : set (Œ† j, F.obj j) :=
{ u | ‚àÄ {j j'} (f : j ‚ü∂ j'), F.map f (u j) = u j'}
end functor
namespace functor_to_types
variables {C : Type u} [category.{v} C] (F G H : C ‚•§ Type w) {X Y Z : C}
variables (œÉ : F ‚ü∂ G) (œÑ : G ‚ü∂ H)
@[simp] lemma map_comp_apply (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (a : F.obj X) :
  (F.map (f ‚â´ g)) a = (F.map g) ((F.map f) a) :=
by simp [types_comp]
@[simp] lemma map_id_apply (a : F.obj X) : (F.map (ùüô X)) a = a :=
by simp [types_id]
lemma naturality (f : X ‚ü∂ Y) (x : F.obj X) : œÉ.app Y ((F.map f) x) = (G.map f) (œÉ.app X x) :=
congr_fun (œÉ.naturality f) x
@[simp] lemma comp (x : F.obj X) : (œÉ ‚â´ œÑ).app X x = œÑ.app X (œÉ.app X x) := rfl
variables {D : Type u'} [ùíü : category.{u'} D] (I J : D ‚•§ C) (œÅ : I ‚ü∂ J) {W : D}
@[simp] lemma hcomp (x : (I ‚ãô F).obj W) :
  (œÅ ‚ó´ œÉ).app W x = (G.map (œÅ.app W)) (œÉ.app (I.obj W) x) :=
rfl
@[simp] lemma map_inv_map_hom_apply (f : X ‚âÖ Y) (x : F.obj X) : F.map f.inv (F.map f.hom x) = x :=
congr_fun (F.map_iso f).hom_inv_id x
@[simp] lemma map_hom_map_inv_apply (f : X ‚âÖ Y) (y : F.obj Y) : F.map f.hom (F.map f.inv y) = y :=
congr_fun (F.map_iso f).inv_hom_id y
@[simp] lemma hom_inv_id_app_apply (Œ± : F ‚âÖ G) (X) (x) : Œ±.inv.app X (Œ±.hom.app X x) = x :=
congr_fun (Œ±.hom_inv_id_app X) x
@[simp] lemma inv_hom_id_app_apply (Œ± : F ‚âÖ G) (X) (x) : Œ±.hom.app X (Œ±.inv.app X x) = x :=
congr_fun (Œ±.inv_hom_id_app X) x
end functor_to_types
def ulift_trivial (V : Type u) : ulift.{u} V ‚âÖ V := by tidy
def ulift_functor : Type u ‚•§ Type (max u v) :=
{ obj := Œª X, ulift.{v} X,
  map := Œª X Y f, Œª x : ulift.{v} X, ulift.up (f x.down) }
@[simp] lemma ulift_functor_map {X Y : Type u} (f : X ‚ü∂ Y) (x : ulift.{v} X) :
  ulift_functor.map f x = ulift.up (f x.down) := rfl
instance ulift_functor_full : full.{u} ulift_functor :=
{ preimage := Œª X Y f x, (f (ulift.up x)).down }
instance ulift_functor_faithful : faithful ulift_functor :=
{ map_injective' := Œª X Y f g p, funext $ Œª x,
    congr_arg ulift.down ((congr_fun p (ulift.up x)) : ((ulift.up (f x)) = (ulift.up (g x)))) }
def ulift_functor_trivial : ulift_functor.{u u} ‚âÖ ùü≠ _ :=
nat_iso.of_components ulift_trivial (by tidy)
lemma mono_iff_injective {X Y : Type u} (f : X ‚ü∂ Y) : mono f ‚Üî function.injective f :=
begin
  split,
  { intros H x x' h,
    resetI,
    rw ‚Üêhom_of_element_eq_iff at ‚ä¢ h,
    exact (cancel_mono f).mp h },
  { exact Œª H, ‚ü®Œª Z, H.comp_left‚ü© }
end
lemma injective_of_mono {X Y : Type u} (f : X ‚ü∂ Y) [hf : mono f] : function.injective f :=
(mono_iff_injective f).1 hf
lemma epi_iff_surjective {X Y : Type u} (f : X ‚ü∂ Y) : epi f ‚Üî function.surjective f :=
begin
  split,
  { rintros ‚ü®H‚ü©,
    refine function.surjective_of_right_cancellable_Prop (Œª g‚ÇÅ g‚ÇÇ hg, _),
    rw [‚Üê equiv.ulift.symm.injective.comp_left.eq_iff],
    apply H,
    change ulift.up ‚àò (g‚ÇÅ ‚àò f) = ulift.up ‚àò (g‚ÇÇ ‚àò f),
    rw hg },
  { exact Œª H, ‚ü®Œª Z, H.injective_comp_right‚ü© }
end
lemma surjective_of_epi {X Y : Type u} (f : X ‚ü∂ Y) [hf : epi f] : function.surjective f :=
(epi_iff_surjective f).1 hf
section
def of_type_functor (m : Type u ‚Üí Type v) [_root_.functor m] [is_lawful_functor m] :
  Type u ‚•§ Type v :=
{ obj       := m,
  map       := ŒªŒ± Œ≤, _root_.functor.map,
  map_id'   := assume Œ±, _root_.functor.map_id,
  map_comp' := assume Œ± Œ≤ Œ≥ f g, funext $ assume a, is_lawful_functor.comp_map f g _ }
variables (m : Type u ‚Üí Type v) [_root_.functor m] [is_lawful_functor m]
@[simp]
lemma of_type_functor_obj : (of_type_functor m).obj = m := rfl
@[simp]
lemma of_type_functor_map {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) :
  (of_type_functor m).map f = (_root_.functor.map f : m Œ± ‚Üí m Œ≤) := rfl
end
end category_theory
def to_iso (e : X ‚âÉ Y) : X ‚âÖ Y :=
{ hom := e.to_fun,
  inv := e.inv_fun,
  hom_inv_id' := funext e.left_inv,
  inv_hom_id' := funext e.right_inv }
@[simp] lemma to_iso_hom {e : X ‚âÉ Y} : e.to_iso.hom = e := rfl
@[simp] lemma to_iso_inv {e : X ‚âÉ Y} : e.to_iso.inv = e.symm := rfl
end equiv
universe u
namespace category_theory.iso
open category_theory
variables {X Y : Type u}
def to_equiv (i : X ‚âÖ Y) : X ‚âÉ Y :=
{ to_fun := i.hom,
  inv_fun := i.inv,
  left_inv := Œª x, congr_fun i.hom_inv_id x,
  right_inv := Œª y, congr_fun i.inv_hom_id y }
@[simp] lemma to_equiv_fun (i : X ‚âÖ Y) : (i.to_equiv : X ‚Üí Y) = i.hom := rfl
@[simp] lemma to_equiv_symm_fun (i : X ‚âÖ Y) : (i.to_equiv.symm : Y ‚Üí X) = i.inv := rfl
@[simp] lemma to_equiv_id (X : Type u) : (iso.refl X).to_equiv = equiv.refl X := rfl
@[simp] lemma to_equiv_comp {X Y Z : Type u} (f : X ‚âÖ Y) (g : Y ‚âÖ Z) :
  (f ‚â™‚â´ g).to_equiv = f.to_equiv.trans (g.to_equiv) := rfl
end category_theory.iso
namespace category_theory
lemma is_iso_iff_bijective {X Y : Type u} (f : X ‚ü∂ Y) : is_iso f ‚Üî function.bijective f :=
iff.intro
  (Œª i, (by exactI as_iso f : X ‚âÖ Y).to_equiv.bijective)
  (Œª b, is_iso.of_iso (equiv.of_bijective f b).to_iso)
noncomputable instance : split_epi_category (Type u) :=
{ split_epi_of_epi := Œª X Y f hf,
  { section_ := function.surj_inv $ (epi_iff_surjective f).1 hf,
    id' := funext $ function.right_inverse_surj_inv $ (epi_iff_surjective f).1 hf } }
end category_theory
@[simps] def equiv_iso_iso {X Y : Type u} : (X ‚âÉ Y) ‚âÖ (X ‚âÖ Y) :=
{ hom := Œª e, e.to_iso,
  inv := Œª i, i.to_equiv, }
def equiv_equiv_iso {X Y : Type u} : (X ‚âÉ Y) ‚âÉ (X ‚âÖ Y) :=
(equiv_iso_iso).to_equiv
@[simp] lemma equiv_equiv_iso_hom {X Y : Type u} (e : X ‚âÉ Y) :
  equiv_equiv_iso e = e.to_iso := rfl
@[simp] lemma equiv_equiv_iso_inv {X Y : Type u} (e : X ‚âÖ Y) :
  equiv_equiv_iso.symm e = e.to_equiv := rfl
