import category_theory.concrete_category.bundled
import category_theory.discrete_category
import category_theory.types
import category_theory.bicategory.strict
universes v u
namespace category_theory
def of (C : Type u) [category.{v} C] : Cat.{v u} := bundled.of C
instance bicategory : bicategory.{(max v u) (max v u)} Cat.{v u} :=
{ hom := Œª C D, C ‚•§ D,
  id := Œª C, ùü≠ C,
  comp := Œª C D E F G, F ‚ãô G,
  hom_category := Œª C D, functor.category C D,
  whisker_left := Œª C D E F G H Œ∑, whisker_left F Œ∑,
  whisker_right := Œª C D E F G Œ∑ H, whisker_right Œ∑ H,
  associator := Œª A B C D, functor.associator,
  left_unitor :=  Œª A B, functor.left_unitor,
  right_unitor := Œª A B, functor.right_unitor,
  pentagon' := Œª A B C D E, functor.pentagon,
  triangle' := Œª A B C, functor.triangle }
instance bicategory.strict : bicategory.strict Cat.{v u} :=
{ id_comp' := Œª C D F, by cases F; refl,
  comp_id' := Œª C D F, by cases F; refl,
  assoc' := by intros; refl }
instance category : large_category.{max v u} Cat.{v u} := strict_bicategory.category Cat.{v u}
@[simp]
lemma id_map {C : Cat} {X Y : C} (f : X ‚ü∂ Y) : (ùüô C : C ‚•§ C).map f = f :=
functor.id_map f
@[simp]
lemma comp_obj {C D E : Cat} (F : C ‚ü∂ D) (G : D ‚ü∂ E) (X : C) :
  (F ‚â´ G).obj X = G.obj (F.obj X) :=
functor.comp_obj F G X
@[simp]
lemma comp_map {C D E : Cat} (F : C ‚ü∂ D) (G : D ‚ü∂ E) {X Y : C} (f : X ‚ü∂ Y) :
  (F ‚â´ G).map f = G.map (F.map f) :=
functor.comp_map F G f
def objects : Cat.{v u} ‚•§ Type u :=
{ obj := Œª C, C,
  map := Œª C D F, F.obj }
section
local attribute [simp] eq_to_hom_map
def equiv_of_iso {C D : Cat} (Œ≥ : C ‚âÖ D) : C ‚âå D :=
{ functor := Œ≥.hom,
  inverse := Œ≥.inv,
  unit_iso := eq_to_iso $ eq.symm Œ≥.hom_inv_id,
  counit_iso := eq_to_iso Œ≥.inv_hom_id }
end
end Cat
@[simps]
def Type_to_Cat : Type u ‚•§ Cat :=
{ obj := Œª X, Cat.of (discrete X),
  map := Œª X Y f, discrete.functor (discrete.mk ‚àò f),
  map_id' := Œª X, begin apply functor.ext, tidy, end,
  map_comp' := Œª X Y Z f g, begin apply functor.ext, tidy, end }
instance : faithful Type_to_Cat.{u} :=
{ map_injective' := Œª X Y f g h, funext (Œª x, congr_arg discrete.as (functor.congr_obj h ‚ü®x‚ü©)), }
instance : full Type_to_Cat.{u} :=
{ preimage := Œª X Y F, discrete.as ‚àò F.obj ‚àò discrete.mk,
  witness' :=
  begin
    intros X Y F,
    apply functor.ext,
    { intros x y f, dsimp, ext, },
    { rintros ‚ü®x‚ü©, ext, refl, }
  end }
end category_theory
