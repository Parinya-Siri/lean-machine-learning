import category_theory.over
import category_theory.adjunction.opposites
import category_theory.limits.preserves.basic
import category_theory.limits.shapes.pullbacks
import category_theory.limits.creates
import category_theory.limits.comma
noncomputable theory
@[simps]
def pullback {X Y : C} (f : X âŸ¶ Y) : over Y â¥¤ over X :=
{ obj := Î» g, over.mk (pullback.snd : pullback g.hom f âŸ¶ X),
  map := Î» g h k,
    over.hom_mk
      (pullback.lift (pullback.fst â‰« k.left) pullback.snd (by simp [pullback.condition]))
      (by tidy) }
def map_pullback_adj {A B : C} (f : A âŸ¶ B) :
  over.map f âŠ£ pullback f :=
adjunction.mk_of_hom_equiv
{ hom_equiv := Î» g h,
  { to_fun := Î» X, over.hom_mk (pullback.lift X.left g.hom (over.w X)) (pullback.lift_snd _ _ _),
    inv_fun := Î» Y,
    begin
      refine over.hom_mk _ _,
      refine Y.left â‰« pullback.fst,
      dsimp,
      rw [â† over.w Y, category.assoc, pullback.condition, category.assoc], refl,
    end,
    left_inv := Î» X, by { ext, dsimp, simp, },
    right_inv := Î» Y, begin
      ext, dsimp,
      simp only [pullback.lift_fst],
      dsimp,
      rw [pullback.lift_snd, â† over.w Y],
      refl,
    end } }
def pullback_id {A : C} : pullback (ğŸ™ A) â‰… ğŸ­ _ :=
adjunction.right_adjoint_uniq
  (map_pullback_adj _)
  (adjunction.id.of_nat_iso_left over.map_id.symm)
def pullback_comp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :
  pullback (f â‰« g) â‰… pullback g â‹™ pullback f :=
adjunction.right_adjoint_uniq
  (map_pullback_adj _)
  (((map_pullback_adj _).comp _ _ (map_pullback_adj _)).of_nat_iso_left
    (over.map_comp _ _).symm)
instance pullback_is_right_adjoint {A B : C} (f : A âŸ¶ B) :
  is_right_adjoint (pullback f) :=
âŸ¨_, map_pullback_adj fâŸ©
end
end category_theory.over
namespace category_theory.under
instance has_limit_of_has_limit_comp_forget
  (F : J â¥¤ under X) [i : has_limit (F â‹™ forget X)] : has_limit F :=
@@structured_arrow.has_limit _ _ _ _ i _
instance [has_limits_of_shape J C] : has_limits_of_shape J (under X) := {}
instance [has_limits C] : has_limits (under X) := âŸ¨infer_instanceâŸ©
instance creates_limits : creates_limits (forget X) := structured_arrow.creates_limits
@[simps]
def pushout {X Y : C} (f : X âŸ¶ Y) : under X â¥¤ under Y :=
{ obj := Î» g, under.mk (pushout.inr : Y âŸ¶ pushout g.hom f),
  map := Î» g h k,
    under.hom_mk
      (pushout.desc (k.right â‰« pushout.inl) pushout.inr (by { simp [â†pushout.condition], }))
      (by tidy) }
end
end category_theory.under
