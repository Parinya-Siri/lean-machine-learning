import category_theory.functor.const
import category_theory.discrete_category
import category_theory.yoneda
import category_theory.functor.reflects_isomorphisms
@[simps]
def cones : C·µí·µñ ‚•§ Type (max u‚ÇÅ v‚ÇÉ) := (const J).op ‚ãô yoneda.obj F
@[simps]
def cocones : C ‚•§ Type (max u‚ÇÅ v‚ÇÉ) := const J ‚ãô coyoneda.obj (op F)
end functor
section
variables (J C)
@[simps] def cones : (J ‚•§ C) ‚•§ (C·µí·µñ ‚•§ Type (max u‚ÇÅ v‚ÇÉ)) :=
{ obj := functor.cones,
  map := Œª F G f, whisker_left (const J).op (yoneda.map f) }
@[simps] def cocones : (J ‚•§ C)·µí·µñ ‚•§ (C ‚•§ Type (max u‚ÇÅ v‚ÇÉ)) :=
{ obj := Œª F, functor.cocones (unop F),
  map := Œª F G f, whisker_left (const J) (coyoneda.map f) }
end
namespace limits
section
local attribute [tidy] tactic.discrete_cases
structure cone (F : J ‚•§ C) :=
(X : C)
(œÄ : (const J).obj X ‚ü∂ F)
instance inhabited_cone (F : discrete punit ‚•§ C) : inhabited (cone F) :=
‚ü®{ X := F.obj ‚ü®‚ü®‚ü©‚ü©,
   œÄ :=
   { app := Œª ‚ü®‚ü®‚ü©‚ü©, ùüô _, }, }‚ü©
@[simp, reassoc] lemma cone.w {F : J ‚•§ C} (c : cone F) {j j' : J} (f : j ‚ü∂ j') :
  c.œÄ.app j ‚â´ F.map f = c.œÄ.app j' :=
by { rw ‚Üê c.œÄ.naturality f, apply id_comp }
structure cocone (F : J ‚•§ C) :=
(X : C)
(Œπ : F ‚ü∂ (const J).obj X)
instance inhabited_cocone (F : discrete punit ‚•§ C) : inhabited (cocone F) :=
‚ü®{ X := F.obj ‚ü®‚ü®‚ü©‚ü©,
   Œπ :=
  { app := Œª ‚ü®‚ü®‚ü©‚ü©, ùüô _, }, }‚ü©
@[simp, reassoc] lemma cocone.w {F : J ‚•§ C} (c : cocone F) {j j' : J} (f : j ‚ü∂ j') :
  F.map f ‚â´ c.Œπ.app j' = c.Œπ.app j :=
by { rw c.Œπ.naturality f, apply comp_id }
end
variables {F : J ‚•§ C}
namespace cone
@[simps]
def equiv (F : J ‚•§ C) : cone F ‚âÖ Œ£ X, F.cones.obj X :=
{ hom := Œª c, ‚ü®op c.X, c.œÄ‚ü©,
  inv := Œª c, { X := c.1.unop, œÄ := c.2 },
  hom_inv_id' := by { ext1, cases x, refl },
  inv_hom_id' := by { ext1, cases x, refl } }
@[simps] def extensions (c : cone F) :
  yoneda.obj c.X ‚ãô ulift_functor.{u‚ÇÅ} ‚ü∂ F.cones :=
{ app := Œª X f, (const J).map f.down ‚â´ c.œÄ }
@[simps] def extend (c : cone F) {X : C} (f : X ‚ü∂ c.X) : cone F :=
{ X := X,
  œÄ := c.extensions.app (op X) ‚ü®f‚ü© }
@[simps] def whisker (E : K ‚•§ J) (c : cone F) : cone (E ‚ãô F) :=
{ X := c.X,
  œÄ := whisker_left E c.œÄ }
end cone
namespace cocone
def equiv (F : J ‚•§ C) : cocone F ‚âÖ Œ£ X, F.cocones.obj X :=
{ hom := Œª c, ‚ü®c.X, c.Œπ‚ü©,
  inv := Œª c, { X := c.1, Œπ := c.2 },
  hom_inv_id' := by { ext1, cases x, refl },
  inv_hom_id' := by { ext1, cases x, refl } }
@[simps] def extensions (c : cocone F) : coyoneda.obj (op c.X) ‚ãô ulift_functor.{u‚ÇÅ} ‚ü∂ F.cocones :=
{ app := Œª X f, c.Œπ ‚â´ (const J).map f.down }
@[simps] def extend (c : cocone F) {X : C} (f : c.X ‚ü∂ X) : cocone F :=
{ X := X,
  Œπ := c.extensions.app X ‚ü®f‚ü© }
@[simps] def whisker (E : K ‚•§ J) (c : cocone F) : cocone (E ‚ãô F) :=
{ X := c.X,
  Œπ := whisker_left E c.Œπ }
end cocone
@[ext] structure cone_morphism (A B : cone F) :=
(hom : A.X ‚ü∂ B.X)
(w'  : ‚àÄ j : J, hom ‚â´ B.œÄ.app j = A.œÄ.app j . obviously)
restate_axiom cone_morphism.w'
attribute [simp, reassoc] cone_morphism.w
instance inhabited_cone_morphism (A : cone F) : inhabited (cone_morphism A A) :=
‚ü®{ hom := ùüô _ }‚ü©
@[simps] instance cone.category : category (cone F) :=
{ hom  := Œª A B, cone_morphism A B,
  comp := Œª X Y Z f g, { hom := f.hom ‚â´ g.hom },
  id   := Œª B, { hom := ùüô B.X } }
namespace cones
@[ext, simps] def ext {c c' : cone F}
  (œÜ : c.X ‚âÖ c'.X) (w : ‚àÄ j, c.œÄ.app j = œÜ.hom ‚â´ c'.œÄ.app j) : c ‚âÖ c' :=
{ hom := { hom := œÜ.hom },
  inv := { hom := œÜ.inv, w' := Œª j, œÜ.inv_comp_eq.mpr (w j) } }
lemma cone_iso_of_hom_iso {K : J ‚•§ C} {c d : cone K} (f : c ‚ü∂ d) [i : is_iso f.hom] :
  is_iso f :=
‚ü®‚ü®{ hom := inv f.hom,
    w' := Œª j, (as_iso f.hom).inv_comp_eq.2 (f.w j).symm }, by tidy‚ü©‚ü©
@[simps] def postcompose {G : J ‚•§ C} (Œ± : F ‚ü∂ G) : cone F ‚•§ cone G :=
{ obj := Œª c, { X := c.X, œÄ := c.œÄ ‚â´ Œ± },
  map := Œª c‚ÇÅ c‚ÇÇ f, { hom := f.hom } }
@[simps]
def postcompose_comp {G H : J ‚•§ C} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :
  postcompose (Œ± ‚â´ Œ≤) ‚âÖ postcompose Œ± ‚ãô postcompose Œ≤ :=
nat_iso.of_components (Œª s, cones.ext (iso.refl _) (by tidy)) (by tidy)
@[simps]
def postcompose_id : postcompose (ùüô F) ‚âÖ ùü≠ (cone F) :=
nat_iso.of_components (Œª s, cones.ext (iso.refl _) (by tidy)) (by tidy)
@[simps]
def postcompose_equivalence {G : J ‚•§ C} (Œ± : F ‚âÖ G) : cone F ‚âå cone G :=
{ functor := postcompose Œ±.hom,
  inverse := postcompose Œ±.inv,
  unit_iso := nat_iso.of_components (Œª s, cones.ext (iso.refl _) (by tidy)) (by tidy),
  counit_iso := nat_iso.of_components (Œª s, cones.ext (iso.refl _) (by tidy)) (by tidy) }
@[simps]
def whiskering (E : K ‚•§ J) : cone F ‚•§ cone (E ‚ãô F) :=
{ obj := Œª c, c.whisker E,
  map := Œª c c' f, { hom := f.hom } }
@[simps]
def whiskering_equivalence (e : K ‚âå J) :
  cone F ‚âå cone (e.functor ‚ãô F) :=
{ functor := whiskering e.functor,
  inverse := whiskering e.inverse ‚ãô postcompose (e.inv_fun_id_assoc F).hom,
  unit_iso := nat_iso.of_components (Œª s, cones.ext (iso.refl _) (by tidy)) (by tidy),
  counit_iso := nat_iso.of_components (Œª s, cones.ext (iso.refl _)
  (begin
    intro k,
@[simps functor inverse unit_iso counit_iso]
def equivalence_of_reindexing {G : K ‚•§ C}
  (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : cone F ‚âå cone G :=
(whiskering_equivalence e).trans (postcompose_equivalence Œ±)
section
variable (F)
@[simps]
def forget : cone F ‚•§ C :=
{ obj := Œª t, t.X, map := Œª s t f, f.hom }
variables (G : C ‚•§ D)
@[simps] def functoriality : cone F ‚•§ cone (F ‚ãô G) :=
{ obj := Œª A,
  { X := G.obj A.X,
    œÄ := { app := Œª j, G.map (A.œÄ.app j), naturality' := by intros; erw ‚ÜêG.map_comp; tidy } },
  map := Œª X Y f,
  { hom := G.map f.hom,
    w' := Œª j, by simp [-cone_morphism.w, ‚Üêf.w j] } }
instance functoriality_full [full G] [faithful G] : full (functoriality F G) :=
{ preimage := Œª X Y t,
  { hom := G.preimage t.hom,
    w' := Œª j, G.map_injective (by simpa using t.w j) } }
instance functoriality_faithful [faithful G] : faithful (cones.functoriality F G) :=
{ map_injective' := Œª X Y f g e, by { ext1, injection e, apply G.map_injective h_1 } }
@[simps]
def functoriality_equivalence (e : C ‚âå D) : cone F ‚âå cone (F ‚ãô e.functor) :=
let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=
  functor.associator _ _ _ ‚â™‚â´ iso_whisker_left _ (e.unit_iso).symm ‚â™‚â´ functor.right_unitor _ in
{ functor := functoriality F e.functor,
  inverse := (functoriality (F ‚ãô e.functor) e.inverse) ‚ãô
    (postcompose_equivalence f).functor,
  unit_iso := nat_iso.of_components (Œª c, cones.ext (e.unit_iso.app _) (by tidy)) (by tidy),
  counit_iso := nat_iso.of_components (Œª c, cones.ext (e.counit_iso.app _) (by tidy)) (by tidy), }
instance reflects_cone_isomorphism (F : C ‚•§ D) [reflects_isomorphisms F] (K : J ‚•§ C) :
  reflects_isomorphisms (cones.functoriality K F) :=
begin
  constructor,
  introsI,
  haveI : is_iso (F.map f.hom) :=
    (cones.forget (K ‚ãô F)).map_is_iso ((cones.functoriality K F).map f),
  haveI := reflects_isomorphisms.reflects F f.hom,
  apply cone_iso_of_hom_iso
end
end
end cones
@[ext] structure cocone_morphism (A B : cocone F) :=
(hom : A.X ‚ü∂ B.X)
(w'  : ‚àÄ j : J, A.Œπ.app j ‚â´ hom = B.Œπ.app j . obviously)
instance inhabited_cocone_morphism (A : cocone F) : inhabited (cocone_morphism A A) :=
‚ü®{ hom := ùüô _ }‚ü©
restate_axiom cocone_morphism.w'
attribute [simp, reassoc] cocone_morphism.w
@[simps] instance cocone.category : category (cocone F) :=
{ hom  := Œª A B, cocone_morphism A B,
  comp := Œª _ _ _ f g,
  { hom := f.hom ‚â´ g.hom },
  id   := Œª B, { hom := ùüô B.X } }
namespace cocones
@[ext, simps] def ext {c c' : cocone F}
  (œÜ : c.X ‚âÖ c'.X) (w : ‚àÄ j, c.Œπ.app j ‚â´ œÜ.hom = c'.Œπ.app j) : c ‚âÖ c' :=
{ hom := { hom := œÜ.hom },
  inv := { hom := œÜ.inv, w' := Œª j, œÜ.comp_inv_eq.mpr (w j).symm } }
lemma cocone_iso_of_hom_iso {K : J ‚•§ C} {c d : cocone K} (f : c ‚ü∂ d) [i : is_iso f.hom] :
  is_iso f :=
‚ü®‚ü®{ hom := inv f.hom,
    w' := Œª j, (as_iso f.hom).comp_inv_eq.2 (f.w j).symm }, by tidy‚ü©‚ü©
@[simps] def precompose {G : J ‚•§ C} (Œ± : G ‚ü∂ F) : cocone F ‚•§ cocone G :=
{ obj := Œª c, { X := c.X, Œπ := Œ± ‚â´ c.Œπ },
  map := Œª c‚ÇÅ c‚ÇÇ f, { hom := f.hom } }
def precompose_comp {G H : J ‚•§ C} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :
  precompose (Œ± ‚â´ Œ≤) ‚âÖ precompose Œ≤ ‚ãô precompose Œ± :=
nat_iso.of_components (Œª s, cocones.ext (iso.refl _) (by tidy)) (by tidy)
def precompose_id : precompose (ùüô F) ‚âÖ ùü≠ (cocone F) :=
nat_iso.of_components (Œª s, cocones.ext (iso.refl _) (by tidy)) (by tidy)
@[simps]
def precompose_equivalence {G : J ‚•§ C} (Œ± : G ‚âÖ F) : cocone F ‚âå cocone G :=
{ functor := precompose Œ±.hom,
  inverse := precompose Œ±.inv,
  unit_iso := nat_iso.of_components (Œª s, cocones.ext (iso.refl _) (by tidy)) (by tidy),
  counit_iso := nat_iso.of_components (Œª s, cocones.ext (iso.refl _) (by tidy)) (by tidy) }
@[simps]
def whiskering (E : K ‚•§ J) : cocone F ‚•§ cocone (E ‚ãô F) :=
{ obj := Œª c, c.whisker E,
  map := Œª c c' f, { hom := f.hom, } }
@[simps]
def whiskering_equivalence (e : K ‚âå J) :
  cocone F ‚âå cocone (e.functor ‚ãô F) :=
{ functor := whiskering e.functor,
  inverse := whiskering e.inverse ‚ãô
    precompose ((functor.left_unitor F).inv ‚â´ (whisker_right (e.counit_iso).inv F) ‚â´
      (functor.associator _ _ _).inv),
  unit_iso := nat_iso.of_components (Œª s, cocones.ext (iso.refl _) (by tidy)) (by tidy),
  counit_iso := nat_iso.of_components (Œª s, cocones.ext (iso.refl _)
  (begin
    intro k,
    dsimp,
    simpa [e.counit_inv_app_functor k] using s.w (e.unit.app k),
  end)) (by tidy), }
@[simps functor_obj]
def equivalence_of_reindexing {G : K ‚•§ C}
  (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : cocone F ‚âå cocone G :=
(whiskering_equivalence e).trans (precompose_equivalence Œ±.symm)
section
variable (F)
@[simps]
def forget : cocone F ‚•§ C :=
{ obj := Œª t, t.X, map := Œª s t f, f.hom }
variables (G : C ‚•§ D)
@[simps] def functoriality : cocone F ‚•§ cocone (F ‚ãô G) :=
{ obj := Œª A,
  { X := G.obj A.X,
    Œπ := { app := Œª j, G.map (A.Œπ.app j), naturality' := by intros; erw ‚ÜêG.map_comp; tidy } },
  map := Œª _ _ f,
  { hom := G.map f.hom,
    w'  := by intros; rw [‚Üêfunctor.map_comp, cocone_morphism.w] } }
instance functoriality_full [full G] [faithful G] : full (functoriality F G) :=
{ preimage := Œª X Y t,
  { hom := G.preimage t.hom,
    w' := Œª j, G.map_injective (by simpa using t.w j) } }
instance functoriality_faithful [faithful G] : faithful (functoriality F G) :=
{ map_injective' := Œª X Y f g e, by { ext1, injection e, apply G.map_injective h_1 } }
@[simps]
def functoriality_equivalence (e : C ‚âå D) : cocone F ‚âå cocone (F ‚ãô e.functor) :=
let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=
  functor.associator _ _ _ ‚â™‚â´ iso_whisker_left _ (e.unit_iso).symm ‚â™‚â´ functor.right_unitor _ in
{ functor := functoriality F e.functor,
  inverse := (functoriality (F ‚ãô e.functor) e.inverse) ‚ãô
    (precompose_equivalence f.symm).functor,
  unit_iso := nat_iso.of_components (Œª c, cocones.ext (e.unit_iso.app _) (by tidy)) (by tidy),
  counit_iso := nat_iso.of_components (Œª c, cocones.ext (e.counit_iso.app _)
  begin
instance reflects_cocone_isomorphism (F : C ‚•§ D) [reflects_isomorphisms F] (K : J ‚•§ C) :
  reflects_isomorphisms (cocones.functoriality K F) :=
begin
  constructor,
  introsI,
  haveI : is_iso (F.map f.hom) :=
    (cocones.forget (K ‚ãô F)).map_is_iso ((cocones.functoriality K F).map f),
  haveI := reflects_isomorphisms.reflects F f.hom,
  apply cocone_iso_of_hom_iso
end
end
end cocones
end limits
namespace functor
variables {F : J ‚•§ C} {G : J ‚•§ C} (H : C ‚•§ D)
open category_theory.limits
@[simps]
def map_cone   (c : cone F)   : cone (F ‚ãô H)   := (cones.functoriality F H).obj c
@[simps]
def map_cocone (c : cocone F) : cocone (F ‚ãô H) := (cocones.functoriality F H).obj c
def map_cone_morphism   {c c' : cone F}   (f : c ‚ü∂ c')   :
  H.map_cone c ‚ü∂ H.map_cone c' := (cones.functoriality F H).map f
def map_cocone_morphism {c c' : cocone F} (f : c ‚ü∂ c') :
  H.map_cocone c ‚ü∂ H.map_cocone c' := (cocones.functoriality F H).map f
def map_cone_inv [is_equivalence H]
  (c : cone (F ‚ãô H)) : cone F :=
(limits.cones.functoriality_equivalence F (as_equivalence H)).inverse.obj c
def map_cone_map_cone_inv {F : J ‚•§ D} (H : D ‚•§ C) [is_equivalence H] (c : cone (F ‚ãô H)) :
  map_cone H (map_cone_inv H c) ‚âÖ c :=
(limits.cones.functoriality_equivalence F (as_equivalence H)).counit_iso.app c
def map_cone_inv_map_cone {F : J ‚•§ D} (H : D ‚•§ C) [is_equivalence H] (c : cone F) :
  map_cone_inv H (map_cone H c) ‚âÖ c :=
(limits.cones.functoriality_equivalence F (as_equivalence H)).unit_iso.symm.app c
def map_cocone_inv [is_equivalence H]
  (c : cocone (F ‚ãô H)) : cocone F :=
(limits.cocones.functoriality_equivalence F (as_equivalence H)).inverse.obj c
def map_cocone_map_cocone_inv {F : J ‚•§ D} (H : D ‚•§ C) [is_equivalence H] (c : cocone (F ‚ãô H)) :
  map_cocone H (map_cocone_inv H c) ‚âÖ c :=
(limits.cocones.functoriality_equivalence F (as_equivalence H)).counit_iso.app c
def map_cocone_inv_map_cocone {F : J ‚•§ D} (H : D ‚•§ C) [is_equivalence H] (c : cocone F) :
  map_cocone_inv H (map_cocone H c) ‚âÖ c :=
(limits.cocones.functoriality_equivalence F (as_equivalence H)).unit_iso.symm.app c
@[simps]
def functoriality_comp_postcompose {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') :
  cones.functoriality F H ‚ãô cones.postcompose (whisker_left F Œ±.hom) ‚âÖ cones.functoriality F H' :=
nat_iso.of_components (Œª c, cones.ext (Œ±.app _) (by tidy)) (by tidy)
@[simps]
def postcompose_whisker_left_map_cone {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : cone F) :
  (cones.postcompose (whisker_left F Œ±.hom : _)).obj (H.map_cone c) ‚âÖ H'.map_cone c :=
(functoriality_comp_postcompose Œ±).app c
@[simps]
def map_cone_postcompose {Œ± : F ‚ü∂ G} {c} :
  H.map_cone ((cones.postcompose Œ±).obj c) ‚âÖ
  (cones.postcompose (whisker_right Œ± H : _)).obj (H.map_cone c) :=
cones.ext (iso.refl _) (by tidy)
@[simps]
def map_cone_postcompose_equivalence_functor {Œ± : F ‚âÖ G} {c} :
  H.map_cone ((cones.postcompose_equivalence Œ±).functor.obj c) ‚âÖ
    (cones.postcompose_equivalence (iso_whisker_right Œ± H : _)).functor.obj (H.map_cone c) :=
cones.ext (iso.refl _) (by tidy)
@[simps]
def functoriality_comp_precompose {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') :
   cocones.functoriality F H ‚ãô cocones.precompose (whisker_left F Œ±.inv)
 ‚âÖ cocones.functoriality F H' :=
nat_iso.of_components (Œª c, cocones.ext (Œ±.app _) (by tidy)) (by tidy)
@[simps]
def precompose_whisker_left_map_cocone {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : cocone F) :
  (cocones.precompose (whisker_left F Œ±.inv : _)).obj (H.map_cocone c) ‚âÖ H'.map_cocone c :=
(functoriality_comp_precompose Œ±).app c
@[simps]
def map_cocone_precompose {Œ± : F ‚ü∂ G} {c} :
  H.map_cocone ((cocones.precompose Œ±).obj c) ‚âÖ
  (cocones.precompose (whisker_right Œ± H : _)).obj (H.map_cocone c) :=
cocones.ext (iso.refl _) (by tidy)
@[simps]
def map_cocone_precompose_equivalence_functor {Œ± : F ‚âÖ G} {c} :
  H.map_cocone ((cocones.precompose_equivalence Œ±).functor.obj c) ‚âÖ
    (cocones.precompose_equivalence (iso_whisker_right Œ± H : _)).functor.obj (H.map_cocone c) :=
cocones.ext (iso.refl _) (by tidy)
@[simps]
def map_cone_whisker {E : K ‚•§ J} {c : cone F} :
  H.map_cone (c.whisker E) ‚âÖ (H.map_cone c).whisker E :=
cones.ext (iso.refl _) (by tidy)
@[simps]
def map_cocone_whisker {E : K ‚•§ J} {c : cocone F} :
  H.map_cocone (c.whisker E) ‚âÖ (H.map_cocone c).whisker E :=
cocones.ext (iso.refl _) (by tidy)
end functor
end category_theory
namespace category_theory.limits
section
variables {F : J ‚•§ C}
@[simps] def cocone.op (c : cocone F) : cone F.op :=
{ X := op c.X,
  œÄ := nat_trans.op c.Œπ }
@[simps] def cone.op (c : cone F) : cocone F.op :=
{ X := op c.X,
  Œπ := nat_trans.op c.œÄ }
@[simps] def cocone.unop (c : cocone F.op) : cone F :=
{ X := unop c.X,
  œÄ := nat_trans.remove_op c.Œπ }
@[simps] def cone.unop (c : cone F.op) : cocone F :=
{ X := unop c.X,
  Œπ := nat_trans.remove_op c.œÄ }
variables (F)
def cocone_equivalence_op_cone_op : cocone F ‚âå (cone F.op)·µí·µñ :=
{ functor :=
  { obj := Œª c, op (cocone.op c),
    map := Œª X Y f, quiver.hom.op
    { hom := f.hom.op,
      w' := Œª j, by { apply quiver.hom.unop_inj, dsimp, simp, }, } },
  inverse :=
  { obj := Œª c, cone.unop (unop c),
    map := Œª X Y f,
    { hom := f.unop.hom.unop,
      w' := Œª j, by { apply quiver.hom.op_inj, dsimp, simp, }, } },
  unit_iso := nat_iso.of_components (Œª c, cocones.ext (iso.refl _) (by tidy)) (by tidy),
  counit_iso := nat_iso.of_components (Œª c,
    by { induction c using opposite.rec,
         dsimp, apply iso.op, exact cones.ext (iso.refl _) (by tidy), })
    (Œª X Y f, quiver.hom.unop_inj (cone_morphism.ext _ _ (by { dsimp, simp }))),
  functor_unit_iso_comp' := Œª c, begin apply quiver.hom.unop_inj, ext, dsimp, simp, end }
attribute [simps] cocone_equivalence_op_cone_op
end
section
variables {F : J ‚•§ C·µí·µñ}
@[simps {rhs_md := semireducible, simp_rhs := tt}]
def cocone_left_op_of_cone (c : cone F) : cocone (F.left_op) :=
{ X := unop c.X,
  Œπ := nat_trans.left_op c.œÄ }
@[simps X]
def cocone_of_cone_left_op (c : cone F.left_op) : cocone F :=
{ X := op c.X,
  Œπ := nat_trans.remove_left_op c.œÄ }
@[simp] lemma cocone_of_cone_left_op_Œπ_app (c : cone F.left_op) (j) :
  (cocone_of_cone_left_op c).Œπ.app j = (c.œÄ.app (op j)).op :=
by { dsimp only [cocone_of_cone_left_op], simp }
@[simps {rhs_md := semireducible, simp_rhs := tt}]
def cone_left_op_of_cocone (c : cocone F) : cone (F.left_op) :=
{ X := unop c.X,
  œÄ := nat_trans.left_op c.Œπ }
end
section
variables {F : J·µí·µñ ‚•§ C}
@[simps] def cone_of_cocone_right_op (c : cocone F.right_op) : cone F :=
{ X := unop c.X,
  œÄ := nat_trans.remove_right_op c.Œπ }
@[simps] def cocone_right_op_of_cone (c : cone F) : cocone (F.right_op) :=
{ X := op c.X,
  Œπ := nat_trans.right_op c.œÄ }
@[simps] def cocone_of_cone_right_op (c : cone F.right_op) : cocone F :=
{ X := unop c.X,
  Œπ := nat_trans.remove_right_op c.œÄ }
@[simps] def cone_right_op_of_cocone (c : cocone F) : cone (F.right_op) :=
{ X := op c.X,
  œÄ := nat_trans.right_op c.Œπ }
end
section
variables {F : J·µí·µñ ‚•§ C·µí·µñ}
@[simps] def cone_of_cocone_unop (c : cocone F.unop) : cone F :=
{ X := op c.X,
  œÄ := nat_trans.remove_unop c.Œπ }
@[simps] def cocone_unop_of_cone (c : cone F) : cocone F.unop :=
{ X := unop c.X,
  Œπ := nat_trans.unop c.œÄ }
@[simps] def cocone_of_cone_unop (c : cone F.unop) : cocone F :=
{ X := op c.X,
  Œπ := nat_trans.remove_unop c.œÄ }
@[simps] def cone_unop_of_cocone (c : cocone F) : cone F.unop :=
{ X := unop c.X,
  œÄ := nat_trans.unop c.Œπ }
end
end category_theory.limits
namespace category_theory.functor
open category_theory.limits
variables {F : J ‚•§ C}
section
variables (G : C ‚•§ D)
@[simps {rhs_md := semireducible}]
def map_cone_op (t : cone F) : (G.map_cone t).op ‚âÖ (G.op.map_cocone t.op) :=
cocones.ext (iso.refl _) (by tidy)
@[simps {rhs_md := semireducible}]
def map_cocone_op {t : cocone F} : (G.map_cocone t).op ‚âÖ (G.op.map_cone t.op) :=
cones.ext (iso.refl _) (by tidy)
end
end category_theory.functor
