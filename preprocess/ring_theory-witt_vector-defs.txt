import ring_theory.witt_vector.structure_polynomial
noncomputable theory
structure witt_vector (p : â„•) (R : Type*) :=
mk [] :: (coeff : â„• â†’ R)
variables {p : â„•}
add_decl_doc witt_vector.mk
add_decl_doc witt_vector.coeff
@[ext] lemma ext {x y : ğ• R} (h : âˆ€ n, x.coeff n = y.coeff n) : x = y :=
begin
  cases x,
  cases y,
  simp only at h,
  simp [function.funext_iff, h]
end
lemma ext_iff {x y : ğ• R} : x = y â†” âˆ€ n, x.coeff n = y.coeff n :=
âŸ¨Î» h n, by rw h, extâŸ©
lemma coeff_mk (x : â„• â†’ R) :
  (mk p x).coeff = x := rfl
instance : functor (witt_vector p) :=
{ map := Î» Î± Î² f v, mk p (f âˆ˜ v.coeff),
  map_const := Î» Î± Î² a v, mk p (Î» _, a) }
instance : is_lawful_functor (witt_vector p) :=
{ map_const_eq := Î» Î± Î², rfl,
  id_map := Î» Î± âŸ¨v, _âŸ©, rfl,
  comp_map := Î» Î± Î² Î³ f g v, rfl }
variables (p) [hp : fact p.prime] [comm_ring R]
include hp
open mv_polynomial
section ring_operations
def witt_zero : â„• â†’ mv_polynomial (fin 0 Ã— â„•) â„¤ :=
witt_structure_int p 0
def witt_one : â„• â†’ mv_polynomial (fin 0 Ã— â„•) â„¤ :=
witt_structure_int p 1
def witt_add : â„• â†’ mv_polynomial (fin 2 Ã— â„•) â„¤ :=
witt_structure_int p (X 0 + X 1)
def witt_nsmul (n : â„•) : â„• â†’ mv_polynomial (fin 1 Ã— â„•) â„¤ :=
witt_structure_int p (n â€¢ X 0)
def witt_zsmul (n : â„¤) : â„• â†’ mv_polynomial (fin 1 Ã— â„•) â„¤ :=
witt_structure_int p (n â€¢ X 0)
def witt_sub : â„• â†’ mv_polynomial (fin 2 Ã— â„•) â„¤ :=
witt_structure_int p (X 0 - X 1)
def witt_mul : â„• â†’ mv_polynomial (fin 2 Ã— â„•) â„¤ :=
witt_structure_int p (X 0 * X 1)
def witt_neg : â„• â†’ mv_polynomial (fin 1 Ã— â„•) â„¤ :=
witt_structure_int p (-X 0)
def witt_pow (n : â„•) : â„• â†’ mv_polynomial (fin 1 Ã— â„•) â„¤ :=
witt_structure_int p (X 0 ^ n)
variable {p}
omit hp
def peval {k : â„•} (Ï† : mv_polynomial (fin k Ã— â„•) â„¤) (x : fin k â†’ â„• â†’ R) : R :=
aeval (function.uncurry x) Ï†
def eval {k : â„•} (Ï† : â„• â†’ mv_polynomial (fin k Ã— â„•) â„¤) (x : fin k â†’ ğ• R) : ğ• R :=
mk p $ Î» n, peval (Ï† n) $ Î» i, (x i).coeff
variables (R) [fact p.prime]
instance : has_zero (ğ• R) :=
âŸ¨eval (witt_zero p) ![]âŸ©
instance : inhabited (ğ• R) := âŸ¨0âŸ©
instance : has_one (ğ• R) :=
âŸ¨eval (witt_one p) ![]âŸ©
instance : has_add (ğ• R) :=
âŸ¨Î» x y, eval (witt_add p) ![x, y]âŸ©
instance : has_sub (ğ• R) :=
âŸ¨Î» x y, eval (witt_sub p) ![x, y]âŸ©
instance has_nat_scalar : has_smul â„• (ğ• R) :=
âŸ¨Î» n x, eval (witt_nsmul p n) ![x]âŸ©
instance has_int_scalar : has_smul â„¤ (ğ• R) :=
âŸ¨Î» n x, eval (witt_zsmul p n) ![x]âŸ©
instance : has_mul (ğ• R) :=
âŸ¨Î» x y, eval (witt_mul p) ![x, y]âŸ©
instance : has_neg (ğ• R) :=
âŸ¨Î» x, eval (witt_neg p) ![x]âŸ©
instance has_nat_pow : has_pow (ğ• R) â„• :=
âŸ¨Î» x n, eval (witt_pow p n) ![x]âŸ©
instance : has_nat_cast (ğ• R) := âŸ¨nat.unary_castâŸ©
instance : has_int_cast (ğ• R) := âŸ¨int.cast_defâŸ©
end ring_operations
section witt_structure_simplifications
@[simp] lemma witt_zero_eq_zero (n : â„•) : witt_zero p n = 0 :=
begin
  apply mv_polynomial.map_injective (int.cast_ring_hom â„š) int.cast_injective,
  simp only [witt_zero, witt_structure_rat, bindâ‚, aeval_zero',
    constant_coeff_X_in_terms_of_W, ring_hom.map_zero,
    alg_hom.map_zero, map_witt_structure_int],
end
@[simp] lemma witt_one_zero_eq_one : witt_one p 0 = 1 :=
begin
  apply mv_polynomial.map_injective (int.cast_ring_hom â„š) int.cast_injective,
  simp only [witt_one, witt_structure_rat, X_in_terms_of_W_zero, alg_hom.map_one,
    ring_hom.map_one, bindâ‚_X_right, map_witt_structure_int]
end
@[simp] lemma witt_one_pos_eq_zero (n : â„•) (hn : 0 < n) : witt_one p n = 0 :=
begin
  apply mv_polynomial.map_injective (int.cast_ring_hom â„š) int.cast_injective,
  simp only [witt_one, witt_structure_rat, ring_hom.map_zero, alg_hom.map_one,
    ring_hom.map_one, map_witt_structure_int],
  revert hn, apply nat.strong_induction_on n, clear n,
  intros n IH hn,
  rw X_in_terms_of_W_eq,
  simp only [alg_hom.map_mul, alg_hom.map_sub, alg_hom.map_sum, alg_hom.map_pow,
    bindâ‚_X_right, bindâ‚_C_right],
  rw [sub_mul, one_mul],
  rw [finset.sum_eq_single 0],
  { simp only [inv_of_eq_inv, one_mul, inv_pow, tsub_zero, ring_hom.map_one, pow_zero],
    simp only [one_pow, one_mul, X_in_terms_of_W_zero, sub_self, bindâ‚_X_right] },
  { intros i hin hi0,
    rw [finset.mem_range] at hin,
    rw [IH _ hin (nat.pos_of_ne_zero hi0), zero_pow (pow_pos hp.1.pos _), mul_zero], },
  { rw finset.mem_range, intro, contradiction }
end
@[simp] lemma witt_add_zero : witt_add p 0 = X (0,0) + X (1,0) :=
begin
  apply mv_polynomial.map_injective (int.cast_ring_hom â„š) int.cast_injective,
  simp only [witt_add, witt_structure_rat, alg_hom.map_add, ring_hom.map_add,
    rename_X, X_in_terms_of_W_zero, map_X,
     witt_polynomial_zero, bindâ‚_X_right, map_witt_structure_int],
end
@[simp] lemma witt_sub_zero : witt_sub p 0 = X (0,0) - X (1,0) :=
begin
  apply mv_polynomial.map_injective (int.cast_ring_hom â„š) int.cast_injective,
  simp only [witt_sub, witt_structure_rat, alg_hom.map_sub, ring_hom.map_sub,
    rename_X, X_in_terms_of_W_zero, map_X,
     witt_polynomial_zero, bindâ‚_X_right, map_witt_structure_int],
end
@[simp] lemma witt_mul_zero : witt_mul p 0 = X (0,0) * X (1,0) :=
begin
  apply mv_polynomial.map_injective (int.cast_ring_hom â„š) int.cast_injective,
  simp only [witt_mul, witt_structure_rat, rename_X, X_in_terms_of_W_zero, map_X,
    witt_polynomial_zero, ring_hom.map_mul,
    bindâ‚_X_right, alg_hom.map_mul, map_witt_structure_int]
end
@[simp] lemma witt_neg_zero : witt_neg p 0 = - X (0,0) :=
begin
  apply mv_polynomial.map_injective (int.cast_ring_hom â„š) int.cast_injective,
  simp only [witt_neg, witt_structure_rat, rename_X, X_in_terms_of_W_zero, map_X,
    witt_polynomial_zero, ring_hom.map_neg,
   alg_hom.map_neg, bindâ‚_X_right, map_witt_structure_int]
end
@[simp] lemma constant_coeff_witt_add (n : â„•) :
  constant_coeff (witt_add p n) = 0 :=
begin
  apply constant_coeff_witt_structure_int p _ _ n,
  simp only [add_zero, ring_hom.map_add, constant_coeff_X],
end
@[simp] lemma constant_coeff_witt_sub (n : â„•) :
  constant_coeff (witt_sub p n) = 0 :=
begin
  apply constant_coeff_witt_structure_int p _ _ n,
  simp only [sub_zero, ring_hom.map_sub, constant_coeff_X],
end
@[simp] lemma constant_coeff_witt_mul (n : â„•) :
  constant_coeff (witt_mul p n) = 0 :=
begin
  apply constant_coeff_witt_structure_int p _ _ n,
  simp only [mul_zero, ring_hom.map_mul, constant_coeff_X],
end
@[simp] lemma constant_coeff_witt_neg (n : â„•) :
  constant_coeff (witt_neg p n) = 0 :=
begin
  apply constant_coeff_witt_structure_int p _ _ n,
  simp only [neg_zero, ring_hom.map_neg, constant_coeff_X],
end
@[simp] lemma constant_coeff_witt_nsmul (m : â„•) (n : â„•):
  constant_coeff (witt_nsmul p m n) = 0 :=
begin
  apply constant_coeff_witt_structure_int p _ _ n,
  simp only [smul_zero, map_nsmul, constant_coeff_X],
end
@[simp] lemma constant_coeff_witt_zsmul (z : â„¤) (n : â„•):
  constant_coeff (witt_zsmul p z n) = 0 :=
begin
  apply constant_coeff_witt_structure_int p _ _ n,
  simp only [smul_zero, map_zsmul, constant_coeff_X],
end
end witt_structure_simplifications
section coeff
variables (p R)
@[simp] lemma zero_coeff (n : â„•) : (0 : ğ• R).coeff n = 0 :=
show (aeval _ (witt_zero p n) : R) = 0,
by simp only [witt_zero_eq_zero, alg_hom.map_zero]
@[simp] lemma one_coeff_zero : (1 : ğ• R).coeff 0 = 1 :=
show (aeval _ (witt_one p 0) : R) = 1,
by simp only [witt_one_zero_eq_one, alg_hom.map_one]
@[simp] lemma one_coeff_eq_of_pos (n : â„•) (hn : 0 < n) : coeff (1 : ğ• R) n = 0 :=
show (aeval _ (witt_one p n) : R) = 0,
by simp only [hn, witt_one_pos_eq_zero, alg_hom.map_zero]
variables {p R}
omit hp
@[simp]
lemma v2_coeff {p' R'} (x y : witt_vector p' R') (i : fin 2) :
  (![x, y] i).coeff = ![x.coeff, y.coeff] i :=
by fin_cases i; simp
include hp
lemma add_coeff (x y : ğ• R) (n : â„•) :
  (x + y).coeff n = peval (witt_add p n) ![x.coeff, y.coeff] :=
by simp [(+), eval]
lemma sub_coeff (x y : ğ• R) (n : â„•) :
  (x - y).coeff n = peval (witt_sub p n) ![x.coeff, y.coeff] :=
by simp [has_sub.sub, eval]
lemma mul_coeff (x y : ğ• R) (n : â„•) :
  (x * y).coeff n = peval (witt_mul p n) ![x.coeff, y.coeff] :=
by simp [(*), eval]
lemma neg_coeff (x : ğ• R) (n : â„•) :
  (-x).coeff n = peval (witt_neg p n) ![x.coeff] :=
by simp [has_neg.neg, eval, matrix.cons_fin_one]
lemma nsmul_coeff (m : â„•) (x : ğ• R) (n : â„•) :
  (m â€¢ x).coeff n = peval (witt_nsmul p m n) ![x.coeff] :=
by simp [has_smul.smul, eval, matrix.cons_fin_one]
lemma zsmul_coeff (m : â„¤) (x : ğ• R) (n : â„•) :
  (m â€¢ x).coeff n = peval (witt_zsmul p m n) ![x.coeff] :=
by simp [has_smul.smul, eval, matrix.cons_fin_one]
lemma pow_coeff (m : â„•) (x : ğ• R) (n : â„•) :
  (x ^ m).coeff n = peval (witt_pow p m n) ![x.coeff] :=
by simp [has_pow.pow, eval, matrix.cons_fin_one]
lemma add_coeff_zero (x y : ğ• R) : (x + y).coeff 0 = x.coeff 0 + y.coeff 0 :=
by simp [add_coeff, peval]
lemma mul_coeff_zero (x y : ğ• R) : (x * y).coeff 0 = x.coeff 0 * y.coeff 0 :=
by simp [mul_coeff, peval]
end coeff
lemma witt_add_vars (n : â„•) :
  (witt_add p n).vars âŠ† finset.univ.product (finset.range (n + 1)) :=
witt_structure_int_vars _ _ _
lemma witt_sub_vars (n : â„•) :
  (witt_sub p n).vars âŠ† finset.univ.product (finset.range (n + 1)) :=
witt_structure_int_vars _ _ _
lemma witt_mul_vars (n : â„•) :
  (witt_mul p n).vars âŠ† finset.univ.product (finset.range (n + 1)) :=
witt_structure_int_vars _ _ _
lemma witt_neg_vars (n : â„•) :
  (witt_neg p n).vars âŠ† finset.univ.product (finset.range (n + 1)) :=
witt_structure_int_vars _ _ _
lemma witt_nsmul_vars (m : â„•) (n : â„•) :
  (witt_nsmul p m n).vars âŠ† finset.univ.product (finset.range (n + 1)) :=
witt_structure_int_vars _ _ _
lemma witt_zsmul_vars (m : â„¤) (n : â„•) :
  (witt_zsmul p m n).vars âŠ† finset.univ.product (finset.range (n + 1)) :=
witt_structure_int_vars _ _ _
lemma witt_pow_vars (m : â„•) (n : â„•) :
  (witt_pow p m n).vars âŠ† finset.univ.product (finset.range (n + 1)) :=
witt_structure_int_vars _ _ _
end witt_vector
