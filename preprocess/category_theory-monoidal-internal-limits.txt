import category_theory.monoidal.internal.functor_category
import category_theory.monoidal.limits
import category_theory.limits.preserves.basic
open category_theory
open category_theory.limits
open category_theory.monoidal
universes v u
noncomputable theory
namespace Mon_
variables {J : Type v} [small_category J]
variables {C : Type u} [category.{v} C] [has_limits C] [monoidal_category.{v} C]
@[simps]
def limit (F : J â¥¤ Mon_ C) : Mon_ C :=
lim_lax.map_Mon.obj (Mon_functor_category_equivalence.inverse.obj F)
@[simps]
def limit_cone (F : J â¥¤ Mon_ C) : cone F :=
{ X := limit F,
  Ï€ :=
  { app := Î» j, { hom := limit.Ï€ (F â‹™ Mon_.forget C) j, },
    naturality' := Î» j j' f, by { ext, exact (limit.cone (F â‹™ Mon_.forget C)).Ï€.naturality f, } } }
def forget_map_cone_limit_cone_iso (F : J â¥¤ Mon_ C) :
  (forget C).map_cone (limit_cone F) â‰… limit.cone (F â‹™ forget C) :=
cones.ext (iso.refl _) (Î» j, (by tidy))
@[simps]
def limit_cone_is_limit (F : J â¥¤ Mon_ C) : is_limit (limit_cone F) :=
{ lift := Î» s,
  { hom := limit.lift (F â‹™ Mon_.forget C) ((Mon_.forget C).map_cone s),
    mul_hom' :=
    begin
      ext, dsimp, simp, dsimp,
      slice_rhs 1 2 { rw [â†monoidal_category.tensor_comp, limit.lift_Ï€], dsimp, }
    end },
  fac' := Î» s h, by { ext, simp, },
  uniq' := Î» s m w,
  begin
    ext,
    dsimp, simp only [Mon_.forget_map, limit.lift_Ï€, functor.map_cone_Ï€_app],
    exact congr_arg Mon_.hom.hom (w j),
  end, }
instance has_limits : has_limits (Mon_ C) :=
{ has_limits_of_shape := Î» J ğ’¥, by exactI
  { has_limit := Î» F, has_limit.mk
    { cone     := limit_cone F,
      is_limit := limit_cone_is_limit F } } }
instance forget_preserves_limits : preserves_limits (Mon_.forget C) :=
{ preserves_limits_of_shape := Î» J ğ’¥, by exactI
  { preserves_limit := Î» F : J â¥¤ Mon_ C, preserves_limit_of_preserves_limit_cone
    (limit_cone_is_limit F)
    (is_limit.of_iso_limit
      (limit.is_limit (F â‹™ Mon_.forget C))
      (forget_map_cone_limit_cone_iso F).symm) } }
end Mon_
