import algebra.ring.pi
import algebra.category.Ring.basic
import algebra.category.Group.limits
import ring_theory.subring.basic
library_note "change elaboration strategy with `by apply`"
open category_theory
open category_theory.limits
universes v u
noncomputable theory
namespace SemiRing
variables {J : Type v} [small_category J]
instance semiring_obj (F : J ‚•§ SemiRing.{max v u}) (j) :
  semiring ((F ‚ãô forget SemiRing).obj j) :=
by { change semiring (F.obj j), apply_instance }
def sections_subsemiring (F : J ‚•§ SemiRing.{max v u}) :
  subsemiring (Œ† j, F.obj j) :=
{ carrier := (F ‚ãô forget SemiRing).sections,
  ..(AddMon.sections_add_submonoid
      (F ‚ãô forget‚ÇÇ SemiRing AddCommMon.{max v u} ‚ãô forget‚ÇÇ AddCommMon AddMon.{max v u})),
  ..(Mon.sections_submonoid (F ‚ãô forget‚ÇÇ SemiRing Mon.{max v u})) }
instance limit_semiring (F : J ‚•§ SemiRing.{max v u}) :
  semiring (types.limit_cone (F ‚ãô forget SemiRing.{max v u})).X :=
(sections_subsemiring F).to_semiring
def limit_œÄ_ring_hom (F : J ‚•§ SemiRing.{max v u}) (j) :
  (types.limit_cone (F ‚ãô forget SemiRing)).X ‚Üí+* (F ‚ãô forget SemiRing).obj j :=
{ to_fun := (types.limit_cone (F ‚ãô forget SemiRing)).œÄ.app j,
  ..AddMon.limit_œÄ_add_monoid_hom
      (F ‚ãô forget‚ÇÇ SemiRing AddCommMon.{max v u} ‚ãô forget‚ÇÇ AddCommMon AddMon.{max v u}) j,
  ..Mon.limit_œÄ_monoid_hom (F ‚ãô forget‚ÇÇ SemiRing Mon.{max v u}) j, }
namespace has_limits
def limit_cone (F : J ‚•§ SemiRing.{max v u}) : cone F :=
{ X := SemiRing.of (types.limit_cone (F ‚ãô forget _)).X,
  œÄ :=
  { app := limit_œÄ_ring_hom F,
    naturality' := Œª j j' f,
      ring_hom.coe_inj ((types.limit_cone (F ‚ãô forget _)).œÄ.naturality f) } }
def limit_cone_is_limit (F : J ‚•§ SemiRing.{max v u}) : is_limit (limit_cone F) :=
begin
  refine is_limit.of_faithful
    (forget SemiRing) (types.limit_cone_is_limit _)
    (Œª s, ‚ü®_, _, _, _, _‚ü©) (Œª s, rfl); tidy
end
end has_limits
open has_limits
@[irreducible]
instance has_limits_of_size : has_limits_of_size.{v} SemiRing.{max v u} :=
{ has_limits_of_shape := Œª J ùí•, by exactI
  { has_limit := Œª F, has_limit.mk
    { cone     := limit_cone F,
      is_limit := limit_cone_is_limit F } } }
instance has_limits : has_limits SemiRing.{u} := SemiRing.has_limits_of_size.{u u}
def forget‚ÇÇ_AddCommMon_preserves_limits_aux (F : J ‚•§ SemiRing.{max v u}) :
  is_limit ((forget‚ÇÇ SemiRing AddCommMon).map_cone (limit_cone F)) :=
by apply AddCommMon.limit_cone_is_limit (F ‚ãô forget‚ÇÇ SemiRing AddCommMon.{max v u})
instance forget‚ÇÇ_AddCommMon_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget‚ÇÇ SemiRing AddCommMon.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F, preserves_limit_of_preserves_limit_cone
      (limit_cone_is_limit F) (forget‚ÇÇ_AddCommMon_preserves_limits_aux F) } }
instance forget‚ÇÇ_AddCommMon_preserves_limits : preserves_limits (forget‚ÇÇ SemiRing AddCommMon.{u}) :=
SemiRing.forget‚ÇÇ_AddCommMon_preserves_limits_of_size.{u u}
def forget‚ÇÇ_Mon_preserves_limits_aux (F : J ‚•§ SemiRing.{max v u}) :
  is_limit ((forget‚ÇÇ SemiRing Mon).map_cone (limit_cone F)) :=
by apply Mon.has_limits.limit_cone_is_limit (F ‚ãô forget‚ÇÇ SemiRing Mon.{max v u})
instance forget‚ÇÇ_Mon_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget‚ÇÇ SemiRing Mon.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F, preserves_limit_of_preserves_limit_cone
    (limit_cone_is_limit F) (forget‚ÇÇ_Mon_preserves_limits_aux F) } }
instance forget‚ÇÇ_Mon_preserves_limits : preserves_limits (forget‚ÇÇ SemiRing Mon.{u}) :=
SemiRing.forget‚ÇÇ_Mon_preserves_limits_of_size.{u u}
instance forget_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget SemiRing.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F, preserves_limit_of_preserves_limit_cone
    (limit_cone_is_limit F) (types.limit_cone_is_limit (F ‚ãô forget _)) } }
instance forget_preserves_limits : preserves_limits (forget SemiRing.{u}) :=
SemiRing.forget_preserves_limits_of_size.{u u}
end SemiRing
namespace CommSemiRing
variables {J : Type v} [small_category J]
instance comm_semiring_obj (F : J ‚•§ CommSemiRing.{max v u}) (j) :
  comm_semiring ((F ‚ãô forget CommSemiRing).obj j) :=
by { change comm_semiring (F.obj j), apply_instance }
instance limit_comm_semiring (F : J ‚•§ CommSemiRing.{max v u}) :
  comm_semiring (types.limit_cone (F ‚ãô forget CommSemiRing.{max v u})).X :=
@subsemiring.to_comm_semiring (Œ† j, F.obj j) _
  (SemiRing.sections_subsemiring (F ‚ãô forget‚ÇÇ CommSemiRing SemiRing.{max v u}))
instance (F : J ‚•§ CommSemiRing.{max v u}) :
  creates_limit F (forget‚ÇÇ CommSemiRing SemiRing.{max v u}) :=
creates_limit_of_reflects_iso (Œª c' t,
{ lifted_cone :=
  { X := CommSemiRing.of (types.limit_cone (F ‚ãô forget _)).X,
    œÄ :=
    { app := by apply SemiRing.limit_œÄ_ring_hom (F ‚ãô forget‚ÇÇ CommSemiRing SemiRing.{max v u}),
      naturality' := (SemiRing.has_limits.limit_cone
        (F ‚ãô forget‚ÇÇ CommSemiRing SemiRing.{max v u})).œÄ.naturality, } },
  valid_lift := by apply is_limit.unique_up_to_iso (SemiRing.has_limits.limit_cone_is_limit _) t,
  makes_limit := is_limit.of_faithful (forget‚ÇÇ CommSemiRing SemiRing.{max v u})
    (by apply SemiRing.has_limits.limit_cone_is_limit _)
    (Œª s, (SemiRing.has_limits.limit_cone_is_limit _).lift ((forget‚ÇÇ _ SemiRing).map_cone s))
    (Œª s, rfl) })
def limit_cone (F : J ‚•§ CommSemiRing.{max v u}) : cone F :=
lift_limit (limit.is_limit (F ‚ãô (forget‚ÇÇ CommSemiRing SemiRing.{max v u})))
def limit_cone_is_limit (F : J ‚•§ CommSemiRing.{max v u}) : is_limit (limit_cone F) :=
lifted_limit_is_limit _
@[irreducible]
instance has_limits_of_size : has_limits_of_size.{v v} CommSemiRing.{max v u} :=
{ has_limits_of_shape := Œª J ùí•, by exactI
  { has_limit := Œª F, has_limit_of_created F (forget‚ÇÇ CommSemiRing SemiRing.{max v u}) } }
instance has_limits : has_limits CommSemiRing.{u} := CommSemiRing.has_limits_of_size.{u u}
instance forget‚ÇÇ_SemiRing_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget‚ÇÇ CommSemiRing SemiRing.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•,
  { preserves_limit := Œª F, by apply_instance } }
instance forget‚ÇÇ_SemiRing_preserves_limits : preserves_limits (forget‚ÇÇ CommSemiRing SemiRing.{u}) :=
CommSemiRing.forget‚ÇÇ_SemiRing_preserves_limits_of_size.{u u}
instance forget_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget CommSemiRing.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F,
    limits.comp_preserves_limit (forget‚ÇÇ CommSemiRing SemiRing) (forget SemiRing) } }
instance forget_preserves_limits : preserves_limits (forget CommSemiRing.{u}) :=
CommSemiRing.forget_preserves_limits_of_size.{u u}
end CommSemiRing
namespace Ring
variables {J : Type v} [small_category J]
instance ring_obj (F : J ‚•§ Ring.{max v u}) (j) :
  ring ((F ‚ãô forget Ring).obj j) :=
by { change ring (F.obj j), apply_instance }
def sections_subring (F : J ‚•§ Ring.{max v u}) :
  subring (Œ† j, F.obj j) :=
{ carrier := (F ‚ãô forget Ring).sections,
  .. AddGroup.sections_add_subgroup
      (F ‚ãô forget‚ÇÇ Ring AddCommGroup.{max v u} ‚ãô forget‚ÇÇ AddCommGroup AddGroup.{max v u}),
  .. SemiRing.sections_subsemiring (F ‚ãô forget‚ÇÇ Ring SemiRing.{max v u}) }
instance limit_ring (F : J ‚•§ Ring.{max v u}) :
  ring (types.limit_cone (F ‚ãô forget Ring.{max v u})).X :=
(sections_subring F).to_ring
instance (F : J ‚•§ Ring.{max v u}) : creates_limit F (forget‚ÇÇ Ring SemiRing.{max v u}) :=
creates_limit_of_reflects_iso (Œª c' t,
{ lifted_cone :=
  { X := Ring.of (types.limit_cone (F ‚ãô forget _)).X,
    œÄ :=
    { app := by apply SemiRing.limit_œÄ_ring_hom (F ‚ãô forget‚ÇÇ Ring SemiRing.{max v u}),
      naturality' :=
        (SemiRing.has_limits.limit_cone (F ‚ãô forget‚ÇÇ Ring SemiRing.{max v u})).œÄ.naturality, } },
  valid_lift := by apply is_limit.unique_up_to_iso (SemiRing.has_limits.limit_cone_is_limit _) t,
  makes_limit := is_limit.of_faithful (forget‚ÇÇ Ring SemiRing.{max v u})
    (by apply SemiRing.has_limits.limit_cone_is_limit _)
    (Œª s, _) (Œª s, rfl) })
def limit_cone (F : J ‚•§ Ring.{max v u}) : cone F :=
lift_limit (limit.is_limit (F ‚ãô (forget‚ÇÇ Ring SemiRing.{max v u})))
def limit_cone_is_limit (F : J ‚•§ Ring.{max v u}) : is_limit (limit_cone F) :=
lifted_limit_is_limit _
@[irreducible]
instance has_limits_of_size : has_limits_of_size.{v v} Ring.{max v u} :=
{ has_limits_of_shape := Œª J ùí•, by exactI
  { has_limit := Œª F, has_limit_of_created F (forget‚ÇÇ Ring SemiRing.{max v u}) } }
instance has_limits : has_limits Ring.{u} := Ring.has_limits_of_size.{u u}
instance forget‚ÇÇ_SemiRing_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget‚ÇÇ Ring SemiRing.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•,
  { preserves_limit := Œª F, by apply_instance } }
instance forget‚ÇÇ_SemiRing_preserves_limits : preserves_limits (forget‚ÇÇ Ring SemiRing.{u}) :=
Ring.forget‚ÇÇ_SemiRing_preserves_limits_of_size.{u u}
def forget‚ÇÇ_AddCommGroup_preserves_limits_aux (F : J ‚•§ Ring.{max v u}) :
  is_limit ((forget‚ÇÇ Ring AddCommGroup).map_cone (limit_cone F)) :=
by apply AddCommGroup.limit_cone_is_limit (F ‚ãô forget‚ÇÇ Ring AddCommGroup.{max v u})
instance forget‚ÇÇ_AddCommGroup_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget‚ÇÇ Ring AddCommGroup.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F, preserves_limit_of_preserves_limit_cone
    (limit_cone_is_limit F) (forget‚ÇÇ_AddCommGroup_preserves_limits_aux F) } }
instance forget‚ÇÇ_AddCommGroup_preserves_limits : preserves_limits (forget‚ÇÇ Ring AddCommGroup.{u}) :=
Ring.forget‚ÇÇ_AddCommGroup_preserves_limits_of_size.{u u}
instance forget_preserves_limits_of_size : preserves_limits_of_size.{v v} (forget Ring.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F,
    limits.comp_preserves_limit (forget‚ÇÇ Ring SemiRing) (forget SemiRing.{max v u}) } }
instance forget_preserves_limits : preserves_limits (forget Ring.{u}) :=
Ring.forget_preserves_limits_of_size.{u u}
end Ring
namespace CommRing
variables {J : Type v} [small_category J]
instance comm_ring_obj (F : J ‚•§ CommRing.{max v u}) (j) :
  comm_ring ((F ‚ãô forget CommRing).obj j) :=
by { change comm_ring (F.obj j), apply_instance }
instance limit_comm_ring (F : J ‚•§ CommRing.{max v u}) :
  comm_ring (types.limit_cone (F ‚ãô forget CommRing.{max v u})).X :=
@subring.to_comm_ring (Œ† j, F.obj j) _
  (Ring.sections_subring (F ‚ãô forget‚ÇÇ CommRing Ring.{max v u}))
instance (F : J ‚•§ CommRing.{max v u}) : creates_limit F (forget‚ÇÇ CommRing Ring.{max v u}) :=
creates_limit_of_reflects_iso (Œª c' t,
{ lifted_cone :=
  { X := CommRing.of (types.limit_cone (F ‚ãô forget _)).X,
    œÄ :=
    { app := by apply
        SemiRing.limit_œÄ_ring_hom
          (F ‚ãô forget‚ÇÇ CommRing Ring.{max v u} ‚ãô forget‚ÇÇ Ring SemiRing.{max v u}),
      naturality' := (SemiRing.has_limits.limit_cone
        (F ‚ãô forget‚ÇÇ _ Ring.{max v u} ‚ãô forget‚ÇÇ _ SemiRing.{max v u})).œÄ.naturality } },
  valid_lift := by apply is_limit.unique_up_to_iso (Ring.limit_cone_is_limit _) t,
  makes_limit := is_limit.of_faithful (forget‚ÇÇ _ Ring.{max v u})
    (by apply Ring.limit_cone_is_limit (F ‚ãô forget‚ÇÇ CommRing Ring.{max v u}))
    (Œª s, (Ring.limit_cone_is_limit _).lift ((forget‚ÇÇ _ Ring.{max v u}).map_cone s)) (Œª s, rfl) })
def limit_cone (F : J ‚•§ CommRing.{max v u}) : cone F :=
lift_limit (limit.is_limit (F ‚ãô (forget‚ÇÇ CommRing Ring.{max v u})))
def limit_cone_is_limit (F : J ‚•§ CommRing.{max v u}) : is_limit (limit_cone F) :=
lifted_limit_is_limit _
@[irreducible]
instance has_limits_of_size : has_limits_of_size.{v v} CommRing.{max v u} :=
{ has_limits_of_shape := Œª J ùí•, by exactI
  { has_limit := Œª F, has_limit_of_created F (forget‚ÇÇ CommRing Ring.{max v u}) } }
instance has_limits : has_limits CommRing.{u} := CommRing.has_limits_of_size.{u u}
instance forget‚ÇÇ_Ring_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget‚ÇÇ CommRing Ring.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•,
  { preserves_limit := Œª F, by apply_instance } }
instance forget‚ÇÇ_Ring_preserves_limits : preserves_limits (forget‚ÇÇ CommRing Ring.{u}) :=
CommRing.forget‚ÇÇ_Ring_preserves_limits_of_size.{u u}
def forget‚ÇÇ_CommSemiRing_preserves_limits_aux (F : J ‚•§ CommRing.{max v u}) :
  is_limit ((forget‚ÇÇ CommRing CommSemiRing).map_cone (limit_cone F)) :=
by apply CommSemiRing.limit_cone_is_limit (F ‚ãô forget‚ÇÇ CommRing CommSemiRing.{max v u})
instance forget‚ÇÇ_CommSemiRing_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget‚ÇÇ CommRing CommSemiRing.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F, preserves_limit_of_preserves_limit_cone
    (limit_cone_is_limit F) (forget‚ÇÇ_CommSemiRing_preserves_limits_aux F) } }
instance forget‚ÇÇ_CommSemiRing_preserves_limits :
  preserves_limits (forget‚ÇÇ CommRing CommSemiRing.{u}) :=
CommRing.forget‚ÇÇ_CommSemiRing_preserves_limits_of_size.{u u}
instance forget_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget CommRing.{max v u}) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F, limits.comp_preserves_limit (forget‚ÇÇ CommRing Ring) (forget Ring) } }
instance forget_preserves_limits : preserves_limits (forget CommRing.{u}) :=
CommRing.forget_preserves_limits_of_size.{u u}
end CommRing
