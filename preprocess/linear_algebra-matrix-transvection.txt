import data.matrix.basis
import data.matrix.dmatrix
import linear_algebra.matrix.determinant
import linear_algebra.matrix.trace
import linear_algebra.matrix.reindex
import tactic.field_simp
universes u‚ÇÅ u‚ÇÇ
namespace matrix
open_locale matrix
variables (n p : Type*) (R : Type u‚ÇÇ) {ùïú : Type*} [field ùïú]
variables [decidable_eq n] [decidable_eq p]
variables [comm_ring R]
section transvection
variables {R n} (i j : n)
def transvection (c : R) : matrix n n R := 1 + matrix.std_basis_matrix i j c
@[simp] lemma transvection_zero : transvection i j (0 : R) = 1 :=
by simp [transvection]
section
variable [fintype n]
lemma update_row_eq_transvection (c : R) :
  update_row (1 : matrix n n R) i (((1 : matrix n n R)) i + c ‚Ä¢ (1 : matrix n n R) j) =
    transvection i j c :=
begin
  ext a b,
  by_cases ha : i = a, by_cases hb : j = b,
  { simp only [update_row, transvection, ha, hb, function.update_same, std_basis_matrix.apply_same,
      pi.add_apply, one_apply_eq, pi.smul_apply, mul_one, algebra.id.smul_eq_mul], },
  { simp only [update_row, transvection, ha, hb, std_basis_matrix.apply_of_ne, function.update_same,
      pi.add_apply, ne.def, not_false_iff, pi.smul_apply, and_false, one_apply_ne,
      algebra.id.smul_eq_mul, mul_zero] },
  { simp only [update_row, transvection, ha, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero,
      algebra.id.smul_eq_mul, function.update_noteq, ne.def, not_false_iff, dmatrix.add_apply,
      pi.smul_apply, mul_zero, false_and] },
end
lemma transvection_mul_transvection_same (h : i ‚â† j) (c d : R) :
  transvection i j c ‚¨ù transvection i j d = transvection i j (c + d) :=
by simp [transvection, matrix.add_mul, matrix.mul_add, h, h.symm, add_smul, add_assoc,
    std_basis_matrix_add]
@[simp] lemma transvection_mul_apply_same (b : n) (c : R) (M : matrix n n R) :
  (transvection i j c ‚¨ù M) i b = M i b + c * M j b :=
by simp [transvection, matrix.add_mul]
@[simp] lemma mul_transvection_apply_same (a : n) (c : R) (M : matrix n n R) :
  (M ‚¨ù transvection i j c) a j = M a j + c * M a i :=
by simp [transvection, matrix.mul_add, mul_comm]
@[simp] lemma transvection_mul_apply_of_ne (a b : n) (ha : a ‚â† i) (c : R) (M : matrix n n R) :
  (transvection i j c ‚¨ù M) a b = M a b :=
by simp [transvection, matrix.add_mul, ha]
@[simp] lemma mul_transvection_apply_of_ne (a b : n) (hb : b ‚â† j) (c : R) (M : matrix n n R) :
  (M ‚¨ù transvection i j c) a b = M a b :=
by simp [transvection, matrix.mul_add, hb]
@[simp] lemma det_transvection_of_ne (h : i ‚â† j) (c : R) : det (transvection i j c) = 1 :=
by rw [‚Üê update_row_eq_transvection i j, det_update_row_add_smul_self _ h, det_one]
end
variables (R n)
@[nolint has_inhabited_instance]
structure transvection_struct :=
(i j : n)
(hij : i ‚â† j)
(c : R)
instance [nontrivial n] : nonempty (transvection_struct n R) :=
by { choose x y hxy using exists_pair_ne n, exact ‚ü®‚ü®x, y, hxy, 0‚ü©‚ü© }
namespace transvection_struct
variables {R n}
def to_matrix (t : transvection_struct n R) : matrix n n R :=
transvection t.i t.j t.c
@[simp] lemma to_matrix_mk (i j : n) (hij : i ‚â† j) (c : R) :
  transvection_struct.to_matrix ‚ü®i, j, hij, c‚ü© = transvection i j c := rfl
@[simp] protected lemma det [fintype n] (t : transvection_struct n R) : det t.to_matrix = 1 :=
det_transvection_of_ne _ _ t.hij _
@[simp] lemma det_to_matrix_prod [fintype n] (L : list (transvection_struct n ùïú)) :
  det ((L.map to_matrix).prod) = 1 :=
begin
  induction L with t L IH,
  { simp },
  { simp [IH], }
end
@[simps] protected def inv (t : transvection_struct n R) : transvection_struct n R :=
{ i := t.i,
  j := t.j,
  hij := t.hij,
  c := - t.c }
section
variable [fintype n]
lemma inv_mul (t : transvection_struct n R) :
  t.inv.to_matrix ‚¨ù t.to_matrix = 1 :=
by { rcases t, simp [to_matrix, transvection_mul_transvection_same, t_hij] }
lemma mul_inv (t : transvection_struct n R) :
  t.to_matrix ‚¨ù t.inv.to_matrix = 1 :=
by { rcases t, simp [to_matrix, transvection_mul_transvection_same, t_hij] }
lemma reverse_inv_prod_mul_prod (L : list (transvection_struct n R)) :
  (L.reverse.map (to_matrix ‚àò transvection_struct.inv)).prod ‚¨ù (L.map to_matrix).prod = 1 :=
begin
  induction L with t L IH,
  { simp },
  { suffices : (L.reverse.map (to_matrix ‚àò transvection_struct.inv)).prod ‚¨ù
      (t.inv.to_matrix ‚¨ù t.to_matrix) ‚¨ù (L.map to_matrix).prod = 1, by simpa [matrix.mul_assoc],
    simpa [inv_mul] using IH, }
end
lemma prod_mul_reverse_inv_prod (L : list (transvection_struct n R)) :
  (L.map to_matrix).prod ‚¨ù (L.reverse.map (to_matrix ‚àò transvection_struct.inv)).prod = 1 :=
begin
  induction L with t L IH,
  { simp },
  { suffices : t.to_matrix ‚¨ù ((L.map to_matrix).prod ‚¨ù
      (L.reverse.map (to_matrix ‚àò transvection_struct.inv)).prod) ‚¨ù t.inv.to_matrix = 1,
        by simpa [matrix.mul_assoc],
    simp_rw [IH, matrix.mul_one, t.mul_inv], }
end
end
variables (p)
open sum
def sum_inl (t : transvection_struct n R) : transvection_struct (n ‚äï p) R :=
{ i := inl t.i,
  j := inl t.j,
  hij := by simp [t.hij],
  c := t.c }
lemma to_matrix_sum_inl (t : transvection_struct n R) :
  (t.sum_inl p).to_matrix = from_blocks t.to_matrix 0 0 1 :=
begin
  cases t,
  ext a b,
  cases a; cases b,
  { by_cases h : a = b;
    simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix], },
  { simp [transvection_struct.sum_inl, transvection] },
  { simp [transvection_struct.sum_inl, transvection] },
  { by_cases h : a = b;
    simp [transvection_struct.sum_inl, transvection, h] },
end
@[simp] lemma sum_inl_to_matrix_prod_mul [fintype n] [fintype p]
  (M : matrix n n R) (L : list (transvection_struct n R)) (N : matrix p p R) :
  (L.map (to_matrix ‚àò sum_inl p)).prod ‚¨ù from_blocks M 0 0 N
  = from_blocks ((L.map to_matrix).prod ‚¨ù M) 0 0 N :=
begin
  induction L with t L IH,
  { simp },
  { simp [matrix.mul_assoc, IH, to_matrix_sum_inl, from_blocks_multiply], },
end
@[simp] lemma mul_sum_inl_to_matrix_prod [fintype n] [fintype p]
  (M : matrix n n R) (L : list (transvection_struct n R)) (N : matrix p p R) :
  (from_blocks M 0 0 N) ‚¨ù (L.map (to_matrix ‚àò sum_inl p)).prod
  = from_blocks (M ‚¨ù (L.map to_matrix).prod) 0 0 N :=
begin
  induction L with t L IH generalizing M N,
  { simp },
  { simp [IH, to_matrix_sum_inl, from_blocks_multiply], },
end
variable {p}
def reindex_equiv (e : n ‚âÉ p) (t : transvection_struct n R) : transvection_struct p R :=
{ i := e t.i,
  j := e t.j,
  hij := by simp [t.hij],
  c := t.c }
variables [fintype n] [fintype p]
lemma to_matrix_reindex_equiv (e : n ‚âÉ p) (t : transvection_struct n R) :
  (t.reindex_equiv e).to_matrix = reindex_alg_equiv R e t.to_matrix :=
begin
  cases t,
  ext a b,
  simp only [reindex_equiv, transvection, mul_boole, algebra.id.smul_eq_mul, to_matrix_mk,
    minor_apply, reindex_apply, dmatrix.add_apply, pi.smul_apply, reindex_alg_equiv_apply],
  by_cases ha : e t_i = a; by_cases hb : e t_j = b; by_cases hab : a = b;
  simp [ha, hb, hab, ‚Üê e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
end
lemma to_matrix_reindex_equiv_prod (e : n ‚âÉ p) (L : list (transvection_struct n R)) :
  (L.map (to_matrix ‚àò (reindex_equiv e))).prod = reindex_alg_equiv R e (L.map to_matrix).prod :=
begin
  induction L with t L IH,
  { simp },
  { simp only [to_matrix_reindex_equiv, IH, function.comp_app, list.prod_cons, mul_eq_mul,
      reindex_alg_equiv_apply, list.map],
    exact (reindex_alg_equiv_mul _ _ _ _).symm }
end
end transvection_struct
end transvection
namespace pivot
variables {R} {r : ‚Ñï} (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú)
open sum unit fin transvection_struct
def list_transvec_col : list (matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) :=
list.of_fn $ Œª i : fin r, transvection (inl i) (inr star) $
  -M (inl i) (inr star) / M (inr star) (inr star)
def list_transvec_row : list (matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) :=
list.of_fn $ Œª i : fin r, transvection (inr star) (inl i) $
  -M (inr star) (inl i) / M (inr star) (inr star)
lemma list_transvec_col_mul_last_row_drop (i : fin r ‚äï unit) {k : ‚Ñï} (hk : k ‚â§ r) :
  (((list_transvec_col M).drop k).prod ‚¨ù M) (inr star) i = M (inr star) i :=
begin
  apply nat.decreasing_induction' _ hk,
  { simp only [list_transvec_col, list.length_of_fn, matrix.one_mul, list.drop_eq_nil_of_le,
      list.prod_nil], },
  { assume n hn hk IH,
    have hn' : n < (list_transvec_col M).length, by simpa [list_transvec_col] using hn,
    rw ‚Üê list.cons_nth_le_drop_succ hn',
    simpa [list_transvec_col, matrix.mul_assoc] }
end
lemma list_transvec_col_mul_last_row (i : fin r ‚äï unit) :
  ((list_transvec_col M).prod ‚¨ù M) (inr star) i = M (inr star) i :=
by simpa using list_transvec_col_mul_last_row_drop M i (zero_le _)
lemma list_transvec_col_mul_last_col (hM : M (inr star) (inr star) ‚â† 0) (i : fin r) :
  ((list_transvec_col M).prod ‚¨ù M) (inl i) (inr star) = 0 :=
begin
  suffices H : ‚àÄ (k : ‚Ñï), k ‚â§ r ‚Üí (((list_transvec_col M).drop k).prod ‚¨ù M) (inl i) (inr star) =
    if k ‚â§ i then 0 else M (inl i) (inr star),
      by simpa only [if_true, list.drop.equations._eqn_1] using H 0 (zero_le _),
  assume k hk,
  apply nat.decreasing_induction' _ hk,
  { simp only [list_transvec_col, list.length_of_fn, matrix.one_mul, list.drop_eq_nil_of_le,
      list.prod_nil],
    rw if_neg,
    simpa only [not_le] using i.2 },
  { assume n hn hk IH,
    have hn' : n < (list_transvec_col M).length, by simpa [list_transvec_col] using hn,
    let n' : fin r := ‚ü®n, hn‚ü©,
    rw ‚Üê list.cons_nth_le_drop_succ hn',
    have A : (list_transvec_col M).nth_le n hn' = transvection (inl n') (inr star)
      (-M (inl n') (inr star) / M (inr star) (inr star)), by simp [list_transvec_col],
    simp only [matrix.mul_assoc, A, matrix.mul_eq_mul, list.prod_cons],
    by_cases h : n' = i,
    { have hni : n = i,
      { cases i, simp only [subtype.mk_eq_mk] at h, simp [h] },
      rw [h, transvection_mul_apply_same, IH, list_transvec_col_mul_last_row_drop _ _ hn, ‚Üê hni],
      field_simp [hM] },
    { have hni : n ‚â† i,
      { rintros rfl, cases i, simpa using h },
      simp only [transvection_mul_apply_of_ne, ne.def, not_false_iff, ne.symm h],
      rw IH,
      rcases le_or_lt (n+1) i with hi|hi,
      { simp only [hi, n.le_succ.trans hi, if_true] },
      { rw [if_neg, if_neg],
        { simpa only [hni.symm, not_le, or_false] using nat.lt_succ_iff_lt_or_eq.1 hi },
        { simpa only [not_le] using hi } } } }
end
lemma mul_list_transvec_row_last_col_take (i : fin r ‚äï unit) {k : ‚Ñï} (hk : k ‚â§ r) :
  (M ‚¨ù ((list_transvec_row M).take k).prod) i (inr star) = M i (inr star) :=
begin
  induction k with k IH,
  { simp only [matrix.mul_one, list.take_zero, list.prod_nil], },
  { have hkr : k < r := hk,
    let k' : fin r := ‚ü®k, hkr‚ü©,
    have : (list_transvec_row M).nth k = ‚Üë(transvection (inr unit.star) (inl k')
      (-M (inr unit.star) (inl k') / M (inr unit.star) (inr unit.star))),
    { simp only [list_transvec_row, list.of_fn_nth_val, hkr, dif_pos, list.nth_of_fn], refl },
    simp only [list.take_succ, ‚Üê matrix.mul_assoc, this, list.prod_append, matrix.mul_one,
      matrix.mul_eq_mul, list.prod_cons, list.prod_nil, option.to_list_some],
    rw [mul_transvection_apply_of_ne, IH hkr.le],
    simp only [ne.def, not_false_iff], }
end
lemma mul_list_transvec_row_last_col (i : fin r ‚äï unit) :
  (M ‚¨ù (list_transvec_row M).prod) i (inr star) = M i (inr star) :=
begin
  have A : (list_transvec_row M).length = r, by simp [list_transvec_row],
  rw [‚Üê list.take_length (list_transvec_row M), A],
  simpa using mul_list_transvec_row_last_col_take M i le_rfl,
end
lemma mul_list_transvec_row_last_row (hM : M (inr star) (inr star) ‚â† 0) (i : fin r) :
  (M ‚¨ù (list_transvec_row M).prod) (inr star) (inl i) = 0 :=
begin
  suffices H : ‚àÄ (k : ‚Ñï), k ‚â§ r ‚Üí (M ‚¨ù ((list_transvec_row M).take k).prod) (inr star) (inl i) =
    if k ‚â§ i then M (inr star) (inl i) else 0,
  { have A : (list_transvec_row M).length = r, by simp [list_transvec_row],
    rw [‚Üê list.take_length (list_transvec_row M), A],
    have : ¬¨ (r ‚â§ i), by simpa using i.2,
    simpa only [this, ite_eq_right_iff] using H r le_rfl },
  assume k hk,
  induction k with n IH,
  { simp only [if_true, matrix.mul_one, list.take_zero, zero_le', list.prod_nil] },
  { have hnr : n < r := hk,
    let n' : fin r := ‚ü®n, hnr‚ü©,
    have A : (list_transvec_row M).nth n = ‚Üë(transvection (inr unit.star) (inl n')
      (-M (inr unit.star) (inl n') / M (inr unit.star) (inr unit.star))),
    { simp only [list_transvec_row, list.of_fn_nth_val, hnr, dif_pos, list.nth_of_fn], refl },
    simp only [list.take_succ, A, ‚Üê matrix.mul_assoc, list.prod_append, matrix.mul_one,
      matrix.mul_eq_mul, list.prod_cons, list.prod_nil, option.to_list_some],
    by_cases h : n' = i,
    { have hni : n = i,
      { cases i, simp only [subtype.mk_eq_mk] at h, simp only [h, coe_mk] },
      have : ¬¨ (n.succ ‚â§ i), by simp only [‚Üê hni, n.lt_succ_self, not_le],
      simp only [h, mul_transvection_apply_same, list.take, if_false,
        mul_list_transvec_row_last_col_take _ _ hnr.le, hni.le, this, if_true, IH hnr.le],
      field_simp [hM] },
    { have hni : n ‚â† i,
      { rintros rfl, cases i, simpa using h },
      simp only [IH hnr.le, ne.def, mul_transvection_apply_of_ne, not_false_iff, ne.symm h],
      rcases le_or_lt (n+1) i with hi|hi,
      { simp [hi, n.le_succ.trans hi, if_true], },
      { rw [if_neg, if_neg],
        { simpa only [not_le] using hi },
        { simpa only [hni.symm, not_le, or_false] using nat.lt_succ_iff_lt_or_eq.1 hi } } } }
end
lemma list_transvec_col_mul_mul_list_transvec_row_last_col
  (hM : M (inr star) (inr star) ‚â† 0) (i : fin r) :
  ((list_transvec_col M).prod ‚¨ù M ‚¨ù (list_transvec_row M).prod) (inr star) (inl i) = 0 :=
begin
  have : list_transvec_row M = list_transvec_row ((list_transvec_col M).prod ‚¨ù M),
    by simp [list_transvec_row, list_transvec_col_mul_last_row],
  rw this,
  apply mul_list_transvec_row_last_row,
  simpa [list_transvec_col_mul_last_row] using hM
end
lemma list_transvec_col_mul_mul_list_transvec_row_last_row
  (hM : M (inr star) (inr star) ‚â† 0) (i : fin r) :
  ((list_transvec_col M).prod ‚¨ù M ‚¨ù (list_transvec_row M).prod) (inl i) (inr star) = 0 :=
begin
  have : list_transvec_col M = list_transvec_col (M ‚¨ù (list_transvec_row M).prod),
    by simp [list_transvec_col, mul_list_transvec_row_last_col],
  rw [this, matrix.mul_assoc],
  apply list_transvec_col_mul_last_col,
  simpa [mul_list_transvec_row_last_col] using hM
end
lemma is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row
  (hM : M (inr star) (inr star) ‚â† 0) :
  is_two_block_diagonal ((list_transvec_col M).prod ‚¨ù M ‚¨ù (list_transvec_row M).prod) :=
begin
  split,
  { ext i j,
    have : j = star, by simp only [eq_iff_true_of_subsingleton],
    simp [to_blocks‚ÇÅ‚ÇÇ, this, list_transvec_col_mul_mul_list_transvec_row_last_row M hM] },
  { ext i j,
    have : i = star, by simp only [eq_iff_true_of_subsingleton],
    simp [to_blocks‚ÇÇ‚ÇÅ, this, list_transvec_col_mul_mul_list_transvec_row_last_col M hM] },
end
lemma exists_is_two_block_diagonal_of_ne_zero (hM : M (inr star) (inr star) ‚â† 0) :
  ‚àÉ (L L' : list (transvection_struct (fin r ‚äï unit) ùïú)),
  is_two_block_diagonal ((L.map to_matrix).prod ‚¨ù M ‚¨ù (L'.map to_matrix).prod) :=
begin
  let L : list (transvection_struct (fin r ‚äï unit) ùïú) :=
    list.of_fn (Œª i : fin r, ‚ü®inl i, inr star, by simp,
      -M (inl i) (inr star) / M (inr star) (inr star)‚ü©),
  let L' : list (transvection_struct (fin r ‚äï unit) ùïú) :=
    list.of_fn (Œª i : fin r, ‚ü®inr star, inl i, by simp,
      -M (inr star) (inl i)  / M (inr star) (inr star)‚ü©),
  refine ‚ü®L, L', _‚ü©,
  have A : L.map to_matrix = list_transvec_col M, by simp [L, list_transvec_col, (‚àò)],
  have B : L'.map to_matrix = list_transvec_row M, by simp [L, list_transvec_row, (‚àò)],
  rw [A, B],
  exact is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row M hM
end
lemma exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec
  (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) :
  ‚àÉ (L L' : list (transvection_struct (fin r ‚äï unit) ùïú)),
  is_two_block_diagonal ((L.map to_matrix).prod ‚¨ù M ‚¨ù (L'.map to_matrix).prod) :=
begin
  by_cases H : is_two_block_diagonal M, { refine ‚ü®list.nil, list.nil, by simpa using H‚ü© },
lemma exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction
  (IH : ‚àÄ (M : matrix (fin r) (fin r) ùïú),
    ‚àÉ (L‚ÇÄ L‚ÇÄ' : list (transvection_struct (fin r) ùïú)) (D‚ÇÄ : (fin r) ‚Üí ùïú),
      (L‚ÇÄ.map to_matrix).prod ‚¨ù M ‚¨ù (L‚ÇÄ'.map to_matrix).prod = diagonal D‚ÇÄ)
  (M : matrix (fin r ‚äï unit) (fin r ‚äï unit) ùïú) :
  ‚àÉ (L L' : list (transvection_struct (fin r ‚äï unit) ùïú)) (D : fin r ‚äï unit ‚Üí ùïú),
    (L.map to_matrix).prod ‚¨ù M ‚¨ù (L'.map to_matrix).prod = diagonal D :=
begin
  rcases exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec M with ‚ü®L‚ÇÅ, L‚ÇÅ', hM‚ü©,
  let M' := (L‚ÇÅ.map to_matrix).prod ‚¨ù M ‚¨ù (L‚ÇÅ'.map to_matrix).prod,
  let M'' := to_blocks‚ÇÅ‚ÇÅ M',
  rcases IH M'' with ‚ü®L‚ÇÄ, L‚ÇÄ', D‚ÇÄ, h‚ÇÄ‚ü©,
  set c := M' (inr star) (inr star) with hc,
  refine ‚ü®L‚ÇÄ.map (sum_inl unit) ++ L‚ÇÅ, L‚ÇÅ' ++ L‚ÇÄ'.map (sum_inl unit),
    sum.elim D‚ÇÄ (Œª _, M' (inr star) (inr star)), _‚ü©,
  suffices :
    (L‚ÇÄ.map (to_matrix ‚àò sum_inl unit)).prod ‚¨ù M' ‚¨ù (L‚ÇÄ'.map (to_matrix ‚àò sum_inl unit)).prod =
      diagonal (sum.elim D‚ÇÄ (Œª _, c)), by simpa [M', matrix.mul_assoc, c],
  have : M' = from_blocks M'' 0 0 (diagonal (Œª _, c)),
  { rw ‚Üê from_blocks_to_blocks M',
    congr,
    { exact hM.1 },
    { exact hM.2 },
    { ext i j,  rw [hc, to_blocks‚ÇÇ‚ÇÇ], congr } },
  rw this,
  simp [h‚ÇÄ],
end
variables {n p} [fintype n] [fintype p]
lemma reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal (M : matrix p p ùïú) (e : p ‚âÉ n)
  (H : ‚àÉ (L L' : list (transvection_struct n ùïú)) (D : n ‚Üí ùïú),
    (L.map to_matrix).prod ‚¨ù (matrix.reindex_alg_equiv ùïú e M) ‚¨ù (L'.map to_matrix).prod
      = diagonal D) :
  ‚àÉ (L L' : list (transvection_struct p ùïú)) (D : p ‚Üí ùïú),
    (L.map to_matrix).prod ‚¨ù M ‚¨ù (L'.map to_matrix).prod = diagonal D :=
begin
  rcases H with ‚ü®L‚ÇÄ, L‚ÇÄ', D‚ÇÄ, h‚ÇÄ‚ü©,
  refine ‚ü®L‚ÇÄ.map (reindex_equiv e.symm), L‚ÇÄ'.map (reindex_equiv e.symm), D‚ÇÄ ‚àò e, _‚ü©,
  have : M = reindex_alg_equiv ùïú e.symm (reindex_alg_equiv ùïú e M),
    by simp only [equiv.symm_symm, minor_minor, reindex_apply, minor_id_id, equiv.symm_comp_self,
      reindex_alg_equiv_apply],
  rw this,
  simp only [to_matrix_reindex_equiv_prod, list.map_map, reindex_alg_equiv_apply],
  simp only [‚Üê reindex_alg_equiv_apply, ‚Üê reindex_alg_equiv_mul, h‚ÇÄ],
  simp only [equiv.symm_symm, reindex_apply, minor_diagonal_equiv, reindex_alg_equiv_apply],
end
lemma exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux
  (n : Type) [fintype n] [decidable_eq n]
  (M : matrix n n ùïú) : ‚àÉ (L L' : list (transvection_struct n ùïú)) (D : n ‚Üí ùïú),
  (L.map to_matrix).prod ‚¨ù M ‚¨ù (L'.map to_matrix).prod = diagonal D :=
begin
  unfreezingI { induction hn : fintype.card n with r IH generalizing n M },
  { refine ‚ü®list.nil, list.nil, Œª _, 1, _‚ü©,
    ext i j,
    rw fintype.card_eq_zero_iff at hn,
    exact hn.elim' i },
  { have e : n ‚âÉ fin r ‚äï unit,
    { refine fintype.equiv_of_card_eq _,
      rw hn,
      convert (@fintype.card_sum (fin r) unit _ _).symm,
      simp },
    apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e,
    apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction
      (Œª N, IH (fin r) N (by simp)) }
end
theorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal
  (M : matrix n n ùïú) : ‚àÉ (L L' : list (transvection_struct n ùïú)) (D : n ‚Üí ùïú),
  (L.map to_matrix).prod ‚¨ù M ‚¨ù (L'.map to_matrix).prod = diagonal D :=
begin
  have e : n ‚âÉ fin (fintype.card n) := fintype.equiv_of_card_eq (by simp),
  apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e,
  apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux
end
theorem exists_list_transvec_mul_diagonal_mul_list_transvec
  (M : matrix n n ùïú) : ‚àÉ (L L' : list (transvection_struct n ùïú)) (D : n ‚Üí ùïú),
  M = (L.map to_matrix).prod ‚¨ù diagonal D ‚¨ù (L'.map to_matrix).prod :=
begin
  rcases exists_list_transvec_mul_mul_list_transvec_eq_diagonal M with ‚ü®L, L', D, h‚ü©,
  refine ‚ü®L.reverse.map transvection_struct.inv, L'.reverse.map transvection_struct.inv, D, _‚ü©,
  suffices : M =
    ((L.reverse.map (to_matrix ‚àò transvection_struct.inv)).prod ‚¨ù (L.map to_matrix).prod) ‚¨ù M ‚¨ù
    ((L'.map to_matrix).prod ‚¨ù (L'.reverse.map (to_matrix ‚àò transvection_struct.inv)).prod),
      by simpa [‚Üê h, matrix.mul_assoc],
  rw [reverse_inv_prod_mul_prod, prod_mul_reverse_inv_prod, matrix.one_mul, matrix.mul_one],
end
end pivot
open pivot transvection_struct
variables {n} [fintype n]
lemma diagonal_transvection_induction (P : matrix n n ùïú ‚Üí Prop) (M : matrix n n ùïú)
  (hdiag : ‚àÄ D : n ‚Üí ùïú, det (diagonal D) = det M ‚Üí P (diagonal D))
  (htransvec : ‚àÄ (t : transvection_struct n ùïú), P t.to_matrix)
  (hmul : ‚àÄ A B, P A ‚Üí P B ‚Üí P (A ‚¨ù B)) :
  P M :=
begin
  rcases exists_list_transvec_mul_diagonal_mul_list_transvec M with ‚ü®L, L', D, h‚ü©,
  have PD : P (diagonal D) := hdiag D (by simp [h]),
  suffices H : ‚àÄ (L‚ÇÅ L‚ÇÇ : list (transvection_struct n ùïú)) (E : matrix n n ùïú),
    P E ‚Üí P ((L‚ÇÅ.map to_matrix).prod ‚¨ù E ‚¨ù (L‚ÇÇ.map to_matrix).prod),
      by { rw h, apply H L L', exact PD },
  assume L‚ÇÅ L‚ÇÇ E PE,
  induction L‚ÇÅ with t L‚ÇÅ IH,
  { simp only [matrix.one_mul, list.prod_nil, list.map],
    induction L‚ÇÇ with t L‚ÇÇ IH generalizing E,
    { simpa },
    { simp only [‚Üêmatrix.mul_assoc, list.prod_cons, mul_eq_mul, list.map],
      apply IH,
      exact hmul _ _ PE (htransvec _) } },
  { simp only [matrix.mul_assoc, list.prod_cons, mul_eq_mul, list.map] at ‚ä¢ IH,
    exact hmul _ _ (htransvec _) IH }
end
lemma diagonal_transvection_induction_of_det_ne_zero (P : matrix n n ùïú ‚Üí Prop)
  (M : matrix n n ùïú) (hMdet : det M ‚â† 0)
  (hdiag : ‚àÄ D : n ‚Üí ùïú, det (diagonal D) ‚â† 0 ‚Üí P (diagonal D))
  (htransvec : ‚àÄ (t : transvection_struct n ùïú), P t.to_matrix)
  (hmul : ‚àÄ A B, det A ‚â† 0 ‚Üí det B ‚â† 0 ‚Üí P A ‚Üí P B ‚Üí P (A ‚¨ù B)) :
  P M :=
begin
  let Q : matrix n n ùïú ‚Üí Prop := Œª N, det N ‚â† 0 ‚àß P N,
  have : Q M,
  { apply diagonal_transvection_induction Q M,
    { assume D hD,
      have detD : det (diagonal D) ‚â† 0, by { rw hD, exact hMdet },
      exact ‚ü®detD, hdiag _ detD‚ü© },
    { assume t,
      exact ‚ü®by simp, htransvec t‚ü© },
    { assume A B QA QB,
      exact ‚ü®by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2‚ü© } },
  exact this.2
end
end matrix
