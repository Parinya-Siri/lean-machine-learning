import category_theory.limits.has_limits
open category_theory
noncomputable theory
namespace category_theory.limits
class preserves_limit (K : J â¥¤ C) (F : C â¥¤ D) :=
(preserves : Î  {c : cone K}, is_limit c â†’ is_limit (F.map_cone c))
class preserves_colimit (K : J â¥¤ C) (F : C â¥¤ D) :=
(preserves : Î  {c : cocone K}, is_colimit c â†’ is_colimit (F.map_cocone c))
class preserves_limits_of_shape (J : Type w) [category.{w'} J] (F : C â¥¤ D) :=
(preserves_limit : Î  {K : J â¥¤ C}, preserves_limit K F . tactic.apply_instance)
class preserves_colimits_of_shape (J : Type w) [category.{w'} J] (F : C â¥¤ D) :=
(preserves_colimit : Î  {K : J â¥¤ C}, preserves_colimit K F . tactic.apply_instance)
abbreviation preserves_limits (F : C â¥¤ D) := preserves_limits_of_size.{vâ‚‚ vâ‚‚} F
abbreviation preserves_colimits (F : C â¥¤ D) := preserves_colimits_of_size.{vâ‚‚ vâ‚‚} F
def is_limit_of_preserves (F : C â¥¤ D) {c : cone K} (t : is_limit c) [preserves_limit K F] :
  is_limit (F.map_cone c) :=
preserves_limit.preserves t
def is_colimit_of_preserves (F : C â¥¤ D) {c : cocone K} (t : is_colimit c)
  [preserves_colimit K F] :
  is_colimit (F.map_cocone c) :=
preserves_colimit.preserves t
instance preserves_limit_subsingleton (K : J â¥¤ C) (F : C â¥¤ D) :
  subsingleton (preserves_limit K F) :=
by split; rintros âŸ¨aâŸ© âŸ¨bâŸ©; congr
instance preserves_colimit_subsingleton (K : J â¥¤ C) (F : C â¥¤ D) :
  subsingleton (preserves_colimit K F) :=
by split; rintros âŸ¨aâŸ© âŸ¨bâŸ©; congr
instance preserves_limits_of_shape_subsingleton (J : Type w) [category.{w'} J] (F : C â¥¤ D) :
  subsingleton (preserves_limits_of_shape J F) :=
by { split, intros, cases a, cases b, congr }
instance preserves_colimits_of_shape_subsingleton (J : Type w) [category.{w'} J] (F : C â¥¤ D) :
  subsingleton (preserves_colimits_of_shape J F) :=
by { split, intros, cases a, cases b, congr }
instance preserves_limits_subsingleton (F : C â¥¤ D) :
  subsingleton (preserves_limits_of_size.{w' w} F) :=
by { split, intros, cases a, cases b, cc }
instance preserves_colimits_subsingleton (F : C â¥¤ D) :
  subsingleton (preserves_colimits_of_size.{w' w} F) :=
by { split, intros, cases a, cases b, cc }
instance id_preserves_limits : preserves_limits_of_size.{w' w} (ğŸ­ C) :=
{ preserves_limits_of_shape := Î» J ğ’¥,
  { preserves_limit := Î» K, by exactI âŸ¨Î» c h,
  âŸ¨Î» s, h.lift âŸ¨s.X, Î» j, s.Ï€.app j, Î» j j' f, s.Ï€.naturality fâŸ©,
   by cases K; rcases c with âŸ¨_, _, _âŸ©; intros s j; cases s; exact h.fac _ j,
   by cases K; rcases c with âŸ¨_, _, _âŸ©; intros s m w; rcases s with âŸ¨_, _, _âŸ©;
     exact h.uniq _ m wâŸ©âŸ© } }
instance id_preserves_colimits : preserves_colimits_of_size.{w' w} (ğŸ­ C) :=
{ preserves_colimits_of_shape := Î» J ğ’¥,
  { preserves_colimit := Î» K, by exactI âŸ¨Î» c h,
  âŸ¨Î» s, h.desc âŸ¨s.X, Î» j, s.Î¹.app j, Î» j j' f, s.Î¹.naturality fâŸ©,
   by cases K; rcases c with âŸ¨_, _, _âŸ©; intros s j; cases s; exact h.fac _ j,
   by cases K; rcases c with âŸ¨_, _, _âŸ©; intros s m w; rcases s with âŸ¨_, _, _âŸ©;
     exact h.uniq _ m wâŸ©âŸ© } }
section
variables {E : Type uâ‚ƒ} [â„° : category.{vâ‚ƒ} E]
variables (F : C â¥¤ D) (G : D â¥¤ E)
local attribute [elab_simple] preserves_limit.preserves preserves_colimit.preserves
instance comp_preserves_limit [preserves_limit K F] [preserves_limit (K â‹™ F) G] :
  preserves_limit K (F â‹™ G) :=
âŸ¨Î» c h, preserves_limit.preserves (preserves_limit.preserves h)âŸ©
instance comp_preserves_limits_of_shape
  [preserves_limits_of_shape J F] [preserves_limits_of_shape J G] :
  preserves_limits_of_shape J (F â‹™ G) :=
{}
instance comp_preserves_limits
  [preserves_limits_of_size.{w' w} F] [preserves_limits_of_size.{w' w} G] :
  preserves_limits_of_size.{w' w} (F â‹™ G) :=
{}
instance comp_preserves_colimit [preserves_colimit K F] [preserves_colimit (K â‹™ F) G] :
  preserves_colimit K (F â‹™ G) :=
âŸ¨Î» c h, preserves_colimit.preserves (preserves_colimit.preserves h)âŸ©
instance comp_preserves_colimits_of_shape
  [preserves_colimits_of_shape J F] [preserves_colimits_of_shape J G] :
  preserves_colimits_of_shape J (F â‹™ G) :=
{}
instance comp_preserves_colimits
  [preserves_colimits_of_size.{w' w} F] [preserves_colimits_of_size.{w' w} G] :
  preserves_colimits_of_size.{w' w} (F â‹™ G) :=
{}
end
def preserves_limit_of_preserves_limit_cone {F : C â¥¤ D} {t : cone K}
  (h : is_limit t) (hF : is_limit (F.map_cone t)) : preserves_limit K F :=
âŸ¨Î» t' h', is_limit.of_iso_limit hF (functor.map_iso _ (is_limit.unique_up_to_iso h h'))âŸ©
def preserves_limit_of_iso_diagram {Kâ‚ Kâ‚‚ : J â¥¤ C} (F : C â¥¤ D) (h : Kâ‚ â‰… Kâ‚‚)
  [preserves_limit Kâ‚ F] : preserves_limit Kâ‚‚ F :=
{ preserves := Î» c t,
  begin
    apply is_limit.postcompose_inv_equiv (iso_whisker_right h F : _) _ _,
    have := (is_limit.postcompose_inv_equiv h c).symm t,
    apply is_limit.of_iso_limit (is_limit_of_preserves F this),
    refine cones.ext (iso.refl _) (Î» j, by tidy),
  end }
def preserves_limit_of_nat_iso (K : J â¥¤ C) {F G : C â¥¤ D} (h : F â‰… G) [preserves_limit K F] :
  preserves_limit K G :=
{ preserves := Î» c t, is_limit.map_cone_equiv h (preserves_limit.preserves t) }
def preserves_limits_of_shape_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [preserves_limits_of_shape J F] :
  preserves_limits_of_shape J G :=
{ preserves_limit := Î» K, preserves_limit_of_nat_iso K h }
def preserves_limits_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [preserves_limits_of_size.{w w'} F] :
  preserves_limits_of_size.{w w'} G :=
{ preserves_limits_of_shape := Î» J ğ’¥â‚, by exactI preserves_limits_of_shape_of_nat_iso h }
def preserves_limits_of_shape_of_equiv {J' : Type wâ‚‚} [category.{wâ‚‚'} J'] (e : J â‰Œ J')
  (F : C â¥¤ D) [preserves_limits_of_shape J F] :
  preserves_limits_of_shape J' F :=
{ preserves_limit := Î» K,
  { preserves := Î» c t,
    begin
      let equ := e.inv_fun_id_assoc (K â‹™ F),
      have := (is_limit_of_preserves F (t.whisker_equivalence e)).whisker_equivalence e.symm,
      apply ((is_limit.postcompose_hom_equiv equ _).symm this).of_iso_limit,
      refine cones.ext (iso.refl _) (Î» j, _),
def preserves_limits_of_size_shrink (F : C â¥¤ D)
  [preserves_limits_of_size.{(max w wâ‚‚) (max w' wâ‚‚')} F] : preserves_limits_of_size.{w w'} F :=
âŸ¨Î» J hJ, by exactI preserves_limits_of_shape_of_equiv
  (ulift_hom_ulift_category.equiv.{wâ‚‚ wâ‚‚'} J).symm FâŸ©
def preserves_smallest_limits_of_preserves_limits
  (F : C â¥¤ D) [preserves_limits_of_size.{vâ‚ƒ uâ‚ƒ} F] : preserves_limits_of_size.{0 0} F :=
preserves_limits_of_size_shrink F
def preserves_colimit_of_preserves_colimit_cocone {F : C â¥¤ D} {t : cocone K}
  (h : is_colimit t) (hF : is_colimit (F.map_cocone t)) : preserves_colimit K F :=
âŸ¨Î» t' h', is_colimit.of_iso_colimit hF (functor.map_iso _ (is_colimit.unique_up_to_iso h h'))âŸ©
def preserves_colimit_of_iso_diagram {Kâ‚ Kâ‚‚ : J â¥¤ C} (F : C â¥¤ D) (h : Kâ‚ â‰… Kâ‚‚)
  [preserves_colimit Kâ‚ F] : preserves_colimit Kâ‚‚ F :=
{ preserves := Î» c t,
  begin
    apply is_colimit.precompose_hom_equiv (iso_whisker_right h F : _) _ _,
    have := (is_colimit.precompose_hom_equiv h c).symm t,
    apply is_colimit.of_iso_colimit (is_colimit_of_preserves F this),
    refine cocones.ext (iso.refl _) (Î» j, by tidy),
  end }
def preserves_colimit_of_nat_iso (K : J â¥¤ C) {F G : C â¥¤ D} (h : F â‰… G) [preserves_colimit K F] :
  preserves_colimit K G :=
{ preserves := Î» c t, is_colimit.map_cocone_equiv h (preserves_colimit.preserves t) }
def preserves_colimits_of_shape_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G)
  [preserves_colimits_of_shape J F] : preserves_colimits_of_shape J G :=
{ preserves_colimit := Î» K, preserves_colimit_of_nat_iso K h }
def preserves_colimits_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [preserves_colimits_of_size.{w w'} F] :
  preserves_colimits_of_size.{w w'} G :=
{ preserves_colimits_of_shape := Î» J ğ’¥â‚, by exactI preserves_colimits_of_shape_of_nat_iso h }
def preserves_colimits_of_shape_of_equiv {J' : Type wâ‚‚} [category.{wâ‚‚'} J'] (e : J â‰Œ J')
  (F : C â¥¤ D) [preserves_colimits_of_shape J F] :
  preserves_colimits_of_shape J' F :=
{ preserves_colimit := Î» K,
  { preserves := Î» c t,
    begin
      let equ := e.inv_fun_id_assoc (K â‹™ F),
      have := (is_colimit_of_preserves F (t.whisker_equivalence e)).whisker_equivalence e.symm,
      apply ((is_colimit.precompose_inv_equiv equ _).symm this).of_iso_colimit,
      refine cocones.ext (iso.refl _) (Î» j, _),
def preserves_colimits_of_size_shrink (F : C â¥¤ D)
  [preserves_colimits_of_size.{(max w wâ‚‚) (max w' wâ‚‚')} F] : preserves_colimits_of_size.{w w'} F :=
âŸ¨Î» J hJ, by exactI preserves_colimits_of_shape_of_equiv
  (ulift_hom_ulift_category.equiv.{wâ‚‚ wâ‚‚'} J).symm FâŸ©
def preserves_smallest_colimits_of_preserves_colimits
  (F : C â¥¤ D) [preserves_colimits_of_size.{vâ‚ƒ uâ‚ƒ} F] : preserves_colimits_of_size.{0 0} F :=
preserves_colimits_of_size_shrink F
class reflects_limit (K : J â¥¤ C) (F : C â¥¤ D) :=
(reflects : Î  {c : cone K}, is_limit (F.map_cone c) â†’ is_limit c)
class reflects_colimit (K : J â¥¤ C) (F : C â¥¤ D) :=
(reflects : Î  {c : cocone K}, is_colimit (F.map_cocone c) â†’ is_colimit c)
class reflects_limits_of_shape (J : Type w) [category.{w'} J] (F : C â¥¤ D) :=
(reflects_limit : Î  {K : J â¥¤ C}, reflects_limit K F . tactic.apply_instance)
class reflects_colimits_of_shape (J : Type w) [category.{w'} J] (F : C â¥¤ D) :=
(reflects_colimit : Î  {K : J â¥¤ C}, reflects_colimit K F . tactic.apply_instance)
abbreviation reflects_limits (F : C â¥¤ D) := reflects_limits_of_size.{vâ‚‚ vâ‚‚} F
abbreviation reflects_colimits (F : C â¥¤ D) := reflects_colimits_of_size.{vâ‚‚ vâ‚‚} F
def is_limit_of_reflects (F : C â¥¤ D) {c : cone K} (t : is_limit (F.map_cone c))
  [reflects_limit K F] : is_limit c :=
reflects_limit.reflects t
def is_colimit_of_reflects (F : C â¥¤ D) {c : cocone K} (t : is_colimit (F.map_cocone c))
  [reflects_colimit K F] :
  is_colimit c :=
reflects_colimit.reflects t
instance reflects_limit_subsingleton (K : J â¥¤ C) (F : C â¥¤ D) : subsingleton (reflects_limit K F) :=
by split; rintros âŸ¨aâŸ© âŸ¨bâŸ©; congr
instance reflects_colimit_subsingleton (K : J â¥¤ C) (F : C â¥¤ D) :
  subsingleton (reflects_colimit K F) :=
by split; rintros âŸ¨aâŸ© âŸ¨bâŸ©; congr
instance reflects_limits_of_shape_subsingleton (J : Type w) [category.{w'} J] (F : C â¥¤ D) :
  subsingleton (reflects_limits_of_shape J F) :=
by { split, intros, cases a, cases b, congr }
instance reflects_colimits_of_shape_subsingleton (J : Type w) [category.{w'} J] (F : C â¥¤ D) :
  subsingleton (reflects_colimits_of_shape J F) :=
by { split, intros, cases a, cases b, congr }
instance reflects_limits_subsingleton (F : C â¥¤ D) :
  subsingleton (reflects_limits_of_size.{w' w} F) :=
by { split, intros, cases a, cases b, cc }
instance reflects_colimits_subsingleton (F : C â¥¤ D) :
  subsingleton (reflects_colimits_of_size.{w' w} F) :=
by { split, intros, cases a, cases b, cc }
def preserves_limit_of_reflects_of_preserves [preserves_limit K (F â‹™ G)]
  [reflects_limit (K â‹™ F) G] : preserves_limit K F :=
âŸ¨Î» c h,
 begin
  apply is_limit_of_reflects G,
  apply is_limit_of_preserves (F â‹™ G) h,
 endâŸ©
def preserves_limits_of_shape_of_reflects_of_preserves [preserves_limits_of_shape J (F â‹™ G)]
  [reflects_limits_of_shape J G] : preserves_limits_of_shape J F :=
{ preserves_limit := Î» K, preserves_limit_of_reflects_of_preserves F G }
def preserves_limits_of_reflects_of_preserves
  [preserves_limits_of_size.{w' w} (F â‹™ G)] [reflects_limits_of_size.{w' w} G] :
  preserves_limits_of_size.{w' w} F :=
{ preserves_limits_of_shape := Î» J ğ’¥â‚,
    by exactI preserves_limits_of_shape_of_reflects_of_preserves F G }
def reflects_limit_of_iso_diagram {Kâ‚ Kâ‚‚ : J â¥¤ C} (F : C â¥¤ D) (h : Kâ‚ â‰… Kâ‚‚)
  [reflects_limit Kâ‚ F] : reflects_limit Kâ‚‚ F :=
{ reflects := Î» c t,
  begin
    apply is_limit.postcompose_inv_equiv h c (is_limit_of_reflects F _),
    apply ((is_limit.postcompose_inv_equiv (iso_whisker_right h F : _) _).symm t).of_iso_limit _,
    exact cones.ext (iso.refl _) (by tidy),
  end }
def reflects_limit_of_nat_iso (K : J â¥¤ C) {F G : C â¥¤ D} (h : F â‰… G) [reflects_limit K F] :
  reflects_limit K G :=
{ reflects := Î» c t, reflects_limit.reflects (is_limit.map_cone_equiv h.symm t) }
def reflects_limits_of_shape_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [reflects_limits_of_shape J F] :
  reflects_limits_of_shape J G :=
{ reflects_limit := Î» K, reflects_limit_of_nat_iso K h }
def reflects_limits_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [reflects_limits_of_size.{w' w} F] :
  reflects_limits_of_size.{w' w} G :=
{ reflects_limits_of_shape := Î» J ğ’¥â‚, by exactI reflects_limits_of_shape_of_nat_iso h }
def reflects_limits_of_shape_of_equiv {J' : Type wâ‚‚} [category.{wâ‚‚'} J'] (e : J â‰Œ J')
  (F : C â¥¤ D) [reflects_limits_of_shape J F] :
  reflects_limits_of_shape J' F :=
{ reflects_limit := Î» K,
  { reflects := Î» c t,
    begin
      apply is_limit.of_whisker_equivalence e,
      apply is_limit_of_reflects F,
      apply is_limit.of_iso_limit _ (functor.map_cone_whisker _).symm,
      exact is_limit.whisker_equivalence t _,
    end } }
def reflects_limits_of_size_shrink (F : C â¥¤ D)
  [reflects_limits_of_size.{(max w wâ‚‚) (max w' wâ‚‚')} F] : reflects_limits_of_size.{w w'} F :=
âŸ¨Î» J hJ, by exactI reflects_limits_of_shape_of_equiv
  (ulift_hom_ulift_category.equiv.{wâ‚‚ wâ‚‚'} J).symm FâŸ©
def reflects_smallest_limits_of_reflects_limits
  (F : C â¥¤ D) [reflects_limits_of_size.{vâ‚ƒ uâ‚ƒ} F] : reflects_limits_of_size.{0 0} F :=
reflects_limits_of_size_shrink F
def reflects_limit_of_reflects_isomorphisms (F : J â¥¤ C) (G : C â¥¤ D)
  [reflects_isomorphisms G] [has_limit F] [preserves_limit F G] :
  reflects_limit F G :=
{ reflects := Î» c t,
  begin
    apply is_limit.of_point_iso (limit.is_limit F),
    change is_iso ((cones.forget _).map ((limit.is_limit F).lift_cone_morphism c)),
    apply (cones.forget F).map_is_iso _,
    apply is_iso_of_reflects_iso _ (cones.functoriality F G),
    refine t.hom_is_iso (is_limit_of_preserves G (limit.is_limit F)) _,
  end }
def reflects_limits_of_shape_of_reflects_isomorphisms {G : C â¥¤ D}
  [reflects_isomorphisms G] [has_limits_of_shape J C] [preserves_limits_of_shape J G] :
  reflects_limits_of_shape J G :=
{ reflects_limit := Î» F, reflects_limit_of_reflects_isomorphisms F G }
def reflects_limits_of_reflects_isomorphisms {G : C â¥¤ D}
  [reflects_isomorphisms G] [has_limits_of_size.{w' w} C] [preserves_limits_of_size.{w' w} G] :
  reflects_limits_of_size.{w' w} G :=
{ reflects_limits_of_shape := Î» J ğ’¥â‚,
  by exactI reflects_limits_of_shape_of_reflects_isomorphisms }
def preserves_colimit_of_reflects_of_preserves [preserves_colimit K (F â‹™ G)]
  [reflects_colimit (K â‹™ F) G] : preserves_colimit K F :=
âŸ¨Î» c h,
 begin
  apply is_colimit_of_reflects G,
  apply is_colimit_of_preserves (F â‹™ G) h,
 endâŸ©
def preserves_colimits_of_shape_of_reflects_of_preserves [preserves_colimits_of_shape J (F â‹™ G)]
  [reflects_colimits_of_shape J G] : preserves_colimits_of_shape J F :=
{ preserves_colimit := Î» K, preserves_colimit_of_reflects_of_preserves F G }
def preserves_colimits_of_reflects_of_preserves [preserves_colimits_of_size.{w' w} (F â‹™ G)]
  [reflects_colimits_of_size.{w' w} G] : preserves_colimits_of_size.{w' w} F :=
{ preserves_colimits_of_shape := Î» J ğ’¥â‚,
    by exactI preserves_colimits_of_shape_of_reflects_of_preserves F G }
def reflects_colimit_of_iso_diagram {Kâ‚ Kâ‚‚ : J â¥¤ C} (F : C â¥¤ D) (h : Kâ‚ â‰… Kâ‚‚)
  [reflects_colimit Kâ‚ F] : reflects_colimit Kâ‚‚ F :=
{ reflects := Î» c t,
  begin
    apply is_colimit.precompose_hom_equiv h c (is_colimit_of_reflects F _),
    apply ((is_colimit.precompose_hom_equiv (iso_whisker_right h F : _) _).symm t).of_iso_colimit _,
    exact cocones.ext (iso.refl _) (by tidy),
  end }
def reflects_colimit_of_nat_iso (K : J â¥¤ C) {F G : C â¥¤ D} (h : F â‰… G) [reflects_colimit K F] :
  reflects_colimit K G :=
{ reflects := Î» c t, reflects_colimit.reflects (is_colimit.map_cocone_equiv h.symm t) }
def reflects_colimits_of_shape_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G)
  [reflects_colimits_of_shape J F] : reflects_colimits_of_shape J G :=
{ reflects_colimit := Î» K, reflects_colimit_of_nat_iso K h }
def reflects_colimits_of_nat_iso {F G : C â¥¤ D} (h : F â‰… G) [reflects_colimits_of_size.{w w'} F] :
  reflects_colimits_of_size.{w w'} G :=
{ reflects_colimits_of_shape := Î» J ğ’¥â‚, by exactI reflects_colimits_of_shape_of_nat_iso h }
def reflects_colimits_of_shape_of_equiv {J' : Type wâ‚‚} [category.{wâ‚‚'} J'] (e : J â‰Œ J')
  (F : C â¥¤ D) [reflects_colimits_of_shape J F] :
  reflects_colimits_of_shape J' F :=
{ reflects_colimit := Î» K,
  { reflects := Î» c t,
    begin
      apply is_colimit.of_whisker_equivalence e,
      apply is_colimit_of_reflects F,
      apply is_colimit.of_iso_colimit _ (functor.map_cocone_whisker _).symm,
      exact is_colimit.whisker_equivalence t _,
    end } }
def reflects_colimits_of_size_shrink (F : C â¥¤ D)
  [reflects_colimits_of_size.{(max w wâ‚‚) (max w' wâ‚‚')} F] : reflects_colimits_of_size.{w w'} F :=
âŸ¨Î» J hJ, by exactI reflects_colimits_of_shape_of_equiv
  (ulift_hom_ulift_category.equiv.{wâ‚‚ wâ‚‚'} J).symm FâŸ©
def reflects_smallest_colimits_of_reflects_colimits
  (F : C â¥¤ D) [reflects_colimits_of_size.{vâ‚ƒ uâ‚ƒ} F] : reflects_colimits_of_size.{0 0} F :=
reflects_colimits_of_size_shrink F
def reflects_colimit_of_reflects_isomorphisms (F : J â¥¤ C) (G : C â¥¤ D)
  [reflects_isomorphisms G] [has_colimit F] [preserves_colimit F G] :
  reflects_colimit F G :=
{ reflects := Î» c t,
  begin
    apply is_colimit.of_point_iso (colimit.is_colimit F),
    change is_iso ((cocones.forget _).map ((colimit.is_colimit F).desc_cocone_morphism c)),
    apply (cocones.forget F).map_is_iso _,
    apply is_iso_of_reflects_iso _ (cocones.functoriality F G),
    refine (is_colimit_of_preserves G (colimit.is_colimit F)).hom_is_iso t _,
  end }
def reflects_colimits_of_shape_of_reflects_isomorphisms {G : C â¥¤ D}
  [reflects_isomorphisms G] [has_colimits_of_shape J C] [preserves_colimits_of_shape J G] :
  reflects_colimits_of_shape J G :=
{ reflects_colimit := Î» F, reflects_colimit_of_reflects_isomorphisms F G }
def reflects_colimits_of_reflects_isomorphisms {G : C â¥¤ D}
  [reflects_isomorphisms G] [has_colimits_of_size.{w' w} C] [preserves_colimits_of_size.{w' w} G] :
  reflects_colimits_of_size.{w' w} G :=
{ reflects_colimits_of_shape := Î» J ğ’¥â‚,
  by exactI reflects_colimits_of_shape_of_reflects_isomorphisms }
end
variable (F : C â¥¤ D)
def fully_faithful_reflects_limits [full F] [faithful F] : reflects_limits_of_size.{w w'} F :=
{ reflects_limits_of_shape := Î» J ğ’¥â‚, by exactI
  { reflects_limit := Î» K,
    { reflects := Î» c t,
      is_limit.mk_cone_morphism (Î» s, (cones.functoriality K F).preimage (t.lift_cone_morphism _)) $
      begin
        apply (Î» s m, (cones.functoriality K F).map_injective _),
        rw [functor.image_preimage],
        apply t.uniq_cone_morphism,
      end } } }
def fully_faithful_reflects_colimits [full F] [faithful F] : reflects_colimits_of_size.{w w'} F :=
{ reflects_colimits_of_shape := Î» J ğ’¥â‚, by exactI
  { reflects_colimit := Î» K,
    { reflects := Î» c t,
      is_colimit.mk_cocone_morphism
        (Î» s, (cocones.functoriality K F).preimage (t.desc_cocone_morphism _)) $
      begin
        apply (Î» s m, (cocones.functoriality K F).map_injective _),
        rw [functor.image_preimage],
        apply t.uniq_cocone_morphism,
      end } } }
end category_theory.limits
