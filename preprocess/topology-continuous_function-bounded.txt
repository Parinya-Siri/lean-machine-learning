import analysis.normed_space.lattice_ordered_group
import analysis.normed_space.operator_norm
import analysis.normed_space.star.basic
import data.real.sqrt
import topology.continuous_function.algebra
noncomputable theory
open_locale topological_space classical nnreal
open set filter metric function
universes u v w
variables {F : Type*} {Î± : Type u} {Î² : Type v} {Î³ : Type w}
structure bounded_continuous_function (Î± : Type u) (Î² : Type v)
  [topological_space Î±] [pseudo_metric_space Î²] extends continuous_map Î± Î² :
  Type (max u v) :=
(map_bounded' : âˆƒ C, âˆ€ x y, dist (to_fun x) (to_fun y) â‰¤ C)
localized "infixr ` â†’áµ‡ `:25 := bounded_continuous_function" in bounded_continuous_function
class bounded_continuous_map_class (F Î± Î² : Type*) [topological_space Î±] [pseudo_metric_space Î²]
  extends continuous_map_class F Î± Î² :=
(map_bounded (f : F) : âˆƒ C, âˆ€ x y, dist (f x) (f y) â‰¤ C)
export bounded_continuous_map_class (map_bounded)
namespace bounded_continuous_function
section basics
variables [topological_space Î±] [pseudo_metric_space Î²] [pseudo_metric_space Î³]
variables {f g : Î± â†’áµ‡ Î²} {x : Î±} {C : â„}
instance : bounded_continuous_map_class (Î± â†’áµ‡ Î²) Î± Î² :=
{ coe := Î» f, f.to_fun,
  coe_injective' := Î» f g h, by { obtain âŸ¨âŸ¨_, _âŸ©, _âŸ© := f, obtain âŸ¨âŸ¨_, _âŸ©, _âŸ© := g, congr' },
  map_continuous := Î» f, f.continuous_to_fun,
  map_bounded := Î» f, f.map_bounded' }
instance : has_coe_to_fun (Î± â†’áµ‡ Î²) (Î» _, Î± â†’ Î²) := fun_like.has_coe_to_fun
instance [bounded_continuous_map_class F Î± Î²] : has_coe_t F (Î± â†’áµ‡ Î²) :=
âŸ¨Î» f, { to_fun := f, continuous_to_fun := map_continuous f, map_bounded' := map_bounded f }âŸ©
@[simp] lemma coe_to_continuous_fun (f : Î± â†’áµ‡ Î²) : (f.to_continuous_map : Î± â†’ Î²) = f := rfl
def simps.apply (h : Î± â†’áµ‡ Î²) : Î± â†’ Î² := h
initialize_simps_projections bounded_continuous_function (to_continuous_map_to_fun â†’ apply)
protected lemma bounded (f : Î± â†’áµ‡ Î²) : âˆƒC, âˆ€ x y : Î±, dist (f x) (f y) â‰¤ C := f.map_bounded'
protected lemma continuous (f : Î± â†’áµ‡ Î²) : continuous f := f.to_continuous_map.continuous
@[ext] lemma ext (h : âˆ€ x, f x = g x) : f = g := fun_like.ext _ _ h
lemma bounded_range (f : Î± â†’áµ‡ Î²) : bounded (range f) :=
bounded_range_iff.2 f.bounded
lemma bounded_image (f : Î± â†’áµ‡ Î²) (s : set Î±) : bounded (f '' s) :=
f.bounded_range.mono $ image_subset_range _ _
lemma eq_of_empty [is_empty Î±] (f g : Î± â†’áµ‡ Î²) : f = g :=
ext $ is_empty.elim â€¹_â€º
def mk_of_bound (f : C(Î±, Î²)) (C : â„) (h : âˆ€ x y : Î±, dist (f x) (f y) â‰¤ C) : Î± â†’áµ‡ Î² :=
âŸ¨f, âŸ¨C, hâŸ©âŸ©
@[simp] lemma mk_of_bound_coe {f} {C} {h} : (mk_of_bound f C h : Î± â†’ Î²) = (f : Î± â†’ Î²) :=
rfl
def mk_of_compact [compact_space Î±] (f : C(Î±, Î²)) : Î± â†’áµ‡ Î² :=
âŸ¨f, bounded_range_iff.1 (is_compact_range f.continuous).boundedâŸ©
@[simp] lemma mk_of_compact_apply [compact_space Î±] (f : C(Î±, Î²)) (a : Î±) :
  mk_of_compact f a = f a :=
rfl
@[simps] def mk_of_discrete [discrete_topology Î±] (f : Î± â†’ Î²)
  (C : â„) (h : âˆ€ x y : Î±, dist (f x) (f y) â‰¤ C) : Î± â†’áµ‡ Î² :=
âŸ¨âŸ¨f, continuous_of_discrete_topologyâŸ©, âŸ¨C, hâŸ©âŸ©
instance : has_dist (Î± â†’áµ‡ Î²) :=
âŸ¨Î»f g, Inf {C | 0 â‰¤ C âˆ§ âˆ€ x : Î±, dist (f x) (g x) â‰¤ C}âŸ©
lemma dist_eq : dist f g = Inf {C | 0 â‰¤ C âˆ§ âˆ€ x : Î±, dist (f x) (g x) â‰¤ C} := rfl
lemma dist_set_exists : âˆƒ C, 0 â‰¤ C âˆ§ âˆ€ x : Î±, dist (f x) (g x) â‰¤ C :=
begin
  rcases f.bounded_range.union g.bounded_range with âŸ¨C, hCâŸ©,
  refine âŸ¨max 0 C, le_max_left _ _, Î» x, (hC _ _ _ _).trans (le_max_right _ _)âŸ©;
    [left, right]; apply mem_range_self
end
lemma dist_coe_le_dist (x : Î±) : dist (f x) (g x) â‰¤ dist f g :=
le_cInf dist_set_exists $ Î»b hb, hb.2 x
private lemma dist_nonneg' : 0 â‰¤ dist f g :=
le_cInf dist_set_exists (Î» C, and.left)
lemma dist_le (C0 : (0 : â„) â‰¤ C) : dist f g â‰¤ C â†” âˆ€x:Î±, dist (f x) (g x) â‰¤ C :=
âŸ¨Î» h x, le_trans (dist_coe_le_dist x) h, Î» H, cInf_le âŸ¨0, Î» C, and.leftâŸ© âŸ¨C0, HâŸ©âŸ©
lemma dist_le_iff_of_nonempty [nonempty Î±] :
  dist f g â‰¤ C â†” âˆ€ x, dist (f x) (g x) â‰¤ C :=
âŸ¨Î» h x, le_trans (dist_coe_le_dist x) h,
 Î» w, (dist_le (le_trans dist_nonneg (w (nonempty.some â€¹_â€º)))).mpr wâŸ©
lemma dist_lt_of_nonempty_compact [nonempty Î±] [compact_space Î±]
  (w : âˆ€x:Î±, dist (f x) (g x) < C) : dist f g < C :=
begin
  have c : continuous (Î» x, dist (f x) (g x)), { continuity, },
  obtain âŸ¨x, -, leâŸ© :=
    is_compact.exists_forall_ge compact_univ set.univ_nonempty (continuous.continuous_on c),
  exact lt_of_le_of_lt (dist_le_iff_of_nonempty.mpr (Î» y, le y trivial)) (w x),
end
lemma dist_lt_iff_of_compact [compact_space Î±] (C0 : (0 : â„) < C) :
  dist f g < C â†” âˆ€x:Î±, dist (f x) (g x) < C :=
begin
  fsplit,
  { intros w x,
    exact lt_of_le_of_lt (dist_coe_le_dist x) w, },
  { by_cases h : nonempty Î±,
    { resetI,
      exact dist_lt_of_nonempty_compact, },
    { rintro -,
      convert C0,
      apply le_antisymm _ dist_nonneg',
      rw [dist_eq],
      exact cInf_le âŸ¨0, Î» C, and.leftâŸ© âŸ¨le_rfl, Î» x, false.elim (h (nonempty.intro x))âŸ©, }, },
end
lemma dist_lt_iff_of_nonempty_compact [nonempty Î±] [compact_space Î±] :
  dist f g < C â†” âˆ€x:Î±, dist (f x) (g x) < C :=
âŸ¨Î» w x, lt_of_le_of_lt (dist_coe_le_dist x) w, dist_lt_of_nonempty_compactâŸ©
instance : pseudo_metric_space (Î± â†’áµ‡ Î²) :=
{ dist_self := Î» f, le_antisymm ((dist_le le_rfl).2 $ Î» x, by simp) dist_nonneg',
  dist_comm := Î» f g, by simp [dist_eq, dist_comm],
  dist_triangle := Î» f g h,
    (dist_le (add_nonneg dist_nonneg' dist_nonneg')).2 $ Î» x,
      le_trans (dist_triangle _ _ _) (add_le_add (dist_coe_le_dist _) (dist_coe_le_dist _)) }
instance {Î± Î²} [topological_space Î±] [metric_space Î²] : metric_space (Î± â†’áµ‡ Î²) :=
{ eq_of_dist_eq_zero := Î» f g hfg, by ext x; exact
    eq_of_dist_eq_zero (le_antisymm (hfg â–¸ dist_coe_le_dist _) dist_nonneg) }
lemma nndist_eq : nndist f g = Inf {C | âˆ€ x : Î±, nndist (f x) (g x) â‰¤ C} :=
subtype.ext $ dist_eq.trans $ begin
  rw [nnreal.coe_Inf, nnreal.coe_image],
  simp_rw [mem_set_of_eq, â†nnreal.coe_le_coe, subtype.coe_mk, exists_prop, coe_nndist],
end
lemma nndist_set_exists : âˆƒ C, âˆ€ x : Î±, nndist (f x) (g x) â‰¤ C :=
subtype.exists.mpr $ dist_set_exists.imp $ Î» a âŸ¨ha, hâŸ©, âŸ¨ha, hâŸ©
lemma nndist_coe_le_nndist (x : Î±) : nndist (f x) (g x) â‰¤ nndist f g :=
dist_coe_le_dist x
lemma dist_zero_of_empty [is_empty Î±] : dist f g = 0 :=
by rw [(ext is_empty_elim : f = g), dist_self]
lemma dist_eq_supr : dist f g = â¨† x : Î±, dist (f x) (g x) :=
begin
  casesI is_empty_or_nonempty Î±, { rw [supr_of_empty', real.Sup_empty, dist_zero_of_empty] },
  refine (dist_le_iff_of_nonempty.mpr $ le_csupr _).antisymm (csupr_le dist_coe_le_dist),
  exact dist_set_exists.imp (Î» C hC, forall_range_iff.2 hC.2)
end
lemma nndist_eq_supr : nndist f g = â¨† x : Î±, nndist (f x) (g x) :=
subtype.ext $ dist_eq_supr.trans $ by simp_rw [nnreal.coe_supr, coe_nndist]
lemma tendsto_iff_tendsto_uniformly {Î¹ : Type*} {F : Î¹ â†’ (Î± â†’áµ‡ Î²)} {f : Î± â†’áµ‡ Î²} {l : filter Î¹} :
  tendsto F l (ğ“ f) â†” tendsto_uniformly (Î» i, F i) f l :=
iff.intro
  (Î» h, tendsto_uniformly_iff.2
    (Î» Îµ Îµ0, (metric.tendsto_nhds.mp h Îµ Îµ0).mp (eventually_of_forall $
    Î» n hn x, lt_of_le_of_lt (dist_coe_le_dist x) (dist_comm (F n) f â–¸ hn))))
  (Î» h, metric.tendsto_nhds.mpr $ Î» Îµ Îµ_pos,
    (h _ (dist_mem_uniformity $ half_pos Îµ_pos)).mp (eventually_of_forall $
    Î» n hn, lt_of_le_of_lt ((dist_le (half_pos Îµ_pos).le).mpr $
    Î» x, dist_comm (f x) (F n x) â–¸ le_of_lt (hn x)) (half_lt_self Îµ_pos)))
variables (Î±) {Î²}
@[simps {fully_applied := ff}] def const (b : Î²) : Î± â†’áµ‡ Î² :=
âŸ¨continuous_map.const Î± b, 0, by simp [le_rfl]âŸ©
variable {Î±}
lemma const_apply' (a : Î±) (b : Î²) : (const Î± b : Î± â†’ Î²) a = b := rfl
instance [inhabited Î²] : inhabited (Î± â†’áµ‡ Î²) := âŸ¨const Î± defaultâŸ©
lemma lipschitz_evalx (x : Î±) : lipschitz_with 1 (Î» f : Î± â†’áµ‡ Î², f x) :=
lipschitz_with.mk_one $ Î» f g, dist_coe_le_dist x
theorem uniform_continuous_coe : @uniform_continuous (Î± â†’áµ‡ Î²) (Î± â†’ Î²) _ _ coe_fn :=
uniform_continuous_pi.2 $ Î» x, (lipschitz_evalx x).uniform_continuous
lemma continuous_coe : continuous (Î» (f : Î± â†’áµ‡ Î²) x, f x) :=
uniform_continuous.continuous uniform_continuous_coe
@[continuity] theorem continuous_eval_const {x : Î±} : continuous (Î» f : Î± â†’áµ‡ Î², f x) :=
(continuous_apply x).comp continuous_coe
@[continuity] theorem continuous_eval : continuous (Î» p : (Î± â†’áµ‡ Î²) Ã— Î±, p.1 p.2) :=
continuous_prod_of_continuous_lipschitz _ 1 (Î» f, f.continuous) $ lipschitz_evalx
instance [complete_space Î²] : complete_space (Î± â†’áµ‡ Î²) :=
complete_of_cauchy_seq_tendsto $ Î» (f : â„• â†’ Î± â†’áµ‡ Î²) (hf : cauchy_seq f),
begin
  rcases cauchy_seq_iff_le_tendsto_0.1 hf with âŸ¨b, b0, b_bound, b_limâŸ©,
  have f_bdd := Î»x n m N hn hm, le_trans (dist_coe_le_dist x) (b_bound n m N hn hm),
  have fx_cau : âˆ€x, cauchy_seq (Î»n, f n x) :=
    Î»x, cauchy_seq_iff_le_tendsto_0.2 âŸ¨b, b0, f_bdd x, b_limâŸ©,
  choose F hF using Î»x, cauchy_seq_tendsto_of_complete (fx_cau x),
  have fF_bdd : âˆ€x N, dist (f N x) (F x) â‰¤ b N :=
    Î» x N, le_of_tendsto (tendsto_const_nhds.dist (hF x))
      (filter.eventually_at_top.2 âŸ¨N, Î»n hn, f_bdd x N n N (le_refl N) hnâŸ©),
  refine âŸ¨âŸ¨âŸ¨F, _âŸ©, _âŸ©, _âŸ©,
    have : tendsto_uniformly (Î»n x, f n x) F at_top,
    { refine metric.tendsto_uniformly_iff.2 (Î» Îµ Îµ0, _),
      refine ((tendsto_order.1 b_lim).2 Îµ Îµ0).mono (Î» n hn x, _),
      rw dist_comm,
      exact lt_of_le_of_lt (fF_bdd x n) hn },
    exact this.continuous (eventually_of_forall $ Î» N, (f N).continuous) },
    rcases (f 0).bounded with âŸ¨C, hCâŸ©,
    refine âŸ¨C + (b 0 + b 0), Î» x y, _âŸ©,
    calc dist (F x) (F y) â‰¤ dist (f 0 x) (f 0 y) + (dist (f 0 x) (F x) + dist (f 0 y) (F y)) :
      dist_triangle4_left _ _ _ _
                      ... â‰¤ C + (b 0 + b 0) : by mono* },
    refine tendsto_iff_dist_tendsto_zero.2 (squeeze_zero (Î» _, dist_nonneg) _ b_lim),
    exact Î» N, (dist_le (b0 _)).2 (Î»x, fF_bdd x N) }
end
@[simps { fully_applied := ff }]
def comp_continuous {Î´ : Type*} [topological_space Î´] (f : Î± â†’áµ‡ Î²) (g : C(Î´, Î±)) : Î´ â†’áµ‡ Î² :=
{ to_continuous_map := f.1.comp g,
  map_bounded' := f.map_bounded'.imp (Î» C hC x y, hC _ _) }
lemma lipschitz_comp_continuous {Î´ : Type*} [topological_space Î´] (g : C(Î´, Î±)) :
  lipschitz_with 1 (Î» f : Î± â†’áµ‡ Î², f.comp_continuous g) :=
lipschitz_with.mk_one $ Î» fâ‚ fâ‚‚, (dist_le dist_nonneg).2 $ Î» x, dist_coe_le_dist (g x)
lemma continuous_comp_continuous {Î´ : Type*} [topological_space Î´] (g : C(Î´, Î±)) :
  continuous (Î» f : Î± â†’áµ‡ Î², f.comp_continuous g) :=
(lipschitz_comp_continuous g).continuous
@[simps apply { fully_applied := ff }]
def restrict (f : Î± â†’áµ‡ Î²) (s : set Î±) : s â†’áµ‡ Î² :=
f.comp_continuous $ (continuous_map.id _).restrict s
def comp (G : Î² â†’ Î³) {C : â„â‰¥0} (H : lipschitz_with C G)
  (f : Î± â†’áµ‡ Î²) : Î± â†’áµ‡ Î³ :=
âŸ¨âŸ¨Î»x, G (f x), H.continuous.comp f.continuousâŸ©,
  let âŸ¨D, hDâŸ© := f.bounded in
  âŸ¨max C 0 * D, Î» x y, calc
    dist (G (f x)) (G (f y)) â‰¤ C * dist (f x) (f y) : H.dist_le_mul _ _
    ... â‰¤ max C 0 * dist (f x) (f y) : mul_le_mul_of_nonneg_right (le_max_left C 0) dist_nonneg
    ... â‰¤ max C 0 * D : mul_le_mul_of_nonneg_left (hD _ _) (le_max_right C 0)âŸ©âŸ©
lemma lipschitz_comp {G : Î² â†’ Î³} {C : â„â‰¥0} (H : lipschitz_with C G) :
  lipschitz_with C (comp G H : (Î± â†’áµ‡ Î²) â†’ Î± â†’áµ‡ Î³) :=
lipschitz_with.of_dist_le_mul $ Î» f g,
(dist_le (mul_nonneg C.2 dist_nonneg)).2 $ Î» x,
calc dist (G (f x)) (G (g x)) â‰¤ C * dist (f x) (g x) : H.dist_le_mul _ _
  ... â‰¤ C * dist f g : mul_le_mul_of_nonneg_left (dist_coe_le_dist _) C.2
lemma uniform_continuous_comp {G : Î² â†’ Î³} {C : â„â‰¥0} (H : lipschitz_with C G) :
  uniform_continuous (comp G H : (Î± â†’áµ‡ Î²) â†’ Î± â†’áµ‡ Î³) :=
(lipschitz_comp H).uniform_continuous
lemma continuous_comp {G : Î² â†’ Î³} {C : â„â‰¥0} (H : lipschitz_with C G) :
  continuous (comp G H : (Î± â†’áµ‡ Î²) â†’ Î± â†’áµ‡ Î³) :=
(lipschitz_comp H).continuous
def cod_restrict (s : set Î²) (f : Î± â†’áµ‡ Î²) (H : âˆ€x, f x âˆˆ s) : Î± â†’áµ‡ s :=
âŸ¨âŸ¨s.cod_restrict f H, continuous_subtype_mk _ f.continuousâŸ©, f.boundedâŸ©
section extend
variables {Î´ : Type*} [topological_space Î´] [discrete_topology Î´]
def extend (f : Î± â†ª Î´) (g : Î± â†’áµ‡ Î²) (h : Î´ â†’áµ‡ Î²) : Î´ â†’áµ‡ Î² :=
{ to_fun := extend f g h,
  continuous_to_fun := continuous_of_discrete_topology,
  map_bounded' :=
    begin
      rw [â† bounded_range_iff, range_extend f.injective, metric.bounded_union],
      exact âŸ¨g.bounded_range, h.bounded_image _âŸ©
    end }
@[simp] lemma extend_apply (f : Î± â†ª Î´) (g : Î± â†’áµ‡ Î²) (h : Î´ â†’áµ‡ Î²) (x : Î±) :
  extend f g h (f x) = g x :=
extend_apply f.injective _ _ _
@[simp] lemma extend_comp (f : Î± â†ª Î´) (g : Î± â†’áµ‡ Î²) (h : Î´ â†’áµ‡ Î²) : extend f g h âˆ˜ f = g :=
extend_comp f.injective _ _
lemma extend_apply' {f : Î± â†ª Î´} {x : Î´} (hx : x âˆ‰ range f) (g : Î± â†’áµ‡ Î²) (h : Î´ â†’áµ‡ Î²) :
  extend f g h x = h x :=
extend_apply' _ _ _ hx
lemma extend_of_empty [is_empty Î±] (f : Î± â†ª Î´) (g : Î± â†’áµ‡ Î²) (h : Î´ â†’áµ‡ Î²) :
  extend f g h = h :=
fun_like.coe_injective $ function.extend_of_empty f g h
@[simp] lemma dist_extend_extend (f : Î± â†ª Î´) (gâ‚ gâ‚‚ : Î± â†’áµ‡ Î²) (hâ‚ hâ‚‚ : Î´ â†’áµ‡ Î²) :
  dist (gâ‚.extend f hâ‚) (gâ‚‚.extend f hâ‚‚) =
    max (dist gâ‚ gâ‚‚) (dist (hâ‚.restrict (range f)á¶œ) (hâ‚‚.restrict (range f)á¶œ)) :=
begin
  refine le_antisymm ((dist_le $ le_max_iff.2 $ or.inl dist_nonneg).2 $ Î» x, _) (max_le _ _),
  { rcases em (âˆƒ y, f y = x) with (âŸ¨x, rflâŸ©|hx),
    { simp only [extend_apply],
      exact (dist_coe_le_dist x).trans (le_max_left _ _) },
    { simp only [extend_apply' hx],
      lift x to ((range f)á¶œ : set Î´) using hx,
      calc dist (hâ‚ x) (hâ‚‚ x) = dist (hâ‚.restrict (range f)á¶œ x) (hâ‚‚.restrict (range f)á¶œ x) : rfl
      ... â‰¤ dist (hâ‚.restrict (range f)á¶œ) (hâ‚‚.restrict (range f)á¶œ) : dist_coe_le_dist x
      ... â‰¤ _ : le_max_right _ _ } },
  { refine (dist_le dist_nonneg).2 (Î» x, _),
    rw [â† extend_apply f gâ‚ hâ‚, â† extend_apply f gâ‚‚ hâ‚‚],
    exact dist_coe_le_dist _ },
  { refine (dist_le dist_nonneg).2 (Î» x, _),
    calc dist (hâ‚ x) (hâ‚‚ x) = dist (extend f gâ‚ hâ‚ x) (extend f gâ‚‚ hâ‚‚ x) :
      by rw [extend_apply' x.coe_prop, extend_apply' x.coe_prop]
    ... â‰¤ _ : dist_coe_le_dist _ }
end
lemma isometry_extend (f : Î± â†ª Î´) (h : Î´ â†’áµ‡ Î²) :
  isometry (Î» g : Î± â†’áµ‡ Î², extend f g h) :=
isometry_emetric_iff_metric.2 $ Î» gâ‚ gâ‚‚, by simp [dist_nonneg]
end extend
end basics
section arzela_ascoli
variables [topological_space Î±] [compact_space Î±] [pseudo_metric_space Î²]
variables {f g : Î± â†’áµ‡ Î²} {x : Î±} {C : â„}
theorem arzela_ascoliâ‚ [compact_space Î²]
  (A : set (Î± â†’áµ‡ Î²))
  (closed : is_closed A)
  (H : âˆ€ (x:Î±) (Îµ > 0), âˆƒU âˆˆ ğ“ x, âˆ€ (y z âˆˆ U) (f : Î± â†’áµ‡ Î²),
    f âˆˆ A â†’ dist (f y) (f z) < Îµ) :
  is_compact A :=
begin
  refine compact_of_totally_bounded_is_closed _ closed,
  refine totally_bounded_of_finite_discretization (Î» Îµ Îµ0, _),
  rcases exists_between Îµ0 with âŸ¨Îµâ‚, Îµâ‚0, ÎµÎµâ‚âŸ©,
  let Îµâ‚‚ := Îµâ‚/2/2,
  have Îµâ‚‚0 : Îµâ‚‚ > 0 := half_pos (half_pos Îµâ‚0),
  have : âˆ€x:Î±, âˆƒU, x âˆˆ U âˆ§ is_open U âˆ§ âˆ€ (y z âˆˆ U) {f : Î± â†’áµ‡ Î²},
    f âˆˆ A â†’ dist (f y) (f z) < Îµâ‚‚ := Î» x,
      let âŸ¨U, nhdsU, hUâŸ© := H x _ Îµâ‚‚0,
          âŸ¨V, VU, openV, xVâŸ© := _root_.mem_nhds_iff.1 nhdsU in
      âŸ¨V, xV, openV, Î»y hy z hz f hf, hU y (VU hy) z (VU hz) f hfâŸ©,
  choose U hU using this,
  rcases compact_univ.elim_finite_subcover_image
    (Î»x _, (hU x).2.1) (Î»x hx, mem_bUnion (mem_univ _) (hU x).1)
    with âŸ¨tÎ±, _, âŸ¨_âŸ©, htÎ±âŸ©,
  rcases @finite_cover_balls_of_compact Î² _ _ compact_univ _ Îµâ‚‚0
    with âŸ¨tÎ², _, âŸ¨_âŸ©, htÎ²âŸ©, resetI,
  choose F hF using Î»y, show âˆƒzâˆˆtÎ², dist y z < Îµâ‚‚, by simpa using htÎ² (mem_univ y),
  refine âŸ¨tÎ± â†’ tÎ², by apply_instance, Î» f a, âŸ¨F (f a), (hF (f a)).1âŸ©, _âŸ©,
  rintro âŸ¨f, hfâŸ© âŸ¨g, hgâŸ© f_eq_g,
  refine lt_of_le_of_lt ((dist_le $ le_of_lt Îµâ‚0).2 (Î» x, _)) ÎµÎµâ‚,
  obtain âŸ¨x', x'tÎ±, hx'âŸ© : âˆƒx' âˆˆ tÎ±, x âˆˆ U x' := mem_Unionâ‚‚.1 (htÎ± (mem_univ x)),
  calc dist (f x) (g x)
      â‰¤ dist (f x) (f x') + dist (g x) (g x') + dist (f x') (g x') : dist_triangle4_right _ _ _ _
  ... â‰¤ Îµâ‚‚ + Îµâ‚‚ + Îµâ‚/2 : le_of_lt (add_lt_add (add_lt_add _ _) _)
  ... = Îµâ‚ : by rw [add_halves, add_halves],
  { exact (hU x').2.2 _ hx' _ ((hU x').1) hf },
  { exact (hU x').2.2 _ hx' _ ((hU x').1) hg },
  { have F_f_g : F (f x') = F (g x') :=
      (congr_arg (Î» f:tÎ± â†’ tÎ², (f âŸ¨x', x'tÎ±âŸ© : Î²)) f_eq_g : _),
    calc dist (f x') (g x')
          â‰¤ dist (f x') (F (f x')) + dist (g x') (F (f x')) : dist_triangle_right _ _ _
      ... = dist (f x') (F (f x')) + dist (g x') (F (g x')) : by rw F_f_g
      ... < Îµâ‚‚ + Îµâ‚‚ : add_lt_add (hF (f x')).2 (hF (g x')).2
      ... = Îµâ‚/2 : add_halves _ }
end
theorem arzela_ascoliâ‚‚
  (s : set Î²) (hs : is_compact s)
  (A : set (Î± â†’áµ‡ Î²))
  (closed : is_closed A)
  (in_s : âˆ€(f : Î± â†’áµ‡ Î²) (x : Î±), f âˆˆ A â†’ f x âˆˆ s)
  (H : âˆ€(x:Î±) (Îµ > 0), âˆƒU âˆˆ ğ“ x, âˆ€ (y z âˆˆ U) (f : Î± â†’áµ‡ Î²),
    f âˆˆ A â†’ dist (f y) (f z) < Îµ) :
  is_compact A :=
begin
  have M : lipschitz_with 1 coe := lipschitz_with.subtype_coe s,
  let F : (Î± â†’áµ‡ s) â†’ Î± â†’áµ‡ Î² := comp coe M,
  refine compact_of_is_closed_subset
    ((_ : is_compact (F â»Â¹' A)).image (continuous_comp M)) closed (Î» f hf, _),
  { haveI : compact_space s := is_compact_iff_compact_space.1 hs,
    refine arzela_ascoliâ‚ _ (continuous_iff_is_closed.1 (continuous_comp M) _ closed)
      (Î» x Îµ Îµ0, bex.imp_right (Î» U U_nhds hU y hy z hz f hf, _) (H x Îµ Îµ0)),
    calc dist (f y) (f z) = dist (F f y) (F f z) : rfl
                        ... < Îµ : hU y hy z hz (F f) hf },
  { let g := cod_restrict s f (Î»x, in_s f x hf),
    rw [show f = F g, by ext; refl] at hf âŠ¢,
    exact âŸ¨g, hf, rflâŸ© }
end
theorem arzela_ascoli [t2_space Î²]
  (s : set Î²) (hs : is_compact s)
  (A : set (Î± â†’áµ‡ Î²))
  (in_s : âˆ€(f : Î± â†’áµ‡ Î²) (x : Î±), f âˆˆ A â†’ f x âˆˆ s)
  (H : âˆ€(x:Î±) (Îµ > 0), âˆƒU âˆˆ ğ“ x, âˆ€ (y z âˆˆ U) (f : Î± â†’áµ‡ Î²),
    f âˆˆ A â†’ dist (f y) (f z) < Îµ) :
  is_compact (closure A) :=
arzela_ascoliâ‚‚ s hs (closure A) is_closed_closure
  (Î» f x hf, (mem_of_closed' hs.is_closed).2 $ Î» Îµ Îµ0,
    let âŸ¨g, gA, dist_fgâŸ© := metric.mem_closure_iff.1 hf Îµ Îµ0 in
    âŸ¨g x, in_s g x gA, lt_of_le_of_lt (dist_coe_le_dist _) dist_fgâŸ©)
  (Î» x Îµ Îµ0, show âˆƒ U âˆˆ ğ“ x,
      âˆ€ y z âˆˆ U, âˆ€ (f : Î± â†’áµ‡ Î²), f âˆˆ closure A â†’ dist (f y) (f z) < Îµ,
    begin
      refine bex.imp_right (Î» U U_set hU y hy z hz f hf, _) (H x (Îµ/2) (half_pos Îµ0)),
      rcases metric.mem_closure_iff.1 hf (Îµ/2/2) (half_pos (half_pos Îµ0)) with âŸ¨g, gA, dist_fgâŸ©,
      replace dist_fg := Î» x, lt_of_le_of_lt (dist_coe_le_dist x) dist_fg,
      calc dist (f y) (f z) â‰¤ dist (f y) (g y) + dist (f z) (g z) + dist (g y) (g z) :
        dist_triangle4_right _ _ _ _
          ... < Îµ/2/2 + Îµ/2/2 + Îµ/2 :
            add_lt_add (add_lt_add (dist_fg y) (dist_fg z)) (hU y hy z hz g gA)
          ... = Îµ : by rw [add_halves, add_halves]
    end)
lemma equicontinuous_of_continuity_modulus {Î± : Type u} [pseudo_metric_space Î±]
  (b : â„ â†’ â„) (b_lim : tendsto b (ğ“ 0) (ğ“ 0))
  (A : set (Î± â†’áµ‡ Î²))
  (H : âˆ€(x y:Î±) (f : Î± â†’áµ‡ Î²), f âˆˆ A â†’ dist (f x) (f y) â‰¤ b (dist x y))
  (x:Î±) (Îµ : â„) (Îµ0 : 0 < Îµ) : âˆƒU âˆˆ ğ“ x, âˆ€ (y z âˆˆ U) (f : Î± â†’áµ‡ Î²),
    f âˆˆ A â†’ dist (f y) (f z) < Îµ :=
begin
  rcases tendsto_nhds_nhds.1 b_lim Îµ Îµ0 with âŸ¨Î´, Î´0, hÎ´âŸ©,
  refine âŸ¨ball x (Î´/2), ball_mem_nhds x (half_pos Î´0), Î» y hy z hz f hf, _âŸ©,
  have : dist y z < Î´ := calc
    dist y z â‰¤ dist y x + dist z x : dist_triangle_right _ _ _
    ... < Î´/2 + Î´/2 : add_lt_add hy hz
    ... = Î´ : add_halves _,
  calc
    dist (f y) (f z) â‰¤ b (dist y z) : H y z f hf
    ... â‰¤ |b (dist y z)| : le_abs_self _
    ... = dist (b (dist y z)) 0 : by simp [real.dist_eq]
    ... < Îµ : hÎ´ (by simpa [real.dist_eq] using this),
end
end arzela_ascoli
section has_one
variables [topological_space Î±] [pseudo_metric_space Î²] [has_one Î²]
@[to_additive] instance : has_one (Î± â†’áµ‡ Î²) := âŸ¨const Î± 1âŸ©
@[simp, to_additive] lemma coe_one : ((1 : Î± â†’áµ‡ Î²) : Î± â†’ Î²) = 1 := rfl
@[simp, to_additive]
lemma mk_of_compact_one [compact_space Î±] : mk_of_compact (1 : C(Î±, Î²)) = 1 := rfl
@[to_additive] lemma forall_coe_one_iff_one (f : Î± â†’áµ‡ Î²) : (âˆ€ x, f x = 1) â†” f = 1 :=
(@fun_like.ext_iff _ _ _ _ f 1).symm
@[simp, to_additive] lemma one_comp_continuous [topological_space Î³] (f : C(Î³, Î±)) :
  (1 : Î± â†’áµ‡ Î²).comp_continuous f = 1 := rfl
end has_one
section has_lipschitz_add
variables [topological_space Î±] [pseudo_metric_space Î²] [add_monoid Î²]
variables [has_lipschitz_add Î²]
variables (f g : Î± â†’áµ‡ Î²) {x : Î±} {C : â„}
instance : has_add (Î± â†’áµ‡ Î²) :=
{ add := Î» f g,
  bounded_continuous_function.mk_of_bound (f.to_continuous_map + g.to_continuous_map)
    (â†‘(has_lipschitz_add.C Î²) * max (classical.some f.bounded) (classical.some g.bounded))
    begin
      intros x y,
      refine le_trans (lipschitz_with_lipschitz_const_add âŸ¨f x, g xâŸ© âŸ¨f y, g yâŸ©) _,
      rw prod.dist_eq,
      refine mul_le_mul_of_nonneg_left _ (has_lipschitz_add.C Î²).coe_nonneg,
      apply max_le_max,
      exact classical.some_spec f.bounded x y,
      exact classical.some_spec g.bounded x y,
    end }
@[simp] lemma coe_add : â‡‘(f + g) = f + g := rfl
lemma add_apply : (f + g) x = f x + g x := rfl
@[simp] lemma mk_of_compact_add [compact_space Î±] (f g : C(Î±, Î²)) :
  mk_of_compact (f + g) = mk_of_compact f + mk_of_compact g := rfl
lemma add_comp_continuous [topological_space Î³] (h : C(Î³, Î±)) :
  (g + f).comp_continuous h = g.comp_continuous h + f.comp_continuous h := rfl
@[simp] lemma coe_nsmul_rec : âˆ€ n, â‡‘(nsmul_rec n f) = n â€¢ f
| 0 := by rw [nsmul_rec, zero_smul, coe_zero]
| (n + 1) := by rw [nsmul_rec, succ_nsmul, coe_add, coe_nsmul_rec]
instance has_nat_scalar : has_smul â„• (Î± â†’áµ‡ Î²) :=
{ smul := Î» n f,
  { to_continuous_map := n â€¢ f.to_continuous_map,
    map_bounded' := by simpa [coe_nsmul_rec] using (nsmul_rec n f).map_bounded' } }
@[simp] lemma coe_nsmul (r : â„•) (f : Î± â†’áµ‡ Î²) : â‡‘(r â€¢ f) = r â€¢ f := rfl
@[simp] lemma nsmul_apply (r : â„•) (f : Î± â†’áµ‡ Î²) (v : Î±) : (r â€¢ f) v = r â€¢ f v := rfl
instance : add_monoid (Î± â†’áµ‡ Î²) :=
fun_like.coe_injective.add_monoid _ coe_zero coe_add (Î» _ _, coe_nsmul _ _)
instance : has_lipschitz_add (Î± â†’áµ‡ Î²) :=
{ lipschitz_add := âŸ¨has_lipschitz_add.C Î², begin
    have C_nonneg := (has_lipschitz_add.C Î²).coe_nonneg,
    rw lipschitz_with_iff_dist_le_mul,
    rintros âŸ¨fâ‚, gâ‚âŸ© âŸ¨fâ‚‚, gâ‚‚âŸ©,
    rw dist_le (mul_nonneg C_nonneg dist_nonneg),
    intros x,
    refine le_trans (lipschitz_with_lipschitz_const_add âŸ¨fâ‚ x, gâ‚ xâŸ© âŸ¨fâ‚‚ x, gâ‚‚ xâŸ©) _,
    refine mul_le_mul_of_nonneg_left _ C_nonneg,
    apply max_le_max; exact dist_coe_le_dist x,
  endâŸ© }
@[simps] def coe_fn_add_hom : (Î± â†’áµ‡ Î²) â†’+ (Î± â†’ Î²) :=
{ to_fun := coe_fn, map_zero' := coe_zero, map_add' := coe_add }
variables (Î± Î²)
@[simps] def to_continuous_map_add_hom : (Î± â†’áµ‡ Î²) â†’+ C(Î±, Î²) :=
{ to_fun := to_continuous_map,
  map_zero' := by { ext, simp, },
  map_add' := by { intros, ext, simp, }, }
end has_lipschitz_add
section comm_has_lipschitz_add
variables [topological_space Î±] [pseudo_metric_space Î²] [add_comm_monoid Î²] [has_lipschitz_add Î²]
@[to_additive] instance : add_comm_monoid (Î± â†’áµ‡ Î²) :=
{ add_comm      := assume f g, by ext; simp [add_comm],
  .. bounded_continuous_function.add_monoid }
open_locale big_operators
@[simp] lemma coe_sum {Î¹ : Type*} (s : finset Î¹) (f : Î¹ â†’ (Î± â†’áµ‡ Î²)) :
  â‡‘(âˆ‘ i in s, f i) = (âˆ‘ i in s, (f i : Î± â†’ Î²)) :=
(@coe_fn_add_hom Î± Î² _ _ _ _).map_sum f s
lemma sum_apply {Î¹ : Type*} (s : finset Î¹) (f : Î¹ â†’ (Î± â†’áµ‡ Î²)) (a : Î±) :
  (âˆ‘ i in s, f i) a = (âˆ‘ i in s, f i a) :=
by simp
end comm_has_lipschitz_add
section normed_group
variables [topological_space Î±] [semi_normed_group Î²]
variables (f g : Î± â†’áµ‡ Î²) {x : Î±} {C : â„}
instance : has_norm (Î± â†’áµ‡ Î²) := âŸ¨Î»u, dist u 0âŸ©
lemma norm_def : âˆ¥fâˆ¥ = dist f 0 := rfl
lemma norm_eq (f : Î± â†’áµ‡ Î²) :
  âˆ¥fâˆ¥ = Inf {C : â„ | 0 â‰¤ C âˆ§ âˆ€ (x : Î±), âˆ¥f xâˆ¥ â‰¤ C} :=
by simp [norm_def, bounded_continuous_function.dist_eq]
lemma norm_eq_of_nonempty [h : nonempty Î±] : âˆ¥fâˆ¥ = Inf {C : â„ | âˆ€ (x : Î±), âˆ¥f xâˆ¥ â‰¤ C} :=
begin
  unfreezingI { obtain âŸ¨aâŸ© := h, },
  rw norm_eq,
  congr,
  ext,
  simp only [and_iff_right_iff_imp],
  exact Î» h', le_trans (norm_nonneg (f a)) (h' a),
end
@[simp] lemma norm_eq_zero_of_empty [h : is_empty Î±] : âˆ¥fâˆ¥ = 0 :=
dist_zero_of_empty
lemma norm_coe_le_norm (x : Î±) : âˆ¥f xâˆ¥ â‰¤ âˆ¥fâˆ¥ := calc
  âˆ¥f xâˆ¥ = dist (f x) ((0 : Î± â†’áµ‡ Î²) x) : by simp [dist_zero_right]
  ... â‰¤ âˆ¥fâˆ¥ : dist_coe_le_dist _
lemma dist_le_two_norm' {f : Î³ â†’ Î²} {C : â„} (hC : âˆ€ x, âˆ¥f xâˆ¥ â‰¤ C) (x y : Î³) :
  dist (f x) (f y) â‰¤ 2 * C :=
calc dist (f x) (f y) â‰¤ âˆ¥f xâˆ¥ + âˆ¥f yâˆ¥ : dist_le_norm_add_norm _ _
                  ... â‰¤ C + C         : add_le_add (hC x) (hC y)
                  ... = 2 * C         : (two_mul _).symm
lemma dist_le_two_norm (x y : Î±) : dist (f x) (f y) â‰¤ 2 * âˆ¥fâˆ¥ :=
dist_le_two_norm' f.norm_coe_le_norm x y
variable {f}
lemma norm_le (C0 : (0 : â„) â‰¤ C) : âˆ¥fâˆ¥ â‰¤ C â†” âˆ€x:Î±, âˆ¥f xâˆ¥ â‰¤ C :=
by simpa using @dist_le _ _ _ _ f 0 _ C0
lemma norm_le_of_nonempty [nonempty Î±]
  {f : Î± â†’áµ‡ Î²} {M : â„} : âˆ¥fâˆ¥ â‰¤ M â†” âˆ€ x, âˆ¥f xâˆ¥ â‰¤ M :=
begin
  simp_rw [norm_def, â†dist_zero_right],
  exact dist_le_iff_of_nonempty,
end
lemma norm_lt_iff_of_compact [compact_space Î±]
  {f : Î± â†’áµ‡ Î²} {M : â„} (M0 : 0 < M) : âˆ¥fâˆ¥ < M â†” âˆ€ x, âˆ¥f xâˆ¥ < M :=
begin
  simp_rw [norm_def, â†dist_zero_right],
  exact dist_lt_iff_of_compact M0,
end
lemma norm_lt_iff_of_nonempty_compact [nonempty Î±] [compact_space Î±]
  {f : Î± â†’áµ‡ Î²} {M : â„} : âˆ¥fâˆ¥ < M â†” âˆ€ x, âˆ¥f xâˆ¥ < M :=
begin
  simp_rw [norm_def, â†dist_zero_right],
  exact dist_lt_iff_of_nonempty_compact,
end
variable (f)
lemma norm_const_le (b : Î²) : âˆ¥const Î± bâˆ¥ â‰¤ âˆ¥bâˆ¥ :=
(norm_le (norm_nonneg b)).2 $ Î» x, le_rfl
@[simp] lemma norm_const_eq [h : nonempty Î±] (b : Î²) : âˆ¥const Î± bâˆ¥ = âˆ¥bâˆ¥ :=
le_antisymm (norm_const_le b) $ h.elim $ Î» x, (const Î± b).norm_coe_le_norm x
def of_normed_group {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²]
  (f : Î± â†’ Î²) (Hf : continuous f) (C : â„) (H : âˆ€x, âˆ¥f xâˆ¥ â‰¤ C) : Î± â†’áµ‡ Î² :=
âŸ¨âŸ¨Î»n, f n, HfâŸ©, âŸ¨_, dist_le_two_norm' HâŸ©âŸ©
@[simp] lemma coe_of_normed_group
  {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²]
  (f : Î± â†’ Î²) (Hf : continuous f) (C : â„) (H : âˆ€x, âˆ¥f xâˆ¥ â‰¤ C) :
  (of_normed_group f Hf C H : Î± â†’ Î²) = f := rfl
lemma norm_of_normed_group_le {f : Î± â†’ Î²} (hfc : continuous f) {C : â„} (hC : 0 â‰¤ C)
  (hfC : âˆ€ x, âˆ¥f xâˆ¥ â‰¤ C) : âˆ¥of_normed_group f hfc C hfCâˆ¥ â‰¤ C :=
(norm_le hC).2 hfC
def of_normed_group_discrete {Î± : Type u} {Î² : Type v}
  [topological_space Î±] [discrete_topology Î±] [semi_normed_group Î²]
  (f : Î±  â†’ Î²) (C : â„) (H : âˆ€x, norm (f x) â‰¤ C) : Î± â†’áµ‡ Î² :=
of_normed_group f continuous_of_discrete_topology C H
@[simp] lemma coe_of_normed_group_discrete
  {Î± : Type u} {Î² : Type v} [topological_space Î±] [discrete_topology Î±] [semi_normed_group Î²]
  (f : Î± â†’ Î²) (C : â„) (H : âˆ€x, âˆ¥f xâˆ¥ â‰¤ C) :
  (of_normed_group_discrete f C H : Î± â†’ Î²) = f := rfl
def norm_comp : Î± â†’áµ‡ â„ :=
f.comp norm lipschitz_with_one_norm
@[simp] lemma coe_norm_comp : (f.norm_comp : Î± â†’ â„) = norm âˆ˜ f := rfl
@[simp] lemma norm_norm_comp : âˆ¥f.norm_compâˆ¥ = âˆ¥fâˆ¥ :=
by simp only [norm_eq, coe_norm_comp, norm_norm]
lemma bdd_above_range_norm_comp : bdd_above $ set.range $ norm âˆ˜ f :=
(real.bounded_iff_bdd_below_bdd_above.mp $ @bounded_range _ _ _ _ f.norm_comp).2
lemma norm_eq_supr_norm : âˆ¥fâˆ¥ = â¨† x : Î±, âˆ¥f xâˆ¥ :=
by simp_rw [norm_def, dist_eq_supr, coe_zero, pi.zero_apply, dist_zero_right]
instance : has_neg (Î± â†’áµ‡ Î²) :=
âŸ¨Î»f, of_normed_group (-f) f.continuous.neg âˆ¥fâˆ¥ $ Î» x,
  trans_rel_right _ (norm_neg _) (f.norm_coe_le_norm x)âŸ©
instance : has_sub (Î± â†’áµ‡ Î²) :=
âŸ¨Î»f g, of_normed_group (f - g) (f.continuous.sub g.continuous) (âˆ¥fâˆ¥ + âˆ¥gâˆ¥) $ Î» x,
  by { simp only [sub_eq_add_neg],
       exact le_trans (norm_add_le _ _) (add_le_add (f.norm_coe_le_norm x) $
         trans_rel_right _ (norm_neg _) (g.norm_coe_le_norm x)) }âŸ©
@[simp] lemma coe_neg : â‡‘(-f) = -f := rfl
lemma neg_apply : (-f) x = -f x := rfl
@[simp] lemma coe_sub : â‡‘(f - g) = f - g := rfl
lemma sub_apply : (f - g) x = f x - g x := rfl
@[simp] lemma mk_of_compact_neg [compact_space Î±] (f : C(Î±, Î²)) :
  mk_of_compact (-f) = -mk_of_compact f := rfl
@[simp] lemma mk_of_compact_sub [compact_space Î±] (f g : C(Î±, Î²)) :
  mk_of_compact (f - g) = mk_of_compact f - mk_of_compact g := rfl
@[simp] lemma coe_zsmul_rec : âˆ€ z, â‡‘(zsmul_rec z f) = z â€¢ f
| (int.of_nat n) := by rw [zsmul_rec, int.of_nat_eq_coe, coe_nsmul_rec, coe_nat_zsmul]
| -[1+ n] := by rw [zsmul_rec, zsmul_neg_succ_of_nat, coe_neg, coe_nsmul_rec]
instance has_int_scalar : has_smul â„¤ (Î± â†’áµ‡ Î²) :=
{ smul := Î» n f,
  { to_continuous_map := n â€¢ f.to_continuous_map,
    map_bounded' := by simpa using (zsmul_rec n f).map_bounded' } }
@[simp] lemma coe_zsmul (r : â„¤) (f : Î± â†’áµ‡ Î²) : â‡‘(r â€¢ f) = r â€¢ f := rfl
@[simp] lemma zsmul_apply (r : â„¤) (f : Î± â†’áµ‡ Î²) (v : Î±) : (r â€¢ f) v = r â€¢ f v := rfl
instance : add_comm_group (Î± â†’áµ‡ Î²) :=
fun_like.coe_injective.add_comm_group _ coe_zero coe_add coe_neg coe_sub (Î» _ _, coe_nsmul _ _)
  (Î» _ _, coe_zsmul _ _)
instance : semi_normed_group (Î± â†’áµ‡ Î²) :=
{ dist_eq := Î» f g, by simp only [norm_eq, dist_eq, dist_eq_norm, sub_apply] }
instance {Î± Î²} [topological_space Î±] [normed_group Î²] : normed_group (Î± â†’áµ‡ Î²) :=
{ ..bounded_continuous_function.semi_normed_group }
lemma nnnorm_def : âˆ¥fâˆ¥â‚Š = nndist f 0 := rfl
lemma nnnorm_coe_le_nnnorm (x : Î±) : âˆ¥f xâˆ¥â‚Š â‰¤ âˆ¥fâˆ¥â‚Š := norm_coe_le_norm _ _
lemma nndist_le_two_nnnorm (x y : Î±) : nndist (f x) (f y) â‰¤ 2 * âˆ¥fâˆ¥â‚Š := dist_le_two_norm _ _ _
lemma nnnorm_le (C : â„â‰¥0) : âˆ¥fâˆ¥â‚Š â‰¤ C â†” âˆ€x:Î±, âˆ¥f xâˆ¥â‚Š â‰¤ C :=
norm_le C.prop
lemma nnnorm_const_le (b : Î²) : âˆ¥const Î± bâˆ¥â‚Š â‰¤ âˆ¥bâˆ¥â‚Š :=
norm_const_le _
@[simp] lemma nnnorm_const_eq [h : nonempty Î±] (b : Î²) : âˆ¥const Î± bâˆ¥â‚Š = âˆ¥bâˆ¥â‚Š :=
subtype.ext $ norm_const_eq _
lemma nnnorm_eq_supr_nnnorm : âˆ¥fâˆ¥â‚Š = â¨† x : Î±, âˆ¥f xâˆ¥â‚Š :=
subtype.ext $ (norm_eq_supr_norm f).trans $ by simp_rw [nnreal.coe_supr, coe_nnnorm]
lemma abs_diff_coe_le_dist : âˆ¥f x - g xâˆ¥ â‰¤ dist f g :=
by { rw dist_eq_norm, exact (f - g).norm_coe_le_norm x }
lemma coe_le_coe_add_dist {f g : Î± â†’áµ‡ â„} : f x â‰¤ g x + dist f g :=
sub_le_iff_le_add'.1 $ (abs_le.1 $ @dist_coe_le_dist _ _ _ _ f g x).2
lemma norm_comp_continuous_le [topological_space Î³] (f : Î± â†’áµ‡ Î²) (g : C(Î³, Î±)) :
  âˆ¥f.comp_continuous gâˆ¥ â‰¤ âˆ¥fâˆ¥ :=
((lipschitz_comp_continuous g).dist_le_mul f 0).trans $
  by rw [nnreal.coe_one, one_mul, dist_zero_right]
end normed_group
section has_bounded_smul
variables {ğ•œ : Type*} [pseudo_metric_space ğ•œ] [topological_space Î±] [pseudo_metric_space Î²]
section has_smul
variables [has_zero ğ•œ] [has_zero Î²] [has_smul ğ•œ Î²] [has_bounded_smul ğ•œ Î²]
instance : has_smul ğ•œ (Î± â†’áµ‡ Î²) :=
{ smul := Î» c f,
  { to_continuous_map := c â€¢ f.to_continuous_map,
    map_bounded' := let âŸ¨b, hbâŸ© := f.bounded in âŸ¨dist c 0 * b, Î» x y, begin
      refine (dist_smul_pair c (f x) (f y)).trans _,
      refine mul_le_mul_of_nonneg_left _ dist_nonneg,
      exact hb x y
    endâŸ© } }
@[simp] lemma coe_smul (c : ğ•œ) (f : Î± â†’áµ‡ Î²) : â‡‘(c â€¢ f) = Î» x, c â€¢ (f x) := rfl
lemma smul_apply (c : ğ•œ) (f : Î± â†’áµ‡ Î²) (x : Î±) : (c â€¢ f) x = c â€¢ f x := rfl
instance [has_smul ğ•œáµáµ’áµ– Î²] [is_central_scalar ğ•œ Î²] : is_central_scalar ğ•œ (Î± â†’áµ‡ Î²) :=
{ op_smul_eq_smul := Î» _ _, ext $ Î» _, op_smul_eq_smul _ _ }
instance : has_bounded_smul ğ•œ (Î± â†’áµ‡ Î²) :=
{ dist_smul_pair' := Î» c fâ‚ fâ‚‚, begin
    rw dist_le (mul_nonneg dist_nonneg dist_nonneg),
    intros x,
    refine (dist_smul_pair c (fâ‚ x) (fâ‚‚ x)).trans _,
    exact mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg
  end,
  dist_pair_smul' := Î» câ‚ câ‚‚ f, begin
    rw dist_le (mul_nonneg dist_nonneg dist_nonneg),
    intros x,
    refine (dist_pair_smul câ‚ câ‚‚ (f x)).trans _,
    convert mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg,
    simp
  end }
end has_smul
section mul_action
variables [monoid_with_zero ğ•œ] [has_zero Î²] [mul_action ğ•œ Î²] [has_bounded_smul ğ•œ Î²]
instance : mul_action ğ•œ (Î± â†’áµ‡ Î²) := fun_like.coe_injective.mul_action _ coe_smul
end mul_action
section distrib_mul_action
variables [monoid_with_zero ğ•œ] [add_monoid Î²] [distrib_mul_action ğ•œ Î²] [has_bounded_smul ğ•œ Î²]
variables [has_lipschitz_add Î²]
instance : distrib_mul_action ğ•œ (Î± â†’áµ‡ Î²) :=
function.injective.distrib_mul_action âŸ¨_, coe_zero, coe_addâŸ© fun_like.coe_injective coe_smul
end distrib_mul_action
section module
variables [semiring ğ•œ] [add_comm_monoid Î²] [module ğ•œ Î²] [has_bounded_smul ğ•œ Î²]
variables {f g : Î± â†’áµ‡ Î²} {x : Î±} {C : â„}
variables [has_lipschitz_add Î²]
instance : module ğ•œ (Î± â†’áµ‡ Î²) :=
function.injective.module _ âŸ¨_, coe_zero, coe_addâŸ© fun_like.coe_injective coe_smul
variables (ğ•œ)
def eval_clm (x : Î±) : (Î± â†’áµ‡ Î²) â†’L[ğ•œ] Î² :=
{ to_fun := Î» f, f x,
  map_add' := Î» f g, add_apply _ _,
  map_smul' := Î» c f, smul_apply _ _ _ }
@[simp] lemma eval_clm_apply (x : Î±) (f : Î± â†’áµ‡ Î²) :
  eval_clm ğ•œ x f = f x := rfl
variables (Î± Î²)
@[simps]
def to_continuous_map_linear_map : (Î± â†’áµ‡ Î²) â†’â‚—[ğ•œ] C(Î±, Î²) :=
{ to_fun := to_continuous_map,
  map_smul' := Î» f g, rfl,
  map_add' := Î» c f, rfl }
end module
end has_bounded_smul
section normed_space
variables {ğ•œ : Type*}
variables [topological_space Î±] [semi_normed_group Î²]
variables {f g : Î± â†’áµ‡ Î²} {x : Î±} {C : â„}
instance [normed_field ğ•œ] [normed_space ğ•œ Î²] : normed_space ğ•œ (Î± â†’áµ‡ Î²) := âŸ¨Î» c f, begin
  refine norm_of_normed_group_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _,
  exact (Î» x, trans_rel_right _ (norm_smul _ _)
    (mul_le_mul_of_nonneg_left (f.norm_coe_le_norm _) (norm_nonneg _))) endâŸ©
variables [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ Î²]
variables [semi_normed_group Î³] [normed_space ğ•œ Î³]
variables (Î±)
protected def _root_.continuous_linear_map.comp_left_continuous_bounded (g : Î² â†’L[ğ•œ] Î³) :
  (Î± â†’áµ‡ Î²) â†’L[ğ•œ] (Î± â†’áµ‡ Î³) :=
linear_map.mk_continuous
  { to_fun := Î» f, of_normed_group
      (g âˆ˜ f)
      (g.continuous.comp f.continuous)
      (âˆ¥gâˆ¥ * âˆ¥fâˆ¥)
      (Î» x, (g.le_op_norm_of_le (f.norm_coe_le_norm x))),
    map_add' := Î» f g, by ext; simp,
    map_smul' := Î» c f, by ext; simp }
  âˆ¥gâˆ¥
  (Î» f, norm_of_normed_group_le _ (mul_nonneg (norm_nonneg g) (norm_nonneg f)) _)
@[simp] lemma _root_.continuous_linear_map.comp_left_continuous_bounded_apply (g : Î² â†’L[ğ•œ] Î³)
  (f : Î± â†’áµ‡ Î²) (x : Î±) :
  (g.comp_left_continuous_bounded Î± f) x = g (f x) :=
rfl
end normed_space
section normed_ring
variables [topological_space Î±] {R : Type*}
section non_unital
section semi_normed
variables [non_unital_semi_normed_ring R]
instance : has_mul (Î± â†’áµ‡ R) :=
{ mul := Î» f g, of_normed_group (f * g) (f.continuous.mul g.continuous) (âˆ¥fâˆ¥ * âˆ¥gâˆ¥) $ Î» x,
    le_trans (norm_mul_le (f x) (g x)) $
      mul_le_mul (f.norm_coe_le_norm x) (g.norm_coe_le_norm x) (norm_nonneg _) (norm_nonneg _) }
@[simp] lemma coe_mul (f g : Î± â†’áµ‡ R) : â‡‘(f * g) = f * g := rfl
lemma mul_apply (f g : Î± â†’áµ‡ R) (x : Î±) : (f * g) x = f x * g x := rfl
instance : non_unital_ring (Î± â†’áµ‡ R) :=
fun_like.coe_injective.non_unital_ring _ coe_zero coe_add coe_mul coe_neg coe_sub
  (Î» _ _, coe_nsmul _ _) (Î» _ _, coe_zsmul _ _)
instance : non_unital_semi_normed_ring (Î± â†’áµ‡ R) :=
{ norm_mul := Î» f g, norm_of_normed_group_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _,
  .. bounded_continuous_function.semi_normed_group }
end semi_normed
instance [non_unital_normed_ring R] : non_unital_normed_ring (Î± â†’áµ‡ R) :=
{ .. bounded_continuous_function.non_unital_semi_normed_ring,
  .. bounded_continuous_function.normed_group }
end non_unital
section semi_normed
variables [semi_normed_ring R]
@[simp] lemma coe_npow_rec (f : Î± â†’áµ‡ R) : âˆ€ n, â‡‘(npow_rec n f) = f ^ n
| 0 := by rw [npow_rec, pow_zero, coe_one]
| (n + 1) := by rw [npow_rec, pow_succ, coe_mul, coe_npow_rec]
instance has_nat_pow : has_pow (Î± â†’áµ‡ R) â„• :=
{ pow := Î» f n,
  { to_continuous_map := f.to_continuous_map ^ n,
    map_bounded' := by simpa [coe_npow_rec] using (npow_rec n f).map_bounded' } }
@[simp] lemma coe_pow (n : â„•) (f : Î± â†’áµ‡ R) : â‡‘(f ^ n) = f ^ n := rfl
@[simp] lemma pow_apply (n : â„•) (f : Î± â†’áµ‡ R) (v : Î±) : (f ^ n) v = f v ^ n := rfl
instance : has_nat_cast (Î± â†’áµ‡ R) :=
âŸ¨Î» n, bounded_continuous_function.const _ nâŸ©
@[simp, norm_cast] lemma coe_nat_cast (n : â„•) : ((n : Î± â†’áµ‡ R) : Î± â†’ R) = n := rfl
instance : has_int_cast (Î± â†’áµ‡ R) :=
âŸ¨Î» n, bounded_continuous_function.const _ nâŸ©
@[simp, norm_cast] lemma coe_int_cast (n : â„¤) : ((n : Î± â†’áµ‡ R) : Î± â†’ R) = n := rfl
instance : ring (Î± â†’áµ‡ R) :=
fun_like.coe_injective.ring _ coe_zero coe_one coe_add coe_mul coe_neg coe_sub
  (Î» _ _, coe_nsmul _ _)
  (Î» _ _, coe_zsmul _ _)
  (Î» _ _, coe_pow _ _)
  coe_nat_cast
  coe_int_cast
instance : semi_normed_ring (Î± â†’áµ‡ R) :=
{ ..bounded_continuous_function.non_unital_semi_normed_ring }
end semi_normed
instance [normed_ring R] : normed_ring (Î± â†’áµ‡ R) :=
{ ..bounded_continuous_function.non_unital_normed_ring }
end normed_ring
section normed_comm_ring
variables [topological_space Î±] {R : Type*}
instance [semi_normed_comm_ring R] : comm_ring (Î± â†’áµ‡ R) :=
{ mul_comm := Î» fâ‚ fâ‚‚, ext $ Î» x, mul_comm _ _,
  .. bounded_continuous_function.ring }
instance [semi_normed_comm_ring R] : semi_normed_comm_ring (Î± â†’áµ‡ R) :=
{ .. bounded_continuous_function.comm_ring, .. bounded_continuous_function.semi_normed_group }
instance [normed_comm_ring R] : normed_comm_ring (Î± â†’áµ‡ R) :=
{ .. bounded_continuous_function.comm_ring, .. bounded_continuous_function.normed_group }
end normed_comm_ring
section normed_algebra
variables {ğ•œ : Type*} [normed_field ğ•œ]
variables [topological_space Î±] [semi_normed_group Î²] [normed_space ğ•œ Î²]
variables [normed_ring Î³] [normed_algebra ğ•œ Î³]
variables {f g : Î± â†’áµ‡ Î³} {x : Î±} {c : ğ•œ}
def C : ğ•œ â†’+* (Î± â†’áµ‡ Î³) :=
{ to_fun    := Î» (c : ğ•œ), const Î± ((algebra_map ğ•œ Î³) c),
  map_one'  := ext $ Î» x, (algebra_map ğ•œ Î³).map_one,
  map_mul'  := Î» câ‚ câ‚‚, ext $ Î» x, (algebra_map ğ•œ Î³).map_mul _ _,
  map_zero' := ext $ Î» x, (algebra_map ğ•œ Î³).map_zero,
  map_add'  := Î» câ‚ câ‚‚, ext $ Î» x, (algebra_map ğ•œ Î³).map_add _ _ }
instance : algebra ğ•œ (Î± â†’áµ‡ Î³) :=
{ to_ring_hom := C,
  commutes' := Î» c f, ext $ Î» x, algebra.commutes' _ _,
  smul_def' := Î» c f, ext $ Î» x, algebra.smul_def' _ _,
  ..bounded_continuous_function.module,
  ..bounded_continuous_function.ring }
@[simp] lemma algebra_map_apply (k : ğ•œ) (a : Î±) :
  algebra_map ğ•œ (Î± â†’áµ‡ Î³) k a = k â€¢ 1 :=
by { rw algebra.algebra_map_eq_smul_one, refl, }
instance : normed_algebra ğ•œ (Î± â†’áµ‡ Î³) :=
{ ..bounded_continuous_function.normed_space }
instance has_smul' : has_smul (Î± â†’áµ‡ ğ•œ) (Î± â†’áµ‡ Î²) :=
âŸ¨Î» (f : Î± â†’áµ‡ ğ•œ) (g : Î± â†’áµ‡ Î²), of_normed_group (Î» x, (f x) â€¢ (g x))
(f.continuous.smul g.continuous) (âˆ¥fâˆ¥ * âˆ¥gâˆ¥) (Î» x, calc
  âˆ¥f x â€¢ g xâˆ¥ â‰¤ âˆ¥f xâˆ¥ * âˆ¥g xâˆ¥ : normed_space.norm_smul_le _ _
  ... â‰¤ âˆ¥fâˆ¥ * âˆ¥gâˆ¥ : mul_le_mul (f.norm_coe_le_norm _) (g.norm_coe_le_norm _) (norm_nonneg _)
    (norm_nonneg _)) âŸ©
instance module' : module (Î± â†’áµ‡ ğ•œ) (Î± â†’áµ‡ Î²) :=
module.of_core $
{ smul     := (â€¢),
  smul_add := Î» c fâ‚ fâ‚‚, ext $ Î» x, smul_add _ _ _,
  add_smul := Î» câ‚ câ‚‚ f, ext $ Î» x, add_smul _ _ _,
  mul_smul := Î» câ‚ câ‚‚ f, ext $ Î» x, mul_smul _ _ _,
  one_smul := Î» f, ext $ Î» x, one_smul ğ•œ (f x) }
lemma norm_smul_le (f : Î± â†’áµ‡ ğ•œ) (g : Î± â†’áµ‡ Î²) : âˆ¥f â€¢ gâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥gâˆ¥ :=
norm_of_normed_group_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _
end normed_algebra
lemma nnreal.upper_bound {Î± : Type*} [topological_space Î±]
  (f : Î± â†’áµ‡ â„â‰¥0) (x : Î±) : f x â‰¤ nndist f 0 :=
begin
  have key : nndist (f x) ((0 : Î± â†’áµ‡ â„â‰¥0) x) â‰¤ nndist f 0,
  { exact @dist_coe_le_dist Î± â„â‰¥0 _ _ f 0 x, },
  simp only [coe_zero, pi.zero_apply] at key,
  rwa nnreal.nndist_zero_eq_val' (f x) at key,
end
section normed_group
variables {ğ•œ : Type*} [normed_field ğ•œ] [star_ring ğ•œ]
variables [topological_space Î±] [semi_normed_group Î²] [star_add_monoid Î²] [normed_star_group Î²]
variables [normed_space ğ•œ Î²] [star_module ğ•œ Î²]
instance : star_add_monoid (Î± â†’áµ‡ Î²) :=
{ star            := Î» f, f.comp star star_normed_group_hom.lipschitz,
  star_involutive := Î» f, ext $ Î» x, star_star (f x),
  star_add        := Î» f g, ext $ Î» x, star_add (f x) (g x) }
@[simp] lemma coe_star (f : Î± â†’áµ‡ Î²) : â‡‘(star f) = star f := rfl
@[simp] lemma star_apply (f : Î± â†’áµ‡ Î²) (x : Î±) : star f x = star (f x) := rfl
instance : normed_star_group (Î± â†’áµ‡ Î²) :=
{ norm_star := Î» f, by simp only [norm_eq, star_apply, norm_star] }
instance : star_module ğ•œ (Î± â†’áµ‡ Î²) :=
{ star_smul := Î» k f, ext $ Î» x, star_smul k (f x) }
end normed_group
section cstar_ring
variables [topological_space Î±]
variables [non_unital_normed_ring Î²] [star_ring Î²]
instance [normed_star_group Î²] : star_ring (Î± â†’áµ‡ Î²) :=
{ star_mul := Î» f g, ext $ Î» x, star_mul (f x) (g x),
  ..bounded_continuous_function.star_add_monoid }
variable [cstar_ring Î²]
instance : cstar_ring (Î± â†’áµ‡ Î²) :=
{ norm_star_mul_self :=
  begin
    intro f,
    refine le_antisymm _ _,
    { rw [â†sq, norm_le (sq_nonneg _)],
      dsimp [star_apply],
      intro x,
      rw [cstar_ring.norm_star_mul_self, â†sq],
      refine sq_le_sq' _ _,
      { linarith [norm_nonneg (f x), norm_nonneg f] },
      { exact norm_coe_le_norm f x }, },
    { rw [â†sq, â†real.le_sqrt (norm_nonneg _) (norm_nonneg _), norm_le (real.sqrt_nonneg _)],
      intro x,
      rw [real.le_sqrt (norm_nonneg _) (norm_nonneg _), sq, â†cstar_ring.norm_star_mul_self],
      exact norm_coe_le_norm (star f * f) x }
  end }
end cstar_ring
section normed_lattice_ordered_group
variables [topological_space Î±] [normed_lattice_add_comm_group Î²]
instance : partial_order (Î± â†’áµ‡ Î²) := partial_order.lift (Î» f, f.to_fun) (by tidy)
instance : semilattice_inf (Î± â†’áµ‡ Î²) :=
{ inf := Î» f g,
  { to_fun := Î» t, f t âŠ“ g t,
    continuous_to_fun := f.continuous.inf g.continuous,
    map_bounded' := begin
      obtain âŸ¨Câ‚, hfâŸ© := f.bounded,
      obtain âŸ¨Câ‚‚, hgâŸ© := g.bounded,
      refine âŸ¨Câ‚ + Câ‚‚, Î» x y, _âŸ©,
      simp_rw normed_group.dist_eq at hf hg âŠ¢,
      exact (norm_inf_sub_inf_le_add_norm _ _ _ _).trans (add_le_add (hf _ _) (hg _ _)),
    end },
  inf_le_left := Î» f g, continuous_map.le_def.mpr (Î» _, inf_le_left),
  inf_le_right := Î» f g, continuous_map.le_def.mpr (Î» _, inf_le_right),
  le_inf := Î» f gâ‚ gâ‚‚ wâ‚ wâ‚‚, continuous_map.le_def.mpr (Î» _, le_inf (continuous_map.le_def.mp wâ‚ _)
    (continuous_map.le_def.mp wâ‚‚ _)),
  ..bounded_continuous_function.partial_order }
instance : semilattice_sup (Î± â†’áµ‡ Î²) :=
{ sup := Î» f g,
  { to_fun := Î» t, f t âŠ” g t,
    continuous_to_fun := f.continuous.sup g.continuous,
    map_bounded' := begin
      obtain âŸ¨Câ‚, hfâŸ© := f.bounded,
      obtain âŸ¨Câ‚‚, hgâŸ© := g.bounded,
      refine âŸ¨Câ‚ + Câ‚‚, Î» x y, _âŸ©,
      simp_rw normed_group.dist_eq at hf hg âŠ¢,
      exact (norm_sup_sub_sup_le_add_norm _ _ _ _).trans (add_le_add (hf _ _) (hg _ _)),
    end },
  le_sup_left := Î» f g, continuous_map.le_def.mpr (Î» _, le_sup_left),
  le_sup_right := Î» f g, continuous_map.le_def.mpr (Î» _, le_sup_right),
  sup_le := Î» f gâ‚ gâ‚‚ wâ‚ wâ‚‚, continuous_map.le_def.mpr (Î» _, sup_le (continuous_map.le_def.mp wâ‚ _)
    (continuous_map.le_def.mp wâ‚‚ _)),
  ..bounded_continuous_function.partial_order }
instance  : lattice (Î± â†’áµ‡ Î²) :=
{ .. bounded_continuous_function.semilattice_sup, .. bounded_continuous_function.semilattice_inf }
@[simp] lemma coe_fn_sup (f g : Î± â†’áµ‡ Î²) : â‡‘(f âŠ” g) = f âŠ” g := rfl
@[simp] lemma coe_fn_abs (f : Î± â†’áµ‡ Î²) : â‡‘|f| = |f| := rfl
instance : normed_lattice_add_comm_group (Î± â†’áµ‡ Î²) :=
{ add_le_add_left := begin
    intros f g hâ‚ h t,
    simp only [coe_to_continuous_fun, pi.add_apply, add_le_add_iff_left, coe_add,
      continuous_map.to_fun_eq_coe],
    exact hâ‚ _,
  end,
  solid :=
  begin
    intros f g h,
    have i1: âˆ€ t, âˆ¥f tâˆ¥ â‰¤ âˆ¥g tâˆ¥ := Î» t, solid (h t),
    rw norm_le (norm_nonneg _),
    exact Î» t, (i1 t).trans (norm_coe_le_norm g t),
  end,
  ..bounded_continuous_function.lattice, }
end normed_lattice_ordered_group
section nonnegative_part
variables [topological_space Î±]
def nnreal_part (f : Î± â†’áµ‡ â„) : Î± â†’áµ‡ â„â‰¥0 :=
bounded_continuous_function.comp _
  (show lipschitz_with 1 real.to_nnreal, from lipschitz_with_pos) f
@[simp] lemma nnreal_part_coe_fun_eq (f : Î± â†’áµ‡ â„) : â‡‘(f.nnreal_part) = real.to_nnreal âˆ˜ â‡‘f := rfl
def nnnorm (f : Î± â†’áµ‡ â„) : Î± â†’áµ‡ â„â‰¥0 :=
bounded_continuous_function.comp _
  (show lipschitz_with 1 (Î» (x : â„), âˆ¥xâˆ¥â‚Š), from lipschitz_with_one_norm) f
@[simp] lemma nnnorm_coe_fun_eq (f : Î± â†’áµ‡ â„) : â‡‘(f.nnnorm) = has_nnnorm.nnnorm âˆ˜ â‡‘f := rfl
lemma self_eq_nnreal_part_sub_nnreal_part_neg (f : Î± â†’áµ‡ â„) :
  â‡‘f = coe âˆ˜ f.nnreal_part - coe âˆ˜ (-f).nnreal_part :=
by { funext x, dsimp, simp only [max_zero_sub_max_neg_zero_eq_self], }
lemma abs_self_eq_nnreal_part_add_nnreal_part_neg (f : Î± â†’áµ‡ â„) :
  abs âˆ˜ â‡‘f = coe âˆ˜ f.nnreal_part + coe âˆ˜ (-f).nnreal_part :=
by { funext x, dsimp, simp only [max_zero_add_max_neg_zero_eq_abs_self], }
end nonnegative_part
end bounded_continuous_function
