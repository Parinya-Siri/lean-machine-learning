import category_theory.preadditive.projective_resolution
noncomputable theory
open category_theory
open category_theory.limits
universes v u
namespace category_theory
variables {C : Type u} [category.{v} C] {D : Type*} [category D]
def functor.left_derived (F : C ‚•§ D) [F.additive] (n : ‚Ñï) : C ‚•§ D :=
projective_resolutions C ‚ãô F.map_homotopy_category _ ‚ãô homotopy_category.homology_functor D _ n
@[simps]
def functor.left_derived_obj_iso (F : C ‚•§ D) [F.additive] (n : ‚Ñï)
  {X : C} (P : ProjectiveResolution X) :
  (F.left_derived n).obj X ‚âÖ
    (homology_functor D _ n).obj ((F.map_homological_complex _).obj P.complex) :=
(homotopy_category.homology_functor D _ n).map_iso
  (homotopy_category.iso_of_homotopy_equiv
    (F.map_homotopy_equiv (ProjectiveResolution.homotopy_equiv _ P)))
  ‚â™‚â´ (homotopy_category.homology_factors D _ n).app _
@[simps]
def functor.left_derived_obj_projective_zero (F : C ‚•§ D) [F.additive]
  (X : C) [projective X] :
  (F.left_derived 0).obj X ‚âÖ F.obj X :=
F.left_derived_obj_iso 0 (ProjectiveResolution.self X) ‚â™‚â´
  (homology_functor _ _ _).map_iso ((chain_complex.single‚ÇÄ_map_homological_complex F).app X) ‚â™‚â´
  (chain_complex.homology_functor_0_single‚ÇÄ D).app (F.obj X)
open_locale zero_object
@[simps inv]
def functor.left_derived_obj_projective_succ (F : C ‚•§ D) [F.additive] (n : ‚Ñï)
  (X : C) [projective X] :
  (F.left_derived (n+1)).obj X ‚âÖ 0 :=
F.left_derived_obj_iso (n+1) (ProjectiveResolution.self X) ‚â™‚â´
  (homology_functor _ _ _).map_iso ((chain_complex.single‚ÇÄ_map_homological_complex F).app X) ‚â™‚â´
  (chain_complex.homology_functor_succ_single‚ÇÄ D n).app (F.obj X) ‚â™‚â´
  (functor.zero_obj _).iso_zero
lemma functor.left_derived_map_eq (F : C ‚•§ D) [F.additive] (n : ‚Ñï) {X Y : C} (f : X ‚ü∂ Y)
  {P : ProjectiveResolution X} {Q : ProjectiveResolution Y} (g : P.complex ‚ü∂ Q.complex)
  (w : g ‚â´ Q.œÄ = P.œÄ ‚â´ (chain_complex.single‚ÇÄ C).map f) :
  (F.left_derived n).map f =
  (F.left_derived_obj_iso n P).hom ‚â´
    (homology_functor D _ n).map ((F.map_homological_complex _).map g) ‚â´
    (F.left_derived_obj_iso n Q).inv :=
begin
  dsimp only [functor.left_derived, functor.left_derived_obj_iso],
  dsimp, simp only [category.comp_id, category.id_comp],
  rw [‚Üêhomology_functor_map, homotopy_category.homology_functor_map_factors],
  simp only [‚Üêfunctor.map_comp],
  congr' 1,
  apply homotopy_category.eq_of_homotopy,
  apply functor.map_homotopy,
  apply homotopy.trans,
  exact homotopy_category.homotopy_out_map _,
  apply ProjectiveResolution.lift_homotopy f,
  { simp, },
  { simp [w], },
end
@[simps]
def nat_trans.left_derived {F G : C ‚•§ D} [F.additive] [G.additive] (Œ± : F ‚ü∂ G) (n : ‚Ñï) :
  F.left_derived n ‚ü∂ G.left_derived n :=
whisker_left (projective_resolutions C)
  (whisker_right (nat_trans.map_homotopy_category Œ± _)
    (homotopy_category.homology_functor D _ n))
@[simp] lemma nat_trans.left_derived_id (F : C ‚•§ D) [F.additive] (n : ‚Ñï) :
  nat_trans.left_derived (ùüô F) n = ùüô (F.left_derived n) :=
by { simp [nat_trans.left_derived], refl, }
lemma nat_trans.left_derived_eq {F G : C ‚•§ D} [F.additive] [G.additive] (Œ± : F ‚ü∂ G) (n : ‚Ñï)
  {X : C} (P : ProjectiveResolution X) :
  (nat_trans.left_derived Œ± n).app X =
    (F.left_derived_obj_iso n P).hom ‚â´
      (homology_functor D _ n).map ((nat_trans.map_homological_complex Œ± _).app P.complex) ‚â´
        (G.left_derived_obj_iso n P).inv :=
begin
  symmetry,
  dsimp [nat_trans.left_derived, functor.left_derived_obj_iso],
  simp only [category.comp_id, category.id_comp],
  rw [‚Üêhomology_functor_map, homotopy_category.homology_functor_map_factors],
  simp only [‚Üêfunctor.map_comp],
  congr' 1,
  apply homotopy_category.eq_of_homotopy,
  simp only [nat_trans.map_homological_complex_naturality_assoc,
    ‚Üêfunctor.map_comp],
  apply homotopy.comp_left_id,
  rw [‚Üêfunctor.map_id],
  apply functor.map_homotopy,
  apply homotopy_equiv.homotopy_hom_inv_id,
end
