import analysis.box_integral.box.basic
import analysis.specific_limits.basic
open set finset function filter metric
open_locale classical topological_space filter ennreal
noncomputable theory
namespace box_integral
namespace box
variables {Œπ : Type*} {I J : box Œπ}
def split_center_box (I : box Œπ) (s : set Œπ) : box Œπ :=
{ lower := s.piecewise (Œª i, (I.lower i + I.upper i) / 2) I.lower,
  upper := s.piecewise I.upper (Œª i, (I.lower i + I.upper i) / 2),
  lower_lt_upper := Œª i, by { dunfold set.piecewise, split_ifs;
    simp only [left_lt_add_div_two, add_div_two_lt_right, I.lower_lt_upper] } }
lemma mem_split_center_box {s : set Œπ} {y : Œπ ‚Üí ‚Ñù} :
  y ‚àà I.split_center_box s ‚Üî y ‚àà I ‚àß ‚àÄ i, (I.lower i + I.upper i) / 2 < y i ‚Üî i ‚àà s :=
begin
  simp only [split_center_box, mem_def, ‚Üê forall_and_distrib],
  refine forall_congr (Œª i, _),
  dunfold set.piecewise,
  split_ifs with hs; simp only [hs, iff_true, iff_false, not_lt],
  exacts [‚ü®Œª H, ‚ü®‚ü®(left_lt_add_div_two.2 (I.lower_lt_upper i)).trans H.1, H.2‚ü©, H.1‚ü©,
    Œª H, ‚ü®H.2, H.1.2‚ü©‚ü©,
    ‚ü®Œª H, ‚ü®‚ü®H.1, H.2.trans (add_div_two_lt_right.2 (I.lower_lt_upper i)).le‚ü©, H.2‚ü©,
      Œª H, ‚ü®H.1.1, H.2‚ü©‚ü©]
end
lemma split_center_box_le (I : box Œπ) (s : set Œπ) : I.split_center_box s ‚â§ I :=
Œª x hx, (mem_split_center_box.1 hx).1
lemma disjoint_split_center_box (I : box Œπ) {s t : set Œπ} (h : s ‚â† t) :
  disjoint (I.split_center_box s : set (Œπ ‚Üí ‚Ñù)) (I.split_center_box t) :=
begin
  rintro y ‚ü®hs, ht‚ü©, apply h,
  ext i,
  rw [mem_coe, mem_split_center_box] at hs ht,
  rw [‚Üê hs.2, ‚Üê ht.2]
end
lemma injective_split_center_box (I : box Œπ) : injective I.split_center_box :=
Œª s t H, by_contra $ Œª Hne, (I.disjoint_split_center_box Hne).ne (nonempty_coe _).ne_empty (H ‚ñ∏ rfl)
@[simp] lemma exists_mem_split_center_box {I : box Œπ} {x : Œπ ‚Üí ‚Ñù} :
  (‚àÉ s, x ‚àà I.split_center_box s) ‚Üî x ‚àà I :=
‚ü®Œª ‚ü®s, hs‚ü©, I.split_center_box_le s hs,
  Œª hx, ‚ü®{i | (I.lower i + I.upper i) / 2 < x i}, mem_split_center_box.2 ‚ü®hx, Œª i, iff.rfl‚ü©‚ü©‚ü©
@[simps] def split_center_box_emb (I : box Œπ) : set Œπ ‚Ü™ box Œπ :=
‚ü®split_center_box I, injective_split_center_box I‚ü©
@[simp] lemma Union_coe_split_center_box (I : box Œπ) :
  (‚ãÉ s, (I.split_center_box s : set (Œπ ‚Üí ‚Ñù))) = I :=
by { ext x, simp }
@[simp] lemma upper_sub_lower_split_center_box (I : box Œπ) (s : set Œπ) (i : Œπ) :
  (I.split_center_box s).upper i - (I.split_center_box s).lower i = (I.upper i - I.lower i) / 2 :=
by by_cases hs : i ‚àà s; field_simp [split_center_box, hs, mul_two, two_mul]
@[elab_as_eliminator]
lemma subbox_induction_on' {p : box Œπ ‚Üí Prop} (I : box Œπ)
  (H_ind : ‚àÄ J ‚â§ I, (‚àÄ s, p (split_center_box J s)) ‚Üí p J)
  (H_nhds : ‚àÄ z ‚àà I.Icc, ‚àÉ (U ‚àà ùìù[I.Icc] z), ‚àÄ (J ‚â§ I) (m : ‚Ñï), z ‚àà J.Icc ‚Üí J.Icc ‚äÜ U ‚Üí
    (‚àÄ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) ‚Üí p J) :
  p I :=
begin
  by_contra hpI,
