import category_theory.limits.preserves.limits
open category_theory category_theory.category
def evaluation_jointly_reflects_limits {F : J â¥¤ K â¥¤ C} (c : cone F)
  (t : Î  (k : K), is_limit (((evaluation K C).obj k).map_cone c)) : is_limit c :=
{ lift := Î» s,
  { app := Î» k, (t k).lift âŸ¨s.X.obj k, whisker_right s.Ï€ ((evaluation K C).obj k)âŸ©,
    naturality' := Î» X Y f, (t Y).hom_ext $ Î» j,
    begin
      rw [assoc, (t Y).fac _ j],
      simpa using
        ((t X).fac_assoc âŸ¨s.X.obj X, whisker_right s.Ï€ ((evaluation K C).obj X)âŸ© j _).symm,
    end },
  fac' := Î» s j, nat_trans.ext _ _ $ funext $ Î» k, (t k).fac _ j,
  uniq' := Î» s m w, nat_trans.ext _ _ $ funext $ Î» x, (t x).hom_ext $ Î» j,
      (congr_app (w j) x).trans
        ((t x).fac âŸ¨s.X.obj _, whisker_right s.Ï€ ((evaluation K C).obj _)âŸ© j).symm }
@[simps] def combine_cones (F : J â¥¤ K â¥¤ C) (c : Î  (k : K), limit_cone (F.flip.obj k)) :
  cone F :=
{ X :=
  { obj := Î» k, (c k).cone.X,
    map := Î» kâ‚ kâ‚‚ f, (c kâ‚‚).is_limit.lift âŸ¨_, (c kâ‚).cone.Ï€ â‰« F.flip.map fâŸ©,
    map_id' := Î» k, (c k).is_limit.hom_ext (Î» j, by { dsimp, simp }),
    map_comp' := Î» kâ‚ kâ‚‚ kâ‚ƒ fâ‚ fâ‚‚, (c kâ‚ƒ).is_limit.hom_ext (Î» j, by simp) },
  Ï€ :=
  { app := Î» j, { app := Î» k, (c k).cone.Ï€.app j },
    naturality' := Î» jâ‚ jâ‚‚ g, nat_trans.ext _ _ $ funext $ Î» k, (c k).cone.Ï€.naturality g } }
def evaluate_combined_cones (F : J â¥¤ K â¥¤ C) (c : Î  (k : K), limit_cone (F.flip.obj k)) (k : K) :
  ((evaluation K C).obj k).map_cone (combine_cones F c) â‰… (c k).cone :=
cones.ext (iso.refl _) (by tidy)
def combined_is_limit (F : J â¥¤ K â¥¤ C) (c : Î  (k : K), limit_cone (F.flip.obj k)) :
  is_limit (combine_cones F c) :=
evaluation_jointly_reflects_limits _
  (Î» k, (c k).is_limit.of_iso_limit (evaluate_combined_cones F c k).symm)
def evaluation_jointly_reflects_colimits {F : J â¥¤ K â¥¤ C} (c : cocone F)
  (t : Î  (k : K), is_colimit (((evaluation K C).obj k).map_cocone c)) : is_colimit c :=
{ desc := Î» s,
  { app := Î» k, (t k).desc âŸ¨s.X.obj k, whisker_right s.Î¹ ((evaluation K C).obj k)âŸ©,
    naturality' := Î» X Y f, (t X).hom_ext $ Î» j,
    begin
      rw [(t X).fac_assoc _ j],
      erw â† (c.Î¹.app j).naturality_assoc f,
      erw (t Y).fac âŸ¨s.X.obj _, whisker_right s.Î¹ _âŸ© j,
      dsimp,
      simp,
    end },
  fac' := Î» s j, nat_trans.ext _ _ $ funext $ Î» k, (t k).fac _ j,
  uniq' := Î» s m w, nat_trans.ext _ _ $ funext $ Î» x, (t x).hom_ext $ Î» j,
      (congr_app (w j) x).trans
        ((t x).fac âŸ¨s.X.obj _, whisker_right s.Î¹ ((evaluation K C).obj _)âŸ© j).symm }
@[simps] def combine_cocones (F : J â¥¤ K â¥¤ C) (c : Î  (k : K), colimit_cocone (F.flip.obj k)) :
  cocone F :=
{ X :=
  { obj := Î» k, (c k).cocone.X,
    map := Î» kâ‚ kâ‚‚ f, (c kâ‚).is_colimit.desc âŸ¨_, F.flip.map f â‰« (c kâ‚‚).cocone.Î¹âŸ©,
    map_id' := Î» k, (c k).is_colimit.hom_ext (Î» j, by { dsimp, simp }),
    map_comp' := Î» kâ‚ kâ‚‚ kâ‚ƒ fâ‚ fâ‚‚, (c kâ‚).is_colimit.hom_ext (Î» j, by simp) },
  Î¹ :=
  { app := Î» j, { app := Î» k, (c k).cocone.Î¹.app j },
    naturality' := Î» jâ‚ jâ‚‚ g, nat_trans.ext _ _ $ funext $ Î» k, (c k).cocone.Î¹.naturality g } }
def evaluate_combined_cocones
  (F : J â¥¤ K â¥¤ C) (c : Î  (k : K), colimit_cocone (F.flip.obj k)) (k : K) :
  ((evaluation K C).obj k).map_cocone (combine_cocones F c) â‰… (c k).cocone :=
cocones.ext (iso.refl _) (by tidy)
def combined_is_colimit (F : J â¥¤ K â¥¤ C) (c : Î  (k : K), colimit_cocone (F.flip.obj k)) :
  is_colimit (combine_cocones F c) :=
evaluation_jointly_reflects_colimits _
  (Î» k, (c k).is_colimit.of_iso_colimit (evaluate_combined_cocones F c k).symm)
noncomputable theory
instance functor_category_has_limits_of_shape
  [has_limits_of_shape J C] : has_limits_of_shape J (K â¥¤ C) :=
{ has_limit := Î» F, has_limit.mk
  { cone := combine_cones F (Î» k, get_limit_cone _),
    is_limit := combined_is_limit _ _ } }
instance functor_category_has_colimits_of_shape
  [has_colimits_of_shape J C] : has_colimits_of_shape J (K â¥¤ C) :=
{ has_colimit := Î» F, has_colimit.mk
  { cocone := combine_cocones _ (Î» k, get_colimit_cocone _),
    is_colimit := combined_is_colimit _ _ } }
instance functor_category_has_limits_of_size [has_limits_of_size.{vâ‚ uâ‚} C] :
  has_limits_of_size.{vâ‚ uâ‚} (K â¥¤ C) := âŸ¨infer_instanceâŸ©
instance functor_category_has_colimits_of_size [has_colimits_of_size.{vâ‚ uâ‚} C] :
  has_colimits_of_size.{vâ‚ uâ‚} (K â¥¤ C) := âŸ¨infer_instanceâŸ©
instance evaluation_preserves_limits_of_shape [has_limits_of_shape J C] (k : K) :
  preserves_limits_of_shape J ((evaluation K C).obj k) :=
{ preserves_limit :=
  Î» F, preserves_limit_of_preserves_limit_cone (combined_is_limit _ _) $
    is_limit.of_iso_limit (limit.is_limit _)
      (evaluate_combined_cones F _ k).symm }
def limit_obj_iso_limit_comp_evaluation [has_limits_of_shape J C] (F : J â¥¤ K â¥¤ C) (k : K) :
  (limit F).obj k â‰… limit (F â‹™ ((evaluation K C).obj k)) :=
preserves_limit_iso ((evaluation K C).obj k) F
@[simp, reassoc]
lemma limit_obj_iso_limit_comp_evaluation_hom_Ï€
  [has_limits_of_shape J C] (F : J â¥¤ (K â¥¤ C)) (j : J) (k : K) :
  (limit_obj_iso_limit_comp_evaluation F k).hom â‰« limit.Ï€ (F â‹™ ((evaluation K C).obj k)) j =
    (limit.Ï€ F j).app k :=
begin
  dsimp [limit_obj_iso_limit_comp_evaluation],
  simp,
end
@[simp, reassoc]
lemma limit_obj_iso_limit_comp_evaluation_inv_Ï€_app
  [has_limits_of_shape J C] (F : J â¥¤ (K â¥¤ C)) (j : J) (k : K):
  (limit_obj_iso_limit_comp_evaluation F k).inv â‰« (limit.Ï€ F j).app k =
    limit.Ï€ (F â‹™ ((evaluation K C).obj k)) j :=
begin
  dsimp [limit_obj_iso_limit_comp_evaluation],
  rw iso.inv_comp_eq,
  simp,
end
@[simp, reassoc]
lemma limit_map_limit_obj_iso_limit_comp_evaluation_hom
  [has_limits_of_shape J C] {i j : K} (F : J â¥¤ K â¥¤ C) (f : i âŸ¶ j) :
  (limit F).map f â‰« (limit_obj_iso_limit_comp_evaluation _ _).hom =
  (limit_obj_iso_limit_comp_evaluation _ _).hom â‰«
  lim_map (whisker_left _ ((evaluation _ _).map f)) :=
by { ext, dsimp, simp }
@[simp, reassoc]
lemma limit_obj_iso_limit_comp_evaluation_inv_limit_map
  [has_limits_of_shape J C] {i j : K} (F : J â¥¤ K â¥¤ C) (f : i âŸ¶ j) :
  (limit_obj_iso_limit_comp_evaluation _ _).inv â‰« (limit F).map f =
  lim_map (whisker_left _ ((evaluation _ _).map f)) â‰«
  (limit_obj_iso_limit_comp_evaluation _ _).inv :=
by rw [iso.inv_comp_eq, â† category.assoc, iso.eq_comp_inv,
  limit_map_limit_obj_iso_limit_comp_evaluation_hom]
@[ext]
lemma limit_obj_ext {H : J â¥¤ K â¥¤ C} [has_limits_of_shape J C]
  {k : K} {W : C} {f g : W âŸ¶ (limit H).obj k}
  (w : âˆ€ j, f â‰« (limits.limit.Ï€ H j).app k = g â‰« (limits.limit.Ï€ H j).app k) : f = g :=
begin
  apply (cancel_mono (limit_obj_iso_limit_comp_evaluation H k).hom).1,
  ext,
  simpa using w j,
end
instance evaluation_preserves_colimits_of_shape [has_colimits_of_shape J C] (k : K) :
  preserves_colimits_of_shape J ((evaluation K C).obj k) :=
{ preserves_colimit :=
  Î» F, preserves_colimit_of_preserves_colimit_cocone (combined_is_colimit _ _) $
    is_colimit.of_iso_colimit (colimit.is_colimit _)
      (evaluate_combined_cocones F _ k).symm }
def colimit_obj_iso_colimit_comp_evaluation [has_colimits_of_shape J C] (F : J â¥¤ K â¥¤ C) (k : K) :
  (colimit F).obj k â‰… colimit (F â‹™ ((evaluation K C).obj k)) :=
preserves_colimit_iso ((evaluation K C).obj k) F
@[simp, reassoc]
lemma colimit_obj_iso_colimit_comp_evaluation_Î¹_inv
  [has_colimits_of_shape J C] (F : J â¥¤ (K â¥¤ C)) (j : J) (k : K) :
  colimit.Î¹ (F â‹™ ((evaluation K C).obj k)) j â‰« (colimit_obj_iso_colimit_comp_evaluation F k).inv =
    (colimit.Î¹ F j).app k :=
begin
  dsimp [colimit_obj_iso_colimit_comp_evaluation],
  simp,
end
@[simp, reassoc]
lemma colimit_obj_iso_colimit_comp_evaluation_Î¹_app_hom
  [has_colimits_of_shape J C] (F : J â¥¤ (K â¥¤ C)) (j : J) (k : K) :
  (colimit.Î¹ F j).app k â‰« (colimit_obj_iso_colimit_comp_evaluation F k).hom =
     colimit.Î¹ (F â‹™ ((evaluation K C).obj k)) j :=
begin
  dsimp [colimit_obj_iso_colimit_comp_evaluation],
  rw â†iso.eq_comp_inv,
  simp,
end
@[simp, reassoc]
lemma colimit_obj_iso_colimit_comp_evaluation_inv_colimit_map
  [has_colimits_of_shape J C] (F : J â¥¤ K â¥¤ C) {i j : K} (f : i âŸ¶ j) :
  (colimit_obj_iso_colimit_comp_evaluation _ _).inv â‰« (colimit F).map f =
  colim_map (whisker_left _ ((evaluation _ _).map f)) â‰«
  (colimit_obj_iso_colimit_comp_evaluation _ _).inv :=
by { ext, dsimp, simp }
@[simp, reassoc]
lemma colimit_map_colimit_obj_iso_colimit_comp_evaluation_hom
  [has_colimits_of_shape J C] (F : J â¥¤ K â¥¤ C) {i j : K} (f : i âŸ¶ j) :
  (colimit F).map f â‰« (colimit_obj_iso_colimit_comp_evaluation _ _).hom =
  (colimit_obj_iso_colimit_comp_evaluation _ _).hom â‰«
  colim_map (whisker_left _ ((evaluation _ _).map f)) :=
by rw [â† iso.inv_comp_eq, â† category.assoc, â† iso.eq_comp_inv,
  colimit_obj_iso_colimit_comp_evaluation_inv_colimit_map]
@[ext]
lemma colimit_obj_ext {H : J â¥¤ K â¥¤ C} [has_colimits_of_shape J C]
  {k : K} {W : C} {f g : (colimit H).obj k âŸ¶ W}
  (w : âˆ€ j, (colimit.Î¹ H j).app k â‰« f = (colimit.Î¹ H j).app k â‰« g) : f = g :=
begin
  apply (cancel_epi (colimit_obj_iso_colimit_comp_evaluation H k).inv).1,
  ext,
  simpa using w j,
end
instance evaluation_preserves_limits [has_limits C] (k : K) :
  preserves_limits ((evaluation K C).obj k) :=
{ preserves_limits_of_shape := Î» J ğ’¥, by resetI; apply_instance }
def preserves_limit_of_evaluation (F : D â¥¤ K â¥¤ C) (G : J â¥¤ D)
  (H : Î  (k : K), preserves_limit G (F â‹™ (evaluation K C).obj k : D â¥¤ C)) :
  preserves_limit G F := âŸ¨Î» c hc,
begin
  apply evaluation_jointly_reflects_limits,
  intro X,
  haveI := H X,
  change is_limit ((F â‹™ (evaluation K C).obj X).map_cone c),
  exact preserves_limit.preserves hc,
endâŸ©
def preserves_limits_of_shape_of_evaluation (F : D â¥¤ K â¥¤ C) (J : Type*) [category J]
  (H : Î  (k : K), preserves_limits_of_shape J (F â‹™ (evaluation K C).obj k)) :
  preserves_limits_of_shape J F :=
âŸ¨Î» G, preserves_limit_of_evaluation F G (Î» k, preserves_limits_of_shape.preserves_limit)âŸ©
def {w' w} preserves_limits_of_evaluation (F : D â¥¤ K â¥¤ C)
  (H : Î  (k : K), preserves_limits_of_size.{w' w} (F â‹™ (evaluation K C).obj k)) :
  preserves_limits_of_size.{w' w} F :=
âŸ¨Î» L hL, by exactI preserves_limits_of_shape_of_evaluation
    F L (Î» k, preserves_limits_of_size.preserves_limits_of_shape)âŸ©
instance evaluation_preserves_colimits [has_colimits C] (k : K) :
  preserves_colimits ((evaluation K C).obj k) :=
{ preserves_colimits_of_shape := Î» J ğ’¥, by resetI; apply_instance }
def preserves_colimit_of_evaluation (F : D â¥¤ K â¥¤ C) (G : J â¥¤ D)
  (H : Î  (k), preserves_colimit G (F â‹™ (evaluation K C).obj k)) : preserves_colimit G F := âŸ¨Î» c hc,
begin
  apply evaluation_jointly_reflects_colimits,
  intro X,
  haveI := H X,
  change is_colimit ((F â‹™ (evaluation K C).obj X).map_cocone c),
  exact preserves_colimit.preserves hc,
endâŸ©
def preserves_colimits_of_shape_of_evaluation (F : D â¥¤ K â¥¤ C) (J : Type*) [category J]
  (H : Î  (k : K), preserves_colimits_of_shape J (F â‹™ (evaluation K C).obj k)) :
  preserves_colimits_of_shape J F :=
âŸ¨Î» G, preserves_colimit_of_evaluation F G (Î» k, preserves_colimits_of_shape.preserves_colimit)âŸ©
def {w' w} preserves_colimits_of_evaluation (F : D â¥¤ K â¥¤ C)
  (H : Î  (k : K), preserves_colimits_of_size.{w' w} (F â‹™ (evaluation K C).obj k)) :
  preserves_colimits_of_size.{w' w} F :=
âŸ¨Î» L hL, by exactI preserves_colimits_of_shape_of_evaluation
    F L (Î» k, preserves_colimits_of_size.preserves_colimits_of_shape)âŸ©
open category_theory.prod
@[simps]
def limit_iso_flip_comp_lim [has_limits_of_shape J C] (F : J â¥¤ K â¥¤ C) :
  limit F â‰… F.flip â‹™ lim :=
nat_iso.of_components (limit_obj_iso_limit_comp_evaluation F) $ by tidy
@[simps]
def limit_flip_iso_comp_lim [has_limits_of_shape J C] (F : K â¥¤ J â¥¤ C) :
  limit F.flip â‰… F â‹™ lim :=
nat_iso.of_components (Î» k,
  limit_obj_iso_limit_comp_evaluation F.flip k â‰ªâ‰«
  has_limit.iso_of_nat_iso (flip_comp_evaluation _ _)) $ by tidy
@[simps] def limit_iso_swap_comp_lim [has_limits_of_shape J C] (G : J â¥¤ K â¥¤ C) :
  limit G â‰… curry.obj (swap K J â‹™ uncurry.obj G) â‹™ lim :=
limit_iso_flip_comp_lim G â‰ªâ‰« iso_whisker_right (flip_iso_curry_swap_uncurry _) _
@[simps]
def colimit_iso_flip_comp_colim [has_colimits_of_shape J C] (F : J â¥¤ K â¥¤ C) :
  colimit F â‰… F.flip â‹™ colim :=
nat_iso.of_components (colimit_obj_iso_colimit_comp_evaluation F) $ by tidy
@[simps]
def colimit_flip_iso_comp_colim [has_colimits_of_shape J C] (F : K â¥¤ J â¥¤ C) :
  colimit F.flip â‰… F â‹™ colim :=
nat_iso.of_components (Î» k,
  colimit_obj_iso_colimit_comp_evaluation _ _ â‰ªâ‰«
  has_colimit.iso_of_nat_iso (flip_comp_evaluation _ _)) $ by tidy
@[simps]
def colimit_iso_swap_comp_colim [has_colimits_of_shape J C] (G : J â¥¤ K â¥¤ C) :
  colimit G â‰… curry.obj (swap K J â‹™ uncurry.obj G) â‹™ colim :=
colimit_iso_flip_comp_colim G â‰ªâ‰« iso_whisker_right (flip_iso_curry_swap_uncurry _) _
end category_theory.limits
