import analysis.normed.group.hom
import analysis.normed_space.basic
import analysis.normed_space.linear_isometry
import algebra.star.self_adjoint
import algebra.star.unitary
open_locale topological_space
local postfix `â‹†`:std.prec.max_plus := star
class normed_star_group (E : Type*) [semi_normed_group E] [star_add_monoid E] : Prop :=
(norm_star : âˆ€ x : E, âˆ¥xâ‹†âˆ¥ = âˆ¥xâˆ¥)
export normed_star_group (norm_star)
attribute [simp] norm_star
variables {ğ•œ E Î± : Type*}
section normed_star_group
variables [semi_normed_group E] [star_add_monoid E] [normed_star_group E]
@[simp] lemma nnnorm_star (x : E) : âˆ¥star xâˆ¥â‚Š = âˆ¥xâˆ¥â‚Š := subtype.ext $ norm_star _
def star_normed_group_hom : normed_group_hom E E :=
{ bound' := âŸ¨1, Î» v, le_trans (norm_star _).le (one_mul _).symm.leâŸ©,
  .. star_add_equiv }
lemma star_isometry : isometry (star : E â†’ E) :=
show isometry star_add_equiv,
by exact add_monoid_hom_class.isometry_of_norm star_add_equiv
    (show âˆ€ x, âˆ¥xâ‹†âˆ¥ = âˆ¥xâˆ¥, from norm_star)
@[priority 100]
instance normed_star_group.to_has_continuous_star : has_continuous_star E :=
âŸ¨star_isometry.continuousâŸ©
end normed_star_group
instance ring_hom_isometric.star_ring_end [normed_comm_ring E] [star_ring E]
  [normed_star_group E] : ring_hom_isometric (star_ring_end E) :=
âŸ¨norm_starâŸ©
class cstar_ring (E : Type*) [non_unital_normed_ring E] [star_ring E] : Prop :=
(norm_star_mul_self : âˆ€ {x : E}, âˆ¥xâ‹† * xâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥)
instance : cstar_ring â„ :=
{ norm_star_mul_self := Î» x, by simp only [star, id.def, norm_mul] }
namespace cstar_ring
section non_unital
variables [non_unital_normed_ring E] [star_ring E] [cstar_ring E]
def starâ‚—áµ¢ : E â‰ƒâ‚—áµ¢â‹†[ğ•œ] E :=
{ map_smul' := star_smul,
  norm_map' := norm_star,
  .. star_add_equiv }
variables {ğ•œ}
@[simp] lemma coe_starâ‚—áµ¢ : (starâ‚—áµ¢ ğ•œ : E â†’ E) = star := rfl
lemma starâ‚—áµ¢_apply {x : E} : starâ‚—áµ¢ ğ•œ x = star x := rfl
end starâ‚—áµ¢
