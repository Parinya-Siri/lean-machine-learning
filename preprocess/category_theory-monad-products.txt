import category_theory.over
import category_theory.monad.algebra
import category_theory.limits.shapes.binary_products
noncomputable theory
@[simps]
def prod_comonad : comonad C :=
{ to_functor := prod.functor.obj X,
  Œµ' := { app := Œª Y, limits.prod.snd },
  Œ¥' := { app := Œª Y, prod.lift limits.prod.fst (ùüô _) } }
@[simps]
def coalgebra_to_over :
  coalgebra (prod_comonad X) ‚•§ over X :=
{ obj := Œª A, over.mk (A.a ‚â´ limits.prod.fst),
  map := Œª A‚ÇÅ A‚ÇÇ f, over.hom_mk f.f (by { rw [over.mk_hom, ‚Üê f.h_assoc], dsimp, simp }) }
@[simps]
def over_to_coalgebra :
  over X ‚•§ coalgebra (prod_comonad X) :=
{ obj := Œª f, { A := f.left, a := prod.lift f.hom (ùüô _) },
  map := Œª f‚ÇÅ f‚ÇÇ g, { f := g.left } }
@[simps]
def coalgebra_equiv_over :
  coalgebra (prod_comonad X) ‚âå over X :=
{ functor := coalgebra_to_over X,
  inverse := over_to_coalgebra X,
  unit_iso := nat_iso.of_components
                (Œª A, coalgebra.iso_mk (iso.refl _)
                        (prod.hom_ext (by { dsimp, simp }) (by { dsimp, simpa using A.counit })))
              (Œª A‚ÇÅ A‚ÇÇ f, by { ext, simp }),
  counit_iso := nat_iso.of_components (Œª f, over.iso_mk (iso.refl _)) (Œª f g k, by tidy) }.
end
section
open _root_.monad
variable [has_binary_coproducts C]
@[simps]
def coprod_monad : monad C :=
{ to_functor := coprod.functor.obj X,
  Œ∑' := { app := Œª Y, coprod.inr },
  Œº' := { app := Œª Y, coprod.desc coprod.inl (ùüô _) } }
@[simps]
def algebra_to_under :
  monad.algebra (coprod_monad X) ‚•§ under X :=
{ obj := Œª A, under.mk (coprod.inl ‚â´ A.a),
  map := Œª A‚ÇÅ A‚ÇÇ f, under.hom_mk f.f (by { rw [under.mk_hom, assoc, ‚Üêf.h], dsimp, simp }) }
@[simps]
def under_to_algebra :
  under X ‚•§ monad.algebra (coprod_monad X) :=
{ obj := Œª f, { A := f.right, a := coprod.desc f.hom (ùüô _) },
  map := Œª f‚ÇÅ f‚ÇÇ g, { f := g.right } }
@[simps]
def algebra_equiv_under :
  monad.algebra (coprod_monad X) ‚âå under X :=
{ functor := algebra_to_under X,
  inverse := under_to_algebra X,
  unit_iso := nat_iso.of_components
                 (Œª A, monad.algebra.iso_mk (iso.refl _)
                         (coprod.hom_ext (by tidy) (by { dsimp, simpa using A.unit.symm })))
                 (Œª A‚ÇÅ A‚ÇÇ f, by { ext, simp }),
  counit_iso :=
    nat_iso.of_components (Œª f, under.iso_mk (iso.refl _) (by tidy)) (Œª f g k, by tidy) }.
end
end category_theory
