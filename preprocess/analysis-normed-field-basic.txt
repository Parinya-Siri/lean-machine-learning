import analysis.normed.group.infinite_sum
import topology.algebra.module.basic
import topology.instances.ennreal
import topology.instances.rat
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œπ : Type*}
noncomputable theory
open filter metric
open_locale topological_space big_operators nnreal ennreal uniformity pointwise
class non_unital_semi_normed_ring (Œ± : Type*)
  extends has_norm Œ±, non_unital_ring Œ±, pseudo_metric_space Œ± :=
(dist_eq : ‚àÄ x y, dist x y = norm (x - y))
(norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b)
class semi_normed_ring (Œ± : Type*) extends has_norm Œ±, ring Œ±, pseudo_metric_space Œ± :=
(dist_eq : ‚àÄ x y, dist x y = norm (x - y))
(norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b)
class non_unital_normed_ring (Œ± : Type*) extends has_norm Œ±, non_unital_ring Œ±, metric_space Œ± :=
(dist_eq : ‚àÄ x y, dist x y = norm (x - y))
(norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b)
class normed_ring (Œ± : Type*) extends has_norm Œ±, ring Œ±, metric_space Œ± :=
(dist_eq : ‚àÄ x y, dist x y = norm (x - y))
(norm_mul : ‚àÄ a b, norm (a * b) ‚â§ norm a * norm b)
class normed_division_ring (Œ± : Type*) extends has_norm Œ±, division_ring Œ±, metric_space Œ± :=
(dist_eq : ‚àÄ x y, dist x y = norm (x - y))
(norm_mul' : ‚àÄ a b, norm (a * b) = norm a * norm b)
class semi_normed_comm_ring (Œ± : Type*) extends semi_normed_ring Œ± :=
(mul_comm : ‚àÄ x y : Œ±, x * y = y * x)
class normed_comm_ring (Œ± : Type*) extends normed_ring Œ± :=
(mul_comm : ‚àÄ x y : Œ±, x * y = y * x)
class norm_one_class (Œ± : Type*) [has_norm Œ±] [has_one Œ±] : Prop :=
(norm_one : ‚à•(1:Œ±)‚à• = 1)
export norm_one_class (norm_one)
attribute [simp] norm_one
@[simp] lemma nnnorm_one [semi_normed_group Œ±] [has_one Œ±] [norm_one_class Œ±] : ‚à•(1 : Œ±)‚à•‚Çä = 1 :=
nnreal.eq norm_one
lemma norm_one_class.nontrivial (Œ± : Type*) [semi_normed_group Œ±] [has_one Œ±] [norm_one_class Œ±] :
  nontrivial Œ± :=
nontrivial_of_ne 0 1 $ ne_of_apply_ne norm $ by simp
lemma mul_left_bound (x : Œ±) :
  ‚àÄ (y:Œ±), ‚à•add_monoid_hom.mul_left x y‚à• ‚â§ ‚à•x‚à• * ‚à•y‚à• :=
norm_mul_le x
lemma mul_right_bound (x : Œ±) :
  ‚àÄ (y:Œ±), ‚à•add_monoid_hom.mul_right x y‚à• ‚â§ ‚à•x‚à• * ‚à•y‚à• :=
Œª y, by {rw mul_comm, convert norm_mul_le y x}
instance : non_unital_semi_normed_ring (ulift Œ±) :=
{ norm_mul := Œª x y, (norm_mul_le x.down y.down : _),
  .. ulift.semi_normed_group }
instance prod.non_unital_semi_normed_ring [non_unital_semi_normed_ring Œ≤] :
  non_unital_semi_normed_ring (Œ± √ó Œ≤) :=
{ norm_mul := assume x y,
  calc
    ‚à•x * y‚à• = ‚à•(x.1*y.1, x.2*y.2)‚à• : rfl
        ... = (max ‚à•x.1*y.1‚à•  ‚à•x.2*y.2‚à•) : rfl
        ... ‚â§ (max (‚à•x.1‚à•*‚à•y.1‚à•) (‚à•x.2‚à•*‚à•y.2‚à•)) :
          max_le_max (norm_mul_le (x.1) (y.1)) (norm_mul_le (x.2) (y.2))
        ... = (max (‚à•x.1‚à•*‚à•y.1‚à•) (‚à•y.2‚à•*‚à•x.2‚à•)) : by simp[mul_comm]
        ... ‚â§ (max (‚à•x.1‚à•) (‚à•x.2‚à•)) * (max (‚à•y.2‚à•) (‚à•y.1‚à•)) :
          by apply max_mul_mul_le_max_mul_max; simp [norm_nonneg]
        ... = (max (‚à•x.1‚à•) (‚à•x.2‚à•)) * (max (‚à•y.1‚à•) (‚à•y.2‚à•)) : by simp [max_comm]
        ... = (‚à•x‚à•*‚à•y‚à•) : rfl,
  ..prod.semi_normed_group }
instance pi.non_unital_semi_normed_ring {œÄ : Œπ ‚Üí Type*} [fintype Œπ]
  [Œ† i, non_unital_semi_normed_ring (œÄ i)] :
  non_unital_semi_normed_ring (Œ† i, œÄ i) :=
{ norm_mul := Œª x y, nnreal.coe_mono $
    calc  finset.univ.sup (Œª i, ‚à•x i * y i‚à•‚Çä)
        ‚â§ finset.univ.sup ((Œª i, ‚à•x i‚à•‚Çä) * (Œª i, ‚à•y i‚à•‚Çä)) :
            finset.sup_mono_fun $ Œª b hb, norm_mul_le _ _
    ... ‚â§ finset.univ.sup (Œª i, ‚à•x i‚à•‚Çä) * finset.univ.sup (Œª i, ‚à•y i‚à•‚Çä) :
            finset.sup_mul_le_mul_sup_of_nonneg _ (Œª i _, zero_le _) (Œª i _, zero_le _),
  ..pi.semi_normed_group }
end non_unital_semi_normed_ring
section semi_normed_ring
variables [semi_normed_ring Œ±]
instance subalgebra.semi_normed_ring {ùïú : Type*} {_ : comm_ring ùïú}
  {E : Type*} [semi_normed_ring E] {_ : algebra ùïú E} (s : subalgebra ùïú E) : semi_normed_ring s :=
{ norm_mul := Œª a b, norm_mul_le a.1 b.1,
  ..s.to_submodule.semi_normed_group }
instance subalgebra.normed_ring {ùïú : Type*} {_ : comm_ring ùïú}
  {E : Type*} [normed_ring E] {_ : algebra ùïú E} (s : subalgebra ùïú E) : normed_ring s :=
{ ..s.semi_normed_ring }
lemma nat.norm_cast_le : ‚àÄ n : ‚Ñï, ‚à•(n : Œ±)‚à• ‚â§ n * ‚à•(1 : Œ±)‚à•
| 0 := by simp
| (n + 1) := by { rw [n.cast_succ, n.cast_succ, add_mul, one_mul],
                  exact norm_add_le_of_le (nat.norm_cast_le n) le_rfl }
lemma list.norm_prod_le' : ‚àÄ {l : list Œ±}, l ‚â† [] ‚Üí ‚à•l.prod‚à• ‚â§ (l.map norm).prod
| [] h := (h rfl).elim
| [a] _ := by simp
| (a :: b :: l) _ :=
  begin
    rw [list.map_cons, list.prod_cons, @list.prod_cons _ _ _ ‚à•a‚à•],
    refine le_trans (norm_mul_le _ _) (mul_le_mul_of_nonneg_left _ (norm_nonneg _)),
    exact list.norm_prod_le' (list.cons_ne_nil b l)
  end
lemma list.nnnorm_prod_le' {l : list Œ±} (hl : l ‚â† []) : ‚à•l.prod‚à•‚Çä ‚â§ (l.map nnnorm).prod :=
(list.norm_prod_le' hl).trans_eq $ by simp [nnreal.coe_list_prod, list.map_map]
lemma list.norm_prod_le [norm_one_class Œ±] : ‚àÄ l : list Œ±, ‚à•l.prod‚à• ‚â§ (l.map norm).prod
| [] := by simp
| (a::l) := list.norm_prod_le' (list.cons_ne_nil a l)
lemma list.nnnorm_prod_le [norm_one_class Œ±] (l : list Œ±) : ‚à•l.prod‚à•‚Çä ‚â§ (l.map nnnorm).prod :=
l.norm_prod_le.trans_eq $ by simp [nnreal.coe_list_prod, list.map_map]
lemma finset.norm_prod_le' {Œ± : Type*} [normed_comm_ring Œ±] (s : finset Œπ) (hs : s.nonempty)
  (f : Œπ ‚Üí Œ±) :
  ‚à•‚àè i in s, f i‚à• ‚â§ ‚àè i in s, ‚à•f i‚à• :=
begin
  rcases s with ‚ü®‚ü®l‚ü©, hl‚ü©,
  have : l.map f ‚â† [], by simpa using hs,
  simpa using list.norm_prod_le' this
end
lemma finset.nnnorm_prod_le' {Œ± : Type*} [normed_comm_ring Œ±] (s : finset Œπ) (hs : s.nonempty)
  (f : Œπ ‚Üí Œ±) :
  ‚à•‚àè i in s, f i‚à•‚Çä ‚â§ ‚àè i in s, ‚à•f i‚à•‚Çä :=
(s.norm_prod_le' hs f).trans_eq $ by simp [nnreal.coe_prod]
lemma finset.norm_prod_le {Œ± : Type*} [normed_comm_ring Œ±] [norm_one_class Œ±] (s : finset Œπ)
  (f : Œπ ‚Üí Œ±) :
  ‚à•‚àè i in s, f i‚à• ‚â§ ‚àè i in s, ‚à•f i‚à• :=
begin
  rcases s with ‚ü®‚ü®l‚ü©, hl‚ü©,
  simpa using (l.map f).norm_prod_le
end
lemma finset.nnnorm_prod_le {Œ± : Type*} [normed_comm_ring Œ±] [norm_one_class Œ±] (s : finset Œπ)
  (f : Œπ ‚Üí Œ±) :
  ‚à•‚àè i in s, f i‚à•‚Çä ‚â§ ‚àè i in s, ‚à•f i‚à•‚Çä :=
(s.norm_prod_le f).trans_eq $ by simp [nnreal.coe_prod]
lemma nnnorm_pow_le' (a : Œ±) : ‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ‚à•a ^ n‚à•‚Çä ‚â§ ‚à•a‚à•‚Çä ^ n
| 1 h := by simp only [pow_one]
| (n + 2) h := by simpa only [pow_succ _ (n + 1)] using
    le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' n.succ_pos) _)
lemma nnnorm_pow_le [norm_one_class Œ±] (a : Œ±) (n : ‚Ñï) : ‚à•a ^ n‚à•‚Çä ‚â§ ‚à•a‚à•‚Çä ^ n :=
nat.rec_on n (by simp only [pow_zero, nnnorm_one]) (Œª k hk, nnnorm_pow_le' a k.succ_pos)
lemma norm_pow_le' (a : Œ±) {n : ‚Ñï} (h : 0 < n) : ‚à•a ^ n‚à• ‚â§ ‚à•a‚à• ^ n :=
by simpa only [nnreal.coe_pow, coe_nnnorm] using nnreal.coe_mono (nnnorm_pow_le' a h)
lemma norm_pow_le [norm_one_class Œ±] (a : Œ±) (n : ‚Ñï) : ‚à•a ^ n‚à• ‚â§ ‚à•a‚à• ^ n :=
nat.rec_on n (by simp only [pow_zero, norm_one]) (Œª n hn, norm_pow_le' a n.succ_pos)
lemma eventually_norm_pow_le (a : Œ±) : ‚àÄ·∂† (n:‚Ñï) in at_top, ‚à•a ^ n‚à• ‚â§ ‚à•a‚à• ^ n :=
eventually_at_top.mpr ‚ü®1, Œª b h, norm_pow_le' a (nat.succ_le_iff.mp h)‚ü©
instance : semi_normed_ring (ulift Œ±) :=
{ .. ulift.non_unital_semi_normed_ring,
  .. ulift.semi_normed_group }
instance prod.semi_normed_ring [semi_normed_ring Œ≤] :
  semi_normed_ring (Œ± √ó Œ≤) :=
{ ..prod.non_unital_semi_normed_ring,
  ..prod.semi_normed_group, }
instance pi.semi_normed_ring {œÄ : Œπ ‚Üí Type*} [fintype Œπ] [Œ† i, semi_normed_ring (œÄ i)] :
  semi_normed_ring (Œ† i, œÄ i) :=
{ ..pi.non_unital_semi_normed_ring,
  ..pi.semi_normed_group, }
end semi_normed_ring
section non_unital_normed_ring
variables [non_unital_normed_ring Œ±]
instance : non_unital_normed_ring (ulift Œ±) :=
{ .. ulift.non_unital_semi_normed_ring,
  .. ulift.semi_normed_group }
instance prod.non_unital_normed_ring [non_unital_normed_ring Œ≤] : non_unital_normed_ring (Œ± √ó Œ≤) :=
{ norm_mul := norm_mul_le,
  ..prod.semi_normed_group }
instance pi.non_unital_normed_ring {œÄ : Œπ ‚Üí Type*} [fintype Œπ] [Œ† i, non_unital_normed_ring (œÄ i)] :
  non_unital_normed_ring (Œ† i, œÄ i) :=
{ norm_mul := norm_mul_le,
  ..pi.normed_group }
end non_unital_normed_ring
section normed_ring
variables [normed_ring Œ±]
lemma units.norm_pos [nontrivial Œ±] (x : Œ±À£) : 0 < ‚à•(x:Œ±)‚à• :=
norm_pos_iff.mpr (units.ne_zero x)
lemma units.nnnorm_pos [nontrivial Œ±] (x : Œ±À£) : 0 < ‚à•(x:Œ±)‚à•‚Çä :=
x.norm_pos
instance : normed_ring (ulift Œ±) :=
{ .. ulift.semi_normed_ring,
  .. ulift.normed_group }
instance prod.normed_ring [normed_ring Œ≤] : normed_ring (Œ± √ó Œ≤) :=
{ norm_mul := norm_mul_le,
  ..prod.normed_group }
instance pi.normed_ring {œÄ : Œπ ‚Üí Type*} [fintype Œπ] [Œ† i, normed_ring (œÄ i)] :
  normed_ring (Œ† i, œÄ i) :=
{ norm_mul := norm_mul_le,
  ..pi.normed_group }
end normed_ring
@[simps] def norm_hom : Œ± ‚Üí*‚ÇÄ ‚Ñù := ‚ü®norm, norm_zero, norm_one, norm_mul‚ü©
@[simps] def nnnorm_hom : Œ± ‚Üí*‚ÇÄ ‚Ñù‚â•0 := ‚ü®nnnorm, nnnorm_zero, nnnorm_one, nnnorm_mul‚ü©
@[simp] lemma norm_pow (a : Œ±) : ‚àÄ (n : ‚Ñï), ‚à•a ^ n‚à• = ‚à•a‚à• ^ n :=
(norm_hom.to_monoid_hom : Œ± ‚Üí* ‚Ñù).map_pow a
@[simp] lemma nnnorm_pow (a : Œ±) (n : ‚Ñï) : ‚à•a ^ n‚à•‚Çä = ‚à•a‚à•‚Çä ^ n :=
(nnnorm_hom.to_monoid_hom : Œ± ‚Üí* ‚Ñù‚â•0).map_pow a n
protected lemma list.norm_prod (l : list Œ±) : ‚à•l.prod‚à• = (l.map norm).prod :=
(norm_hom.to_monoid_hom : Œ± ‚Üí* ‚Ñù).map_list_prod _
protected lemma list.nnnorm_prod (l : list Œ±) : ‚à•l.prod‚à•‚Çä = (l.map nnnorm).prod :=
(nnnorm_hom.to_monoid_hom : Œ± ‚Üí* ‚Ñù‚â•0).map_list_prod _
@[simp] lemma norm_div (a b : Œ±) : ‚à•a / b‚à• = ‚à•a‚à• / ‚à•b‚à• := (norm_hom : Œ± ‚Üí*‚ÇÄ ‚Ñù).map_div a b
@[simp] lemma nnnorm_div (a b : Œ±) : ‚à•a / b‚à•‚Çä = ‚à•a‚à•‚Çä / ‚à•b‚à•‚Çä := (nnnorm_hom : Œ± ‚Üí*‚ÇÄ ‚Ñù‚â•0).map_div a b
@[simp] lemma norm_inv (a : Œ±) : ‚à•a‚Åª¬π‚à• = ‚à•a‚à•‚Åª¬π := (norm_hom : Œ± ‚Üí*‚ÇÄ ‚Ñù).map_inv a
@[simp] lemma nnnorm_inv (a : Œ±) : ‚à•a‚Åª¬π‚à•‚Çä = ‚à•a‚à•‚Çä‚Åª¬π :=
nnreal.eq $ by simp
@[simp] lemma norm_zpow : ‚àÄ (a : Œ±) (n : ‚Ñ§), ‚à•a^n‚à• = ‚à•a‚à•^n := (norm_hom : Œ± ‚Üí*‚ÇÄ ‚Ñù).map_zpow
@[simp] lemma nnnorm_zpow : ‚àÄ (a : Œ±) (n : ‚Ñ§), ‚à•a ^ n‚à•‚Çä = ‚à•a‚à•‚Çä ^ n :=
(nnnorm_hom : Œ± ‚Üí*‚ÇÄ ‚Ñù‚â•0).map_zpow
lemma filter.tendsto_mul_left_cobounded {a : Œ±} (ha : a ‚â† 0) :
  tendsto ((*) a) (comap norm at_top) (comap norm at_top) :=
by simpa only [tendsto_comap_iff, (‚àò), norm_mul]
  using tendsto_const_nhds.mul_at_top (norm_pos_iff.2 ha) tendsto_comap
lemma filter.tendsto_mul_right_cobounded {a : Œ±} (ha : a ‚â† 0) :
  tendsto (Œª x, x * a) (comap norm at_top) (comap norm at_top) :=
by simpa only [tendsto_comap_iff, (‚àò), norm_mul]
  using tendsto_comap.at_top_mul (norm_pos_iff.2 ha) tendsto_const_nhds
class normed_field (Œ± : Type*) extends has_norm Œ±, field Œ±, metric_space Œ± :=
(dist_eq : ‚àÄ x y, dist x y = norm (x - y))
(norm_mul' : ‚àÄ a b, norm (a * b) = norm a * norm b)
class nondiscrete_normed_field (Œ± : Type*) extends normed_field Œ± :=
(non_trivial : ‚àÉ x : Œ±, 1 < ‚à•x‚à•)
section normed_field
variables [normed_field Œ±]
instance punctured_nhds_module_ne_bot
  {E : Type*} [add_comm_group E] [topological_space E] [has_continuous_add E] [nontrivial E]
  [module ‚Ñù E] [has_continuous_smul ‚Ñù E] (x : E) :
  ne_bot (ùìù[‚â†] x) :=
module.punctured_nhds_ne_bot ‚Ñù E x
end real
namespace nnreal
open_locale nnreal
@[simp] lemma norm_eq (x : ‚Ñù‚â•0) : ‚à•(x : ‚Ñù)‚à• = x :=
by rw [real.norm_eq_abs, x.abs_eq]
@[simp] lemma nnnorm_eq (x : ‚Ñù‚â•0) : ‚à•(x : ‚Ñù)‚à•‚Çä = x :=
nnreal.eq $ real.norm_of_nonneg x.2
end nnreal
@[simp] lemma norm_norm [semi_normed_group Œ±] (x : Œ±) : ‚à•‚à•x‚à•‚à• = ‚à•x‚à• :=
real.norm_of_nonneg (norm_nonneg _)
@[simp] lemma nnnorm_norm [semi_normed_group Œ±] (a : Œ±) : ‚à•‚à•a‚à•‚à•‚Çä = ‚à•a‚à•‚Çä :=
by simpa [real.nnnorm_of_nonneg (norm_nonneg a)]
lemma normed_group.tendsto_at_top [nonempty Œ±] [semilattice_sup Œ±] {Œ≤ : Type*} [semi_normed_group Œ≤]
  {f : Œ± ‚Üí Œ≤} {b : Œ≤} :
  tendsto f at_top (ùìù b) ‚Üî ‚àÄ Œµ, 0 < Œµ ‚Üí ‚àÉ N, ‚àÄ n, N ‚â§ n ‚Üí ‚à•f n - b‚à• < Œµ :=
(at_top_basis.tendsto_iff metric.nhds_basis_ball).trans (by simp [dist_eq_norm])
lemma normed_group.tendsto_at_top' [nonempty Œ±] [semilattice_sup Œ±] [no_max_order Œ±]
  {Œ≤ : Type*} [semi_normed_group Œ≤]
  {f : Œ± ‚Üí Œ≤} {b : Œ≤} :
  tendsto f at_top (ùìù b) ‚Üî ‚àÄ Œµ, 0 < Œµ ‚Üí ‚àÉ N, ‚àÄ n, N < n ‚Üí ‚à•f n - b‚à• < Œµ :=
(at_top_basis_Ioi.tendsto_iff metric.nhds_basis_ball).trans (by simp [dist_eq_norm])
instance : normed_comm_ring ‚Ñ§ :=
{ norm := Œª n, ‚à•(n : ‚Ñù)‚à•,
  norm_mul := Œª m n, le_of_eq $ by simp only [norm, int.cast_mul, abs_mul],
  dist_eq := Œª m n, by simp only [int.dist_eq, norm, int.cast_sub],
  mul_comm := mul_comm }
@[norm_cast] lemma int.norm_cast_real (m : ‚Ñ§) : ‚à•(m : ‚Ñù)‚à• = ‚à•m‚à• := rfl
lemma int.norm_eq_abs (n : ‚Ñ§) : ‚à•n‚à• = |n| := rfl
lemma nnreal.coe_nat_abs (n : ‚Ñ§) : (n.nat_abs : ‚Ñù‚â•0) = ‚à•n‚à•‚Çä :=
nnreal.eq $ calc ((n.nat_abs : ‚Ñù‚â•0) : ‚Ñù)
               = (n.nat_abs : ‚Ñ§) : by simp only [int.cast_coe_nat, nnreal.coe_nat_cast]
           ... = |n|           : by simp only [‚Üê int.abs_eq_nat_abs, int.cast_abs]
           ... = ‚à•n‚à•              : rfl
lemma int.abs_le_floor_nnreal_iff (z : ‚Ñ§) (c : ‚Ñù‚â•0) : |z| ‚â§ ‚åäc‚åã‚Çä ‚Üî ‚à•z‚à•‚Çä ‚â§ c :=
begin
  rw [int.abs_eq_nat_abs, int.coe_nat_le, nat.le_floor_iff (zero_le c)],
  congr',
  exact nnreal.coe_nat_abs z,
end
instance : norm_one_class ‚Ñ§ :=
‚ü®by simp [‚Üê int.norm_cast_real]‚ü©
instance : normed_field ‚Ñö :=
{ norm := Œª r, ‚à•(r : ‚Ñù)‚à•,
  norm_mul' := Œª r‚ÇÅ r‚ÇÇ, by simp only [norm, rat.cast_mul, abs_mul],
  dist_eq := Œª r‚ÇÅ r‚ÇÇ, by simp only [rat.dist_eq, norm, rat.cast_sub] }
instance : nondiscrete_normed_field ‚Ñö :=
{ non_trivial := ‚ü®2, by { unfold norm, rw abs_of_nonneg; norm_num }‚ü© }
@[norm_cast, simp] lemma rat.norm_cast_real (r : ‚Ñö) : ‚à•(r : ‚Ñù)‚à• = ‚à•r‚à• := rfl
@[norm_cast, simp] lemma int.norm_cast_rat (m : ‚Ñ§) : ‚à•(m : ‚Ñö)‚à• = ‚à•m‚à• :=
by rw [‚Üê rat.norm_cast_real, ‚Üê int.norm_cast_real]; congr' 1; norm_cast
variables {Œπ' : Type*} [normed_ring Œ±]
open finset
open_locale classical
lemma summable.mul_of_nonneg {f : Œπ ‚Üí ‚Ñù} {g : Œπ' ‚Üí ‚Ñù}
  (hf : summable f) (hg : summable g) (hf' : 0 ‚â§ f) (hg' : 0 ‚â§ g) :
  summable (Œª (x : Œπ √ó Œπ'), f x.1 * g x.2) :=
let ‚ü®s, hf‚ü© := hf in
let ‚ü®t, hg‚ü© := hg in
suffices this : ‚àÄ u : finset (Œπ √ó Œπ'), ‚àë x in u, f x.1 * g x.2 ‚â§ s*t,
  from summable_of_sum_le (Œª x, mul_nonneg (hf' _) (hg' _)) this,
assume u,
calc  ‚àë x in u, f x.1 * g x.2
    ‚â§ ‚àë x in (u.image prod.fst).product (u.image prod.snd), f x.1 * g x.2 :
      sum_mono_set_of_nonneg (Œª x, mul_nonneg (hf' _) (hg' _)) subset_product
... = ‚àë x in u.image prod.fst, ‚àë y in u.image prod.snd, f x * g y : sum_product
... = ‚àë x in u.image prod.fst, f x * ‚àë y in u.image prod.snd, g y :
      sum_congr rfl (Œª x _, mul_sum.symm)
... ‚â§ ‚àë x in u.image prod.fst, f x * t :
      sum_le_sum
        (Œª x _, mul_le_mul_of_nonneg_left (sum_le_has_sum _ (Œª _ _, hg' _) hg) (hf' _))
... = (‚àë x in u.image prod.fst, f x) * t : sum_mul.symm
... ‚â§ s * t :
      mul_le_mul_of_nonneg_right (sum_le_has_sum _ (Œª _ _, hf' _) hf) (hg.nonneg $ Œª _, hg' _)
lemma summable.mul_norm {f : Œπ ‚Üí Œ±} {g : Œπ' ‚Üí Œ±}
  (hf : summable (Œª x, ‚à•f x‚à•)) (hg : summable (Œª x, ‚à•g x‚à•)) :
  summable (Œª (x : Œπ √ó Œπ'), ‚à•f x.1 * g x.2‚à•) :=
summable_of_nonneg_of_le (Œª x, norm_nonneg (f x.1 * g x.2)) (Œª x, norm_mul_le (f x.1) (g x.2))
  (hf.mul_of_nonneg hg (Œª x, norm_nonneg $ f x) (Œª x, norm_nonneg $ g x) : _)
lemma summable_mul_of_summable_norm [complete_space Œ±] {f : Œπ ‚Üí Œ±} {g : Œπ' ‚Üí Œ±}
  (hf : summable (Œª x, ‚à•f x‚à•)) (hg : summable (Œª x, ‚à•g x‚à•)) :
  summable (Œª (x : Œπ √ó Œπ'), f x.1 * g x.2) :=
summable_of_summable_norm (hf.mul_norm hg)
lemma tsum_mul_tsum_of_summable_norm [complete_space Œ±] {f : Œπ ‚Üí Œ±} {g : Œπ' ‚Üí Œ±}
  (hf : summable (Œª x, ‚à•f x‚à•)) (hg : summable (Œª x, ‚à•g x‚à•)) :
  (‚àë' x, f x) * (‚àë' y, g y) = (‚àë' z : Œπ √ó Œπ', f z.1 * g z.2) :=
tsum_mul_tsum (summable_of_summable_norm hf) (summable_of_summable_norm hg)
  (summable_mul_of_summable_norm hf hg)
section nat
open finset.nat
lemma summable_norm_sum_mul_antidiagonal_of_summable_norm {f g : ‚Ñï ‚Üí Œ±}
  (hf : summable (Œª x, ‚à•f x‚à•)) (hg : summable (Œª x, ‚à•g x‚à•)) :
  summable (Œª n, ‚à•‚àë kl in antidiagonal n, f kl.1 * g kl.2‚à•) :=
begin
  have := summable_sum_mul_antidiagonal_of_summable_mul
    (summable.mul_of_nonneg hf hg (Œª _, norm_nonneg _) (Œª _, norm_nonneg _)),
  refine summable_of_nonneg_of_le (Œª _, norm_nonneg _) _ this,
  intros n,
  calc  ‚à•‚àë kl in antidiagonal n, f kl.1 * g kl.2‚à•
      ‚â§ ‚àë kl in antidiagonal n, ‚à•f kl.1 * g kl.2‚à• : norm_sum_le _ _
  ... ‚â§ ‚àë kl in antidiagonal n, ‚à•f kl.1‚à• * ‚à•g kl.2‚à• : sum_le_sum (Œª i _, norm_mul_le _ _)
end
lemma tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm [complete_space Œ±] {f g : ‚Ñï ‚Üí Œ±}
  (hf : summable (Œª x, ‚à•f x‚à•)) (hg : summable (Œª x, ‚à•g x‚à•)) :
  (‚àë' n, f n) * (‚àë' n, g n) = ‚àë' n, ‚àë kl in antidiagonal n, f kl.1 * g kl.2 :=
tsum_mul_tsum_eq_tsum_sum_antidiagonal (summable_of_summable_norm hf) (summable_of_summable_norm hg)
  (summable_mul_of_summable_norm hf hg)
lemma summable_norm_sum_mul_range_of_summable_norm {f g : ‚Ñï ‚Üí Œ±}
  (hf : summable (Œª x, ‚à•f x‚à•)) (hg : summable (Œª x, ‚à•g x‚à•)) :
  summable (Œª n, ‚à•‚àë k in range (n+1), f k * g (n - k)‚à•) :=
begin
  simp_rw ‚Üê sum_antidiagonal_eq_sum_range_succ (Œª k l, f k * g l),
  exact summable_norm_sum_mul_antidiagonal_of_summable_norm hf hg
end
lemma tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm [complete_space Œ±] {f g : ‚Ñï ‚Üí Œ±}
  (hf : summable (Œª x, ‚à•f x‚à•)) (hg : summable (Œª x, ‚à•g x‚à•)) :
  (‚àë' n, f n) * (‚àë' n, g n) = ‚àë' n, ‚àë k in range (n+1), f k * g (n - k) :=
begin
  simp_rw ‚Üê sum_antidiagonal_eq_sum_range_succ (Œª k l, f k * g l),
  exact tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm hf hg
end
end nat
end cauchy_product
section ring_hom_isometric
variables {R‚ÇÅ : Type*} {R‚ÇÇ : Type*} {R‚ÇÉ : Type*}
class ring_hom_isometric [semiring R‚ÇÅ] [semiring R‚ÇÇ] [has_norm R‚ÇÅ] [has_norm R‚ÇÇ]
  (œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ) : Prop :=
(is_iso : ‚àÄ {x : R‚ÇÅ}, ‚à•œÉ x‚à• = ‚à•x‚à•)
attribute [simp] ring_hom_isometric.is_iso
variables [semi_normed_ring R‚ÇÅ] [semi_normed_ring R‚ÇÇ] [semi_normed_ring R‚ÇÉ]
instance ring_hom_isometric.ids : ring_hom_isometric (ring_hom.id R‚ÇÅ) :=
‚ü®Œª x, rfl‚ü©
end ring_hom_isometric
