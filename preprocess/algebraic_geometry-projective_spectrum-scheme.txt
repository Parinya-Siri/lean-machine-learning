import algebraic_geometry.projective_spectrum.structure_sheaf
import algebraic_geometry.Spec
noncomputable theory
namespace algebraic_geometry
open_locale direct_sum big_operators pointwise big_operators
open direct_sum set_like.graded_monoid localization finset (hiding mk_zero)
variables {R A : Type*}
variables [comm_ring R] [comm_ring A] [algebra R A]
variables (ğ’œ : â„• â†’ submodule R A)
variables [graded_algebra ğ’œ]
open Top topological_space
open category_theory opposite
open projective_spectrum.structure_sheaf
local notation `Proj` := Proj.to_LocallyRingedSpace ğ’œ
def degree_zero_part {f : A} {m : â„•} (f_deg : f âˆˆ ğ’œ m) : subring (away f) :=
{ carrier := { y | âˆƒ (n : â„•) (a : ğ’œ (m * n)), y = mk a.1 âŸ¨f^n, âŸ¨n, rflâŸ©âŸ© },
  mul_mem' := Î» _ _ âŸ¨n, âŸ¨a, hâŸ©âŸ© âŸ¨n', âŸ¨b, h'âŸ©âŸ©, h.symm â–¸ h'.symm â–¸
    âŸ¨n+n', âŸ¨âŸ¨a.1 * b.1, (mul_add m n n').symm â–¸ mul_mem a.2 b.2âŸ©,
    by {rw mk_mul, congr' 1, simp only [pow_add], refl }âŸ©âŸ©,
  one_mem' := âŸ¨0, âŸ¨1, (mul_zero m).symm â–¸ one_memâŸ©,
    by { symmetry, convert â† mk_self 1, simp only [pow_zero], refl, }âŸ©,
  add_mem' := Î» _ _ âŸ¨n, âŸ¨a, hâŸ©âŸ© âŸ¨n', âŸ¨b, h'âŸ©âŸ©, h.symm â–¸ h'.symm â–¸
    âŸ¨n+n', âŸ¨âŸ¨f ^ n * b.1 + f ^ n' * a.1, (mul_add m n n').symm â–¸
      add_mem (mul_mem (by { rw mul_comm, exact set_like.graded_monoid.pow_mem n f_deg }) b.2)
        begin
          rw add_comm,
          refine mul_mem _ a.2,
          rw mul_comm,
          exact set_like.graded_monoid.pow_mem _ f_deg
        endâŸ©, begin
          rw add_mk,
          congr' 1,
          simp only [pow_add],
          refl,
        endâŸ©âŸ©,
  zero_mem' := âŸ¨0, âŸ¨0, (mk_zero _).symmâŸ©âŸ©,
  neg_mem' := Î» x âŸ¨n, âŸ¨a, hâŸ©âŸ©, h.symm â–¸ âŸ¨n, âŸ¨-a, neg_mk _ _âŸ©âŸ© }
local notation `Aâ°_` f_deg := degree_zero_part f_deg
instance (f : A) {m : â„•} (f_deg : f âˆˆ ğ’œ m) : comm_ring (degree_zero_part f_deg) :=
(degree_zero_part f_deg).to_comm_ring
def degree_zero_part.deg {f : A} {m : â„•} (f_deg : f âˆˆ ğ’œ m) (x : Aâ°_ f_deg) : â„• :=
x.2.some
def degree_zero_part.num {f : A} {m : â„•} (f_deg : f âˆˆ ğ’œ m) (x : Aâ°_ f_deg) : A :=
x.2.some_spec.some.1
lemma degree_zero_part.num_mem {f : A} {m : â„•} (f_deg : f âˆˆ ğ’œ m) (x : Aâ°_ f_deg) :
  degree_zero_part.num f_deg x âˆˆ ğ’œ (m * degree_zero_part.deg f_deg x) :=
x.2.some_spec.some.2
lemma degree_zero_part.eq {f : A} {m : â„•} (f_deg : f âˆˆ ğ’œ m) (x : Aâ°_ f_deg) :
  x.1 = mk (degree_zero_part.num f_deg x) âŸ¨f^(degree_zero_part.deg f_deg x), âŸ¨_, rflâŸ©âŸ© :=
x.2.some_spec.some_spec
lemma degree_zero_part.mul_val {f : A} {m : â„•} (f_deg : f âˆˆ ğ’œ m) (x y : Aâ°_ f_deg) :
  (x * y).1 = x.1 * y.1 := rfl
end
end algebraic_geometry
