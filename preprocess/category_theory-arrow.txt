import category_theory.comma
namespace category_theory
@[derive category]
def arrow := comma.{v v v} (ğŸ­ T) (ğŸ­ T)
@[simps]
def mk {X Y : T} (f : X âŸ¶ Y) : arrow T :=
{ left := X,
  right := Y,
  hom := f }
theorem mk_injective (A B : T) :
  function.injective (arrow.mk : (A âŸ¶ B) â†’ arrow T) :=
Î» f g h, by { cases h, refl }
theorem mk_inj (A B : T) {f g : A âŸ¶ B} : arrow.mk f = arrow.mk g â†” f = g :=
(mk_injective A B).eq_iff
instance {X Y : T} : has_coe (X âŸ¶ Y) (arrow T) := âŸ¨mkâŸ©
@[simps]
def hom_mk {f g : arrow T} {u : f.left âŸ¶ g.left} {v : f.right âŸ¶ g.right}
  (w : u â‰« g.hom = f.hom â‰« v) : f âŸ¶ g :=
{ left := u,
  right := v,
  w' := w }
@[simps]
def hom_mk' {X Y : T} {f : X âŸ¶ Y} {P Q : T} {g : P âŸ¶ Q} {u : X âŸ¶ P} {v : Y âŸ¶ Q}
  (w : u â‰« g = f â‰« v) : arrow.mk f âŸ¶ arrow.mk g :=
{ left := u,
  right := v,
  w' := w }
@[simp, reassoc] lemma w {f g : arrow T} (sq : f âŸ¶ g) : sq.left â‰« g.hom = f.hom â‰« sq.right := sq.w
@[simps] def iso_mk {f g : arrow T}
  (l : f.left â‰… g.left) (r : f.right â‰… g.right) (h : l.hom â‰« g.hom = f.hom â‰« r.hom) :
  f â‰… g :=
comma.iso_mk l r h
section
variables {f g : arrow T} (sq : f âŸ¶ g)
instance is_iso_left [is_iso sq] : is_iso sq.left :=
{ out := âŸ¨(inv sq).left, by simp only [â† comma.comp_left, is_iso.hom_inv_id, is_iso.inv_hom_id,
    arrow.id_left, eq_self_iff_true, and_self]âŸ© }
instance is_iso_right [is_iso sq] : is_iso sq.right :=
{ out := âŸ¨(inv sq).right, by simp only [â† comma.comp_right, is_iso.hom_inv_id, is_iso.inv_hom_id,
    arrow.id_right, eq_self_iff_true, and_self]âŸ© }
@[simp] lemma inv_left [is_iso sq] : (inv sq).left = inv sq.left :=
is_iso.eq_inv_of_hom_inv_id $ by rw [â† comma.comp_left, is_iso.hom_inv_id, id_left]
@[simp] lemma inv_right [is_iso sq] : (inv sq).right = inv sq.right :=
is_iso.eq_inv_of_hom_inv_id $ by rw [â† comma.comp_right, is_iso.hom_inv_id, id_right]
@[simp] lemma left_hom_inv_right [is_iso sq] : sq.left â‰« g.hom â‰« inv sq.right = f.hom :=
by simp only [â† category.assoc, is_iso.comp_inv_eq, w]
@[simp] lemma square_to_iso_invert (i : arrow T) {X Y : T} (p : X â‰… Y) (sq : i âŸ¶ arrow.mk p.hom) :
  i.hom â‰« sq.right â‰« p.inv = sq.left :=
by simpa only [category.assoc] using (iso.comp_inv_eq p).mpr ((arrow.w_mk_right sq).symm)
lemma square_from_iso_invert {X Y : T} (i : X â‰… Y) (p : arrow T) (sq : arrow.mk i.hom âŸ¶ p) :
  i.inv â‰« sq.left â‰« p.hom = sq.right :=
by simp only [iso.inv_hom_id_assoc, arrow.w, arrow.mk_hom]
@[ext] structure lift_struct {f g : arrow T} (sq : f âŸ¶ g) :=
(lift : f.right âŸ¶ g.left)
(fac_left' : f.hom â‰« lift = sq.left . obviously)
(fac_right' : lift â‰« g.hom = sq.right . obviously)
restate_axiom lift_struct.fac_left'
restate_axiom lift_struct.fac_right'
instance lift_struct_inhabited {X : T} : inhabited (lift_struct (ğŸ™ (arrow.mk (ğŸ™ X)))) :=
âŸ¨âŸ¨ğŸ™ _, category.id_comp _, category.comp_id _âŸ©âŸ©
class has_lift {f g : arrow T} (sq : f âŸ¶ g) : Prop :=
mk' :: (exists_lift : nonempty (lift_struct sq))
lemma has_lift.mk {f g : arrow T} {sq : f âŸ¶ g} (s : lift_struct sq) : has_lift sq :=
âŸ¨nonempty.intro sâŸ©
attribute [simp, reassoc] lift_struct.fac_left lift_struct.fac_right
noncomputable def has_lift.struct {f g : arrow T} (sq : f âŸ¶ g) [has_lift sq] : lift_struct sq :=
classical.choice has_lift.exists_lift
noncomputable abbreviation lift {f g : arrow T} (sq : f âŸ¶ g) [has_lift sq] : f.right âŸ¶ g.left :=
(has_lift.struct sq).lift
lemma lift.fac_left {f g : arrow T} (sq : f âŸ¶ g) [has_lift sq] : f.hom â‰« lift sq = sq.left :=
by simp
lemma lift.fac_right {f g : arrow T} (sq : f âŸ¶ g) [has_lift sq] : lift sq â‰« g.hom = sq.right :=
by simp
@[simp, reassoc]
lemma lift.fac_right_of_to_mk {X Y : T} {f : arrow T} {g : X âŸ¶ Y} (sq : f âŸ¶ mk g) [has_lift sq] :
  lift sq â‰« g = sq.right :=
by simp only [â†mk_hom g, lift.fac_right]
@[simp, reassoc]
lemma lift.fac_left_of_from_mk {X Y : T} {f : X âŸ¶ Y} {g : arrow T} (sq : mk f âŸ¶ g) [has_lift sq] :
  f â‰« lift sq = sq.left :=
by simp only [â†mk_hom f, lift.fac_left]
@[simp, reassoc]
lemma lift_mk'_left {X Y P Q : T} {f : X âŸ¶ Y} {g : P âŸ¶ Q} {u : X âŸ¶ P} {v : Y âŸ¶ Q}
  (h : u â‰« g = f â‰« v) [has_lift $ arrow.hom_mk' h] : f â‰« lift (arrow.hom_mk' h) = u :=
by simp only [â†arrow.mk_hom f, lift.fac_left, arrow.hom_mk'_left]
@[simp, reassoc]
lemma lift_mk'_right {X Y P Q : T} {f : X âŸ¶ Y} {g : P âŸ¶ Q} {u : X âŸ¶ P} {v : Y âŸ¶ Q}
  (h : u â‰« g = f â‰« v) [has_lift $ arrow.hom_mk' h] : lift (arrow.hom_mk' h) â‰« g = v :=
by simp only [â†arrow.mk_hom g, lift.fac_right, arrow.hom_mk'_right]
section
instance subsingleton_lift_struct_of_epi {f g : arrow T} (sq : f âŸ¶ g) [epi f.hom] :
  subsingleton (lift_struct sq) :=
subsingleton.intro $ Î» a b, lift_struct.ext a b $ (cancel_epi f.hom).1 $ by simp
instance subsingleton_lift_struct_of_mono {f g : arrow T} (sq : f âŸ¶ g) [mono g.hom] :
  subsingleton (lift_struct sq) :=
subsingleton.intro $ Î» a b, lift_struct.ext a b $ (cancel_mono g.hom).1 $ by simp
end
variables {C : Type u} [category.{v} C]
@[simps] def square_to_snd {X Y Z: C} {i : arrow C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z}
  (sq : i âŸ¶ arrow.mk (f â‰« g)) :
  i âŸ¶ arrow.mk g :=
{ left := sq.left â‰« f,
  right := sq.right }
@[simps] def left_func : arrow C â¥¤ C := comma.fst _ _
@[simps] def right_func : arrow C â¥¤ C := comma.snd _ _
@[simps]
def left_to_right : (left_func : arrow C â¥¤ C) âŸ¶ right_func :=
{ app := Î» f, f.hom }
end arrow
namespace functor
universes vâ‚ vâ‚‚ uâ‚ uâ‚‚
variables {C : Type uâ‚} [category.{vâ‚} C] {D : Type uâ‚‚} [category.{vâ‚‚} D]
@[simps]
def map_arrow (F : C â¥¤ D) : arrow C â¥¤ arrow D :=
{ obj := Î» a,
  { left := F.obj a.left,
    right := F.obj a.right,
    hom := F.map a.hom, },
  map := Î» a b f,
  { left := F.map f.left,
    right := F.map f.right,
    w' := by { have w := f.w, simp only [id_map] at w, dsimp, simp only [â†F.map_comp, w], } } }
end functor
end category_theory
