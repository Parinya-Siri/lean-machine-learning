import category_theory.bicategory.End
import category_theory.monoidal.functorial
namespace category_theory
variables (C : Type*) [category C] [monoidal_category C]
@[nolint unused_arguments, derive inhabited]
def monoidal_single_obj (C : Type*) [category C] [monoidal_category C] := punit
open monoidal_category
instance : bicategory (monoidal_single_obj C) :=
{ hom := Î» _ _, C,
  id := Î» _, ğŸ™_ C,
  comp := Î» _ _ _ X Y, X âŠ— Y,
  whisker_left := Î» _ _ _ X Y Z f, ğŸ™ X âŠ— f,
  whisker_right := Î» _ _ _ X Y f Z, f âŠ— ğŸ™ Z,
  associator := Î» _ _ _ _ X Y Z, Î±_ X Y Z,
  left_unitor := Î» _ _ X, Î»_ X,
  right_unitor := Î» _ _ X, Ï_ X,
  comp_whisker_left' :=
    by { intros, rw [associator_inv_naturality, iso.hom_inv_id_assoc, tensor_id], },
  whisker_assoc' := by { intros, rw [associator_inv_naturality, iso.hom_inv_id_assoc], },
  whisker_right_comp' :=
    by { intros, rw [â†tensor_id, associator_naturality, iso.inv_hom_id_assoc], },
  id_whisker_left' := by { intros, rw [left_unitor_inv_naturality, iso.hom_inv_id_assoc], },
  whisker_right_id' := by { intros, rw [right_unitor_inv_naturality, iso.hom_inv_id_assoc], },
  pentagon' := by { intros, rw [pentagon], }, }
namespace monoidal_single_obj
@[nolint unused_arguments]
protected def star : monoidal_single_obj C := punit.star
@[simps]
def End_monoidal_star_functor : monoidal_functor (End_monoidal (monoidal_single_obj.star C)) C :=
{ obj := Î» X, X,
  map := Î» X Y f, f,
  Îµ := ğŸ™ _,
  Î¼ := Î» X Y, ğŸ™ _,
  Î¼_natural' := Î» X Y X' Y' f g, begin
    dsimp,
    simp only [category.id_comp, category.comp_id],
def End_monoidal_star_functor_is_equivalence :
  is_equivalence (End_monoidal_star_functor C).to_functor :=
{ inverse :=
  { obj := Î» X, X,
    map := Î» X Y f, f, },
  unit_iso := nat_iso.of_components (Î» X, as_iso (ğŸ™ _)) (by tidy),
  counit_iso := nat_iso.of_components (Î» X, as_iso (ğŸ™ _)) (by tidy), }
end monoidal_single_obj
end category_theory
