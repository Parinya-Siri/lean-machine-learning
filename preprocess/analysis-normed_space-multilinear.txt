import analysis.normed_space.operator_norm
import topology.algebra.module.multilinear
noncomputable theory
open_locale classical big_operators nnreal
open finset metric
local attribute [instance, priority 1001]
add_comm_group.to_add_comm_monoid normed_group.to_add_comm_group normed_space.to_module'
universes u v v' wE wEâ‚ wE' wEi wG wG'
variables {ğ•œ : Type u} {Î¹ : Type v} {Î¹' : Type v'} {n : â„•}
  {E : Î¹ â†’ Type wE} {Eâ‚ : Î¹ â†’ Type wEâ‚} {E' : Î¹' â†’ Type wE'} {Ei : fin n.succ â†’ Type wEi}
  {G : Type wG} {G' : Type wG'}
  [decidable_eq Î¹] [fintype Î¹] [decidable_eq Î¹'] [fintype Î¹'] [nondiscrete_normed_field ğ•œ]
  [Î  i, normed_group (E i)] [Î  i, normed_space ğ•œ (E i)]
  [Î  i, normed_group (Eâ‚ i)] [Î  i, normed_space ğ•œ (Eâ‚ i)]
  [Î  i, normed_group (E' i)] [Î  i, normed_space ğ•œ (E' i)]
  [Î  i, normed_group (Ei i)] [Î  i, normed_space ğ•œ (Ei i)]
  [normed_group G] [normed_space ğ•œ G] [normed_group G'] [normed_space ğ•œ G']
namespace multilinear_map
variable (f : multilinear_map ğ•œ E G)
lemma bound_of_shell {Îµ : Î¹ â†’ â„} {C : â„} (hÎµ : âˆ€ i, 0 < Îµ i) {c : Î¹ â†’ ğ•œ} (hc : âˆ€ i, 1 < âˆ¥c iâˆ¥)
  (hf : âˆ€ m : Î  i, E i, (âˆ€ i, Îµ i / âˆ¥c iâˆ¥ â‰¤ âˆ¥m iâˆ¥) â†’ (âˆ€ i, âˆ¥m iâˆ¥ < Îµ i) â†’ âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥)
  (m : Î  i, E i) : âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥ :=
begin
  rcases em (âˆƒ i, m i = 0) with âŸ¨i, hiâŸ©|hm; [skip, push_neg at hm],
  { simp [f.map_coord_zero i hi, prod_eq_zero (mem_univ i), hi] },
  choose Î´ hÎ´0 hÎ´m_lt hle_Î´m hÎ´inv using Î» i, rescale_to_shell (hc i) (hÎµ i) (hm i),
  have hÎ´0 : 0 < âˆ i, âˆ¥Î´ iâˆ¥, from prod_pos (Î» i _, norm_pos_iff.2 (hÎ´0 i)),
  simpa [map_smul_univ, norm_smul, prod_mul_distrib, mul_left_comm C, mul_le_mul_left hÎ´0]
    using hf (Î» i, Î´ i â€¢ m i) hle_Î´m hÎ´m_lt,
end
theorem exists_bound_of_continuous (hf : continuous f) :
  âˆƒ (C : â„), 0 < C âˆ§ (âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) :=
begin
  casesI is_empty_or_nonempty Î¹,
  { refine âŸ¨âˆ¥f 0âˆ¥ + 1, add_pos_of_nonneg_of_pos (norm_nonneg _) zero_lt_one, Î» m, _âŸ©,
    obtain rfl : m = 0, from funext (is_empty.elim â€¹_â€º),
    simp [univ_eq_empty, zero_le_one] },
  obtain âŸ¨Îµ : â„, Îµ0 : 0 < Îµ, hÎµ : âˆ€ m : Î  i, E i, âˆ¥m - 0âˆ¥ < Îµ â†’ âˆ¥f m - f 0âˆ¥ < 1âŸ© :=
    normed_group.tendsto_nhds_nhds.1 (hf.tendsto 0) 1 zero_lt_one,
  simp only [sub_zero, f.map_zero] at hÎµ,
  rcases normed_field.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©,
  have : 0 < (âˆ¥câˆ¥ / Îµ) ^ fintype.card Î¹, from pow_pos (div_pos (zero_lt_one.trans hc) Îµ0) _,
  refine âŸ¨_, this, _âŸ©,
  refine f.bound_of_shell (Î» _, Îµ0) (Î» _, hc) (Î» m hcm hm, _),
  refine (hÎµ m ((pi_norm_lt_iff Îµ0).2 hm)).le.trans _,
  rw [â† div_le_iff' this, one_div, â† inv_pow, inv_div, fintype.card, â† prod_const],
  exact prod_le_prod (Î» _ _, div_nonneg Îµ0.le (norm_nonneg _)) (Î» i _, hcm i)
end
lemma norm_image_sub_le_of_bound' {C : â„} (hC : 0 â‰¤ C)
  (H : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) (mâ‚ mâ‚‚ : Î i, E i) :
  âˆ¥f mâ‚ - f mâ‚‚âˆ¥ â‰¤
  C * âˆ‘ i, âˆ j, if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥ :=
begin
  have A : âˆ€(s : finset Î¹), âˆ¥f mâ‚ - f (s.piecewise mâ‚‚ mâ‚)âˆ¥
    â‰¤ C * âˆ‘ i in s, âˆ j, if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥,
  { refine finset.induction (by simp) _,
    assume i s his Hrec,
    have I : âˆ¥f (s.piecewise mâ‚‚ mâ‚) - f ((insert i s).piecewise mâ‚‚ mâ‚)âˆ¥
      â‰¤ C * âˆ j, if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥,
    { have A : ((insert i s).piecewise mâ‚‚ mâ‚)
            = function.update (s.piecewise mâ‚‚ mâ‚) i (mâ‚‚ i) := s.piecewise_insert _ _ _,
      have B : s.piecewise mâ‚‚ mâ‚ = function.update (s.piecewise mâ‚‚ mâ‚) i (mâ‚ i),
      { ext j,
        by_cases h : j = i,
        { rw h, simp [his] },
        { simp [h] } },
      rw [B, A, â† f.map_sub],
      apply le_trans (H _) (mul_le_mul_of_nonneg_left _ hC),
      refine prod_le_prod (Î»j hj, norm_nonneg _) (Î»j hj, _),
      by_cases h : j = i,
      { rw h, simp },
      { by_cases h' : j âˆˆ s;
        simp [h', h, le_refl] } },
    calc âˆ¥f mâ‚ - f ((insert i s).piecewise mâ‚‚ mâ‚)âˆ¥ â‰¤
      âˆ¥f mâ‚ - f (s.piecewise mâ‚‚ mâ‚)âˆ¥ + âˆ¥f (s.piecewise mâ‚‚ mâ‚) - f ((insert i s).piecewise mâ‚‚ mâ‚)âˆ¥ :
        by { rw [â† dist_eq_norm, â† dist_eq_norm, â† dist_eq_norm], exact dist_triangle _ _ _ }
      ... â‰¤ (C * âˆ‘ i in s, âˆ j, if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)
            + C * âˆ j, if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥ :
        add_le_add Hrec I
      ... = C * âˆ‘ i in insert i s, âˆ j, if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥ :
        by simp [his, add_comm, left_distrib] },
  convert A univ,
  simp
end
lemma norm_image_sub_le_of_bound {C : â„} (hC : 0 â‰¤ C)
  (H : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) (mâ‚ mâ‚‚ : Î i, E i) :
  âˆ¥f mâ‚ - f mâ‚‚âˆ¥ â‰¤ C * (fintype.card Î¹) * (max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥) ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥ :=
begin
  have A : âˆ€ (i : Î¹), âˆ j, (if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)
    â‰¤ âˆ¥mâ‚ - mâ‚‚âˆ¥ * (max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥) ^ (fintype.card Î¹ - 1),
  { assume i,
    calc âˆ j, (if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥)
    â‰¤ âˆ j : Î¹, function.update (Î» j, max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥) i (âˆ¥mâ‚ - mâ‚‚âˆ¥) j :
      begin
        apply prod_le_prod,
        { assume j hj, by_cases h : j = i; simp [h, norm_nonneg] },
        { assume j hj,
          by_cases h : j = i,
          { rw h, simp, exact norm_le_pi_norm (mâ‚ - mâ‚‚) i },
          { simp [h, max_le_max, norm_le_pi_norm (_ : Î  i, E i)] } }
      end
    ... = âˆ¥mâ‚ - mâ‚‚âˆ¥ * (max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥) ^ (fintype.card Î¹ - 1) :
      by { rw prod_update_of_mem (finset.mem_univ _), simp [card_univ_diff] } },
  calc
  âˆ¥f mâ‚ - f mâ‚‚âˆ¥
  â‰¤ C * âˆ‘ i, âˆ j, if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥ :
    f.norm_image_sub_le_of_bound' hC H mâ‚ mâ‚‚
  ... â‰¤ C * âˆ‘ i, âˆ¥mâ‚ - mâ‚‚âˆ¥ * (max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥) ^ (fintype.card Î¹ - 1) :
    mul_le_mul_of_nonneg_left (sum_le_sum (Î»i hi, A i)) hC
  ... = C * (fintype.card Î¹) * (max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥) ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥ :
    by { rw [sum_const, card_univ, nsmul_eq_mul], ring }
end
theorem continuous_of_bound (C : â„) (H : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) :
  continuous f :=
begin
  let D := max C 1,
  have D_pos : 0 â‰¤ D := le_trans zero_le_one (le_max_right _ _),
  replace H : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ D * âˆ i, âˆ¥m iâˆ¥,
  { assume m,
    apply le_trans (H m) (mul_le_mul_of_nonneg_right (le_max_left _ _) _),
    exact prod_nonneg (Î»(i : Î¹) hi, norm_nonneg (m i)) },
  refine continuous_iff_continuous_at.2 (Î»m, _),
  refine continuous_at_of_locally_lipschitz zero_lt_one
    (D * (fintype.card Î¹) * (âˆ¥mâˆ¥ + 1) ^ (fintype.card Î¹ - 1)) (Î»m' h', _),
  rw [dist_eq_norm, dist_eq_norm],
  have : 0 â‰¤ (max âˆ¥m'âˆ¥ âˆ¥mâˆ¥), by simp,
  have : (max âˆ¥m'âˆ¥ âˆ¥mâˆ¥) â‰¤ âˆ¥mâˆ¥ + 1,
    by simp [zero_le_one, norm_le_of_mem_closed_ball (le_of_lt h'), -add_comm],
  calc
    âˆ¥f m' - f mâˆ¥
    â‰¤ D * (fintype.card Î¹) * (max âˆ¥m'âˆ¥ âˆ¥mâˆ¥) ^ (fintype.card Î¹ - 1) * âˆ¥m' - mâˆ¥ :
      f.norm_image_sub_le_of_bound D_pos H m' m
    ... â‰¤ D * (fintype.card Î¹) * (âˆ¥mâˆ¥ + 1) ^ (fintype.card Î¹ - 1) * âˆ¥m' - mâˆ¥ :
      by apply_rules [mul_le_mul_of_nonneg_right, mul_le_mul_of_nonneg_left, mul_nonneg,
        norm_nonneg, nat.cast_nonneg, pow_le_pow_of_le_left]
end
def mk_continuous (C : â„) (H : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) :
  continuous_multilinear_map ğ•œ E G :=
{ cont := f.continuous_of_bound C H, ..f }
@[simp] lemma coe_mk_continuous (C : â„) (H : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) :
  â‡‘(f.mk_continuous C H) = f :=
rfl
lemma restr_norm_le {k n : â„•} (f : (multilinear_map ğ•œ (Î» i : fin n, G) G' : _))
  (s : finset (fin n)) (hk : s.card = k) (z : G) {C : â„}
  (H : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) (v : fin k â†’ G) :
  âˆ¥f.restr s hk z vâˆ¥ â‰¤ C * âˆ¥zâˆ¥ ^ (n - k) * âˆ i, âˆ¥v iâˆ¥ :=
begin
  rw [mul_right_comm, mul_assoc],
  convert H _ using 2,
  simp only [apply_dite norm, fintype.prod_dite, prod_const (âˆ¥zâˆ¥), finset.card_univ,
    fintype.card_of_subtype sá¶œ (Î» x, mem_compl), card_compl, fintype.card_fin, hk, mk_coe,
    â† (s.order_iso_of_fin hk).symm.bijective.prod_comp (Î» x, âˆ¥v xâˆ¥)],
  refl
end
end multilinear_map
namespace continuous_multilinear_map
variables (c : ğ•œ) (f g : continuous_multilinear_map ğ•œ E G) (m : Î i, E i)
theorem bound : âˆƒ (C : â„), 0 < C âˆ§ (âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) :=
f.to_multilinear_map.exists_bound_of_continuous f.2
open real
def op_norm := Inf {c | 0 â‰¤ (c : â„) âˆ§ âˆ€ m, âˆ¥f mâˆ¥ â‰¤ c * âˆ i, âˆ¥m iâˆ¥}
instance has_op_norm : has_norm (continuous_multilinear_map ğ•œ E G) := âŸ¨op_normâŸ©
instance has_op_norm' : has_norm (continuous_multilinear_map ğ•œ (Î» (i : Î¹), G) G') :=
continuous_multilinear_map.has_op_norm
lemma norm_def : âˆ¥fâˆ¥ = Inf {c | 0 â‰¤ (c : â„) âˆ§ âˆ€ m, âˆ¥f mâˆ¥ â‰¤ c * âˆ i, âˆ¥m iâˆ¥} := rfl
theorem le_op_norm : âˆ¥f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥ :=
begin
  have A : 0 â‰¤ âˆ i, âˆ¥m iâˆ¥ := prod_nonneg (Î»j hj, norm_nonneg _),
  cases A.eq_or_lt with h hlt,
  { rcases prod_eq_zero_iff.1 h.symm with âŸ¨i, _, hiâŸ©,
    rw norm_eq_zero at hi,
    have : f m = 0 := f.map_coord_zero i hi,
    rw [this, norm_zero],
    exact mul_nonneg (op_norm_nonneg f) A },
  { rw [â† div_le_iff hlt],
    apply le_cInf bounds_nonempty,
    rintro c âŸ¨_, hcâŸ©, rw [div_le_iff hlt], apply hc }
end
theorem le_of_op_norm_le {C : â„} (h : âˆ¥fâˆ¥ â‰¤ C) : âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥ :=
(f.le_op_norm m).trans $ mul_le_mul_of_nonneg_right h (prod_nonneg $ Î» i _, norm_nonneg (m i))
lemma ratio_le_op_norm : âˆ¥f mâˆ¥ / âˆ i, âˆ¥m iâˆ¥ â‰¤ âˆ¥fâˆ¥ :=
div_le_of_nonneg_of_le_mul (prod_nonneg $ Î» i _, norm_nonneg _) (op_norm_nonneg _) (f.le_op_norm m)
lemma unit_le_op_norm (h : âˆ¥mâˆ¥ â‰¤ 1) : âˆ¥f mâˆ¥ â‰¤ âˆ¥fâˆ¥ :=
calc
  âˆ¥f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥ : f.le_op_norm m
  ... â‰¤ âˆ¥fâˆ¥ * âˆ i : Î¹, 1 :
    mul_le_mul_of_nonneg_left (prod_le_prod (Î»i hi, norm_nonneg _)
      (Î»i hi, le_trans (norm_le_pi_norm (_ : Î  i, E i) _) h)) (op_norm_nonneg f)
  ... = âˆ¥fâˆ¥ : by simp
lemma op_norm_le_bound {M : â„} (hMp: 0 â‰¤ M) (hM : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ M * âˆ i, âˆ¥m iâˆ¥) :
  âˆ¥fâˆ¥ â‰¤ M :=
cInf_le bounds_bdd_below âŸ¨hMp, hMâŸ©
theorem op_norm_add_le : âˆ¥f + gâˆ¥ â‰¤ âˆ¥fâˆ¥ + âˆ¥gâˆ¥ :=
cInf_le bounds_bdd_below
  âŸ¨add_nonneg (op_norm_nonneg _) (op_norm_nonneg _), Î» x, by { rw add_mul,
    exact norm_add_le_of_le (le_op_norm _ _) (le_op_norm _ _) }âŸ©
theorem op_norm_zero_iff : âˆ¥fâˆ¥ = 0 â†” f = 0 :=
begin
  split,
  { assume h,
    ext m,
    simpa [h] using f.le_op_norm m },
  { rintro rfl,
    apply le_antisymm (op_norm_le_bound 0 le_rfl (Î»m, _)) (op_norm_nonneg _),
    simp }
end
section
variables {ğ•œ' : Type*} [normed_field ğ•œ'] [normed_space ğ•œ' G] [smul_comm_class ğ•œ ğ•œ' G]
lemma op_norm_smul_le (c : ğ•œ') : âˆ¥c â€¢ fâˆ¥ â‰¤ âˆ¥câˆ¥ * âˆ¥fâˆ¥ :=
(c â€¢ f).op_norm_le_bound
  (mul_nonneg (norm_nonneg _) (op_norm_nonneg _))
  begin
    intro m,
    erw [norm_smul, mul_assoc],
    exact mul_le_mul_of_nonneg_left (le_op_norm _ _) (norm_nonneg _)
  end
lemma op_norm_neg : âˆ¥-fâˆ¥ = âˆ¥fâˆ¥ := by { rw norm_def, apply congr_arg, ext, simp }
instance normed_group : normed_group (continuous_multilinear_map ğ•œ E G) :=
normed_group.of_core _ âŸ¨op_norm_zero_iff, op_norm_add_le, op_norm_negâŸ©
instance normed_group' : normed_group (continuous_multilinear_map ğ•œ (Î» i : Î¹, G) G') :=
continuous_multilinear_map.normed_group
instance normed_space : normed_space ğ•œ' (continuous_multilinear_map ğ•œ E G) :=
âŸ¨Î» c f, f.op_norm_smul_le câŸ©
instance normed_space' : normed_space ğ•œ' (continuous_multilinear_map ğ•œ (Î» i : Î¹, G') G) :=
continuous_multilinear_map.normed_space
theorem le_op_norm_mul_prod_of_le {b : Î¹ â†’ â„} (hm : âˆ€ i, âˆ¥m iâˆ¥ â‰¤ b i) : âˆ¥f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ i, b i :=
(f.le_op_norm m).trans $ mul_le_mul_of_nonneg_left
  (prod_le_prod (Î» _ _, norm_nonneg _) (Î» i _, hm i)) (norm_nonneg f)
theorem le_op_norm_mul_pow_card_of_le {b : â„} (hm : âˆ€ i, âˆ¥m iâˆ¥ â‰¤ b) :
  âˆ¥f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * b ^ fintype.card Î¹ :=
by simpa only [prod_const] using f.le_op_norm_mul_prod_of_le m hm
theorem le_op_norm_mul_pow_of_le {Ei : fin n â†’ Type*} [Î  i, normed_group (Ei i)]
  [Î  i, normed_space ğ•œ (Ei i)] (f : continuous_multilinear_map ğ•œ Ei G) (m : Î  i, Ei i)
  {b : â„} (hm : âˆ¥mâˆ¥ â‰¤ b) :
  âˆ¥f mâˆ¥ â‰¤ âˆ¥fâˆ¥ * b ^ n :=
by simpa only [fintype.card_fin]
  using f.le_op_norm_mul_pow_card_of_le m (Î» i, (norm_le_pi_norm m i).trans hm)
theorem le_op_nnnorm : âˆ¥f mâˆ¥â‚Š â‰¤ âˆ¥fâˆ¥â‚Š * âˆ i, âˆ¥m iâˆ¥â‚Š :=
nnreal.coe_le_coe.1 $ by { push_cast, exact f.le_op_norm m }
theorem le_of_op_nnnorm_le {C : â„â‰¥0} (h : âˆ¥fâˆ¥â‚Š â‰¤ C) : âˆ¥f mâˆ¥â‚Š â‰¤ C * âˆ i, âˆ¥m iâˆ¥â‚Š :=
(f.le_op_nnnorm m).trans $ mul_le_mul' h le_rfl
lemma op_norm_prod (f : continuous_multilinear_map ğ•œ E G) (g : continuous_multilinear_map ğ•œ E G') :
  âˆ¥f.prod gâˆ¥ = max (âˆ¥fâˆ¥) (âˆ¥gâˆ¥) :=
le_antisymm
  (op_norm_le_bound _ (norm_nonneg (f, g)) (Î» m,
    have H : 0 â‰¤ âˆ i, âˆ¥m iâˆ¥, from prod_nonneg $ Î» _ _,  norm_nonneg _,
    by simpa only [prod_apply, prod.norm_def, max_mul_of_nonneg, H]
      using max_le_max (f.le_op_norm m) (g.le_op_norm m))) $
  max_le
    (f.op_norm_le_bound (norm_nonneg _) $ Î» m, (le_max_left _ _).trans ((f.prod g).le_op_norm _))
    (g.op_norm_le_bound (norm_nonneg _) $ Î» m, (le_max_right _ _).trans ((f.prod g).le_op_norm _))
lemma norm_pi {Î¹' : Type v'} [fintype Î¹'] {E' : Î¹' â†’ Type wE'} [Î  i', normed_group (E' i')]
  [Î  i', normed_space ğ•œ (E' i')] (f : Î  i', continuous_multilinear_map ğ•œ E (E' i')) :
  âˆ¥pi fâˆ¥ = âˆ¥fâˆ¥ :=
begin
  apply le_antisymm,
  { refine (op_norm_le_bound _ (norm_nonneg f) (Î» m, _)),
    dsimp,
    rw pi_norm_le_iff,
    exacts [Î» i, (f i).le_of_op_norm_le m (norm_le_pi_norm f i),
      mul_nonneg (norm_nonneg f) (prod_nonneg $ Î» _ _, norm_nonneg _)] },
  { refine (pi_norm_le_iff (norm_nonneg _)).2 (Î» i, _),
    refine (op_norm_le_bound _ (norm_nonneg _) (Î» m, _)),
    refine le_trans _ ((pi f).le_op_norm m),
    convert norm_le_pi_norm (Î» j, f j m) i }
end
section
variables (ğ•œ E E' G G')
def prodL :
  (continuous_multilinear_map ğ•œ E G) Ã— (continuous_multilinear_map ğ•œ E G') â‰ƒâ‚—áµ¢[ğ•œ]
    continuous_multilinear_map ğ•œ E (G Ã— G') :=
{ to_fun := Î» f, f.1.prod f.2,
  inv_fun := Î» f, ((continuous_linear_map.fst ğ•œ G G').comp_continuous_multilinear_map f,
    (continuous_linear_map.snd ğ•œ G G').comp_continuous_multilinear_map f),
  map_add' := Î» f g, rfl,
  map_smul' := Î» c f, rfl,
  left_inv := Î» f, by ext; refl,
  right_inv := Î» f, by ext; refl,
  norm_map' := Î» f, op_norm_prod f.1 f.2 }
def piâ‚—áµ¢ {Î¹' : Type v'} [fintype Î¹'] {E' : Î¹' â†’ Type wE'} [Î  i', normed_group (E' i')]
  [Î  i', normed_space ğ•œ (E' i')] :
  @linear_isometry_equiv ğ•œ ğ•œ _ _ (ring_hom.id ğ•œ) _ _ _
    (Î  i', continuous_multilinear_map ğ•œ E (E' i')) (continuous_multilinear_map ğ•œ E (Î  i, E' i)) _ _
      (@pi.module Î¹' _ ğ•œ _ _ (Î» i', infer_instance)) _ :=
{ to_linear_equiv :=
def restrict_scalars_linear :
  continuous_multilinear_map ğ•œ E G â†’L[ğ•œ'] continuous_multilinear_map ğ•œ' E G :=
linear_map.mk_continuous
{ to_fun := restrict_scalars ğ•œ',
  map_add' := Î» mâ‚ mâ‚‚, rfl,
  map_smul' := Î» c m, rfl } 1 $ Î» f, by simp
variable {ğ•œ'}
lemma continuous_restrict_scalars :
  continuous (restrict_scalars ğ•œ' : continuous_multilinear_map ğ•œ E G â†’
    continuous_multilinear_map ğ•œ' E G) :=
(restrict_scalars_linear ğ•œ').continuous
end restrict_scalars
lemma norm_image_sub_le' (mâ‚ mâ‚‚ : Î i, E i) :
  âˆ¥f mâ‚ - f mâ‚‚âˆ¥ â‰¤
  âˆ¥fâˆ¥ * âˆ‘ i, âˆ j, if j = i then âˆ¥mâ‚ i - mâ‚‚ iâˆ¥ else max âˆ¥mâ‚ jâˆ¥ âˆ¥mâ‚‚ jâˆ¥ :=
f.to_multilinear_map.norm_image_sub_le_of_bound' (norm_nonneg _) f.le_op_norm _ _
lemma norm_image_sub_le (mâ‚ mâ‚‚ : Î i, E i) :
  âˆ¥f mâ‚ - f mâ‚‚âˆ¥ â‰¤ âˆ¥fâˆ¥ * (fintype.card Î¹) * (max âˆ¥mâ‚âˆ¥ âˆ¥mâ‚‚âˆ¥) ^ (fintype.card Î¹ - 1) * âˆ¥mâ‚ - mâ‚‚âˆ¥ :=
f.to_multilinear_map.norm_image_sub_le_of_bound (norm_nonneg _) f.le_op_norm _ _
lemma continuous_eval :
  continuous (Î» p : continuous_multilinear_map ğ•œ E G Ã— Î  i, E i, p.1 p.2) :=
begin
  apply continuous_iff_continuous_at.2 (Î»p, _),
  apply continuous_at_of_locally_lipschitz zero_lt_one
    ((âˆ¥pâˆ¥ + 1) * (fintype.card Î¹) * (âˆ¥pâˆ¥ + 1) ^ (fintype.card Î¹ - 1) + âˆ i, âˆ¥p.2 iâˆ¥)
    (Î»q hq, _),
  have : 0 â‰¤ (max âˆ¥q.2âˆ¥ âˆ¥p.2âˆ¥), by simp,
  have : 0 â‰¤ âˆ¥pâˆ¥ + 1 := zero_le_one.trans ((le_add_iff_nonneg_left 1).2 $ norm_nonneg p),
  have A : âˆ¥qâˆ¥ â‰¤ âˆ¥pâˆ¥ + 1 := norm_le_of_mem_closed_ball hq.le,
  have : (max âˆ¥q.2âˆ¥ âˆ¥p.2âˆ¥) â‰¤ âˆ¥pâˆ¥ + 1 :=
    (max_le_max (norm_snd_le q) (norm_snd_le p)).trans (by simp [A, -add_comm, zero_le_one]),
  have : âˆ€ (i : Î¹), i âˆˆ univ â†’ 0 â‰¤ âˆ¥p.2 iâˆ¥ := Î» i hi, norm_nonneg _,
  calc dist (q.1 q.2) (p.1 p.2)
    â‰¤ dist (q.1 q.2) (q.1 p.2) + dist (q.1 p.2) (p.1 p.2) : dist_triangle _ _ _
    ... = âˆ¥q.1 q.2 - q.1 p.2âˆ¥ + âˆ¥q.1 p.2 - p.1 p.2âˆ¥ : by rw [dist_eq_norm, dist_eq_norm]
    ... â‰¤ âˆ¥q.1âˆ¥ * (fintype.card Î¹) * (max âˆ¥q.2âˆ¥ âˆ¥p.2âˆ¥) ^ (fintype.card Î¹ - 1) * âˆ¥q.2 - p.2âˆ¥
          + âˆ¥q.1 - p.1âˆ¥ * âˆ i, âˆ¥p.2 iâˆ¥ :
      add_le_add (norm_image_sub_le _ _ _) ((q.1 - p.1).le_op_norm p.2)
    ... â‰¤ (âˆ¥pâˆ¥ + 1) * (fintype.card Î¹) * (âˆ¥pâˆ¥ + 1) ^ (fintype.card Î¹ - 1) * âˆ¥q - pâˆ¥
          + âˆ¥q - pâˆ¥ * âˆ i, âˆ¥p.2 iâˆ¥ :
      by apply_rules [add_le_add, mul_le_mul, le_refl, le_trans (norm_fst_le q) A, nat.cast_nonneg,
        mul_nonneg, pow_le_pow_of_le_left, pow_nonneg, norm_snd_le (q - p), norm_nonneg,
        norm_fst_le (q - p), prod_nonneg]
    ... = ((âˆ¥pâˆ¥ + 1) * (fintype.card Î¹) * (âˆ¥pâˆ¥ + 1) ^ (fintype.card Î¹ - 1)
              + (âˆ i, âˆ¥p.2 iâˆ¥)) * dist q p : by { rw dist_eq_norm, ring }
end
lemma continuous_eval_left (m : Î  i, E i) :
  continuous (Î» p : continuous_multilinear_map ğ•œ E G, p m) :=
continuous_eval.comp (continuous_id.prod_mk continuous_const)
lemma has_sum_eval
  {Î± : Type*} {p : Î± â†’ continuous_multilinear_map ğ•œ E G} {q : continuous_multilinear_map ğ•œ E G}
  (h : has_sum p q) (m : Î  i, E i) : has_sum (Î» a, p a m) (q m) :=
begin
  dsimp [has_sum] at h âŠ¢,
  convert ((continuous_eval_left m).tendsto _).comp h,
  ext s,
  simp
end
lemma tsum_eval {Î± : Type*} {p : Î± â†’ continuous_multilinear_map ğ•œ E G} (hp : summable p)
  (m : Î  i, E i) : (âˆ‘' a, p a) m = âˆ‘' a, p a m :=
(has_sum_eval hp.has_sum m).tsum_eq.symm
open_locale topological_space
open filter
instance [complete_space G] : complete_space (continuous_multilinear_map ğ•œ E G) :=
begin
  have nonneg : âˆ€ (v : Î  i, E i), 0 â‰¤ âˆ i, âˆ¥v iâˆ¥ :=
    Î» v, finset.prod_nonneg (Î» i hi, norm_nonneg _),
lemma multilinear_map.mk_continuous_norm_le (f : multilinear_map ğ•œ E G) {C : â„} (hC : 0 â‰¤ C)
  (H : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) : âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ C :=
continuous_multilinear_map.op_norm_le_bound _ hC (Î»m, H m)
lemma multilinear_map.mk_continuous_norm_le' (f : multilinear_map ğ•œ E G) {C : â„}
  (H : âˆ€ m, âˆ¥f mâˆ¥ â‰¤ C * âˆ i, âˆ¥m iâˆ¥) : âˆ¥f.mk_continuous C Hâˆ¥ â‰¤ max C 0 :=
continuous_multilinear_map.op_norm_le_bound _ (le_max_right _ _) $
  Î» m, (H m).trans $ mul_le_mul_of_nonneg_right (le_max_left _ _)
    (prod_nonneg $ Î» _ _, norm_nonneg _)
namespace continuous_multilinear_map
def restr {k n : â„•} (f : (G [Ã—n]â†’L[ğ•œ] G' : _)) (s : finset (fin n)) (hk : s.card = k) (z : G) :
  G [Ã—k]â†’L[ğ•œ] G' :=
(f.to_multilinear_map.restr s hk z).mk_continuous
(âˆ¥fâˆ¥ * âˆ¥zâˆ¥^(n-k)) $ Î» v, multilinear_map.restr_norm_le _ _ _ _ f.le_op_norm _
lemma norm_restr {k n : â„•} (f : G [Ã—n]â†’L[ğ•œ] G') (s : finset (fin n)) (hk : s.card = k) (z : G) :
  âˆ¥f.restr s hk zâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥zâˆ¥ ^ (n - k) :=
begin
  apply multilinear_map.mk_continuous_norm_le,
  exact mul_nonneg (norm_nonneg _) (pow_nonneg (norm_nonneg _) _)
end
section
variables {ğ•œ Î¹} {A : Type*} [normed_comm_ring A] [normed_algebra ğ•œ A]
@[simp]
lemma norm_mk_pi_algebra_le [nonempty Î¹] :
  âˆ¥continuous_multilinear_map.mk_pi_algebra ğ•œ Î¹ Aâˆ¥ â‰¤ 1 :=
begin
  have := Î» f, @op_norm_le_bound ğ•œ Î¹ (Î» i, A) A _ _ _ _ _ _ _ f _ zero_le_one,
  refine this _ _,
  intros m,
  simp only [continuous_multilinear_map.mk_pi_algebra_apply, one_mul],
  exact norm_prod_le' _ univ_nonempty _,
end
lemma norm_mk_pi_algebra_of_empty [is_empty Î¹] :
  âˆ¥continuous_multilinear_map.mk_pi_algebra ğ•œ Î¹ Aâˆ¥ = âˆ¥(1 : A)âˆ¥ :=
begin
  apply le_antisymm,
  { have := Î» f, @op_norm_le_bound ğ•œ Î¹ (Î» i, A) A _ _ _ _ _ _ _ f _ (norm_nonneg (1 : A)),
    refine this _ _,
    simp, },
  { convert ratio_le_op_norm _ (Î» _, (1 : A)),
    simp [eq_empty_of_is_empty (univ : finset Î¹)], },
end
@[simp] lemma norm_mk_pi_algebra [norm_one_class A] :
  âˆ¥continuous_multilinear_map.mk_pi_algebra ğ•œ Î¹ Aâˆ¥ = 1 :=
begin
  casesI is_empty_or_nonempty Î¹,
  { simp [norm_mk_pi_algebra_of_empty] },
  { refine le_antisymm norm_mk_pi_algebra_le _,
    convert ratio_le_op_norm _ (Î» _, 1); [skip, apply_instance],
    simp },
end
end
section
variables {ğ•œ n} {A : Type*} [normed_ring A] [normed_algebra ğ•œ A]
lemma norm_mk_pi_algebra_fin_succ_le :
  âˆ¥continuous_multilinear_map.mk_pi_algebra_fin ğ•œ n.succ Aâˆ¥ â‰¤ 1 :=
begin
  have := Î» f, @op_norm_le_bound ğ•œ (fin n.succ) (Î» i, A) A _ _ _ _ _ _ _ f _ zero_le_one,
  refine this _ _,
  intros m,
  simp only [continuous_multilinear_map.mk_pi_algebra_fin_apply, one_mul, list.of_fn_eq_map,
    fin.univ_def, finset.fin_range, finset.prod, multiset.coe_map, multiset.coe_prod],
  refine (list.norm_prod_le' _).trans_eq _,
  { rw [ne.def, list.map_eq_nil, list.fin_range_eq_nil],
    exact nat.succ_ne_zero _, },
  rw list.map_map,
end
lemma norm_mk_pi_algebra_fin_le_of_pos (hn : 0 < n) :
  âˆ¥continuous_multilinear_map.mk_pi_algebra_fin ğ•œ n Aâˆ¥ â‰¤ 1 :=
begin
  obtain âŸ¨n, rflâŸ© := nat.exists_eq_succ_of_ne_zero hn.ne',
  exact norm_mk_pi_algebra_fin_succ_le
end
lemma norm_mk_pi_algebra_fin_zero :
  âˆ¥continuous_multilinear_map.mk_pi_algebra_fin ğ•œ 0 Aâˆ¥ = âˆ¥(1 : A)âˆ¥ :=
begin
  refine le_antisymm _ _,
  { have := Î» f, @op_norm_le_bound ğ•œ (fin 0) (Î» i, A) A _ _ _ _ _ _ _ f _ (norm_nonneg (1 : A)),
    refine this _ _,
    simp, },
  { convert ratio_le_op_norm _ (Î» _, (1 : A)),
    simp }
end
@[simp] lemma norm_mk_pi_algebra_fin [norm_one_class A] :
  âˆ¥continuous_multilinear_map.mk_pi_algebra_fin ğ•œ n Aâˆ¥ = 1 :=
begin
  cases n,
  { simp [norm_mk_pi_algebra_fin_zero] },
  { refine le_antisymm norm_mk_pi_algebra_fin_succ_le _,
    convert ratio_le_op_norm _ (Î» _, 1); [skip, apply_instance],
    simp }
end
end
variables (ğ•œ Î¹)
protected def mk_pi_field (z : G) : continuous_multilinear_map ğ•œ (Î»(i : Î¹), ğ•œ) G :=
multilinear_map.mk_continuous
  (multilinear_map.mk_pi_ring ğ•œ Î¹ z) (âˆ¥zâˆ¥)
  (Î» m, by simp only [multilinear_map.mk_pi_ring_apply, norm_smul, norm_prod,
    mul_comm])
variables {ğ•œ Î¹}
@[simp] lemma mk_pi_field_apply (z : G) (m : Î¹ â†’ ğ•œ) :
  (continuous_multilinear_map.mk_pi_field ğ•œ Î¹ z : (Î¹ â†’ ğ•œ) â†’ G) m = (âˆ i, m i) â€¢ z := rfl
lemma mk_pi_field_apply_one_eq_self (f : continuous_multilinear_map ğ•œ (Î»(i : Î¹), ğ•œ) G) :
  continuous_multilinear_map.mk_pi_field ğ•œ Î¹ (f (Î»i, 1)) = f :=
to_multilinear_map_inj f.to_multilinear_map.mk_pi_ring_apply_one_eq_self
@[simp] lemma norm_mk_pi_field (z : G) : âˆ¥continuous_multilinear_map.mk_pi_field ğ•œ Î¹ zâˆ¥ = âˆ¥zâˆ¥ :=
(multilinear_map.mk_continuous_norm_le _ (norm_nonneg z) _).antisymm $
  by simpa using (continuous_multilinear_map.mk_pi_field ğ•œ Î¹ z).le_op_norm (Î» _, 1)
variables (ğ•œ Î¹ G)
protected def pi_field_equiv : G â‰ƒâ‚—áµ¢[ğ•œ] (continuous_multilinear_map ğ•œ (Î»(i : Î¹), ğ•œ) G) :=
{ to_fun    := Î» z, continuous_multilinear_map.mk_pi_field ğ•œ Î¹ z,
  inv_fun   := Î» f, f (Î»i, 1),
  map_add'  := Î» z z', by { ext m, simp [smul_add] },
  map_smul' := Î» c z, by { ext m, simp [smul_smul, mul_comm] },
  left_inv  := Î» z, by simp,
  right_inv := Î» f, f.mk_pi_field_apply_one_eq_self,
  norm_map' := norm_mk_pi_field }
end continuous_multilinear_map
namespace continuous_linear_map
lemma norm_comp_continuous_multilinear_map_le (g : G â†’L[ğ•œ] G')
  (f : continuous_multilinear_map ğ•œ E G) :
  âˆ¥g.comp_continuous_multilinear_map fâˆ¥ â‰¤ âˆ¥gâˆ¥ * âˆ¥fâˆ¥ :=
continuous_multilinear_map.op_norm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) $ Î» m,
calc âˆ¥g (f m)âˆ¥ â‰¤ âˆ¥gâˆ¥ * (âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥) : g.le_op_norm_of_le $ f.le_op_norm _
           ... = _                        : (mul_assoc _ _ _).symm
variables (ğ•œ E G G')
def comp_continuous_multilinear_mapL :
  (G â†’L[ğ•œ] G') â†’L[ğ•œ] continuous_multilinear_map ğ•œ E G â†’L[ğ•œ] continuous_multilinear_map ğ•œ E G' :=
linear_map.mk_continuousâ‚‚
  (linear_map.mkâ‚‚ ğ•œ comp_continuous_multilinear_map (Î» fâ‚ fâ‚‚ g, rfl) (Î» c f g, rfl)
    (Î» f gâ‚ gâ‚‚, by { ext1, apply f.map_add }) (Î» c f g, by { ext1, simp }))
  1 $ Î» f g, by { rw one_mul, exact f.norm_comp_continuous_multilinear_map_le g }
variables {ğ•œ E G G'}
def flip_multilinear (f : G â†’L[ğ•œ] continuous_multilinear_map ğ•œ E G') :
  continuous_multilinear_map ğ•œ E (G â†’L[ğ•œ] G') :=
multilinear_map.mk_continuous
  { to_fun := Î» m, linear_map.mk_continuous
      { to_fun := Î» x, f x m,
        map_add' := Î» x y, by simp only [map_add, continuous_multilinear_map.add_apply],
        map_smul' := Î» c x, by simp only [continuous_multilinear_map.smul_apply, map_smul,
                                          ring_hom.id_apply] }
      (âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥) $ Î» x,
      by { rw mul_right_comm, exact (f x).le_of_op_norm_le _ (f.le_op_norm x) },
    map_add' := Î» m i x y,
      by { ext1, simp only [add_apply, continuous_multilinear_map.map_add, linear_map.coe_mk,
                            linear_map.mk_continuous_apply]},
    map_smul' := Î» m i c x,
      by { ext1, simp only [coe_smul', continuous_multilinear_map.map_smul, linear_map.coe_mk,
                            linear_map.mk_continuous_apply, pi.smul_apply]} }
  âˆ¥fâˆ¥ $ Î» m,
  linear_map.mk_continuous_norm_le _
    (mul_nonneg (norm_nonneg f) (prod_nonneg $ Î» i hi, norm_nonneg (m i))) _
end continuous_linear_map
open continuous_multilinear_map
namespace multilinear_map
def mk_continuous_linear (f : G â†’â‚—[ğ•œ] multilinear_map ğ•œ E G') (C : â„)
  (H : âˆ€ x m, âˆ¥f x mâˆ¥ â‰¤ C * âˆ¥xâˆ¥ * âˆ i, âˆ¥m iâˆ¥) :
  G â†’L[ğ•œ] continuous_multilinear_map ğ•œ E G' :=
linear_map.mk_continuous
  { to_fun := Î» x, (f x).mk_continuous (C * âˆ¥xâˆ¥) $ H x,
    map_add' := Î» x y, by { ext1, simp },
    map_smul' := Î» c x, by { ext1, simp } }
  (max C 0) $ Î» x, ((f x).mk_continuous_norm_le' _).trans_eq $
    by rw [max_mul_of_nonneg _ _ (norm_nonneg x), zero_mul]
lemma mk_continuous_linear_norm_le' (f : G â†’â‚—[ğ•œ] multilinear_map ğ•œ E G') (C : â„)
  (H : âˆ€ x m, âˆ¥f x mâˆ¥ â‰¤ C * âˆ¥xâˆ¥ * âˆ i, âˆ¥m iâˆ¥) :
  âˆ¥mk_continuous_linear f C Hâˆ¥ â‰¤ max C 0 :=
begin
  dunfold mk_continuous_linear,
  exact linear_map.mk_continuous_norm_le _ (le_max_right _ _) _
end
lemma mk_continuous_linear_norm_le (f : G â†’â‚—[ğ•œ] multilinear_map ğ•œ E G') {C : â„} (hC : 0 â‰¤ C)
  (H : âˆ€ x m, âˆ¥f x mâˆ¥ â‰¤ C * âˆ¥xâˆ¥ * âˆ i, âˆ¥m iâˆ¥) :
  âˆ¥mk_continuous_linear f C Hâˆ¥ â‰¤ C :=
(mk_continuous_linear_norm_le' f C H).trans_eq (max_eq_left hC)
def mk_continuous_multilinear (f : multilinear_map ğ•œ E (multilinear_map ğ•œ E' G)) (C : â„)
  (H : âˆ€ mâ‚ mâ‚‚, âˆ¥f mâ‚ mâ‚‚âˆ¥ â‰¤ C * (âˆ i, âˆ¥mâ‚ iâˆ¥) * âˆ i, âˆ¥mâ‚‚ iâˆ¥) :
  continuous_multilinear_map ğ•œ E (continuous_multilinear_map ğ•œ E' G) :=
mk_continuous
  { to_fun := Î» m, mk_continuous (f m) (C * âˆ i, âˆ¥m iâˆ¥) $ H m,
    map_add' := Î» m i x y, by { ext1, simp },
    map_smul' := Î» m i c x, by { ext1, simp } }
  (max C 0) $ Î» m, ((f m).mk_continuous_norm_le' _).trans_eq $
    by { rw [max_mul_of_nonneg, zero_mul], exact prod_nonneg (Î» _ _, norm_nonneg _) }
@[simp] lemma mk_continuous_multilinear_apply (f : multilinear_map ğ•œ E (multilinear_map ğ•œ E' G))
  {C : â„} (H : âˆ€ mâ‚ mâ‚‚, âˆ¥f mâ‚ mâ‚‚âˆ¥ â‰¤ C * (âˆ i, âˆ¥mâ‚ iâˆ¥) * âˆ i, âˆ¥mâ‚‚ iâˆ¥) (m : Î  i, E i) :
  â‡‘(mk_continuous_multilinear f C H m) = f m :=
rfl
lemma mk_continuous_multilinear_norm_le' (f : multilinear_map ğ•œ E (multilinear_map ğ•œ E' G)) (C : â„)
  (H : âˆ€ mâ‚ mâ‚‚, âˆ¥f mâ‚ mâ‚‚âˆ¥ â‰¤ C * (âˆ i, âˆ¥mâ‚ iâˆ¥) * âˆ i, âˆ¥mâ‚‚ iâˆ¥) :
  âˆ¥mk_continuous_multilinear f C Hâˆ¥ â‰¤ max C 0 :=
begin
  dunfold mk_continuous_multilinear,
  exact mk_continuous_norm_le _ (le_max_right _ _) _
end
lemma mk_continuous_multilinear_norm_le (f : multilinear_map ğ•œ E (multilinear_map ğ•œ E' G)) {C : â„}
  (hC : 0 â‰¤ C) (H : âˆ€ mâ‚ mâ‚‚, âˆ¥f mâ‚ mâ‚‚âˆ¥ â‰¤ C * (âˆ i, âˆ¥mâ‚ iâˆ¥) * âˆ i, âˆ¥mâ‚‚ iâˆ¥) :
  âˆ¥mk_continuous_multilinear f C Hâˆ¥ â‰¤ C :=
(mk_continuous_multilinear_norm_le' f C H).trans_eq (max_eq_left hC)
end multilinear_map
namespace continuous_multilinear_map
lemma norm_comp_continuous_linear_le (g : continuous_multilinear_map ğ•œ Eâ‚ G)
  (f : Î  i, E i â†’L[ğ•œ] Eâ‚ i) :
  âˆ¥g.comp_continuous_linear_map fâˆ¥ â‰¤ âˆ¥gâˆ¥ * âˆ i, âˆ¥f iâˆ¥ :=
op_norm_le_bound _ (mul_nonneg (norm_nonneg _) $ prod_nonneg $ Î» i hi, norm_nonneg _) $ Î» m,
calc âˆ¥g (Î» i, f i (m i))âˆ¥ â‰¤ âˆ¥gâˆ¥ * âˆ i, âˆ¥f i (m i)âˆ¥ : g.le_op_norm _
... â‰¤ âˆ¥gâˆ¥ * âˆ i, (âˆ¥f iâˆ¥ * âˆ¥m iâˆ¥) :
  mul_le_mul_of_nonneg_left
    (prod_le_prod (Î» _ _, norm_nonneg _) (Î» i hi, (f i).le_op_norm (m i))) (norm_nonneg g)
... = (âˆ¥gâˆ¥ * âˆ i, âˆ¥f iâˆ¥) * âˆ i, âˆ¥m iâˆ¥ : by rw [prod_mul_distrib, mul_assoc]
def comp_continuous_linear_mapL (f : Î  i, E i â†’L[ğ•œ] Eâ‚ i) :
  continuous_multilinear_map ğ•œ Eâ‚ G â†’L[ğ•œ] continuous_multilinear_map ğ•œ E G :=
linear_map.mk_continuous
  { to_fun := Î» g, g.comp_continuous_linear_map f,
    map_add' := Î» gâ‚ gâ‚‚, rfl,
    map_smul' := Î» c g, rfl }
  (âˆ i, âˆ¥f iâˆ¥) $ Î» g, (norm_comp_continuous_linear_le _ _).trans_eq (mul_comm _ _)
@[simp] lemma comp_continuous_linear_mapL_apply (g : continuous_multilinear_map ğ•œ Eâ‚ G)
  (f : Î  i, E i â†’L[ğ•œ] Eâ‚ i) :
  comp_continuous_linear_mapL f g = g.comp_continuous_linear_map f :=
rfl
lemma norm_comp_continuous_linear_mapL_le (f : Î  i, E i â†’L[ğ•œ] Eâ‚ i) :
  âˆ¥@comp_continuous_linear_mapL ğ•œ Î¹ E Eâ‚ G _ _ _ _ _ _ _ _ _ fâˆ¥ â‰¤ (âˆ i, âˆ¥f iâˆ¥) :=
linear_map.mk_continuous_norm_le _ (prod_nonneg $ Î» i _, norm_nonneg _) _
end continuous_multilinear_map
section currying
open fin function
lemma continuous_linear_map.norm_map_tail_le
  (f : Ei 0 â†’L[ğ•œ] (continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.succ) G)) (m : Î i, Ei i) :
  âˆ¥f (m 0) (tail m)âˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥ :=
calc
  âˆ¥f (m 0) (tail m)âˆ¥ â‰¤ âˆ¥f (m 0)âˆ¥ * âˆ i, âˆ¥(tail m) iâˆ¥ : (f (m 0)).le_op_norm _
  ... â‰¤ (âˆ¥fâˆ¥ * âˆ¥m 0âˆ¥) * âˆ i, âˆ¥(tail m) iâˆ¥ :
    mul_le_mul_of_nonneg_right (f.le_op_norm _) (prod_nonneg (Î»i hi, norm_nonneg _))
  ... = âˆ¥fâˆ¥ * (âˆ¥m 0âˆ¥ * âˆ i, âˆ¥(tail m) iâˆ¥) : by ring
  ... = âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥ : by { rw prod_univ_succ, refl }
lemma continuous_multilinear_map.norm_map_init_le
  (f : continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.cast_succ) (Ei (last n) â†’L[ğ•œ] G))
  (m : Î i, Ei i) :
  âˆ¥f (init m) (m (last n))âˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥ :=
calc
  âˆ¥f (init m) (m (last n))âˆ¥ â‰¤ âˆ¥f (init m)âˆ¥ * âˆ¥m (last n)âˆ¥ : (f (init m)).le_op_norm _
  ... â‰¤ (âˆ¥fâˆ¥ * (âˆ i, âˆ¥(init m) iâˆ¥)) * âˆ¥m (last n)âˆ¥ :
    mul_le_mul_of_nonneg_right (f.le_op_norm _) (norm_nonneg _)
  ... = âˆ¥fâˆ¥ * ((âˆ i, âˆ¥(init m) iâˆ¥) * âˆ¥m (last n)âˆ¥) : mul_assoc _ _ _
  ... = âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥ : by { rw prod_univ_cast_succ, refl }
lemma continuous_multilinear_map.norm_map_cons_le
  (f : continuous_multilinear_map ğ•œ Ei G) (x : Ei 0) (m : Î (i : fin n), Ei i.succ) :
  âˆ¥f (cons x m)âˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥ * âˆ i, âˆ¥m iâˆ¥ :=
calc
  âˆ¥f (cons x m)âˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ i, âˆ¥cons x m iâˆ¥ : f.le_op_norm _
  ... = (âˆ¥fâˆ¥ * âˆ¥xâˆ¥) * âˆ i, âˆ¥m iâˆ¥ : by { rw prod_univ_succ, simp [mul_assoc] }
lemma continuous_multilinear_map.norm_map_snoc_le
  (f : continuous_multilinear_map ğ•œ Ei G) (m : Î (i : fin n), Ei i.cast_succ) (x : Ei (last n)) :
  âˆ¥f (snoc m x)âˆ¥ â‰¤ âˆ¥fâˆ¥ * (âˆ i, âˆ¥m iâˆ¥) * âˆ¥xâˆ¥ :=
calc
  âˆ¥f (snoc m x)âˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ i, âˆ¥snoc m x iâˆ¥ : f.le_op_norm _
  ... = âˆ¥fâˆ¥ * (âˆ i, âˆ¥m iâˆ¥) * âˆ¥xâˆ¥ : by { rw prod_univ_cast_succ, simp [mul_assoc] }
def continuous_linear_map.uncurry_left
  (f : Ei 0 â†’L[ğ•œ] (continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.succ) G)) :
  continuous_multilinear_map ğ•œ Ei G :=
(@linear_map.uncurry_left ğ•œ n Ei G _ _ _ _ _
  (continuous_multilinear_map.to_multilinear_map_linear.comp f.to_linear_map)).mk_continuous
    (âˆ¥fâˆ¥) (Î»m, continuous_linear_map.norm_map_tail_le f m)
@[simp] lemma continuous_linear_map.uncurry_left_apply
  (f : Ei 0 â†’L[ğ•œ] (continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.succ) G)) (m : Î i, Ei i) :
  f.uncurry_left m = f (m 0) (tail m) := rfl
def continuous_multilinear_map.curry_left
  (f : continuous_multilinear_map ğ•œ Ei G) :
  Ei 0 â†’L[ğ•œ] (continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.succ) G) :=
linear_map.mk_continuous
def continuous_multilinear_curry_left_equiv :
  (Ei 0 â†’L[ğ•œ] (continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.succ) G)) â‰ƒâ‚—áµ¢[ğ•œ]
  (continuous_multilinear_map ğ•œ Ei G) :=
linear_isometry_equiv.of_bounds
  { to_fun    := continuous_linear_map.uncurry_left,
    map_add'  := Î»fâ‚ fâ‚‚, by { ext m, refl },
    map_smul' := Î»c f, by { ext m, refl },
    inv_fun   := continuous_multilinear_map.curry_left,
    left_inv  := continuous_linear_map.curry_uncurry_left,
    right_inv := continuous_multilinear_map.uncurry_curry_left }
  (Î» f, multilinear_map.mk_continuous_norm_le _ (norm_nonneg f) _)
  (Î» f, linear_map.mk_continuous_norm_le _ (norm_nonneg f) _)
variables {ğ•œ Ei G}
@[simp] lemma continuous_multilinear_curry_left_equiv_apply
  (f : Ei 0 â†’L[ğ•œ] (continuous_multilinear_map ğ•œ (Î» i : fin n, Ei i.succ) G)) (v : Î  i, Ei i) :
  continuous_multilinear_curry_left_equiv ğ•œ Ei G f v = f (v 0) (tail v) := rfl
@[simp] lemma continuous_multilinear_curry_left_equiv_symm_apply
  (f : continuous_multilinear_map ğ•œ Ei G) (x : Ei 0) (v : Î  i : fin n, Ei i.succ) :
  (continuous_multilinear_curry_left_equiv ğ•œ Ei G).symm f x v = f (cons x v) := rfl
@[simp] lemma continuous_multilinear_map.curry_left_norm
  (f : continuous_multilinear_map ğ•œ Ei G) : âˆ¥f.curry_leftâˆ¥ = âˆ¥fâˆ¥ :=
(continuous_multilinear_curry_left_equiv ğ•œ Ei G).symm.norm_map f
@[simp] lemma continuous_linear_map.uncurry_left_norm
  (f : Ei 0 â†’L[ğ•œ] (continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.succ) G)) :
  âˆ¥f.uncurry_leftâˆ¥ = âˆ¥fâˆ¥ :=
(continuous_multilinear_curry_left_equiv ğ•œ Ei G).norm_map f
def continuous_multilinear_map.uncurry_right
  (f : continuous_multilinear_map ğ•œ (Î» i : fin n, Ei i.cast_succ) (Ei (last n) â†’L[ğ•œ] G)) :
  continuous_multilinear_map ğ•œ Ei G :=
let f' : multilinear_map ğ•œ (Î»(i : fin n), Ei i.cast_succ) (Ei (last n) â†’â‚—[ğ•œ] G) :=
{ to_fun    := Î» m, (f m).to_linear_map,
  map_add'  := Î» m i x y, by simp,
  map_smul' := Î» m i c x, by simp } in
(@multilinear_map.uncurry_right ğ•œ n Ei G _ _ _ _ _ f').mk_continuous
  (âˆ¥fâˆ¥) (Î»m, f.norm_map_init_le m)
@[simp] lemma continuous_multilinear_map.uncurry_right_apply
  (f : continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.cast_succ) (Ei (last n) â†’L[ğ•œ] G))
  (m : Î i, Ei i) :
  f.uncurry_right m = f (init m) (m (last n)) := rfl
def continuous_multilinear_map.curry_right
  (f : continuous_multilinear_map ğ•œ Ei G) :
  continuous_multilinear_map ğ•œ (Î» i : fin n, Ei i.cast_succ) (Ei (last n) â†’L[ğ•œ] G) :=
let f' : multilinear_map ğ•œ (Î»(i : fin n), Ei i.cast_succ) (Ei (last n) â†’L[ğ•œ] G) :=
{ to_fun    := Î»m, (f.to_multilinear_map.curry_right m).mk_continuous
    (âˆ¥fâˆ¥ * âˆ i, âˆ¥m iâˆ¥) $ Î»x, f.norm_map_snoc_le m x,
  map_add'  := Î» m i x y, by { simp, refl },
  map_smul' := Î» m i c x, by { simp, refl } } in
f'.mk_continuous (âˆ¥fâˆ¥) (Î»m, linear_map.mk_continuous_norm_le _
  (mul_nonneg (norm_nonneg _) (prod_nonneg (Î»j hj, norm_nonneg _))) _)
@[simp] lemma continuous_multilinear_map.curry_right_apply
  (f : continuous_multilinear_map ğ•œ Ei G) (m : Î  i : fin n, Ei i.cast_succ) (x : Ei (last n)) :
  f.curry_right m x = f (snoc m x) := rfl
@[simp] lemma continuous_multilinear_map.curry_uncurry_right
  (f : continuous_multilinear_map ğ•œ (Î» i : fin n, Ei i.cast_succ) (Ei (last n) â†’L[ğ•œ] G)) :
  f.uncurry_right.curry_right = f :=
begin
  ext m x,
  simp only [snoc_last, continuous_multilinear_map.curry_right_apply,
             continuous_multilinear_map.uncurry_right_apply],
  rw init_snoc
end
@[simp] lemma continuous_multilinear_map.uncurry_curry_right
  (f : continuous_multilinear_map ğ•œ Ei G) : f.curry_right.uncurry_right = f :=
by { ext m, simp }
variables (ğ•œ Ei G)
def continuous_multilinear_curry_right_equiv :
  (continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.cast_succ) (Ei (last n) â†’L[ğ•œ] G)) â‰ƒâ‚—áµ¢[ğ•œ]
  (continuous_multilinear_map ğ•œ Ei G) :=
linear_isometry_equiv.of_bounds
  { to_fun    := continuous_multilinear_map.uncurry_right,
    map_add'  := Î»fâ‚ fâ‚‚, by { ext m, refl },
    map_smul' := Î»c f, by { ext m, refl },
    inv_fun   := continuous_multilinear_map.curry_right,
    left_inv  := continuous_multilinear_map.curry_uncurry_right,
    right_inv := continuous_multilinear_map.uncurry_curry_right }
  (Î» f, multilinear_map.mk_continuous_norm_le _ (norm_nonneg f) _)
  (Î» f, multilinear_map.mk_continuous_norm_le _ (norm_nonneg f) _)
variables (n G')
def continuous_multilinear_curry_right_equiv' :
  (G [Ã—n]â†’L[ğ•œ] (G â†’L[ğ•œ] G')) â‰ƒâ‚—áµ¢[ğ•œ] (G [Ã—n.succ]â†’L[ğ•œ] G') :=
continuous_multilinear_curry_right_equiv ğ•œ (Î» (i : fin n.succ), G) G'
variables {n ğ•œ G Ei G'}
@[simp] lemma continuous_multilinear_curry_right_equiv_apply
  (f : (continuous_multilinear_map ğ•œ (Î»(i : fin n), Ei i.cast_succ) (Ei (last n) â†’L[ğ•œ] G)))
  (v : Î  i, Ei i) :
  (continuous_multilinear_curry_right_equiv ğ•œ Ei G) f v = f (init v) (v (last n)) := rfl
@[simp] lemma continuous_multilinear_curry_right_equiv_symm_apply
  (f : continuous_multilinear_map ğ•œ Ei G)
  (v : Î  (i : fin n), Ei i.cast_succ) (x : Ei (last n)) :
  (continuous_multilinear_curry_right_equiv ğ•œ Ei G).symm f v x = f (snoc v x) := rfl
@[simp] lemma continuous_multilinear_curry_right_equiv_apply'
  (f : G [Ã—n]â†’L[ğ•œ] (G â†’L[ğ•œ] G')) (v : fin (n + 1) â†’ G) :
  continuous_multilinear_curry_right_equiv' ğ•œ n G G' f v = f (init v) (v (last n)) := rfl
@[simp] lemma continuous_multilinear_curry_right_equiv_symm_apply'
  (f : G [Ã—n.succ]â†’L[ğ•œ] G') (v : fin n â†’ G) (x : G) :
  (continuous_multilinear_curry_right_equiv' ğ•œ n G G').symm f v x = f (snoc v x) := rfl
@[simp] lemma continuous_multilinear_map.curry_right_norm
  (f : continuous_multilinear_map ğ•œ Ei G) : âˆ¥f.curry_rightâˆ¥ = âˆ¥fâˆ¥ :=
(continuous_multilinear_curry_right_equiv ğ•œ Ei G).symm.norm_map f
@[simp] lemma continuous_multilinear_map.uncurry_right_norm
  (f : continuous_multilinear_map ğ•œ (Î» i : fin n, Ei i.cast_succ) (Ei (last n) â†’L[ğ•œ] G)) :
  âˆ¥f.uncurry_rightâˆ¥ = âˆ¥fâˆ¥ :=
(continuous_multilinear_curry_right_equiv ğ•œ Ei G).norm_map f
section
local attribute [instance] unique.subsingleton
variables {ğ•œ G G'}
def continuous_multilinear_map.uncurry0
  (f : continuous_multilinear_map ğ•œ (Î» (i : fin 0), G) G') : G' := f 0
variables (ğ•œ G)
def continuous_multilinear_map.curry0 (x : G') : G [Ã—0]â†’L[ğ•œ] G' :=
{ to_fun    := Î»m, x,
  map_add'  := Î» m i, fin.elim0 i,
  map_smul' := Î» m i, fin.elim0 i,
  cont      := continuous_const }
variable {G}
@[simp] lemma continuous_multilinear_map.curry0_apply (x : G') (m : (fin 0) â†’ G) :
  continuous_multilinear_map.curry0 ğ•œ G x m = x := rfl
variable {ğ•œ}
@[simp] lemma continuous_multilinear_map.uncurry0_apply (f : G [Ã—0]â†’L[ğ•œ] G') :
  f.uncurry0 = f 0 := rfl
@[simp] lemma continuous_multilinear_map.apply_zero_curry0 (f : G [Ã—0]â†’L[ğ•œ] G') {x : fin 0 â†’ G} :
  continuous_multilinear_map.curry0 ğ•œ G (f x) = f :=
by { ext m, simp [(subsingleton.elim _ _ : x = m)] }
lemma continuous_multilinear_map.uncurry0_curry0 (f : G [Ã—0]â†’L[ğ•œ] G') :
  continuous_multilinear_map.curry0 ğ•œ G (f.uncurry0) = f :=
by simp
variables (ğ•œ G)
@[simp] lemma continuous_multilinear_map.curry0_uncurry0 (x : G') :
  (continuous_multilinear_map.curry0 ğ•œ G x).uncurry0 = x := rfl
@[simp] lemma continuous_multilinear_map.curry0_norm (x : G')  :
  âˆ¥continuous_multilinear_map.curry0 ğ•œ G xâˆ¥ = âˆ¥xâˆ¥ :=
begin
  apply le_antisymm,
  { exact continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (Î»m, by simp) },
  { simpa using (continuous_multilinear_map.curry0 ğ•œ G x).le_op_norm 0 }
end
variables {ğ•œ G}
@[simp] lemma continuous_multilinear_map.fin0_apply_norm (f : G [Ã—0]â†’L[ğ•œ] G') {x : fin 0 â†’ G} :
  âˆ¥f xâˆ¥ = âˆ¥fâˆ¥ :=
begin
  obtain rfl : x = 0 := subsingleton.elim _ _,
  refine le_antisymm (by simpa using f.le_op_norm 0) _,
  have : âˆ¥continuous_multilinear_map.curry0 ğ•œ G (f.uncurry0)âˆ¥ â‰¤ âˆ¥f.uncurry0âˆ¥ :=
    continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (Î»m,
      by simp [-continuous_multilinear_map.apply_zero_curry0]),
  simpa
end
lemma continuous_multilinear_map.uncurry0_norm (f : G [Ã—0]â†’L[ğ•œ] G') : âˆ¥f.uncurry0âˆ¥ = âˆ¥fâˆ¥ :=
by simp
variables (ğ•œ G G')
def continuous_multilinear_curry_fin0 : (G [Ã—0]â†’L[ğ•œ] G') â‰ƒâ‚—áµ¢[ğ•œ] G' :=
{ to_fun    := Î»f, continuous_multilinear_map.uncurry0 f,
  inv_fun   := Î»f, continuous_multilinear_map.curry0 ğ•œ G f,
  map_add'  := Î»f g, rfl,
  map_smul' := Î»c f, rfl,
  left_inv  := continuous_multilinear_map.uncurry0_curry0,
  right_inv := continuous_multilinear_map.curry0_uncurry0 ğ•œ G,
  norm_map' := continuous_multilinear_map.uncurry0_norm }
variables {ğ•œ G G'}
@[simp] lemma continuous_multilinear_curry_fin0_apply (f : G [Ã—0]â†’L[ğ•œ] G') :
  continuous_multilinear_curry_fin0 ğ•œ G G' f = f 0 := rfl
@[simp] lemma continuous_multilinear_curry_fin0_symm_apply (x : G') (v : (fin 0) â†’ G) :
  (continuous_multilinear_curry_fin0 ğ•œ G G').symm x v = x := rfl
end
variables (ğ•œ G G')
def continuous_multilinear_curry_fin1 : (G [Ã—1]â†’L[ğ•œ] G') â‰ƒâ‚—áµ¢[ğ•œ] (G â†’L[ğ•œ] G') :=
(continuous_multilinear_curry_right_equiv ğ•œ (Î» (i : fin 1), G) G').symm.trans
(continuous_multilinear_curry_fin0 ğ•œ G (G â†’L[ğ•œ] G'))
variables {ğ•œ G G'}
@[simp] lemma continuous_multilinear_curry_fin1_apply (f : G [Ã—1]â†’L[ğ•œ] G') (x : G) :
  continuous_multilinear_curry_fin1 ğ•œ G G' f x = f (fin.snoc 0 x) := rfl
@[simp] lemma continuous_multilinear_curry_fin1_symm_apply
  (f : G â†’L[ğ•œ] G') (v : (fin 1) â†’ G) :
  (continuous_multilinear_curry_fin1 ğ•œ G G').symm f v = f (v 0) := rfl
namespace continuous_multilinear_map
variables (ğ•œ G G')
def dom_dom_congr (Ïƒ : Î¹ â‰ƒ Î¹') :
  continuous_multilinear_map ğ•œ (Î» _ : Î¹, G) G' â‰ƒâ‚—áµ¢[ğ•œ]
    continuous_multilinear_map ğ•œ (Î» _ : Î¹', G) G' :=
linear_isometry_equiv.of_bounds
  { to_fun := Î» f, (multilinear_map.dom_dom_congr Ïƒ f.to_multilinear_map).mk_continuous âˆ¥fâˆ¥ $
      Î» m, (f.le_op_norm (Î» i, m (Ïƒ i))).trans_eq $ by rw [â† Ïƒ.prod_comp],
    inv_fun := Î» f, (multilinear_map.dom_dom_congr Ïƒ.symm f.to_multilinear_map).mk_continuous âˆ¥fâˆ¥ $
      Î» m, (f.le_op_norm (Î» i, m (Ïƒ.symm i))).trans_eq $ by rw [â† Ïƒ.symm.prod_comp],
    left_inv := Î» f, ext $ Î» m, congr_arg f $ by simp only [Ïƒ.symm_apply_apply],
    right_inv := Î» f, ext $ Î» m, congr_arg f $ by simp only [Ïƒ.apply_symm_apply],
    map_add' := Î» f g, rfl,
    map_smul' := Î» c f, rfl }
  (Î» f, multilinear_map.mk_continuous_norm_le _ (norm_nonneg f) _)
  (Î» f, multilinear_map.mk_continuous_norm_le _ (norm_nonneg f) _)
variables {ğ•œ G G'}
section
variable [decidable_eq (Î¹ âŠ• Î¹')]
def curry_sum (f : continuous_multilinear_map ğ•œ (Î» x : Î¹ âŠ• Î¹', G) G') :
  continuous_multilinear_map ğ•œ (Î» x : Î¹, G) (continuous_multilinear_map ğ•œ (Î» x : Î¹', G) G') :=
multilinear_map.mk_continuous_multilinear (multilinear_map.curry_sum f.to_multilinear_map) (âˆ¥fâˆ¥) $
  Î» m m', by simpa [fintype.prod_sum_type, mul_assoc] using f.le_op_norm (sum.elim m m')
@[simp] lemma curry_sum_apply (f : continuous_multilinear_map ğ•œ (Î» x : Î¹ âŠ• Î¹', G) G')
  (m : Î¹ â†’ G) (m' : Î¹' â†’ G) :
  f.curry_sum m m' = f (sum.elim m m') :=
rfl
def uncurry_sum
  (f : continuous_multilinear_map ğ•œ (Î» x : Î¹, G) (continuous_multilinear_map ğ•œ (Î» x : Î¹', G) G')) :
  continuous_multilinear_map ğ•œ (Î» x : Î¹ âŠ• Î¹', G) G' :=
multilinear_map.mk_continuous
  (to_multilinear_map_linear.comp_multilinear_map f.to_multilinear_map).uncurry_sum (âˆ¥fâˆ¥) $ Î» m,
  by simpa [fintype.prod_sum_type, mul_assoc]
    using (f (m âˆ˜ sum.inl)).le_of_op_norm_le (m âˆ˜ sum.inr) (f.le_op_norm _)
@[simp] lemma uncurry_sum_apply
  (f : continuous_multilinear_map ğ•œ (Î» x : Î¹, G) (continuous_multilinear_map ğ•œ (Î» x : Î¹', G) G'))
  (m : Î¹ âŠ• Î¹' â†’ G) :
  f.uncurry_sum m = f (m âˆ˜ sum.inl) (m âˆ˜ sum.inr) :=
rfl
variables (ğ•œ Î¹ Î¹' G G')
def curry_sum_equiv : continuous_multilinear_map ğ•œ (Î» x : Î¹ âŠ• Î¹', G) G' â‰ƒâ‚—áµ¢[ğ•œ]
  continuous_multilinear_map ğ•œ (Î» x : Î¹, G) (continuous_multilinear_map ğ•œ (Î» x : Î¹', G) G') :=
linear_isometry_equiv.of_bounds
  { to_fun := curry_sum,
    inv_fun := uncurry_sum,
    map_add' := Î» f g, by { ext, refl },
    map_smul' := Î» c f, by { ext, refl },
    left_inv := Î» f, by { ext m, exact congr_arg f (sum.elim_comp_inl_inr m) },
    right_inv := Î» f, by { ext mâ‚ mâ‚‚, change f _ _ = f _ _,
      rw [sum.elim_comp_inl, sum.elim_comp_inr] } }
  (Î» f, multilinear_map.mk_continuous_multilinear_norm_le _ (norm_nonneg f) _)
  (Î» f, multilinear_map.mk_continuous_norm_le _ (norm_nonneg f) _)
end
section
variables (ğ•œ G G') {k l : â„•} {s : finset (fin n)}
def curry_fin_finset {k l n : â„•} {s : finset (fin n)}
  (hk : s.card = k) (hl : sá¶œ.card = l) :
  (G [Ã—n]â†’L[ğ•œ] G') â‰ƒâ‚—áµ¢[ğ•œ] (G [Ã—k]â†’L[ğ•œ] G [Ã—l]â†’L[ğ•œ] G') :=
(dom_dom_congr ğ•œ G G' (fin_sum_equiv_of_finset hk hl).symm).trans
  (curry_sum_equiv ğ•œ (fin k) (fin l) G G')
variables {ğ•œ G G'}
@[simp] lemma curry_fin_finset_apply (hk : s.card = k) (hl : sá¶œ.card = l)
  (f : G [Ã—n]â†’L[ğ•œ] G') (mk : fin k â†’ G) (ml : fin l â†’ G) :
  curry_fin_finset ğ•œ G G' hk hl f mk ml =
    f (Î» i, sum.elim mk ml ((fin_sum_equiv_of_finset hk hl).symm i)) :=
rfl
@[simp] lemma curry_fin_finset_symm_apply (hk : s.card = k) (hl : sá¶œ.card = l)
  (f : G [Ã—k]â†’L[ğ•œ] G [Ã—l]â†’L[ğ•œ] G') (m : fin n â†’ G) :
  (curry_fin_finset ğ•œ G G' hk hl).symm f m =
    f (Î» i, m $ fin_sum_equiv_of_finset hk hl (sum.inl i))
      (Î» i, m $ fin_sum_equiv_of_finset hk hl (sum.inr i)) :=
rfl
@[simp] lemma curry_fin_finset_symm_apply_piecewise_const (hk : s.card = k) (hl : sá¶œ.card = l)
  (f : G [Ã—k]â†’L[ğ•œ] G [Ã—l]â†’L[ğ•œ] G') (x y : G) :
  (curry_fin_finset ğ•œ G G' hk hl).symm f (s.piecewise (Î» _, x) (Î» _, y)) = f (Î» _, x) (Î» _, y) :=
multilinear_map.curry_fin_finset_symm_apply_piecewise_const hk hl _ x y
@[simp] lemma curry_fin_finset_symm_apply_const (hk : s.card = k) (hl : sá¶œ.card = l)
  (f : G [Ã—k]â†’L[ğ•œ] G [Ã—l]â†’L[ğ•œ] G') (x : G) :
  (curry_fin_finset ğ•œ G G' hk hl).symm f (Î» _, x) = f (Î» _, x) (Î» _, x) :=
rfl
@[simp] lemma curry_fin_finset_apply_const (hk : s.card = k) (hl : sá¶œ.card = l)
  (f : G [Ã—n]â†’L[ğ•œ] G') (x y : G) :
  curry_fin_finset ğ•œ G G' hk hl f (Î» _, x) (Î» _, y) = f (s.piecewise (Î» _, x) (Î» _, y)) :=
begin
