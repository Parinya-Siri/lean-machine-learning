import category_theory.functor
structure iso {C : Type u} [category.{v} C] (X Y : C) :=
(hom : X âŸ¶ Y)
(inv : Y âŸ¶ X)
(hom_inv_id' : hom â‰« inv = ğŸ™ X . obviously)
(inv_hom_id' : inv â‰« hom = ğŸ™ Y . obviously)
restate_axiom iso.hom_inv_id'
restate_axiom iso.inv_hom_id'
attribute [simp, reassoc] iso.hom_inv_id iso.inv_hom_id
@[symm] def symm (I : X â‰… Y) : Y â‰… X :=
{ hom := I.inv,
  inv := I.hom,
  hom_inv_id' := I.inv_hom_id',
  inv_hom_id' := I.hom_inv_id' }
@[simp] lemma symm_hom (Î± : X â‰… Y) : Î±.symm.hom = Î±.inv := rfl
@[simp] lemma symm_inv (Î± : X â‰… Y) : Î±.symm.inv = Î±.hom := rfl
@[simp] lemma symm_mk {X Y : C} (hom : X âŸ¶ Y) (inv : Y âŸ¶ X) (hom_inv_id) (inv_hom_id) :
  iso.symm {hom := hom, inv := inv, hom_inv_id' := hom_inv_id, inv_hom_id' := inv_hom_id} =
    {hom := inv, inv := hom, hom_inv_id' := inv_hom_id, inv_hom_id' := hom_inv_id} := rfl
@[simp] lemma symm_symm_eq {X Y : C} (Î± : X â‰… Y) : Î±.symm.symm = Î± :=
by cases Î±; refl
@[simp] lemma symm_eq_iff {X Y : C} {Î± Î² : X â‰… Y} : Î±.symm = Î².symm â†” Î± = Î² :=
âŸ¨Î» h, symm_symm_eq Î± â–¸ symm_symm_eq Î² â–¸ congr_arg symm h, congr_arg symmâŸ©
@[refl, simps] def refl (X : C) : X â‰… X :=
{ hom := ğŸ™ X,
  inv := ğŸ™ X }
instance : inhabited (X â‰… X) := âŸ¨iso.refl XâŸ©
@[simp] lemma refl_symm (X : C) : (iso.refl X).symm = iso.refl X := rfl
@[trans, simps] def trans (Î± : X â‰… Y) (Î² : Y â‰… Z) : X â‰… Z :=
{ hom := Î±.hom â‰« Î².hom,
  inv := Î².inv â‰« Î±.inv }
class is_iso (f : X âŸ¶ Y) : Prop :=
(out : âˆƒ inv : Y âŸ¶ X, f â‰« inv = ğŸ™ X âˆ§ inv â‰« f = ğŸ™ Y)
noncomputable def inv (f : X âŸ¶ Y) [I : is_iso f] := classical.some I.1
namespace is_iso
@[simp, reassoc] lemma hom_inv_id (f : X âŸ¶ Y) [I : is_iso f] : f â‰« inv f = ğŸ™ X :=
(classical.some_spec I.1).left
@[simp, reassoc] lemma inv_hom_id (f : X âŸ¶ Y) [I : is_iso f] : inv f â‰« f = ğŸ™ Y :=
(classical.some_spec I.1).right
end is_iso
open is_iso
noncomputable
def as_iso (f : X âŸ¶ Y) [h : is_iso f] : X â‰… Y := âŸ¨f, inv f, hom_inv_id f, inv_hom_id fâŸ©
@[simp] lemma as_iso_hom (f : X âŸ¶ Y) [is_iso f] : (as_iso f).hom = f := rfl
@[simp] lemma as_iso_inv (f : X âŸ¶ Y) [is_iso f] : (as_iso f).inv = inv f := rfl
namespace is_iso
@[priority 900]
instance comp_is_iso [is_iso f] [is_iso h] : is_iso (f â‰« h) :=
is_iso.of_iso $ (as_iso f) â‰ªâ‰« (as_iso h)
@[simp] lemma inv_id : inv (ğŸ™ X) = ğŸ™ X := by { ext, simp, }
@[simp] lemma inv_comp [is_iso f] [is_iso h] : inv (f â‰« h) = inv h â‰« inv f := by { ext, simp, }
@[simp] lemma inv_inv [is_iso f] : inv (inv f) = f := by { ext, simp, }
@[simp] lemma iso.inv_inv (f : X â‰… Y) : inv (f.inv) = f.hom := by { ext, simp, }
@[simp] lemma iso.inv_hom (f : X â‰… Y) : inv (f.hom) = f.inv := by { ext, simp, }
@[simp]
lemma inv_comp_eq (Î± : X âŸ¶ Y) [is_iso Î±] {f : X âŸ¶ Z} {g : Y âŸ¶ Z} : inv Î± â‰« f = g â†” f = Î± â‰« g :=
(as_iso Î±).inv_comp_eq
@[simp]
lemma eq_inv_comp (Î± : X âŸ¶ Y) [is_iso Î±] {f : X âŸ¶ Z} {g : Y âŸ¶ Z} : g = inv Î± â‰« f â†” Î± â‰« g = f :=
(as_iso Î±).eq_inv_comp
@[simp]
lemma comp_inv_eq (Î± : X âŸ¶ Y) [is_iso Î±] {f : Z âŸ¶ Y} {g : Z âŸ¶ X} : f â‰« inv Î± = g â†” f = g â‰« Î± :=
(as_iso Î±).comp_inv_eq
@[simp]
lemma eq_comp_inv (Î± : X âŸ¶ Y) [is_iso Î±] {f : Z âŸ¶ Y} {g : Z âŸ¶ X} : g = f â‰« inv Î± â†” g â‰« Î± = f :=
(as_iso Î±).eq_comp_inv
lemma of_is_iso_comp_left {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z)
  [is_iso f] [is_iso (f â‰« g)] : is_iso g :=
by { rw [â† id_comp g, â† inv_hom_id f, assoc], apply_instance, }
lemma of_is_iso_comp_right {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z)
  [is_iso g] [is_iso (f â‰« g)] : is_iso f :=
by { rw [â† comp_id f, â† hom_inv_id g, â† assoc], apply_instance, }
lemma of_is_iso_fac_left {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} {h : X âŸ¶ Z}
  [is_iso f] [hh : is_iso h] (w : f â‰« g = h) : is_iso g :=
by { rw â† w at hh, haveI := hh, exact of_is_iso_comp_left f g, }
lemma of_is_iso_fac_right {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} {h : X âŸ¶ Z}
  [is_iso g] [hh : is_iso h] (w : f â‰« g = h) : is_iso f :=
by { rw â† w at hh, haveI := hh, exact of_is_iso_comp_right f g, }
end is_iso
open is_iso
lemma eq_of_inv_eq_inv {f g : X âŸ¶ Y} [is_iso f] [is_iso g] (p : inv f = inv g) : f = g :=
begin
  apply (cancel_epi (inv f)).1,
  erw [inv_hom_id, p, inv_hom_id],
end
lemma is_iso.inv_eq_inv {f g : X âŸ¶ Y} [is_iso f] [is_iso g] : inv f = inv g â†” f = g :=
iso.inv_eq_inv (as_iso f) (as_iso g)
lemma hom_comp_eq_id (g : X âŸ¶ Y) [is_iso g] {f : Y âŸ¶ X} : g â‰« f = ğŸ™ X â†” f = inv g :=
(as_iso g).hom_comp_eq_id
lemma comp_hom_eq_id (g : X âŸ¶ Y) [is_iso g] {f : Y âŸ¶ X} : f â‰« g = ğŸ™ Y â†” f = inv g :=
(as_iso g).comp_hom_eq_id
lemma inv_comp_eq_id (g : X âŸ¶ Y) [is_iso g] {f : X âŸ¶ Y} : inv g â‰« f = ğŸ™ Y â†” f = g :=
(as_iso g).inv_comp_eq_id
lemma comp_inv_eq_id (g : X âŸ¶ Y) [is_iso g] {f : X âŸ¶ Y} : f â‰« inv g = ğŸ™ X â†” f = g :=
(as_iso g).comp_inv_eq_id
lemma is_iso_of_hom_comp_eq_id (g : X âŸ¶ Y) [is_iso g] {f : Y âŸ¶ X} (h : g â‰« f = ğŸ™ X) : is_iso f :=
by { rw [(hom_comp_eq_id _).mp h], apply_instance }
lemma is_iso_of_comp_hom_eq_id (g : X âŸ¶ Y) [is_iso g] {f : Y âŸ¶ X} (h : f â‰« g = ğŸ™ Y) : is_iso f :=
by { rw [(comp_hom_eq_id _).mp h], apply_instance }
namespace iso
@[ext] lemma inv_ext {f : X â‰… Y} {g : Y âŸ¶ X}
  (hom_inv_id : f.hom â‰« g = ğŸ™ X) : f.inv = g :=
((hom_comp_eq_id f).1 hom_inv_id).symm
@[ext] lemma inv_ext' {f : X â‰… Y} {g : Y âŸ¶ X}
  (hom_inv_id : f.hom â‰« g = ğŸ™ X) : g = f.inv :=
(hom_comp_eq_id f).1 hom_inv_id
@[simp] lemma cancel_iso_hom_left {X Y Z : C} (f : X â‰… Y) (g g' : Y âŸ¶ Z) :
  f.hom â‰« g = f.hom â‰« g' â†” g = g' :=
by simp only [cancel_epi]
@[simp] lemma cancel_iso_inv_left {X Y Z : C} (f : Y â‰… X) (g g' : Y âŸ¶ Z) :
  f.inv â‰« g = f.inv â‰« g' â†” g = g' :=
by simp only [cancel_epi]
@[simp] lemma cancel_iso_hom_right {X Y Z : C} (f f' : X âŸ¶ Y) (g : Y â‰… Z) :
  f â‰« g.hom = f' â‰« g.hom â†” f = f' :=
by simp only [cancel_mono]
@[simp] lemma cancel_iso_inv_right {X Y Z : C} (f f' : X âŸ¶ Y) (g : Z â‰… Y) :
  f â‰« g.inv = f' â‰« g.inv â†” f = f' :=
by simp only [cancel_mono]
@[simp] lemma cancel_iso_hom_right_assoc {W X X' Y Z : C}
  (f : W âŸ¶ X) (g : X âŸ¶ Y) (f' : W âŸ¶ X') (g' : X' âŸ¶ Y)
  (h : Y â‰… Z) :
  f â‰« g â‰« h.hom = f' â‰« g' â‰« h.hom â†” f â‰« g = f' â‰« g' :=
by simp only [â†category.assoc, cancel_mono]
@[simp] lemma cancel_iso_inv_right_assoc {W X X' Y Z : C}
  (f : W âŸ¶ X) (g : X âŸ¶ Y) (f' : W âŸ¶ X') (g' : X' âŸ¶ Y)
  (h : Z â‰… Y) :
  f â‰« g â‰« h.inv = f' â‰« g' â‰« h.inv â†” f â‰« g = f' â‰« g' :=
by simp only [â†category.assoc, cancel_mono]
end iso
namespace functor
universes uâ‚ vâ‚ uâ‚‚ vâ‚‚
variables {D : Type uâ‚‚}
variables [category.{vâ‚‚} D]
@[simps]
def map_iso (F : C â¥¤ D) {X Y : C} (i : X â‰… Y) : F.obj X â‰… F.obj Y :=
{ hom := F.map i.hom,
  inv := F.map i.inv,
  hom_inv_id' := by rw [â†map_comp, iso.hom_inv_id, â†map_id],
  inv_hom_id' := by rw [â†map_comp, iso.inv_hom_id, â†map_id] }
@[simp] lemma map_iso_symm (F : C â¥¤ D) {X Y : C} (i : X â‰… Y) :
  F.map_iso i.symm = (F.map_iso i).symm :=
rfl
@[simp] lemma map_iso_trans (F : C â¥¤ D) {X Y Z : C} (i : X â‰… Y) (j : Y â‰… Z) :
  F.map_iso (i â‰ªâ‰« j) = (F.map_iso i) â‰ªâ‰« (F.map_iso j) :=
by ext; apply functor.map_comp
@[simp] lemma map_iso_refl (F : C â¥¤ D) (X : C) : F.map_iso (iso.refl X) = iso.refl (F.obj X) :=
iso.ext $ F.map_id X
instance map_is_iso (F : C â¥¤ D) (f : X âŸ¶ Y) [is_iso f] : is_iso (F.map f) :=
is_iso.of_iso $ F.map_iso (as_iso f)
@[simp] lemma map_inv (F : C â¥¤ D) {X Y : C} (f : X âŸ¶ Y) [is_iso f] :
  F.map (inv f) = inv (F.map f) :=
by { ext, simp [â†F.map_comp], }
lemma map_hom_inv (F : C â¥¤ D) {X Y : C} (f : X âŸ¶ Y) [is_iso f] :
  F.map f â‰« F.map (inv f) = ğŸ™ (F.obj X) :=
by simp
lemma map_inv_hom (F : C â¥¤ D) {X Y : C} (f : X âŸ¶ Y) [is_iso f] :
  F.map (inv f) â‰« F.map f = ğŸ™ (F.obj Y) :=
by simp
end functor
end category_theory
