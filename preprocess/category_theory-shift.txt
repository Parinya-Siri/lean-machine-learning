import category_theory.limits.preserves.shapes.zero
import category_theory.monoidal.End
import category_theory.monoidal.discrete
namespace category_theory
noncomputable theory
universes v u
variables (C : Type u) (A : Type*) [category.{v} C]
local attribute [instance] endofunctor_monoidal_category
section eq_to_hom
variables {A C}
variables [add_monoid A] (F : monoidal_functor (discrete A) (C ‚•§ C))
 @[simp, reassoc] lemma eq_to_hom_Œº_app {i j i' j' : A} (h‚ÇÅ : i = i') (h‚ÇÇ : j = j') (X : C) :
   eq_to_hom (by rw [h‚ÇÅ, h‚ÇÇ] : (F.obj ‚ü®i‚ü© ‚äó F.obj ‚ü®j‚ü©).obj X =
       (F.obj ‚ü®i'‚ü© ‚äó F.obj ‚ü®j'‚ü©).obj X) ‚â´ (F.Œº ‚ü®i'‚ü© ‚ü®j'‚ü©).app X =
     (F.Œº ‚ü®i‚ü© ‚ü®j‚ü©).app X ‚â´ eq_to_hom (by rw [h‚ÇÅ, h‚ÇÇ]) :=
 by { cases h‚ÇÅ, cases h‚ÇÇ, rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id] }
 @[simp, reassoc] lemma Œº_inv_app_eq_to_hom {i j i' j' : A} (h‚ÇÅ : i = i') (h‚ÇÇ : j = j') (X : C) :
   inv ((F.Œº ‚ü®i‚ü© ‚ü®j‚ü©).app X) ‚â´ eq_to_hom (by rw [h‚ÇÅ, h‚ÇÇ]) =
     eq_to_hom (by rw [h‚ÇÅ, h‚ÇÇ]) ‚â´ inv ((F.Œº ‚ü®i'‚ü© ‚ü®j'‚ü©).app X) :=
 by { cases h‚ÇÅ, cases h‚ÇÇ, rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id] }
end eq_to_hom
variables {A C}
@[simps functor inverse unit_iso_hom unit_iso_inv counit_iso_hom counit_iso_inv]
def add_neg_equiv [add_group A] (F : monoidal_functor (discrete A) (C ‚•§ C)) (n : A) : C ‚âå C :=
equiv_of_tensor_iso_unit F ‚ü®n‚ü© ‚ü®(-n : A)‚ü©
  (discrete.eq_to_iso (add_neg_self n)) (discrete.eq_to_iso (neg_add_self n))
  (subsingleton.elim _ _)
section defs
variables (A C) [add_monoid A]
class has_shift (C : Type u) (A : Type*) [category.{v} C] [add_monoid A] :=
(shift : monoidal_functor (discrete A) (C ‚•§ C))
@[nolint has_inhabited_instance]
structure shift_mk_core :=
(F : A ‚Üí (C ‚•§ C))
(Œµ : ùü≠ C ‚âÖ F 0)
(Œº : Œ† n m : A, F n ‚ãô F m ‚âÖ F (n + m))
(associativity : ‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C),
  (F m‚ÇÉ).map ((Œº m‚ÇÅ m‚ÇÇ).hom.app X) ‚â´ (Œº (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).hom.app X ‚â´
    eq_to_hom (by { congr' 2, exact add_assoc _ _ _ }) =
    (Œº m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X) ‚â´ (Œº m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).hom.app X . obviously)
(left_unitality : ‚àÄ (n : A) (X : C),
  (F n).map (Œµ.hom.app X) ‚â´ (Œº 0 n).hom.app X =
    eq_to_hom (by { dsimp, rw zero_add }) . obviously)
(right_unitality : ‚àÄ (n : A) (X : C),
  Œµ.hom.app ((F n).obj X) ‚â´ (Œº n 0).hom.app X =
    eq_to_hom (by { dsimp, rw add_zero }) . obviously)
section
local attribute [simp] eq_to_hom_map
local attribute [reducible] endofunctor_monoidal_category discrete.add_monoidal
@[simps]
def has_shift_mk (h : shift_mk_core C A) : has_shift C A :=
‚ü®{ Œµ := h.Œµ.hom,
   Œº := Œª m n, (h.Œº m.as n.as).hom,
   Œº_natural' := by { rintros ‚ü®X‚ü© ‚ü®Y‚ü© ‚ü®X'‚ü© ‚ü®Y'‚ü© ‚ü®‚ü®‚ü®rfl‚ü©‚ü©‚ü© ‚ü®‚ü®‚ü®rfl‚ü©‚ü©‚ü©, ext,
     dsimp, simp, dsimp, simp },
   associativity' := by { introv, ext, dsimp, simpa using h.associativity _ _ _ _, },
   left_unitality' :=
    by { rintro ‚ü®X‚ü©, ext, dsimp, rw [category.id_comp, ‚Üê category.assoc, h.left_unitality], simp },
   right_unitality' :=
    by { rintro ‚ü®X‚ü©, ext, dsimp, rw [functor.map_id, category.comp_id,
      ‚Üê category.assoc, h.right_unitality], simp },
 ..(discrete.functor h.F) }‚ü©
end
variables [has_shift C A]
def shift_monoidal_functor : monoidal_functor (discrete A) (C ‚•§ C) := has_shift.shift
variable {A}
abbreviation shift_functor (i : A) : C ‚•§ C := (shift_monoidal_functor C A).obj ‚ü®i‚ü©
abbreviation shift_functor_add (i j : A) :
  shift_functor C (i + j) ‚âÖ shift_functor C i ‚ãô shift_functor C j :=
((shift_monoidal_functor C A).Œº_iso ‚ü®i‚ü© ‚ü®j‚ü©).symm
variables (A)
abbreviation shift_functor_zero : shift_functor C (0 : A) ‚âÖ ùü≠ C :=
(shift_monoidal_functor C A).Œµ_iso.symm
abbreviation shift_add (i j : A) : X‚ü¶i + j‚üß ‚âÖ X‚ü¶i‚üß‚ü¶j‚üß := (shift_functor_add C i j).app _
@[reassoc] lemma shift_add_hom_comp_eq_to_hom‚ÇÅ (i i' j : A) (h : i = i') :
  (shift_add X i j).hom ‚â´ eq_to_hom (by rw h) = eq_to_hom (by rw h) ‚â´ (shift_add X i' j).hom :=
by { cases h, rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id] }
@[reassoc] lemma shift_add_hom_comp_eq_to_hom‚ÇÇ (i j j' : A) (h : j = j') :
  (shift_add X i j).hom ‚â´ eq_to_hom (by rw h) = eq_to_hom (by rw h) ‚â´ (shift_add X i j').hom :=
by { cases h, rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id] }
@[reassoc] lemma shift_add_hom_comp_eq_to_hom‚ÇÅ‚ÇÇ (i j i' j' : A) (h‚ÇÅ : i = i') (h‚ÇÇ : j = j') :
  (shift_add X i j).hom ‚â´ eq_to_hom (by rw [h‚ÇÅ, h‚ÇÇ]) =
    eq_to_hom (by rw [h‚ÇÅ, h‚ÇÇ]) ‚â´ (shift_add X i' j').hom :=
by { cases h‚ÇÅ, cases h‚ÇÇ, rw [eq_to_hom_refl, eq_to_hom_refl, category.id_comp, category.comp_id] }
@[reassoc] lemma eq_to_hom_comp_shift_add_inv‚ÇÅ (i i' j : A) (h : i = i') :
  eq_to_hom (by rw h) ‚â´ (shift_add X i' j).inv = (shift_add X i j).inv ‚â´ eq_to_hom (by rw h) :=
by rw [iso.comp_inv_eq, category.assoc, iso.eq_inv_comp, shift_add_hom_comp_eq_to_hom‚ÇÅ]
@[reassoc] lemma eq_to_hom_comp_shift_add_inv‚ÇÇ (i j j' : A) (h : j = j') :
  eq_to_hom (by rw h) ‚â´ (shift_add X i j').inv = (shift_add X i j).inv ‚â´ eq_to_hom (by rw h) :=
by rw [iso.comp_inv_eq, category.assoc, iso.eq_inv_comp, shift_add_hom_comp_eq_to_hom‚ÇÇ]
@[reassoc] lemma eq_to_hom_comp_shift_add_inv‚ÇÅ‚ÇÇ (i j i' j' : A) (h‚ÇÅ : i = i') (h‚ÇÇ : j = j') :
  eq_to_hom (by rw [h‚ÇÅ, h‚ÇÇ]) ‚â´ (shift_add X i' j').inv =
    (shift_add X i j).inv ‚â´ eq_to_hom (by rw [h‚ÇÅ, h‚ÇÇ]) :=
by rw [iso.comp_inv_eq, category.assoc, iso.eq_inv_comp, shift_add_hom_comp_eq_to_hom‚ÇÅ‚ÇÇ]
lemma shift_shift' (i j : A) :
  f‚ü¶i‚üß'‚ü¶j‚üß' = (shift_add X i j).inv ‚â´ f‚ü¶i + j‚üß' ‚â´ (shift_add Y i j).hom :=
by { symmetry, apply nat_iso.naturality_1 }
variables (A)
abbreviation shift_zero  :
  X‚ü¶0‚üß ‚âÖ X := (shift_functor_zero C A).app _
lemma shift_zero' :
  f‚ü¶(0 : A)‚üß' = (shift_zero A X).hom ‚â´ f ‚â´ (shift_zero A Y).inv :=
by { symmetry, apply nat_iso.naturality_2 }
end add_monoid
section add_group
variables (C) {A} [add_group A] [has_shift C A]
variables (X Y : C) (f : X ‚ü∂ Y)
instance (i : A) : is_equivalence (shift_functor C i) :=
begin
  change is_equivalence (add_neg_equiv (shift_monoidal_functor C A) i).functor,
  apply_instance,
end
@[simp] lemma shift_functor_inv (i : A) :
  (shift_functor C i).inv = shift_functor C (-i) :=
rfl
abbreviation shift_functor_comp_shift_functor_neg (i : A) :
  shift_functor C i ‚ãô shift_functor C (-i) ‚âÖ ùü≠ C :=
unit_of_tensor_iso_unit (shift_monoidal_functor C A) ‚ü®i‚ü© ‚ü®(-i : A)‚ü©
  (discrete.eq_to_iso (add_neg_self i))
abbreviation shift_functor_neg_comp_shift_functor (i : A) :
  shift_functor C (-i) ‚ãô shift_functor C i ‚âÖ ùü≠ C :=
unit_of_tensor_iso_unit (shift_monoidal_functor C A) ‚ü®(-i : A)‚ü© ‚ü®i‚ü©
  (discrete.eq_to_iso (neg_add_self i))
section
variables (C)
instance shift_functor_faithful (i : A) : faithful (shift_functor C i) :=
faithful.of_comp_iso (shift_functor_comp_shift_functor_neg C i)
instance shift_functor_full (i : A) : full (shift_functor C i) :=
begin
  haveI : full (shift_functor C i ‚ãô shift_functor C (-i)) :=
    full.of_iso (shift_functor_comp_shift_functor_neg C i).symm,
  exact full.of_comp_faithful _ (shift_functor C (-i))
end
instance shift_functor_ess_surj (i : A) : ess_surj (shift_functor C i) :=
{ mem_ess_image := Œª Y, ‚ü®Y‚ü¶-i‚üß, ‚ü®(shift_functor_neg_comp_shift_functor C i).app Y‚ü©‚ü© }
end
variables {C}
abbreviation shift_shift_neg (i : A) : X‚ü¶i‚üß‚ü¶-i‚üß ‚âÖ X :=
(shift_functor_comp_shift_functor_neg C i).app _
abbreviation shift_neg_shift (i : A) : X‚ü¶-i‚üß‚ü¶i‚üß ‚âÖ X :=
(shift_functor_neg_comp_shift_functor C i).app _
variables {X Y}
lemma shift_shift_neg' (i : A) :
  f‚ü¶i‚üß'‚ü¶-i‚üß' = (shift_shift_neg X i).hom ‚â´ f ‚â´ (shift_shift_neg Y i).inv :=
by { symmetry, apply nat_iso.naturality_2 }
lemma shift_neg_shift' (i : A) :
  f‚ü¶-i‚üß'‚ü¶i‚üß' = (shift_neg_shift X i).hom ‚â´ f ‚â´ (shift_neg_shift Y i).inv :=
by { symmetry, apply nat_iso.naturality_2 }
lemma shift_equiv_triangle (n : A) (X : C) :
  (shift_shift_neg X n).inv‚ü¶n‚üß' ‚â´ (shift_neg_shift (X‚ü¶n‚üß) n).hom = ùüô (X‚ü¶n‚üß) :=
(add_neg_equiv (shift_monoidal_functor C A) n).functor_unit_iso_comp X
section
local attribute [reducible] discrete.add_monoidal
lemma shift_shift_neg_hom_shift (n : A) (X : C) :
  (shift_shift_neg X n).hom ‚ü¶n‚üß' = (shift_neg_shift (X‚ü¶n‚üß) n).hom :=
begin
@[simps]
def shift_equiv (n : A) : C ‚âå C :=
{ functor := shift_functor C n,
  inverse := shift_functor C (-n),
  ..(add_neg_equiv (shift_monoidal_functor C A) n) }
variable {C}
open category_theory.limits
variables [has_zero_morphisms C]
lemma shift_zero_eq_zero (X Y : C) (n : A) : (0 : X ‚ü∂ Y)‚ü¶n‚üß' = (0 : X‚ü¶n‚üß ‚ü∂ Y‚ü¶n‚üß) :=
category_theory.functor.map_zero _ _ _
end add_group
section add_comm_monoid
variables {C A} [add_comm_monoid A] [has_shift C A]
variables (X Y : C) (f : X ‚ü∂ Y)
def shift_comm (i j : A) : X‚ü¶i‚üß‚ü¶j‚üß ‚âÖ X‚ü¶j‚üß‚ü¶i‚üß :=
(shift_add X i j).symm ‚â™‚â´ ((shift_monoidal_functor C A).to_functor.map_iso
  (discrete.eq_to_iso $ add_comm i j : (‚ü®i+j‚ü© : discrete A) ‚âÖ ‚ü®j+i‚ü©)).app X ‚â™‚â´ shift_add X j i
@[simp] lemma shift_comm_symm (i j : A) : (shift_comm X i j).symm = shift_comm X j i :=
begin
  ext, dsimp [shift_comm], simpa [eq_to_hom_map],
end
variables {X Y}
lemma shift_comm' (i j : A) :
  f‚ü¶i‚üß'‚ü¶j‚üß' = (shift_comm _ _ _).hom ‚â´ f‚ü¶j‚üß'‚ü¶i‚üß' ‚â´ (shift_comm _ _ _).hom :=
begin
def has_shift_of_fully_faithful
  (s : A ‚Üí C ‚•§ C) (i : ‚àÄ i, s i ‚ãô F ‚âÖ F ‚ãô shift_functor D i) : has_shift C A :=
has_shift_mk C A
{ F := s,
  Œµ := nat_iso_of_comp_fully_faithful F
    (calc ùü≠ C ‚ãô F ‚âÖ F                                   : functor.left_unitor _
      ... ‚âÖ F ‚ãô ùü≠ D                                     : (functor.right_unitor _).symm
      ... ‚âÖ F ‚ãô shift_functor D (0 : A)                 :
              iso_whisker_left F (shift_functor_zero D A).symm
      ... ‚âÖ s 0 ‚ãô F                                     : (i 0).symm),
  Œº := Œª a b, nat_iso_of_comp_fully_faithful F
    (calc (s a ‚ãô s b) ‚ãô F ‚âÖ s a ‚ãô s b ‚ãô F             : functor.associator _ _ _
     ... ‚âÖ s a ‚ãô F ‚ãô shift_functor D b                 : iso_whisker_left _ (i b)
     ... ‚âÖ (s a ‚ãô F) ‚ãô shift_functor D b               : (functor.associator _ _ _).symm
     ... ‚âÖ (F ‚ãô shift_functor D a) ‚ãô shift_functor D b : iso_whisker_right (i a) _
     ... ‚âÖ F ‚ãô shift_functor D a ‚ãô shift_functor D b   : functor.associator _ _ _
     ... ‚âÖ F ‚ãô shift_functor D (a + b)                  :
             iso_whisker_left _ (shift_functor_add D a b).symm
     ... ‚âÖ s (a + b) ‚ãô F                                : (i (a + b)).symm),
  associativity := begin
    intros, apply F.map_injective, dsimp,
    simp only [category.comp_id, category.id_comp, category.assoc,
      category_theory.functor.map_comp, functor.image_preimage,
       eq_to_hom_map, iso.inv_hom_id_app_assoc],
    erw (i m‚ÇÉ).hom.naturality_assoc,
    congr' 1,
    dsimp,
    simp only [eq_to_iso.inv, eq_to_hom_app, eq_to_hom_map, obj_Œº_app, Œº_naturality_assoc,
      category.assoc, category_theory.functor.map_comp, functor.image_preimage],
    congr' 3,
    dsimp,
    simp only [‚Üê(shift_functor D m‚ÇÉ).map_comp_assoc, iso.inv_hom_id_app],
    erw [(shift_functor D m‚ÇÉ).map_id, category.id_comp],
    erw [((shift_monoidal_functor D A).Œº_iso ‚ü®m‚ÇÅ + m‚ÇÇ‚ü© ‚ü®m‚ÇÉ‚ü©).inv_hom_id_app_assoc],
    congr' 1,
    have := dcongr_arg (Œª a, (i a).inv.app X) (add_assoc m‚ÇÅ m‚ÇÇ m‚ÇÉ),
    dsimp at this,
    simp [this],
  end,
  left_unitality := begin
    intros, apply F.map_injective, dsimp,
    simp only [category.comp_id, category.id_comp, category.assoc, category_theory.functor.map_comp,
      eq_to_hom_app, eq_to_hom_map, functor.image_preimage],
    erw (i n).hom.naturality_assoc,
    dsimp,
    simp only [eq_to_iso.inv, eq_to_hom_app, category.assoc, category_theory.functor.map_comp,
      eq_to_hom_map, obj_Œµ_app, functor.image_preimage],
    simp only [‚Üê(shift_functor D n).map_comp_assoc, iso.inv_hom_id_app],
    dsimp,
    simp only [category.id_comp, Œº_inv_hom_app_assoc, category_theory.functor.map_id],
    have := dcongr_arg (Œª a, (i a).inv.app X) (zero_add n),
    dsimp at this,
    simp [this],
  end,
  right_unitality := begin
    intros, apply F.map_injective, dsimp,
    simp only [category.comp_id, category.id_comp, category.assoc,
      iso.inv_hom_id_app_assoc, eq_to_iso.inv, eq_to_hom_app, eq_to_hom_map,
      category_theory.functor.map_comp, functor.image_preimage,
      obj_zero_map_Œº_app, Œµ_hom_inv_app_assoc],
    have := dcongr_arg (Œª a, (i a).inv.app X) (add_zero n),
    dsimp at this,
    simp [this],
  end, }
end
