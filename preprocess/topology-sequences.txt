import topology.subset_properties
import topology.metric_space.basic
open set function filter
open_locale topological_space
variables {X Y : Type*}
local notation x ` âŸ¶ ` a := tendsto x at_top (ğ“ a)
section topological_space
variables [topological_space X] [topological_space Y]
def seq_closure (s : set X) : set X :=
{a | âˆƒ x : â„• â†’ X, (âˆ€ n : â„•, x n âˆˆ s) âˆ§ (x âŸ¶ a)}
lemma subset_seq_closure (s : set X) : s âŠ† seq_closure s :=
Î» a ha, âŸ¨const â„• a, Î» n, ha, tendsto_const_nhdsâŸ©
def is_seq_closed (s : set X) : Prop := s = seq_closure s
lemma is_seq_closed_of_def {s : set X}
  (h : âˆ€ (x : â„• â†’ X) (a : X), (âˆ€ n : â„•, x n âˆˆ s) â†’ (x âŸ¶ a) â†’ a âˆˆ s) : is_seq_closed s :=
show s = seq_closure s, from subset.antisymm
  (subset_seq_closure s)
  (show âˆ€ a, a âˆˆ seq_closure s â†’ a âˆˆ s, from
    (assume a âŸ¨x, _, _âŸ©, show a âˆˆ s, from h x a â€¹âˆ€ n : â„•, ((x n) âˆˆ s)â€º â€¹(x âŸ¶ a)â€º))
lemma seq_closure_subset_closure (s : set X) : seq_closure s âŠ† closure s :=
assume a âŸ¨x, xM, xaâŸ©,
mem_closure_of_tendsto xa (eventually_of_forall xM)
lemma is_closed.is_seq_closed {s : set X} (hs : is_closed s) : is_seq_closed s :=
suffices seq_closure s âŠ† s, from (subset_seq_closure s).antisymm this,
calc seq_closure s âŠ† closure s : seq_closure_subset_closure s
               ... = s         : hs.closure_eq
lemma is_seq_closed.mem_of_tendsto {s : set X} (hs : is_seq_closed s) {x : â„• â†’ X}
  (hmem : âˆ€ n, x n âˆˆ s) {a : X} (ha : (x âŸ¶ a)) : a âˆˆ s :=
have a âˆˆ seq_closure s, from
  show âˆƒ x : â„• â†’ X, (âˆ€ n : â„•, x n âˆˆ s) âˆ§ (x âŸ¶ a), from âŸ¨x, â€¹âˆ€ n, x n âˆˆ sâ€º, â€¹(x âŸ¶ a)â€ºâŸ©,
eq.subst (eq.symm â€¹is_seq_closed sâ€º) â€¹a âˆˆ seq_closure sâ€º
class sequential_space (X : Type*) [topological_space X] : Prop :=
(seq_closure_eq_closure : âˆ€ s : set X, seq_closure s = closure s)
lemma is_seq_closed_iff_is_closed [sequential_space X] {s : set X} :
  is_seq_closed s â†” is_closed s :=
iff.intro
  (assume _, closure_eq_iff_is_closed.mp (eq.symm
    (calc s = seq_closure s : by assumption
        ... = closure s     : sequential_space.seq_closure_eq_closure s)))
  is_closed.is_seq_closed
alias is_seq_closed_iff_is_closed â†” is_seq_closed.is_closed _
lemma mem_closure_iff_seq_limit [sequential_space X] {s : set X} {a : X} :
  a âˆˆ closure s â†” âˆƒ x : â„• â†’ X, (âˆ€ n : â„•, x n âˆˆ s) âˆ§ (x âŸ¶ a) :=
by { rw â† sequential_space.seq_closure_eq_closure, exact iff.rfl }
def seq_continuous (f : X â†’ Y) : Prop :=
âˆ€ (x : â„• â†’ X), âˆ€ {a : X}, (x âŸ¶ a) â†’ (f âˆ˜ x âŸ¶ f a)
protected lemma continuous.seq_continuous {f : X â†’ Y} (hf : continuous f) : seq_continuous f :=
assume x a (_ : x âŸ¶ a),
have tendsto f (ğ“ a) (ğ“ (f a)), from continuous.tendsto â€¹continuous fâ€º a,
show (f âˆ˜ x) âŸ¶ (f a), from tendsto.comp this â€¹(x âŸ¶ a)â€º
lemma continuous_iff_seq_continuous {f : X â†’ Y} [sequential_space X] :
  continuous f â†” seq_continuous f :=
iff.intro
  continuous.seq_continuous
  (assume : seq_continuous f, show continuous f, from
    suffices h : âˆ€ {s : set Y}, is_closed s â†’ is_seq_closed (f â»Â¹' s), from
      continuous_iff_is_closed.mpr (assume s _, is_seq_closed_iff_is_closed.mp $ h â€¹is_closed sâ€º),
    assume s (_ : is_closed s),
      is_seq_closed_of_def $
        assume (x : â„• â†’ X) a (_ : âˆ€ n, f (x n) âˆˆ s) (_ : x âŸ¶ a),
        have (f âˆ˜ x) âŸ¶ (f a), from â€¹seq_continuous fâ€º x â€¹(x âŸ¶ a)â€º,
        show f a âˆˆ s,
          from â€¹is_closed sâ€º.is_seq_closed.mem_of_tendsto â€¹âˆ€ n, f (x n) âˆˆ sâ€º â€¹(fâˆ˜x âŸ¶ f a)â€º)
alias continuous_iff_seq_continuous â†” _ seq_continuous.continuous
end topological_space
namespace topological_space
namespace first_countable_topology
variables [topological_space X] [first_countable_topology X]
def is_seq_compact (s : set X) :=
âˆ€ â¦ƒx : â„• â†’ Xâ¦„, (âˆ€ n, x n âˆˆ s) â†’ âˆƒ (a âˆˆ s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ (x âˆ˜ Ï† âŸ¶ a)
class seq_compact_space (X : Type*) [topological_space X] : Prop :=
(seq_compact_univ : is_seq_compact (univ : set X))
lemma is_seq_compact.subseq_of_frequently_in {s : set X} (hs : is_seq_compact s) {x : â„• â†’ X}
  (hx : âˆƒá¶  n in at_top, x n âˆˆ s) :
  âˆƒ (a âˆˆ s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ (x âˆ˜ Ï† âŸ¶ a) :=
let âŸ¨Ïˆ, hÏˆ, huÏˆâŸ© := extraction_of_frequently_at_top hx, âŸ¨a, a_in, Ï†, hÏ†, hâŸ© := hs huÏˆ in
âŸ¨a, a_in, Ïˆ âˆ˜ Ï†, hÏˆ.comp hÏ†, hâŸ©
lemma seq_compact_space.tendsto_subseq [seq_compact_space X] (x : â„• â†’ X) :
  âˆƒ a (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ (x âˆ˜ Ï† âŸ¶ a) :=
let âŸ¨a, _, Ï†, mono, hâŸ© := seq_compact_space.seq_compact_univ (Î» n, mem_univ (x n)) in
âŸ¨a, Ï†, mono, hâŸ©
section first_countable_topology
variables [first_countable_topology X]
open topological_space.first_countable_topology
lemma is_compact.is_seq_compact {s : set X} (hs : is_compact s) : is_seq_compact s :=
Î» x x_in,
let âŸ¨a, a_in, haâŸ© := @hs (map x at_top) _
  (le_principal_iff.mpr (univ_mem' x_in : _)) in âŸ¨a, a_in, tendsto_subseq haâŸ©
lemma is_compact.tendsto_subseq' {s : set X} {x : â„• â†’ X} (hs : is_compact s)
  (hx : âˆƒá¶  n in at_top, x n âˆˆ s) :
  âˆƒ (a âˆˆ s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ (x âˆ˜ Ï† âŸ¶ a) :=
hs.is_seq_compact.subseq_of_frequently_in hx
lemma is_compact.tendsto_subseq {s : set X} {x : â„• â†’ X} (hs : is_compact s) (hx : âˆ€ n, x n âˆˆ s) :
  âˆƒ (a âˆˆ s) (Ï† : â„• â†’ â„•), strict_mono Ï† âˆ§ (x âˆ˜ Ï† âŸ¶ a) :=
hs.is_seq_compact hx
protected lemma uniform_space.compact_iff_seq_compact [is_countably_generated $ ğ“¤ X] :
 is_compact s â†” is_seq_compact s :=
âŸ¨Î» H, H.is_seq_compact, Î» H, H.is_compactâŸ©
lemma uniform_space.compact_space_iff_seq_compact_space [is_countably_generated $ ğ“¤ X] :
  compact_space X â†” seq_compact_space X :=
have key : is_compact (univ : set X) â†” is_seq_compact univ := uniform_space.compact_iff_seq_compact,
âŸ¨Î» âŸ¨hâŸ©, âŸ¨key.mp hâŸ©, Î» âŸ¨hâŸ©, âŸ¨key.mpr hâŸ©âŸ©
end uniform_space_seq_compact
section metric_seq_compact
variables [pseudo_metric_space X]
open metric
lemma seq_compact.lebesgue_number_lemma_of_metric {Î¹ : Sort*} {c : Î¹ â†’ set X}
  {s : set X} (hs : is_seq_compact s) (hcâ‚ : âˆ€ i, is_open (c i)) (hcâ‚‚ : s âŠ† â‹ƒ i, c i) :
  âˆƒ Î´ > 0, âˆ€ a âˆˆ s, âˆƒ i, ball a Î´ âŠ† c i :=
lebesgue_number_lemma_of_metric hs.is_compact hcâ‚ hcâ‚‚
variables [proper_space X] {s : set X}
lemma tendsto_subseq_of_frequently_bounded (hs : bounded s)
  {x : â„• â†’ X} (hx : âˆƒá¶  n in at_top, x n âˆˆ s) :
  âˆƒ a âˆˆ closure s, âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ (x âˆ˜ Ï† âŸ¶ a) :=
have hcs : is_seq_compact (closure s), from hs.is_compact_closure.is_seq_compact,
have hu' : âˆƒá¶  n in at_top, x n âˆˆ closure s, from hx.mono (Î» n hn, subset_closure hn),
hcs.subseq_of_frequently_in hu'
lemma tendsto_subseq_of_bounded (hs : bounded s) {x : â„• â†’ X} (hx : âˆ€ n, x n âˆˆ s) :
  âˆƒ a âˆˆ closure s, âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ (x âˆ˜ Ï† âŸ¶ a) :=
tendsto_subseq_of_frequently_bounded hs $ frequently_of_forall hx
end metric_seq_compact
