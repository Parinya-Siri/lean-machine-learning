import topology.algebra.module.basic
noncomputable theory
open filter
open_locale topological_space
variables {Î± ğ•œ ğ• R E F M : Type*}
section weak_topology
@[derive [add_comm_monoid, module ğ•œ],
nolint has_inhabited_instance unused_arguments]
def weak_bilin [comm_semiring ğ•œ] [add_comm_monoid E] [module ğ•œ E] [add_comm_monoid F]
  [module ğ•œ F] (B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) := E
namespace weak_bilin
instance [comm_semiring ğ•œ] [a : add_comm_group E] [module ğ•œ E] [add_comm_monoid F]
  [module ğ•œ F] (B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) : add_comm_group (weak_bilin B) := a
@[priority 100]
instance module' [comm_semiring ğ•œ] [comm_semiring ğ•] [add_comm_group E] [module ğ•œ E]
  [add_comm_group F] [module ğ•œ F] [m : module ğ• E] (B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) :
  module ğ• (weak_bilin B) := m
instance [comm_semiring ğ•œ] [comm_semiring ğ•] [add_comm_group E] [module ğ•œ E]
  [add_comm_group F] [module ğ•œ F] [has_smul ğ• ğ•œ] [module ğ• E] [s : is_scalar_tower ğ• ğ•œ E]
  (B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ) : is_scalar_tower ğ• ğ•œ (weak_bilin B) := s
section semiring
variables [topological_space ğ•œ] [comm_semiring ğ•œ]
variables [add_comm_monoid E] [module ğ•œ E]
variables [add_comm_monoid F] [module ğ•œ F]
variables (B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ)
instance : topological_space (weak_bilin B) :=
topological_space.induced (Î» x y, B x y) Pi.topological_space
lemma coe_fn_continuous : continuous (Î» (x : weak_bilin B) y, B x y) :=
continuous_induced_dom
lemma eval_continuous (y : F) : continuous (Î» x : weak_bilin B, B x y) :=
( continuous_pi_iff.mp (coe_fn_continuous B)) y
lemma continuous_of_continuous_eval [topological_space Î±] {g : Î± â†’ weak_bilin B}
  (h : âˆ€ y, continuous (Î» a, B (g a) y)) : continuous g :=
continuous_induced_rng (continuous_pi_iff.mpr h)
lemma embedding {B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ} (hB : function.injective B) :
  embedding (Î» (x : weak_bilin B)  y, B x y) :=
function.injective.embedding_induced $ linear_map.coe_injective.comp hB
theorem tendsto_iff_forall_eval_tendsto {l : filter Î±} {f : Î± â†’ (weak_bilin B)} {x : weak_bilin B}
  (hB : function.injective B) : tendsto f l (ğ“ x) â†” âˆ€ y, tendsto (Î» i, B (f i) y) l (ğ“ (B x y)) :=
by rw [â† tendsto_pi_nhds, embedding.tendsto_nhds_iff (embedding hB)]
instance [has_continuous_add ğ•œ] : has_continuous_add (weak_bilin B) :=
begin
  refine âŸ¨continuous_induced_rng _âŸ©,
  refine cast (congr_arg _ _) (((coe_fn_continuous B).comp continuous_fst).add
    ((coe_fn_continuous B).comp continuous_snd)),
  ext,
  simp only [function.comp_app, pi.add_apply, map_add, linear_map.add_apply],
end
instance [has_continuous_smul ğ•œ ğ•œ] : has_continuous_smul ğ•œ (weak_bilin B) :=
begin
  refine âŸ¨continuous_induced_rng _âŸ©,
  refine cast (congr_arg _ _) (continuous_fst.smul ((coe_fn_continuous B).comp continuous_snd)),
  ext,
  simp only [function.comp_app, pi.smul_apply, linear_map.map_smulâ‚›â‚—, ring_hom.id_apply,
    linear_map.smul_apply],
end
end semiring
section ring
variables [topological_space ğ•œ] [comm_ring ğ•œ]
variables [add_comm_group E] [module ğ•œ E]
variables [add_comm_group F] [module ğ•œ F]
variables (B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ)
instance [has_continuous_add ğ•œ] : topological_add_group (weak_bilin B) :=
{ to_has_continuous_add := by apply_instance,
  continuous_neg := begin
    refine continuous_induced_rng (continuous_pi_iff.mpr (Î» y, _)),
    refine cast (congr_arg _ _) (eval_continuous B (-y)),
    ext,
    simp only [map_neg, function.comp_app, linear_map.neg_apply],
  end }
end ring
end weak_bilin
end weak_topology
section weak_star_topology
def top_dual_pairing (ğ•œ E) [comm_semiring ğ•œ] [topological_space ğ•œ] [has_continuous_add ğ•œ]
  [add_comm_monoid E] [module ğ•œ E] [topological_space E]
  [has_continuous_const_smul ğ•œ ğ•œ] :
  (E â†’L[ğ•œ] ğ•œ) â†’â‚—[ğ•œ] E â†’â‚—[ğ•œ] ğ•œ := continuous_linear_map.coe_lm ğ•œ
variables [comm_semiring ğ•œ] [topological_space ğ•œ] [has_continuous_add ğ•œ]
variables [has_continuous_const_smul ğ•œ ğ•œ]
variables [add_comm_monoid E] [module ğ•œ E] [topological_space E]
lemma dual_pairing_apply (v : (E â†’L[ğ•œ] ğ•œ)) (x : E) : top_dual_pairing ğ•œ E v x = v x := rfl
@[derive [add_comm_monoid, module ğ•œ, topological_space, has_continuous_add]]
def weak_dual (ğ•œ E) [comm_semiring ğ•œ] [topological_space ğ•œ] [has_continuous_add ğ•œ]
  [has_continuous_const_smul ğ•œ ğ•œ] [add_comm_monoid E] [module ğ•œ E] [topological_space E] :=
weak_bilin (top_dual_pairing ğ•œ E)
namespace weak_dual
instance : inhabited (weak_dual ğ•œ E) := continuous_linear_map.inhabited
instance weak_dual.continuous_linear_map_class :
  continuous_linear_map_class (weak_dual ğ•œ E) ğ•œ E ğ•œ :=
continuous_linear_map.continuous_semilinear_map_class
instance : has_coe_to_fun (weak_dual ğ•œ E) (Î» _, E â†’ ğ•œ) := fun_like.has_coe_to_fun
instance (M) [monoid M] [distrib_mul_action M ğ•œ] [smul_comm_class ğ•œ M ğ•œ]
  [has_continuous_const_smul M ğ•œ] :
  mul_action M (weak_dual ğ•œ E) :=
continuous_linear_map.mul_action
instance (M) [monoid M] [distrib_mul_action M ğ•œ] [smul_comm_class ğ•œ M ğ•œ]
  [has_continuous_const_smul M ğ•œ] :
  distrib_mul_action M (weak_dual ğ•œ E) :=
continuous_linear_map.distrib_mul_action
instance module' (R) [semiring R] [module R ğ•œ] [smul_comm_class ğ•œ R ğ•œ]
  [has_continuous_const_smul R ğ•œ] :
  module R (weak_dual ğ•œ E) :=
continuous_linear_map.module
instance (M) [monoid M] [distrib_mul_action M ğ•œ] [smul_comm_class ğ•œ M ğ•œ]
  [has_continuous_const_smul M ğ•œ] : has_continuous_const_smul M (weak_dual ğ•œ E) :=
âŸ¨Î» m, continuous_induced_rng $ (weak_bilin.coe_fn_continuous (top_dual_pairing ğ•œ E)).const_smul mâŸ©
instance (M) [monoid M] [distrib_mul_action M ğ•œ] [smul_comm_class ğ•œ M ğ•œ]
  [topological_space M] [has_continuous_smul M ğ•œ] :
  has_continuous_smul M (weak_dual ğ•œ E) :=
âŸ¨continuous_induced_rng $ continuous_fst.smul ((weak_bilin.coe_fn_continuous
                          (top_dual_pairing ğ•œ E)).comp continuous_snd)âŸ©
lemma coe_fn_continuous : continuous (Î» (x : weak_dual ğ•œ E) y, x y) :=
continuous_induced_dom
lemma eval_continuous (y : E) : continuous (Î» x : weak_dual ğ•œ E, x y) :=
continuous_pi_iff.mp coe_fn_continuous y
lemma continuous_of_continuous_eval [topological_space Î±] {g : Î± â†’ weak_dual ğ•œ E}
  (h : âˆ€ y, continuous (Î» a, (g a) y)) : continuous g :=
continuous_induced_rng (continuous_pi_iff.mpr h)
end weak_dual
@[derive [add_comm_monoid, module ğ•œ, topological_space, has_continuous_add],
nolint has_inhabited_instance]
def weak_space (ğ•œ E) [comm_semiring ğ•œ] [topological_space ğ•œ] [has_continuous_add ğ•œ]
  [has_continuous_const_smul ğ•œ ğ•œ] [add_comm_monoid E] [module ğ•œ E] [topological_space E] :=
weak_bilin (top_dual_pairing ğ•œ E).flip
theorem tendsto_iff_forall_eval_tendsto_top_dual_pairing
  {l : filter Î±} {f : Î± â†’ weak_dual ğ•œ E} {x : weak_dual ğ•œ E} :
  tendsto f l (ğ“ x) â†”
    âˆ€ y, tendsto (Î» i, top_dual_pairing ğ•œ E (f i) y) l (ğ“ (top_dual_pairing ğ•œ E x y)) :=
weak_bilin.tendsto_iff_forall_eval_tendsto _ continuous_linear_map.coe_injective
end weak_star_topology
