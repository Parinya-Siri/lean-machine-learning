import category_theory.limits.shapes.images
import category_theory.filtered
import tactic.equiv_rw
universes v u
open category_theory
open category_theory.limits
namespace category_theory.limits.types
variables {J : Type v} [small_category J]
def limit_cone (F : J ‚•§ Type (max v u)) : cone F :=
{ X := F.sections,
  œÄ := { app := Œª j u, u.val j } }
local attribute [elab_simple] congr_fun
def limit_cone_is_limit (F : J ‚•§ Type (max v u)) : is_limit (limit_cone F) :=
{ lift := Œª s v, ‚ü®Œª j, s.œÄ.app j v, Œª j j' f, congr_fun (cone.w s f) _‚ü©,
  uniq' := by { intros, ext x j, exact congr_fun (w j) x } }
instance has_limits_of_size : has_limits_of_size.{v} (Type (max v u)) :=
{ has_limits_of_shape := Œª J ùí•, by exactI
  { has_limit := Œª F, has_limit.mk
    { cone := limit_cone F, is_limit := limit_cone_is_limit F } } }
instance : has_limits (Type u) := types.has_limits_of_size.{u u}
def is_limit_equiv_sections {F : J ‚•§ Type (max v u)} {c : cone F} (t : is_limit c) :
  c.X ‚âÉ F.sections :=
(is_limit.cone_point_unique_up_to_iso t (limit_cone_is_limit F)).to_equiv
@[simp]
lemma is_limit_equiv_sections_apply
  {F : J ‚•§ Type (max v u)} {c : cone F} (t : is_limit c) (j : J) (x : c.X) :
  (((is_limit_equiv_sections t) x) : Œ† j, F.obj j) j = c.œÄ.app j x :=
rfl
@[simp]
lemma is_limit_equiv_sections_symm_apply
  {F : J ‚•§ Type (max v u)} {c : cone F} (t : is_limit c) (x : F.sections) (j : J) :
  c.œÄ.app j ((is_limit_equiv_sections t).symm x) = (x : Œ† j, F.obj j) j :=
begin
  equiv_rw (is_limit_equiv_sections t).symm at x,
  simp,
end
noncomputable
def limit_equiv_sections (F : J ‚•§ Type (max v u)) : (limit F : Type (max v u)) ‚âÉ F.sections :=
is_limit_equiv_sections (limit.is_limit _)
@[simp]
lemma limit_equiv_sections_apply (F : J ‚•§ Type (max v u)) (x : limit F) (j : J) :
  (((limit_equiv_sections F) x) : Œ† j, F.obj j) j = limit.œÄ F j x :=
rfl
@[simp]
lemma limit_equiv_sections_symm_apply (F : J ‚•§ Type (max v u)) (x : F.sections) (j : J) :
  limit.œÄ F j ((limit_equiv_sections F).symm x) = (x : Œ† j, F.obj j) j :=
is_limit_equiv_sections_symm_apply _ _ _
@[simp]
lemma limit_equiv_sections_symm_apply' (F : J ‚•§ Type v) (x : F.sections) (j : J) :
  limit.œÄ F j ((limit_equiv_sections.{v v} F).symm x) = (x : Œ† j, F.obj j) j :=
is_limit_equiv_sections_symm_apply _ _ _
@[ext]
noncomputable
def limit.mk (F : J ‚•§ Type (max v u)) (x : Œ† j, F.obj j)
  (h : ‚àÄ (j j') (f : j ‚ü∂ j'), F.map f (x j) = x j') : (limit F : Type (max v u)) :=
(limit_equiv_sections F).symm ‚ü®x, h‚ü©
@[simp]
lemma limit.œÄ_mk (F : J ‚•§ Type (max v u)) (x : Œ† j, F.obj j)
  (h : ‚àÄ (j j') (f : j ‚ü∂ j'), F.map f (x j) = x j') (j) : limit.œÄ F j (limit.mk F x h) = x j :=
by { dsimp [limit.mk], simp, }
@[simp]
lemma limit.œÄ_mk' (F : J ‚•§ Type v) (x : Œ† j, F.obj j)
  (h : ‚àÄ (j j') (f : j ‚ü∂ j'), F.map f (x j) = x j') (j) :
  limit.œÄ F j (limit.mk.{v v} F x h) = x j :=
by { dsimp [limit.mk], simp, }
def quot.rel (F : J ‚•§ Type (max v u)) : (Œ£ j, F.obj j) ‚Üí (Œ£ j, F.obj j) ‚Üí Prop :=
(Œª p p', ‚àÉ f : p.1 ‚ü∂ p'.1, p'.2 = F.map f p.2)
@[nolint has_inhabited_instance]
def quot (F : J ‚•§ Type (max v u)) : Type (max v u) :=
@quot (Œ£ j, F.obj j) (quot.rel F)
def colimit_cocone (F : J ‚•§ Type (max v u)) : cocone F :=
{ X := quot F,
  Œπ :=
  { app := Œª j x, quot.mk _ ‚ü®j, x‚ü©,
    naturality' := Œª j j' f, funext $ Œª x, eq.symm (quot.sound ‚ü®f, rfl‚ü©) } }
local attribute [elab_with_expected_type] quot.lift
def colimit_cocone_is_colimit (F : J ‚•§ Type (max v u)) : is_colimit (colimit_cocone F) :=
{ desc := Œª s, quot.lift (Œª (p : Œ£ j, F.obj j), s.Œπ.app p.1 p.2)
    (assume ‚ü®j, x‚ü© ‚ü®j', x'‚ü© ‚ü®f, hf‚ü©, by rw hf; exact (congr_fun (cocone.w s f) x).symm) }
instance has_colimits_of_size : has_colimits_of_size.{v} (Type (max v u)) :=
{ has_colimits_of_shape := Œª J ùí•, by exactI
  { has_colimit := Œª F, has_colimit.mk
    { cocone := colimit_cocone F, is_colimit := colimit_cocone_is_colimit F } } }
instance : has_colimits (Type u) := types.has_colimits_of_size.{u u}
noncomputable
def colimit_equiv_quot (F : J ‚•§ Type (max v u)) : (colimit F : Type (max v u)) ‚âÉ quot F :=
(is_colimit.cocone_point_unique_up_to_iso
  (colimit.is_colimit F)
  (colimit_cocone_is_colimit F)).to_equiv
@[simp]
lemma colimit_equiv_quot_symm_apply (F : J ‚•§ Type (max v u)) (j : J) (x : F.obj j) :
  (colimit_equiv_quot F).symm (quot.mk _ ‚ü®j, x‚ü©) = colimit.Œπ F j x :=
rfl
@[simp]
lemma colimit_equiv_quot_apply (F : J ‚•§ Type (max v u)) (j : J) (x : F.obj j) :
  (colimit_equiv_quot F) (colimit.Œπ F j x) = quot.mk _ ‚ü®j, x‚ü© :=
begin
  apply (colimit_equiv_quot F).symm.injective,
  simp,
end
@[simp]
lemma colimit.w_apply {F : J ‚•§ Type (max v u)} {j j' : J} {x : F.obj j} (f : j ‚ü∂ j') :
  colimit.Œπ F j' (F.map f x) = colimit.Œπ F j x :=
congr_fun (colimit.w F f) x
@[simp]
lemma colimit.Œπ_desc_apply (F : J ‚•§ Type (max v u)) (s : cocone F) (j : J) (x : F.obj j) :
  colimit.desc F s (colimit.Œπ F j x) = s.Œπ.app j x :=
congr_fun (colimit.Œπ_desc s j) x
@[simp]
lemma colimit.Œπ_map_apply {F G : J ‚•§ Type (max v u)} (Œ± : F ‚ü∂ G) (j : J) (x) :
  colim.map Œ± (colimit.Œπ F j x) = colimit.Œπ G j (Œ±.app j x) :=
congr_fun (colimit.Œπ_map Œ± j) x
@[simp]
lemma colimit.w_apply' {F : J ‚•§ Type v} {j j' : J} {x : F.obj j} (f : j ‚ü∂ j') :
  colimit.Œπ F j' (F.map f x) = colimit.Œπ F j x :=
congr_fun (colimit.w F f) x
@[simp]
lemma colimit.Œπ_desc_apply' (F : J ‚•§ Type v) (s : cocone F) (j : J) (x : F.obj j) :
  colimit.desc F s (colimit.Œπ F j x) = s.Œπ.app j x :=
congr_fun (colimit.Œπ_desc s j) x
@[simp]
lemma colimit.Œπ_map_apply' {F G : J ‚•§ Type v} (Œ± : F ‚ü∂ G) (j : J) (x) :
  colim.map Œ± (colimit.Œπ F j x) = colimit.Œπ G j (Œ±.app j x) :=
congr_fun (colimit.Œπ_map Œ± j) x
lemma colimit_sound
  {F : J ‚•§ Type (max v u)} {j j' : J} {x : F.obj j} {x' : F.obj j'}
  (f : j ‚ü∂ j') (w : F.map f x = x') : colimit.Œπ F j x = colimit.Œπ F j' x' :=
begin
  rw [‚Üêw],
  simp,
end
lemma colimit_sound'
  {F : J ‚•§ Type (max v u)} {j j' : J} {x : F.obj j} {x' : F.obj j'} {j'' : J}
  (f : j ‚ü∂ j'') (f' : j' ‚ü∂ j'') (w : F.map f x = F.map f' x') :
  colimit.Œπ F j x = colimit.Œπ F j' x' :=
begin
  rw [‚Üêcolimit.w _ f, ‚Üêcolimit.w _ f'],
  rw [types_comp_apply, types_comp_apply, w],
end
lemma colimit_eq {F : J ‚•§ Type (max v u)} {j j' : J} {x : F.obj j} {x' : F.obj j'}
  (w : colimit.Œπ F j x = colimit.Œπ F j' x') : eqv_gen (quot.rel F) ‚ü®j, x‚ü© ‚ü®j', x'‚ü© :=
begin
  apply quot.eq.1,
  simpa using congr_arg (colimit_equiv_quot F) w,
end
lemma jointly_surjective (F : J ‚•§ Type (max v u)) {t : cocone F} (h : is_colimit t)
  (x : t.X) : ‚àÉ j y, t.Œπ.app j y = x :=
begin
  suffices : (Œª (x : t.X), ulift.up (‚àÉ j y, t.Œπ.app j y = x)) = (Œª _, ulift.up true),
  { have := congr_fun this x,
    have H := congr_arg ulift.down this,
    dsimp at H,
    rwa eq_true at H },
  refine h.hom_ext _,
  intro j, ext y,
  erw iff_true,
  exact ‚ü®j, y, rfl‚ü©
end
lemma jointly_surjective' {F : J ‚•§ Type (max v u)}
  (x : colimit F) : ‚àÉ j y, colimit.Œπ F j y = x :=
jointly_surjective F (colimit.is_colimit _) x
namespace filtered_colimit
variables (F : J ‚•§ Type (max v u))
protected def rel (x y : Œ£ j, F.obj j) : Prop :=
‚àÉ k (f : x.1 ‚ü∂ k) (g : y.1 ‚ü∂ k), F.map f x.2 = F.map g y.2
lemma rel_of_quot_rel (x y : Œ£ j, F.obj j) : quot.rel F x y ‚Üí filtered_colimit.rel F x y :=
Œª ‚ü®f, h‚ü©, ‚ü®y.1, f, ùüô y.1, by rw [‚Üê h, functor_to_types.map_id_apply]‚ü©
lemma eqv_gen_quot_rel_of_rel (x y : Œ£ j, F.obj j) :
  filtered_colimit.rel F x y ‚Üí eqv_gen (quot.rel F) x y :=
Œª ‚ü®k, f, g, h‚ü©, eqv_gen.trans _ ‚ü®k, F.map f x.2‚ü© _ (eqv_gen.rel _ _ ‚ü®f, rfl‚ü©)
  (eqv_gen.symm _ _ (eqv_gen.rel _ _ ‚ü®g, h‚ü©))
local attribute [elab_simple] nat_trans.app
noncomputable def is_colimit_of (t : cocone F) (hsurj : ‚àÄ (x : t.X), ‚àÉ i xi, x = t.Œπ.app i xi)
  (hinj : ‚àÄ i j xi xj, t.Œπ.app i xi = t.Œπ.app j xj ‚Üí
   ‚àÉ k (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj) : is_colimit t :=
def image : Type u := set.range f
instance [inhabited Œ±] : inhabited (image f) :=
{ default := ‚ü®f default, ‚ü®_, rfl‚ü©‚ü© }
def image.Œπ : image f ‚ü∂ Œ≤ := subtype.val
instance : mono (image.Œπ f) :=
(mono_iff_injective _).2 subtype.val_injective
variables {f}
noncomputable def image.lift (F' : mono_factorisation f) : image f ‚ü∂ F'.I :=
(Œª x, F'.e (classical.indefinite_description _ x.2).1 : image f ‚Üí F'.I)
lemma image.lift_fac (F' : mono_factorisation f) : image.lift F' ‚â´ F'.m = image.Œπ f :=
begin
  ext x,
  change (F'.e ‚â´ F'.m) _ = _,
  rw [F'.fac, (classical.indefinite_description _ x.2).2],
  refl,
end
end
def mono_factorisation : mono_factorisation f :=
{ I := image f,
  m := image.Œπ f,
  e := set.range_factorization f }
noncomputable def is_image : is_image (mono_factorisation f) :=
{ lift := image.lift,
  lift_fac' := image.lift_fac }
instance : has_image f :=
has_image.mk ‚ü®_, is_image f‚ü©
instance : has_images (Type u) :=
{ has_image := by apply_instance }
instance : has_image_maps (Type u) :=
{ has_image_map := Œª f g st, has_image_map.transport st (mono_factorisation f.hom) (is_image g.hom)
    (Œª x, ‚ü®st.right x.1, ‚ü®st.left (classical.some x.2),
      begin
        have p := st.w,
        replace p := congr_fun p (classical.some x.2),
        simp only [functor.id_map, types_comp_apply, subtype.val_eq_coe] at p,
        erw [p, classical.some_spec x.2],
      end‚ü©‚ü©) rfl }
end category_theory.limits.types
