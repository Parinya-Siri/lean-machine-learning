import category_theory.monoidal.rigid.basic
import category_theory.monoidal.subcategory
import linear_algebra.tensor_product_basis
import linear_algebra.coevaluation
import algebra.category.Module.monoidal
noncomputable theory
open category_theory Module.monoidal_category
open_locale classical big_operators
universes u
variables (K : Type u) [field K]
instance monoidal_predicate_finite_dimensional :
  monoidal_category.monoidal_predicate (Î» V : Module.{u} K, finite_dimensional K V) :=
{ prop_id' := finite_dimensional.finite_dimensional_self K,
  prop_tensor' := Î» X Y hX hY, by exactI module.finite.tensor_product K X Y }
@[derive [large_category, Î» Î±, has_coe_to_sort Î± (Sort*), concrete_category, monoidal_category,
  symmetric_category]]
def FinVect := { V : Module.{u} K // finite_dimensional K V }
namespace FinVect
instance finite_dimensional (V : FinVect K) : finite_dimensional K V := V.prop
instance : inhabited (FinVect K) := âŸ¨âŸ¨Module.of K K, finite_dimensional.finite_dimensional_self KâŸ©âŸ©
instance : has_coe (FinVect.{u} K) (Module.{u} K) := { coe := Î» V, V.1, }
protected lemma coe_comp {U V W : FinVect K} (f : U âŸ¶ V) (g : V âŸ¶ W) :
  ((f â‰« g) : U â†’ W) = (g : V â†’ W) âˆ˜ (f : U â†’ V) := rfl
def of (V : Type u) [add_comm_group V] [module K V] [finite_dimensional K V] : FinVect K :=
âŸ¨Module.of K V, by { change finite_dimensional K V, apply_instance }âŸ©
instance : has_forgetâ‚‚ (FinVect.{u} K) (Module.{u} K) :=
by { dsimp [FinVect], apply_instance, }
instance : full (forgetâ‚‚ (FinVect K) (Module.{u} K)) :=
{ preimage := Î» X Y f, f, }
variables (V : FinVect K)
def FinVect_dual : FinVect K :=
âŸ¨Module.of K (module.dual K V), subspace.module.dual.finite_dimensionalâŸ©
instance : has_coe_to_fun (FinVect_dual K V) (Î» _, V â†’ K) :=
{ coe := Î» v, by { change V â†’â‚—[K] K at v, exact v, } }
open category_theory.monoidal_category
def FinVect_coevaluation : ğŸ™_ (FinVect K) âŸ¶ V âŠ— (FinVect_dual K V) :=
by apply coevaluation K V
lemma FinVect_coevaluation_apply_one : FinVect_coevaluation K V (1 : K) =
   âˆ‘ (i : basis.of_vector_space_index K V),
    (basis.of_vector_space K V) i âŠ—â‚œ[K] (basis.of_vector_space K V).coord i :=
by apply coevaluation_apply_one K V
def FinVect_evaluation : (FinVect_dual K V) âŠ— V âŸ¶ ğŸ™_ (FinVect K) :=
by apply contract_left K V
@[simp]
lemma FinVect_evaluation_apply (f : (FinVect_dual K V)) (x : V) :
  (FinVect_evaluation K V) (f âŠ—â‚œ x) = f x :=
by apply contract_left_apply f x
private theorem coevaluation_evaluation :
  let V' : FinVect K := FinVect_dual K V in
  (ğŸ™ V' âŠ— (FinVect_coevaluation K V)) â‰« (Î±_ V' V V').inv â‰« (FinVect_evaluation K V âŠ— ğŸ™ V')
  = (Ï_ V').hom â‰« (Î»_ V').inv :=
by apply contract_left_assoc_coevaluation K V
private theorem evaluation_coevaluation :
  (FinVect_coevaluation K V âŠ— ğŸ™ V)
  â‰« (Î±_ V (FinVect_dual K V) V).hom â‰« (ğŸ™ V âŠ— FinVect_evaluation K V)
  = (Î»_ V).hom â‰« (Ï_ V).inv :=
by apply contract_left_assoc_coevaluation' K V
instance exact_pairing : exact_pairing V (FinVect_dual K V) :=
{ coevaluation := FinVect_coevaluation K V,
  evaluation := FinVect_evaluation K V,
  coevaluation_evaluation' := coevaluation_evaluation K V,
  evaluation_coevaluation' := evaluation_coevaluation K V }
instance right_dual : has_right_dual V := âŸ¨FinVect_dual K VâŸ©
instance right_rigid_category : right_rigid_category (FinVect K) := { }
variables {K V} (W : FinVect K)
def iso_to_linear_equiv {V W : FinVect K} (i : V â‰… W) : V â‰ƒâ‚—[K] W :=
  ((forgetâ‚‚ (FinVect.{u} K) (Module.{u} K)).map_iso i).to_linear_equiv
lemma iso.conj_eq_conj {V W : FinVect K} (i : V â‰… W) (f : End V) :
  iso.conj i f = linear_equiv.conj (iso_to_linear_equiv i) f := rfl
end FinVect
variables {K}
@[simps] def linear_equiv.to_FinVect_iso
  {V W : Type u} [add_comm_group V] [module K V] [finite_dimensional K V]
  [add_comm_group W] [module K W] [finite_dimensional K W]
  (e : V â‰ƒâ‚—[K] W) :
  FinVect.of K V â‰… FinVect.of K W :=
{ hom := e.to_linear_map,
  inv := e.symm.to_linear_map,
  hom_inv_id' := by {ext, exact e.left_inv x},
  inv_hom_id' := by {ext, exact e.right_inv x} }
