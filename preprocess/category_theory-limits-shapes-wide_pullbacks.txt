import category_theory.limits.has_limits
import category_theory.thin
universes w w' v u
open category_theory category_theory.limits opposite
namespace category_theory.limits
variable (J : Type w)
@[derive inhabited]
def wide_pullback_shape := option J
@[derive inhabited]
def wide_pushout_shape := option J
namespace wide_pullback_shape
variable {J}
@[derive decidable_eq]
inductive hom : wide_pullback_shape J â†’ wide_pullback_shape J â†’ Type w
| id : Î  X, hom X X
| term : Î  (j : J), hom (some j) none
attribute [nolint unused_arguments] hom.decidable_eq
instance struct : category_struct (wide_pullback_shape J) :=
{ hom := hom,
  id := Î» j, hom.id j,
  comp := Î» jâ‚ jâ‚‚ jâ‚ƒ f g,
  begin
    cases f,
      exact g,
    cases g,
    apply hom.term _
  end }
instance hom.inhabited : inhabited (hom none none) := âŸ¨hom.id (none : wide_pullback_shape J)âŸ©
local attribute [tidy] tactic.case_bash
instance subsingleton_hom (j j' : wide_pullback_shape J) : subsingleton (j âŸ¶ j') :=
âŸ¨by tidyâŸ©
instance category : small_category (wide_pullback_shape J) := thin_category
@[simp] lemma hom_id (X : wide_pullback_shape J) : hom.id X = ğŸ™ X := rfl
variables {C : Type u} [category.{v} C]
@[simps]
def wide_cospan (B : C) (objs : J â†’ C) (arrows : Î  (j : J), objs j âŸ¶ B) :
  wide_pullback_shape J â¥¤ C :=
{ obj := Î» j, option.cases_on j B objs,
  map := Î» X Y f,
  begin
    cases f with _ j,
    { apply (ğŸ™ _) },
    { exact arrows j }
  end,
  map_comp' := Î» _ _ _ f g,
  begin
    cases f,
    { simpa },
    cases g,
    simp
  end }
def diagram_iso_wide_cospan (F : wide_pullback_shape J â¥¤ C) :
  F â‰… wide_cospan (F.obj none) (Î» j, F.obj (some j)) (Î» j, F.map (hom.term j)) :=
nat_iso.of_components (Î» j, eq_to_iso $ by tidy) $ by tidy
@[simps]
def mk_cone {F : wide_pullback_shape J â¥¤ C} {X : C}
  (f : X âŸ¶ F.obj none) (Ï€ : Î  j, X âŸ¶ F.obj (some j))
  (w : âˆ€ j, Ï€ j â‰« F.map (hom.term j) = f) : cone F :=
{ X := X,
  Ï€ :=
  { app := Î» j, match j with
    | none := f
    | (some j) := Ï€ j
    end,
    naturality' := Î» j j' f, by { cases j; cases j'; cases f; unfold_aux; dsimp; simp [w], }, } }
def equivalence_of_equiv (J' : Type w') (h : J â‰ƒ J') :
  wide_pullback_shape J â‰Œ wide_pullback_shape J' :=
{ functor := wide_cospan none (Î» j, some (h j)) (Î» j, hom.term (h j)),
  inverse := wide_cospan none (Î» j, some (h.inv_fun j)) (Î» j, hom.term (h.inv_fun j)),
  unit_iso := nat_iso.of_components (Î» j, by cases j; simp)
    (Î» j k f, by { simp only [eq_iff_true_of_subsingleton]}),
  counit_iso := nat_iso.of_components (Î» j, by cases j; simp)
    (Î» j k f, by { simp only [eq_iff_true_of_subsingleton]}) }
def ulift_equivalence :
  ulift_hom.{w'} (ulift.{w'} (wide_pullback_shape J)) â‰Œ wide_pullback_shape (ulift J) :=
(ulift_hom_ulift_category.equiv.{w' w' w w} (wide_pullback_shape J)).symm.trans
  (equivalence_of_equiv _ (equiv.ulift.{w' w}.symm : J â‰ƒ ulift.{w'} J))
end wide_pullback_shape
namespace wide_pushout_shape
variable {J}
@[derive decidable_eq]
inductive hom : wide_pushout_shape J â†’ wide_pushout_shape J â†’ Type w
| id : Î  X, hom X X
| init : Î  (j : J), hom none (some j)
attribute [nolint unused_arguments] hom.decidable_eq
instance struct : category_struct (wide_pushout_shape J) :=
{ hom := hom,
  id := Î» j, hom.id j,
  comp := Î» jâ‚ jâ‚‚ jâ‚ƒ f g,
  begin
    cases f,
      exact g,
    cases g,
    apply hom.init _
  end }
instance hom.inhabited : inhabited (hom none none) := âŸ¨hom.id (none : wide_pushout_shape J)âŸ©
local attribute [tidy] tactic.case_bash
instance subsingleton_hom (j j' : wide_pushout_shape J) : subsingleton (j âŸ¶ j') :=
âŸ¨by tidyâŸ©
instance category : small_category (wide_pushout_shape J) := thin_category
@[simp] lemma hom_id (X : wide_pushout_shape J) : hom.id X = ğŸ™ X := rfl
variables {C : Type u} [category.{v} C]
@[simps]
def wide_span (B : C) (objs : J â†’ C) (arrows : Î  (j : J), B âŸ¶ objs j) : wide_pushout_shape J â¥¤ C :=
{ obj := Î» j, option.cases_on j B objs,
  map := Î» X Y f,
  begin
    cases f with _ j,
    { apply (ğŸ™ _) },
    { exact arrows j }
  end,
  map_comp' := by { rintros (_|_) (_|_) (_|_) (_|_) (_|_); simpa <|> simp } }
def diagram_iso_wide_span (F : wide_pushout_shape J â¥¤ C) :
  F â‰… wide_span (F.obj none) (Î» j, F.obj (some j)) (Î» j, F.map (hom.init j)) :=
nat_iso.of_components (Î» j, eq_to_iso $ by tidy) $ by tidy
@[simps]
def mk_cocone {F : wide_pushout_shape J â¥¤ C} {X : C}
  (f : F.obj none âŸ¶ X) (Î¹ : Î  j, F.obj (some j) âŸ¶ X)
  (w : âˆ€ j, F.map (hom.init j) â‰« Î¹ j = f) : cocone F :=
{ X := X,
  Î¹ :=
  { app := Î» j, match j with
    | none := f
    | (some j) := Î¹ j
    end,
    naturality' := Î» j j' f, by { cases j; cases j'; cases f; unfold_aux; dsimp; simp [w], }, } }
end wide_pushout_shape
variables (C : Type u) [category.{v} C]
abbreviation has_wide_pullbacks : Prop :=
Î  (J : Type w), has_limits_of_shape (wide_pullback_shape J) C
abbreviation has_wide_pushouts : Prop :=
Î  (J : Type w), has_colimits_of_shape (wide_pushout_shape J) C
variables {C J}
abbreviation has_wide_pullback (B : C) (objs : J â†’ C)
  (arrows : Î  (j : J), objs j âŸ¶ B) : Prop :=
has_limit (wide_pullback_shape.wide_cospan B objs arrows)
abbreviation has_wide_pushout (B : C) (objs : J â†’ C)
  (arrows : Î  (j : J), B âŸ¶ objs j) : Prop :=
has_colimit (wide_pushout_shape.wide_span B objs arrows)
noncomputable
abbreviation wide_pullback (B : C) (objs : J â†’ C) (arrows : Î  (j : J), objs j âŸ¶ B)
  [has_wide_pullback B objs arrows] : C :=
limit (wide_pullback_shape.wide_cospan B objs arrows)
noncomputable
abbreviation wide_pushout (B : C) (objs : J â†’ C) (arrows : Î  (j : J), B âŸ¶ objs j)
  [has_wide_pushout B objs arrows] : C :=
colimit (wide_pushout_shape.wide_span B objs arrows)
variable (C)
namespace wide_pullback
variables {C} {B : C} {objs : J â†’ C} (arrows : Î  (j : J), objs j âŸ¶ B)
variables [has_wide_pullback B objs arrows]
noncomputable
abbreviation Ï€ (j : J) : wide_pullback _ _ arrows âŸ¶ objs j :=
limit.Ï€ (wide_pullback_shape.wide_cospan _ _ _) (option.some j)
noncomputable
abbreviation base : wide_pullback _ _ arrows âŸ¶ B :=
limit.Ï€ (wide_pullback_shape.wide_cospan _ _ _) option.none
@[simp, reassoc]
lemma Ï€_arrow (j : J) : Ï€ arrows j â‰« arrows _ = base arrows :=
by apply limit.w (wide_pullback_shape.wide_cospan _ _ _) (wide_pullback_shape.hom.term j)
variables {arrows}
noncomputable
abbreviation lift {X : C} (f : X âŸ¶ B) (fs : Î  (j : J), X âŸ¶ objs j)
  (w : âˆ€ j, fs j â‰« arrows j = f) : X âŸ¶ wide_pullback _ _ arrows :=
limit.lift (wide_pullback_shape.wide_cospan _ _ _)
  (wide_pullback_shape.mk_cone f fs $ by exact w)
variables (arrows)
variables {X : C} (f : X âŸ¶ B) (fs : Î  (j : J), X âŸ¶ objs j)
  (w : âˆ€ j, fs j â‰« arrows j = f)
@[simp, reassoc]
lemma lift_Ï€ (j : J) : lift f fs w â‰« Ï€ arrows j = fs _ :=
by { simp, refl }
@[simp, reassoc]
lemma lift_base : lift f fs w â‰« base arrows = f :=
by { simp, refl }
lemma eq_lift_of_comp_eq (g : X âŸ¶ wide_pullback _ _ arrows) :
  (âˆ€ j : J, g â‰« Ï€ arrows j = fs j) â†’ g â‰« base arrows = f â†’ g = lift f fs w :=
begin
  intros h1 h2,
  apply (limit.is_limit (wide_pullback_shape.wide_cospan B objs arrows)).uniq
    (wide_pullback_shape.mk_cone f fs $ by exact w),
  rintro (_|_),
  { apply h2 },
  { apply h1 }
end
lemma hom_eq_lift (g : X âŸ¶ wide_pullback _ _ arrows) :
  g = lift (g â‰« base arrows) (Î» j, g â‰« Ï€ arrows j) (by tidy) :=
begin
  apply eq_lift_of_comp_eq,
  tidy,
end
@[ext]
lemma hom_ext (g1 g2 : X âŸ¶ wide_pullback _ _ arrows) :
  (âˆ€ j : J, g1 â‰« Ï€ arrows j = g2 â‰« Ï€ arrows j) â†’
  g1 â‰« base arrows = g2 â‰« base arrows â†’ g1 = g2 :=
begin
  intros h1 h2,
  apply limit.hom_ext,
  rintros (_|_),
  { apply h2 },
  { apply h1 },
end
end wide_pullback
namespace wide_pushout
variables {C} {B : C} {objs : J â†’ C} (arrows : Î  (j : J), B âŸ¶ objs j)
variables [has_wide_pushout B objs arrows]
noncomputable
abbreviation Î¹ (j : J) : objs j âŸ¶ wide_pushout _ _ arrows :=
colimit.Î¹ (wide_pushout_shape.wide_span _ _ _) (option.some j)
noncomputable
abbreviation head : B âŸ¶ wide_pushout B objs arrows :=
colimit.Î¹ (wide_pushout_shape.wide_span _ _ _) option.none
@[simp, reassoc]
lemma arrow_Î¹ (j : J) : arrows j â‰« Î¹ arrows j = head arrows :=
by apply colimit.w (wide_pushout_shape.wide_span _ _ _) (wide_pushout_shape.hom.init j)
variables {arrows}
noncomputable
abbreviation desc {X : C} (f : B âŸ¶ X) (fs : Î  (j : J), objs j âŸ¶ X)
  (w : âˆ€ j, arrows j â‰« fs j = f) : wide_pushout _ _ arrows âŸ¶ X :=
colimit.desc (wide_pushout_shape.wide_span B objs arrows)
  (wide_pushout_shape.mk_cocone f fs $ by exact w)
variables (arrows)
variables {X : C} (f : B âŸ¶ X) (fs : Î  (j : J), objs j âŸ¶ X)
  (w : âˆ€ j, arrows j â‰« fs j = f)
@[simp, reassoc]
lemma Î¹_desc (j : J) : Î¹ arrows j â‰« desc f fs w = fs _ :=
by { simp, refl }
@[simp, reassoc]
lemma head_desc : head arrows â‰« desc f fs w = f :=
by { simp, refl }
lemma eq_desc_of_comp_eq (g : wide_pushout _ _ arrows âŸ¶ X) :
  (âˆ€ j : J, Î¹ arrows j â‰« g = fs j) â†’ head arrows â‰« g = f â†’ g = desc f fs w :=
begin
  intros h1 h2,
  apply (colimit.is_colimit (wide_pushout_shape.wide_span B objs arrows)).uniq
    (wide_pushout_shape.mk_cocone f fs $ by exact w),
  rintro (_|_),
  { apply h2 },
  { apply h1 }
end
lemma hom_eq_desc (g : wide_pushout _ _ arrows âŸ¶ X) :
  g = desc (head arrows â‰« g) (Î» j, Î¹ arrows j â‰« g) (Î» j, by { rw â† category.assoc, simp }) :=
begin
  apply eq_desc_of_comp_eq,
  tidy,
end
@[ext]
lemma hom_ext (g1 g2 : wide_pushout _ _ arrows âŸ¶ X) :
  (âˆ€ j : J, Î¹ arrows j â‰« g1 = Î¹ arrows j â‰« g2) â†’
  head arrows â‰« g1 = head arrows â‰« g2 â†’ g1 = g2 :=
begin
  intros h1 h2,
  apply colimit.hom_ext,
  rintros (_|_),
  { apply h2 },
  { apply h1 },
end
end wide_pushout
variable (J)
def wide_pullback_shape_op_map : Î  (X Y : wide_pullback_shape J),
  (X âŸ¶ Y) â†’ ((op X : (wide_pushout_shape J)áµ’áµ–) âŸ¶ (op Y : (wide_pushout_shape J)áµ’áµ–))
| _ _ (wide_pullback_shape.hom.id X) := quiver.hom.op (wide_pushout_shape.hom.id _)
| _ _ (wide_pullback_shape.hom.term j) := quiver.hom.op (wide_pushout_shape.hom.init _)
@[simps]
def wide_pullback_shape_op : wide_pullback_shape J â¥¤ (wide_pushout_shape J)áµ’áµ– :=
{ obj := Î» X, op X,
  map := wide_pullback_shape_op_map J, }
def wide_pushout_shape_op_map : Î  (X Y : wide_pushout_shape J),
  (X âŸ¶ Y) â†’ ((op X : (wide_pullback_shape J)áµ’áµ–) âŸ¶ (op Y : (wide_pullback_shape J)áµ’áµ–))
| _ _ (wide_pushout_shape.hom.id X) := quiver.hom.op (wide_pullback_shape.hom.id _)
| _ _ (wide_pushout_shape.hom.init j) := quiver.hom.op (wide_pullback_shape.hom.term _)
@[simps]
def wide_pushout_shape_op : wide_pushout_shape J â¥¤ (wide_pullback_shape J)áµ’áµ– :=
{ obj := Î» X, op X,
  map := wide_pushout_shape_op_map J, }
@[simps]
def wide_pullback_shape_unop : (wide_pullback_shape J)áµ’áµ– â¥¤ wide_pushout_shape J :=
(wide_pullback_shape_op J).left_op
@[simps]
def wide_pushout_shape_unop : (wide_pushout_shape J)áµ’áµ– â¥¤ wide_pullback_shape J :=
(wide_pushout_shape_op J).left_op
def wide_pushout_shape_op_unop : wide_pushout_shape_unop J â‹™ wide_pullback_shape_op J â‰… ğŸ­ _ :=
nat_iso.of_components (Î» X, iso.refl _) (Î» X Y f, dec_trivial)
def wide_pushout_shape_unop_op : wide_pushout_shape_op J â‹™ wide_pullback_shape_unop J â‰… ğŸ­ _ :=
nat_iso.of_components (Î» X, iso.refl _) (Î» X Y f, dec_trivial)
def wide_pullback_shape_op_unop : wide_pullback_shape_unop J â‹™ wide_pushout_shape_op J â‰… ğŸ­ _ :=
nat_iso.of_components (Î» X, iso.refl _) (Î» X Y f, dec_trivial)
def wide_pullback_shape_unop_op : wide_pullback_shape_op J â‹™ wide_pushout_shape_unop J â‰… ğŸ­ _ :=
nat_iso.of_components (Î» X, iso.refl _) (Î» X Y f, dec_trivial)
@[simps]
def wide_pushout_shape_op_equiv : (wide_pushout_shape J)áµ’áµ– â‰Œ wide_pullback_shape J :=
{ functor := wide_pushout_shape_unop J,
  inverse := wide_pullback_shape_op J,
  unit_iso := (wide_pushout_shape_op_unop J).symm,
  counit_iso := wide_pullback_shape_unop_op J, }
@[simps]
def wide_pullback_shape_op_equiv : (wide_pullback_shape J)áµ’áµ– â‰Œ wide_pushout_shape J :=
{ functor := wide_pullback_shape_unop J,
  inverse := wide_pushout_shape_op J,
  unit_iso := (wide_pullback_shape_op_unop J).symm,
  counit_iso := wide_pushout_shape_unop_op J, }
lemma has_wide_pullbacks_shrink [has_wide_pullbacks.{max w w'} C] : has_wide_pullbacks.{w} C :=
Î» J, has_limits_of_shape_of_equivalence
  (wide_pullback_shape.equivalence_of_equiv _ equiv.ulift.{w'})
end category_theory.limits
