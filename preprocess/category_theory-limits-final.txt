import category_theory.punit
import category_theory.structured_arrow
import category_theory.is_connected
import category_theory.limits.yoneda
import category_theory.limits.types
noncomputable theory
universes v u
namespace category_theory
namespace functor
open opposite
open category_theory.limits
variables {C : Type v} [small_category C]
variables {D : Type v} [small_category D]
class final (F : C ‚•§ D) : Prop :=
(out (d : D) : is_connected (structured_arrow d F))
attribute [instance] final.out
class initial (F : C ‚•§ D) : Prop :=
(out (d : D) : is_connected (costructured_arrow F d))
attribute [instance] initial.out
instance final_op_of_initial (F : C ‚•§ D) [initial F] : final F.op :=
{ out := Œª d, is_connected_of_equivalent (costructured_arrow_op_equivalence F (unop d)) }
instance initial_op_of_final (F : C ‚•§ D) [final F] : initial F.op :=
{ out := Œª d, is_connected_of_equivalent (structured_arrow_op_equivalence F (unop d)) }
lemma final_of_initial_op (F : C ‚•§ D) [initial F.op] : final F :=
{ out := Œª d, @is_connected_of_is_connected_op _ _
  (is_connected_of_equivalent (structured_arrow_op_equivalence F d).symm) }
lemma initial_of_final_op (F : C ‚•§ D) [final F.op] : initial F :=
{ out := Œª d, @is_connected_of_is_connected_op _ _
  (is_connected_of_equivalent (costructured_arrow_op_equivalence F d).symm) }
lemma final_of_adjunction {L : C ‚•§ D} {R : D ‚•§ C} (adj : L ‚ä£ R) : final R :=
{ out := Œª c,
  let u : structured_arrow c R := structured_arrow.mk (adj.unit.app c) in
  @zigzag_is_connected _ _ ‚ü®u‚ü© $ Œª f g, relation.refl_trans_gen.trans
    (relation.refl_trans_gen.single (show zag f u, from
      or.inr ‚ü®structured_arrow.hom_mk ((adj.hom_equiv c f.right).symm f.hom) (by simp)‚ü©))
    (relation.refl_trans_gen.single (show zag u g, from
      or.inl ‚ü®structured_arrow.hom_mk ((adj.hom_equiv c g.right).symm g.hom) (by simp)‚ü©)) }
lemma initial_of_adjunction {L : C ‚•§ D} {R : D ‚•§ C} (adj : L ‚ä£ R) : initial L :=
{ out := Œª d,
  let u : costructured_arrow L d := costructured_arrow.mk (adj.counit.app d) in
  @zigzag_is_connected _ _ ‚ü®u‚ü© $ Œª f g, relation.refl_trans_gen.trans
    (relation.refl_trans_gen.single (show zag f u, from
      or.inl ‚ü®costructured_arrow.hom_mk (adj.hom_equiv f.left d f.hom) (by simp)‚ü©))
    (relation.refl_trans_gen.single (show zag u g, from
      or.inr ‚ü®costructured_arrow.hom_mk (adj.hom_equiv g.left d g.hom) (by simp)‚ü©)) }
@[priority 100]
instance final_of_is_right_adjoint (F : C ‚•§ D) [h : is_right_adjoint F] : final F :=
final_of_adjunction h.adj
@[priority 100]
instance initial_of_is_left_adjoint (F : C ‚•§ D) [h : is_left_adjoint F] : initial F :=
initial_of_adjunction h.adj
namespace final
variables (F : C ‚•§ D) [final F]
instance (d : D) : nonempty (structured_arrow d F) := is_connected.is_nonempty
variables {E : Type u} [category.{v} E] (G : D ‚•§ E)
def lift (d : D) : C :=
(classical.arbitrary (structured_arrow d F)).right
def hom_to_lift (d : D) : d ‚ü∂ F.obj (lift F d) :=
(classical.arbitrary (structured_arrow d F)).hom
def induction {d : D} (Z : Œ† (X : C) (k : d ‚ü∂ F.obj X), Sort*)
  (h‚ÇÅ : Œ† X‚ÇÅ X‚ÇÇ (k‚ÇÅ : d ‚ü∂ F.obj X‚ÇÅ) (k‚ÇÇ : d ‚ü∂ F.obj X‚ÇÇ) (f : X‚ÇÅ ‚ü∂ X‚ÇÇ),
    (k‚ÇÅ ‚â´ F.map f = k‚ÇÇ) ‚Üí Z X‚ÇÅ k‚ÇÅ ‚Üí Z X‚ÇÇ k‚ÇÇ)
  (h‚ÇÇ : Œ† X‚ÇÅ X‚ÇÇ (k‚ÇÅ : d ‚ü∂ F.obj X‚ÇÅ) (k‚ÇÇ : d ‚ü∂ F.obj X‚ÇÇ) (f : X‚ÇÅ ‚ü∂ X‚ÇÇ),
    (k‚ÇÅ ‚â´ F.map f = k‚ÇÇ) ‚Üí Z X‚ÇÇ k‚ÇÇ ‚Üí Z X‚ÇÅ k‚ÇÅ)
  {X‚ÇÄ : C} {k‚ÇÄ : d ‚ü∂ F.obj X‚ÇÄ} (z : Z X‚ÇÄ k‚ÇÄ) : Z (lift F d) (hom_to_lift F d) :=
begin
  apply nonempty.some,
  apply @is_preconnected_induction _ _ _
    (Œª (Y : structured_arrow d F), Z Y.right Y.hom) _ _ { right := X‚ÇÄ, hom := k‚ÇÄ, } z,
  { intros j‚ÇÅ j‚ÇÇ f a, fapply h‚ÇÅ _ _ _ _ f.right _ a, convert f.w.symm, dsimp, simp, },
  { intros j‚ÇÅ j‚ÇÇ f a, fapply h‚ÇÇ _ _ _ _ f.right _ a, convert f.w.symm, dsimp, simp, },
end
variables {F G}
@[simps]
def extend_cocone : cocone (F ‚ãô G) ‚•§ cocone G :=
{ obj := Œª c,
  { X := c.X,
    Œπ :=
    { app := Œª X, G.map (hom_to_lift F X) ‚â´ c.Œπ.app (lift F X),
      naturality' := Œª X Y f,
      begin
        dsimp, simp,
@[simps]
def cocones_equiv : cocone (F ‚ãô G) ‚âå cocone G :=
{ functor := extend_cocone,
  inverse := cocones.whiskering F,
  unit_iso := nat_iso.of_components (Œª c, cocones.ext (iso.refl _) (by tidy)) (by tidy),
  counit_iso := nat_iso.of_components (Œª c, cocones.ext (iso.refl _) (by tidy)) (by tidy), }.
variables {G}
def is_colimit_whisker_equiv (t : cocone G) : is_colimit (t.whisker F) ‚âÉ is_colimit t :=
is_colimit.of_cocone_equiv (cocones_equiv F G).symm
def is_colimit_extend_cocone_equiv (t : cocone (F ‚ãô G)) :
  is_colimit (extend_cocone.obj t) ‚âÉ is_colimit t :=
is_colimit.of_cocone_equiv (cocones_equiv F G)
@[simps]
def colimit_cocone_comp (t : colimit_cocone G) :
  colimit_cocone (F ‚ãô G) :=
{ cocone := _,
  is_colimit := (is_colimit_whisker_equiv F _).symm (t.is_colimit) }
@[priority 100]
instance comp_has_colimit [has_colimit G] :
  has_colimit (F ‚ãô G) :=
has_colimit.mk (colimit_cocone_comp F (get_colimit_cocone G))
lemma colimit_pre_is_iso_aux {t : cocone G} (P : is_colimit t) :
  ((is_colimit_whisker_equiv F _).symm P).desc (t.whisker F) = ùüô t.X :=
begin
  dsimp [is_colimit_whisker_equiv],
  apply P.hom_ext,
  intro j,
def colimit_iso [has_colimit G] : colimit (F ‚ãô G) ‚âÖ colimit G := as_iso (colimit.pre G F)
end
@[simps]
def colimit_cocone_of_comp (t : colimit_cocone (F ‚ãô G)) :
  colimit_cocone G :=
{ cocone := extend_cocone.obj t.cocone,
  is_colimit := (is_colimit_extend_cocone_equiv F _).symm (t.is_colimit), }
lemma has_colimit_of_comp [has_colimit (F ‚ãô G)] :
  has_colimit G :=
has_colimit.mk (colimit_cocone_of_comp F (get_colimit_cocone (F ‚ãô G)))
section
local attribute [instance] has_colimit_of_comp
def colimit_iso' [has_colimit (F ‚ãô G)] : colimit (F ‚ãô G) ‚âÖ colimit G := as_iso (colimit.pre G F)
end
def colimit_comp_coyoneda_iso (d : D) [is_iso (colimit.pre (coyoneda.obj (op d)) F)] :
  colimit (F ‚ãô coyoneda.obj (op d)) ‚âÖ punit :=
as_iso (colimit.pre (coyoneda.obj (op d)) F) ‚â™‚â´ coyoneda.colimit_coyoneda_iso (op d)
lemma zigzag_of_eqv_gen_quot_rel {F : C ‚•§ D} {d : D} {f‚ÇÅ f‚ÇÇ : Œ£ X, d ‚ü∂ F.obj X}
  (t : eqv_gen (types.quot.rel.{v v} (F ‚ãô coyoneda.obj (op d))) f‚ÇÅ f‚ÇÇ) :
  zigzag (structured_arrow.mk f‚ÇÅ.2) (structured_arrow.mk f‚ÇÇ.2) :=
begin
  induction t,
  case eqv_gen.rel : x y r
  { obtain ‚ü®f, w‚ü© := r,
    fconstructor,
    swap 2, fconstructor,
    left, fsplit,
    exact { right := f, } },
  case eqv_gen.refl
  { fconstructor, },
  case eqv_gen.symm : x y h ih
  { apply zigzag_symmetric,
    exact ih, },
  case eqv_gen.trans : x y z h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ
  { apply relation.refl_trans_gen.trans,
    exact ih‚ÇÅ, exact ih‚ÇÇ, }
end
lemma cofinal_of_colimit_comp_coyoneda_iso_punit
  (I : Œ† d, colimit (F ‚ãô coyoneda.obj (op d)) ‚âÖ punit) : final F :=
‚ü®Œª d, begin
  haveI : nonempty (structured_arrow d F),
  { have := (I d).inv punit.star,
    obtain ‚ü®j, y, rfl‚ü© := limits.types.jointly_surjective'.{v v} this,
    exact ‚ü®structured_arrow.mk y‚ü©, },
  apply zigzag_is_connected,
  rintros ‚ü®‚ü®‚ü®‚ü©‚ü©,X‚ÇÅ,f‚ÇÅ‚ü© ‚ü®‚ü®‚ü®‚ü©‚ü©,X‚ÇÇ,f‚ÇÇ‚ü©,
  dsimp at *,
  let y‚ÇÅ := colimit.Œπ (F ‚ãô coyoneda.obj (op d)) X‚ÇÅ f‚ÇÅ,
  let y‚ÇÇ := colimit.Œπ (F ‚ãô coyoneda.obj (op d)) X‚ÇÇ f‚ÇÇ,
  have e : y‚ÇÅ = y‚ÇÇ,
  { apply (I d).to_equiv.injective, ext, },
  have t := types.colimit_eq.{v v} e,
  clear e y‚ÇÅ y‚ÇÇ,
  exact zigzag_of_eqv_gen_quot_rel t,
end‚ü©
end final
namespace initial
variables (F : C ‚•§ D) [initial F]
instance (d : D) : nonempty (costructured_arrow F d) := is_connected.is_nonempty
variables {E : Type u} [category.{v} E] (G : D ‚•§ E)
def lift (d : D) : C := (classical.arbitrary (costructured_arrow F d)).left
def hom_to_lift (d : D) : F.obj (lift F d) ‚ü∂ d :=
  (classical.arbitrary (costructured_arrow F d)).hom
def induction {d : D} (Z : Œ† (X : C) (k : F.obj X ‚ü∂ d), Sort*)
  (h‚ÇÅ : Œ† X‚ÇÅ X‚ÇÇ (k‚ÇÅ : F.obj X‚ÇÅ ‚ü∂ d) (k‚ÇÇ : F.obj X‚ÇÇ ‚ü∂ d) (f : X‚ÇÅ ‚ü∂ X‚ÇÇ),
    (F.map f ‚â´ k‚ÇÇ = k‚ÇÅ) ‚Üí Z X‚ÇÅ k‚ÇÅ ‚Üí Z X‚ÇÇ k‚ÇÇ)
  (h‚ÇÇ : Œ† X‚ÇÅ X‚ÇÇ (k‚ÇÅ : F.obj X‚ÇÅ ‚ü∂ d) (k‚ÇÇ : F.obj X‚ÇÇ ‚ü∂ d) (f : X‚ÇÅ ‚ü∂ X‚ÇÇ),
    (F.map f ‚â´ k‚ÇÇ = k‚ÇÅ) ‚Üí Z X‚ÇÇ k‚ÇÇ ‚Üí Z X‚ÇÅ k‚ÇÅ)
  {X‚ÇÄ : C} {k‚ÇÄ : F.obj X‚ÇÄ ‚ü∂ d} (z : Z X‚ÇÄ k‚ÇÄ) : Z (lift F d) (hom_to_lift F d) :=
begin
  apply nonempty.some,
  apply @is_preconnected_induction _ _ _
    (Œª Y : costructured_arrow F d, Z Y.left Y.hom) _ _ { left := X‚ÇÄ, hom := k‚ÇÄ } z,
  { intros j‚ÇÅ j‚ÇÇ f a, fapply h‚ÇÅ _ _ _ _ f.left _ a, convert f.w, dsimp, simp, },
  { intros j‚ÇÅ j‚ÇÇ f a, fapply h‚ÇÇ _ _ _ _ f.left _ a, convert f.w, dsimp, simp, },
end
variables {F G}
@[simps]
def extend_cone : cone (F ‚ãô G) ‚•§ cone G :=
{ obj := Œª c,
  { X := c.X,
    œÄ :=
    { app := Œª d, c.œÄ.app (lift F d) ‚â´ G.map (hom_to_lift F d),
      naturality' := Œª X Y f,
      begin
        dsimp, simp,
@[simps]
def cones_equiv : cone (F ‚ãô G) ‚âå cone G :=
{ functor := extend_cone,
  inverse := cones.whiskering F,
  unit_iso := nat_iso.of_components (Œª c, cones.ext (iso.refl _) (by tidy)) (by tidy),
  counit_iso := nat_iso.of_components (Œª c, cones.ext (iso.refl _) (by tidy)) (by tidy), }.
variables {G}
def is_limit_whisker_equiv (t : cone G) : is_limit (t.whisker F) ‚âÉ is_limit t :=
is_limit.of_cone_equiv (cones_equiv F G).symm
def is_limit_extend_cone_equiv (t : cone (F ‚ãô G)) :
  is_limit (extend_cone.obj t) ‚âÉ is_limit t :=
is_limit.of_cone_equiv (cones_equiv F G)
@[simps]
def limit_cone_comp (t : limit_cone G) :
  limit_cone (F ‚ãô G) :=
{ cone := _,
  is_limit := (is_limit_whisker_equiv F _).symm (t.is_limit) }
@[priority 100]
instance comp_has_limit [has_limit G] :
  has_limit (F ‚ãô G) :=
has_limit.mk (limit_cone_comp F (get_limit_cone G))
lemma limit_pre_is_iso_aux {t : cone G} (P : is_limit t) :
  ((is_limit_whisker_equiv F _).symm P).lift (t.whisker F) = ùüô t.X :=
begin
  dsimp [is_limit_whisker_equiv],
  apply P.hom_ext,
  intro j,
  simp,
end
instance limit_pre_is_iso [has_limit G] :
  is_iso (limit.pre G F) :=
begin
  rw limit.pre_eq (limit_cone_comp F (get_limit_cone G)) (get_limit_cone G),
  erw limit_pre_is_iso_aux,
  dsimp,
  apply_instance,
end
section
variables (G)
def limit_iso [has_limit G] : limit (F ‚ãô G) ‚âÖ limit G := (as_iso (limit.pre G F)).symm
end
@[simps]
def limit_cone_of_comp (t : limit_cone (F ‚ãô G)) :
  limit_cone G :=
{ cone := extend_cone.obj t.cone,
  is_limit := (is_limit_extend_cone_equiv F _).symm (t.is_limit), }
lemma has_limit_of_comp [has_limit (F ‚ãô G)] :
  has_limit G :=
has_limit.mk (limit_cone_of_comp F (get_limit_cone (F ‚ãô G)))
section
local attribute [instance] has_limit_of_comp
def limit_iso' [has_limit (F ‚ãô G)] : limit (F ‚ãô G) ‚âÖ limit G :=
(as_iso (limit.pre G F)).symm
end
end initial
end functor
end category_theory
