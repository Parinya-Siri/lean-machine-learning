import data.fintype.basic
import category_theory.discrete_category
import category_theory.opposites
import category_theory.category.ulift
universes w v u
open_locale classical
noncomputable theory
namespace category_theory
instance discrete_fintype {Œ± : Type*} [fintype Œ±] : fintype (discrete Œ±) :=
fintype.of_equiv Œ± (discrete_equiv.symm)
instance discrete_hom_fintype {Œ± : Type*} (X Y : discrete Œ±) : fintype (X ‚ü∂ Y) :=
by { apply ulift.fintype }
class fin_category (J : Type v) [small_category J] :=
(fintype_obj : fintype J . tactic.apply_instance)
(fintype_hom : Œ† (j j' : J), fintype (j ‚ü∂ j') . tactic.apply_instance)
attribute [instance] fin_category.fintype_obj fin_category.fintype_hom
instance fin_category_discrete_of_fintype (J : Type v) [fintype J] :
  fin_category (discrete J) :=
{ }
namespace fin_category
variables (Œ± : Type*) [fintype Œ±] [small_category Œ±] [fin_category Œ±]
@[nolint unused_arguments]
abbreviation obj_as_type : Type := induced_category Œ± (fintype.equiv_fin Œ±).symm
noncomputable def obj_as_type_equiv : obj_as_type Œ± ‚âå Œ± :=
(induced_functor (fintype.equiv_fin Œ±).symm).as_equivalence
@[nolint unused_arguments] abbreviation as_type : Type := fin (fintype.card Œ±)
@[simps hom id comp (lemmas_only)] noncomputable
instance category_as_type : small_category (as_type Œ±) :=
{ hom := Œª i j, fin (fintype.card (@quiver.hom (obj_as_type Œ±) _ i j)),
  id := Œª i, fintype.equiv_fin _ (ùüô i),
  comp := Œª i j k f g, fintype.equiv_fin _
    ((fintype.equiv_fin _).symm f ‚â´ (fintype.equiv_fin _).symm g) }
local attribute [simp] category_as_type_hom category_as_type_id
  category_as_type_comp
@[simps] noncomputable def as_type_to_obj_as_type : as_type Œ± ‚•§ obj_as_type Œ± :=
{ obj := id, map := Œª i j, (fintype.equiv_fin _).symm }
@[simps] noncomputable def obj_as_type_to_as_type : obj_as_type Œ± ‚•§ as_type Œ± :=
{ obj := id, map := Œª i j, fintype.equiv_fin _ }
noncomputable def as_type_equiv_obj_as_type : as_type Œ± ‚âå obj_as_type Œ± :=
equivalence.mk (as_type_to_obj_as_type Œ±) (obj_as_type_to_as_type Œ±)
  (nat_iso.of_components iso.refl $ Œª _ _ _, by { dsimp, simp })
  (nat_iso.of_components iso.refl $ Œª _ _ _, by { dsimp, simp })
noncomputable
instance as_type_fin_category : fin_category (as_type Œ±) := {}
noncomputable def equiv_as_type : as_type Œ± ‚âå Œ± :=
(as_type_equiv_obj_as_type Œ±).trans (obj_as_type_equiv Œ±)
end fin_category
open opposite
instance fin_category_opposite {J : Type v} [small_category J] [fin_category J] :
  fin_category J·µí·µñ :=
{ fintype_obj := fintype.of_equiv _ equiv_to_opposite,
  fintype_hom := Œª j j', fintype.of_equiv _ (op_equiv j j').symm, }
instance fin_category_ulift {J : Type v} [small_category J] [fin_category J] :
  fin_category.{(max w v)} (ulift_hom.{w (max w v)} (ulift.{w v} J)) :=
{ fintype_obj := ulift.fintype J }
end category_theory
