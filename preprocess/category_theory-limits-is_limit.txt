import category_theory.adjunction.basic
import category_theory.limits.cones
noncomputable theory
open category_theory category_theory.category category_theory.functor opposite
namespace category_theory.limits
@[nolint has_inhabited_instance]
structure is_limit (t : cone F) :=
(lift  : Œ† (s : cone F), s.X ‚ü∂ t.X)
(fac'  : ‚àÄ (s : cone F) (j : J), lift s ‚â´ t.œÄ.app j = s.œÄ.app j . obviously)
(uniq' : ‚àÄ (s : cone F) (m : s.X ‚ü∂ t.X) (w : ‚àÄ j : J, m ‚â´ t.œÄ.app j = s.œÄ.app j),
  m = lift s . obviously)
restate_axiom is_limit.fac'
attribute [simp, reassoc] is_limit.fac
restate_axiom is_limit.uniq'
namespace is_limit
instance subsingleton {t : cone F} : subsingleton (is_limit t) :=
‚ü®by intros P Q; cases P; cases Q; congr; ext; solve_by_elim‚ü©
def map {F G : J ‚•§ C} (s : cone F) {t : cone G} (P : is_limit t)
  (Œ± : F ‚ü∂ G) : s.X ‚ü∂ t.X :=
P.lift ((cones.postcompose Œ±).obj s)
@[simp, reassoc] lemma map_œÄ {F G : J ‚•§ C} (c : cone F) {d : cone G} (hd : is_limit d)
  (Œ± : F ‚ü∂ G) (j : J) : hd.map c Œ± ‚â´ d.œÄ.app j = c.œÄ.app j ‚â´ Œ±.app j :=
fac _ _ _
lemma lift_self {c : cone F} (t : is_limit c) : t.lift c = ùüô c.X :=
(t.uniq _ _ (Œª j, id_comp _)).symm
@[simps]
def lift_cone_morphism {t : cone F} (h : is_limit t) (s : cone F) : s ‚ü∂ t :=
{ hom := h.lift s }
lemma uniq_cone_morphism {s t : cone F} (h : is_limit t) {f f' : s ‚ü∂ t} :
  f = f' :=
have ‚àÄ {g : s ‚ü∂ t}, g = h.lift_cone_morphism s, by intro g; ext; exact h.uniq _ _ g.w,
this.trans this.symm
lemma exists_unique {t : cone F} (h : is_limit t) (s : cone F) :
  ‚àÉ! (l : s.X ‚ü∂ t.X), ‚àÄ j, l ‚â´ t.œÄ.app j = s.œÄ.app j :=
‚ü®h.lift s, h.fac s, h.uniq s‚ü©
def of_exists_unique {t : cone F}
  (ht : ‚àÄ s : cone F, ‚àÉ! l : s.X ‚ü∂ t.X, ‚àÄ j, l ‚â´ t.œÄ.app j = s.œÄ.app j) : is_limit t :=
by { choose s hs hs' using ht, exact ‚ü®s, hs, hs'‚ü© }
@[simps]
def mk_cone_morphism {t : cone F}
  (lift : Œ† (s : cone F), s ‚ü∂ t)
  (uniq' : ‚àÄ (s : cone F) (m : s ‚ü∂ t), m = lift s) : is_limit t :=
{ lift := Œª s, (lift s).hom,
  uniq' := Œª s m w,
    have cone_morphism.mk m w = lift s, by apply uniq',
    congr_arg cone_morphism.hom this }
@[simps]
def unique_up_to_iso {s t : cone F} (P : is_limit s) (Q : is_limit t) : s ‚âÖ t :=
{ hom := Q.lift_cone_morphism s,
  inv := P.lift_cone_morphism t,
  hom_inv_id' := P.uniq_cone_morphism,
  inv_hom_id' := Q.uniq_cone_morphism }
lemma hom_is_iso {s t : cone F} (P : is_limit s) (Q : is_limit t) (f : s ‚ü∂ t) : is_iso f :=
‚ü®‚ü®P.lift_cone_morphism t, ‚ü®P.uniq_cone_morphism, Q.uniq_cone_morphism‚ü©‚ü©‚ü©
def cone_point_unique_up_to_iso {s t : cone F} (P : is_limit s) (Q : is_limit t) : s.X ‚âÖ t.X :=
(cones.forget F).map_iso (unique_up_to_iso P Q)
@[simp, reassoc] lemma cone_point_unique_up_to_iso_hom_comp {s t : cone F} (P : is_limit s)
  (Q : is_limit t) (j : J) : (cone_point_unique_up_to_iso P Q).hom ‚â´ t.œÄ.app j = s.œÄ.app j :=
(unique_up_to_iso P Q).hom.w _
@[simp, reassoc] lemma cone_point_unique_up_to_iso_inv_comp {s t : cone F} (P : is_limit s)
  (Q : is_limit t) (j : J) : (cone_point_unique_up_to_iso P Q).inv ‚â´ s.œÄ.app j = t.œÄ.app j :=
(unique_up_to_iso P Q).inv.w _
@[simp, reassoc] lemma lift_comp_cone_point_unique_up_to_iso_hom {r s t : cone F}
  (P : is_limit s) (Q : is_limit t) :
  P.lift r ‚â´ (cone_point_unique_up_to_iso P Q).hom = Q.lift r :=
Q.uniq _ _ (by simp)
@[simp, reassoc] lemma lift_comp_cone_point_unique_up_to_iso_inv {r s t : cone F}
  (P : is_limit s) (Q : is_limit t) :
  Q.lift r ‚â´ (cone_point_unique_up_to_iso P Q).inv = P.lift r :=
P.uniq _ _ (by simp)
def of_iso_limit {r t : cone F} (P : is_limit r) (i : r ‚âÖ t) : is_limit t :=
is_limit.mk_cone_morphism
  (Œª s, P.lift_cone_morphism s ‚â´ i.hom)
  (Œª s m, by rw ‚Üêi.comp_inv_eq; apply P.uniq_cone_morphism)
@[simp] lemma of_iso_limit_lift {r t : cone F} (P : is_limit r) (i : r ‚âÖ t) (s) :
  (P.of_iso_limit i).lift s = P.lift s ‚â´ i.hom.hom :=
rfl
def equiv_iso_limit {r t : cone F} (i : r ‚âÖ t) : is_limit r ‚âÉ is_limit t :=
{ to_fun := Œª h, h.of_iso_limit i,
  inv_fun := Œª h, h.of_iso_limit i.symm,
  left_inv := by tidy,
  right_inv := by tidy }
@[simp] lemma equiv_iso_limit_apply {r t : cone F} (i : r ‚âÖ t) (P : is_limit r) :
  equiv_iso_limit i P = P.of_iso_limit i := rfl
@[simp] lemma equiv_iso_limit_symm_apply {r t : cone F} (i : r ‚âÖ t) (P : is_limit t) :
  (equiv_iso_limit i).symm P = P.of_iso_limit i.symm := rfl
def of_point_iso {r t : cone F} (P : is_limit r) [i : is_iso (P.lift t)] : is_limit t :=
of_iso_limit P
begin
  haveI : is_iso (P.lift_cone_morphism t).hom := i,
  haveI : is_iso (P.lift_cone_morphism t) := cones.cone_iso_of_hom_iso _,
  symmetry,
  apply as_iso (P.lift_cone_morphism t),
end
variables {t : cone F}
lemma hom_lift (h : is_limit t) {W : C} (m : W ‚ü∂ t.X) :
  m = h.lift { X := W, œÄ := { app := Œª b, m ‚â´ t.œÄ.app b } } :=
h.uniq { X := W, œÄ := { app := Œª b, m ‚â´ t.œÄ.app b } } m (Œª b, rfl)
lemma hom_ext (h : is_limit t) {W : C} {f f' : W ‚ü∂ t.X}
  (w : ‚àÄ j, f ‚â´ t.œÄ.app j = f' ‚â´ t.œÄ.app j) : f = f' :=
by rw [h.hom_lift f, h.hom_lift f']; congr; exact funext w
def of_right_adjoint {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] {G : K ‚•§ D}
  (h : cone G ‚•§ cone F) [is_right_adjoint h] {c : cone G} (t : is_limit c) :
  is_limit (h.obj c) :=
mk_cone_morphism
  (Œª s, (adjunction.of_right_adjoint h).hom_equiv s c (t.lift_cone_morphism _))
  (Œª s m, (adjunction.eq_hom_equiv_apply _ _ _).2 t.uniq_cone_morphism)
def of_cone_equiv {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] {G : K ‚•§ D}
  (h : cone G ‚âå cone F) {c : cone G} :
  is_limit (h.functor.obj c) ‚âÉ is_limit c :=
{ to_fun := Œª P, of_iso_limit (of_right_adjoint h.inverse P) (h.unit_iso.symm.app c),
  inv_fun := of_right_adjoint h.functor,
  left_inv := by tidy,
  right_inv := by tidy, }
@[simp] lemma of_cone_equiv_apply_desc {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] {G : K ‚•§ D}
  (h : cone G ‚âå cone F) {c : cone G} (P : is_limit (h.functor.obj c)) (s) :
  (of_cone_equiv h P).lift s =
    ((h.unit_iso.hom.app s).hom ‚â´
      (h.functor.inv.map (P.lift_cone_morphism (h.functor.obj s))).hom) ‚â´
      (h.unit_iso.inv.app c).hom :=
rfl
@[simp] lemma of_cone_equiv_symm_apply_desc {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] {G : K ‚•§ D}
  (h : cone G ‚âå cone F) {c : cone G} (P : is_limit c) (s) :
  ((of_cone_equiv h).symm P).lift s =
    (h.counit_iso.inv.app s).hom ‚â´ (h.functor.map (P.lift_cone_morphism (h.inverse.obj s))).hom :=
rfl
def postcompose_hom_equiv {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : cone F) :
  is_limit ((cones.postcompose Œ±.hom).obj c) ‚âÉ is_limit c :=
of_cone_equiv (cones.postcompose_equivalence Œ±)
def postcompose_inv_equiv {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : cone G) :
  is_limit ((cones.postcompose Œ±.inv).obj c) ‚âÉ is_limit c :=
postcompose_hom_equiv Œ±.symm c
def equiv_of_nat_iso_of_iso {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : cone F) (d : cone G)
  (w : (cones.postcompose Œ±.hom).obj c ‚âÖ d) :
  is_limit c ‚âÉ is_limit d :=
(postcompose_hom_equiv Œ± _).symm.trans (equiv_iso_limit w)
@[simps]
def cone_points_iso_of_nat_iso {F G : J ‚•§ C} {s : cone F} {t : cone G}
  (P : is_limit s) (Q : is_limit t) (w : F ‚âÖ G) : s.X ‚âÖ t.X :=
{ hom := Q.map s w.hom,
  inv := P.map t w.inv,
  hom_inv_id' := P.hom_ext (by tidy),
  inv_hom_id' := Q.hom_ext (by tidy), }
@[reassoc]
lemma cone_points_iso_of_nat_iso_hom_comp {F G : J ‚•§ C} {s : cone F} {t : cone G}
  (P : is_limit s) (Q : is_limit t) (w : F ‚âÖ G) (j : J) :
  (cone_points_iso_of_nat_iso P Q w).hom ‚â´ t.œÄ.app j = s.œÄ.app j ‚â´ w.hom.app j :=
by simp
@[reassoc]
lemma cone_points_iso_of_nat_iso_inv_comp {F G : J ‚•§ C} {s : cone F} {t : cone G}
  (P : is_limit s) (Q : is_limit t) (w : F ‚âÖ G) (j : J) :
  (cone_points_iso_of_nat_iso P Q w).inv ‚â´ s.œÄ.app j = t.œÄ.app j ‚â´ w.inv.app j :=
by simp
@[reassoc]
lemma lift_comp_cone_points_iso_of_nat_iso_hom {F G : J ‚•§ C} {r s : cone F} {t : cone G}
  (P : is_limit s) (Q : is_limit t) (w : F ‚âÖ G) :
  P.lift r ‚â´ (cone_points_iso_of_nat_iso P Q w).hom = Q.map r w.hom :=
Q.hom_ext (by simp)
@[reassoc]
lemma lift_comp_cone_points_iso_of_nat_iso_inv {F G : J ‚•§ C} {r s : cone G} {t : cone F}
  (P : is_limit t) (Q : is_limit s) (w : F ‚âÖ G) :
  Q.lift r ‚â´ (cone_points_iso_of_nat_iso P Q w).inv = P.map r w.inv :=
P.hom_ext (by simp)
section equivalence
open category_theory.equivalence
def whisker_equivalence {s : cone F} (P : is_limit s) (e : K ‚âå J) :
  is_limit (s.whisker e.functor) :=
of_right_adjoint (cones.whiskering_equivalence e).functor P
def of_whisker_equivalence {s : cone F} (e : K ‚âå J) (P : is_limit (s.whisker e.functor)) :
  is_limit s :=
equiv_iso_limit ((cones.whiskering_equivalence e).unit_iso.app s).symm
  (of_right_adjoint (cones.whiskering_equivalence e).inverse P : _)
def whisker_equivalence_equiv {s : cone F} (e : K ‚âå J) :
  is_limit s ‚âÉ is_limit (s.whisker e.functor) :=
‚ü®Œª h, h.whisker_equivalence e, of_whisker_equivalence e, by tidy, by tidy‚ü©
@[simps]
def cone_points_iso_of_equivalence {F : J ‚•§ C} {s : cone F} {G : K ‚•§ C} {t : cone G}
  (P : is_limit s) (Q : is_limit t) (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : s.X ‚âÖ t.X :=
let w' : e.inverse ‚ãô F ‚âÖ G := (iso_whisker_left e.inverse w).symm ‚â™‚â´ inv_fun_id_assoc e G in
{ hom := Q.lift ((cones.equivalence_of_reindexing e.symm w').functor.obj s),
  inv := P.lift ((cones.equivalence_of_reindexing e w).functor.obj t),
  hom_inv_id' :=
  begin
    apply hom_ext P, intros j,
    dsimp,
    simp only [limits.cone.whisker_œÄ, limits.cones.postcompose_obj_œÄ, fac, whisker_left_app,
      assoc, id_comp, inv_fun_id_assoc_hom_app, fac_assoc, nat_trans.comp_app],
    rw [counit_app_functor, ‚Üêfunctor.comp_map, w.hom.naturality],
    simp,
  end,
  inv_hom_id' := by { apply hom_ext Q, tidy, }, }
end equivalence
def hom_iso (h : is_limit t) (W : C) : ulift.{u‚ÇÅ} (W ‚ü∂ t.X : Type v‚ÇÉ) ‚âÖ (const J).obj W ‚ü∂ F :=
{ hom := Œª f, (t.extend f.down).œÄ,
  inv := Œª œÄ, ‚ü®h.lift { X := W, œÄ := œÄ }‚ü©,
  hom_inv_id' := by ext f; apply h.hom_ext; intro j; simp; dsimp; refl }
@[simp] lemma hom_iso_hom (h : is_limit t) {W : C} (f : ulift.{u‚ÇÅ} (W ‚ü∂ t.X)) :
  (is_limit.hom_iso h W).hom f = (t.extend f.down).œÄ := rfl
def nat_iso (h : is_limit t) : yoneda.obj t.X ‚ãô ulift_functor.{u‚ÇÅ} ‚âÖ F.cones :=
nat_iso.of_components (Œª W, is_limit.hom_iso h (unop W)) (by tidy).
def hom_iso' (h : is_limit t) (W : C) :
  ulift.{u‚ÇÅ} ((W ‚ü∂ t.X) : Type v‚ÇÉ) ‚âÖ
    { p : Œ† j, W ‚ü∂ F.obj j // ‚àÄ {j j'} (f : j ‚ü∂ j'), p j ‚â´ F.map f = p j' } :=
h.hom_iso W ‚â™‚â´
{ hom := Œª œÄ,
  ‚ü®Œª j, œÄ.app j, Œª j j' f,
   by convert ‚Üê(œÄ.naturality f).symm; apply id_comp‚ü©,
  inv := Œª p,
  { app := Œª j, p.1 j,
    naturality' := Œª j j' f, begin dsimp, rw [id_comp], exact (p.2 f).symm end } }
def of_faithful {t : cone F} {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] (G : C ‚•§ D) [faithful G]
  (ht : is_limit (G.map_cone t)) (lift : Œ† (s : cone F), s.X ‚ü∂ t.X)
  (h : ‚àÄ s, G.map (lift s) = ht.lift (G.map_cone s)) : is_limit t :=
{ lift := lift,
  fac' := Œª s j, by apply G.map_injective; rw [G.map_comp, h]; apply ht.fac,
  uniq' := Œª s m w, begin
    apply G.map_injective, rw h,
    refine ht.uniq (G.map_cone s) _ (Œª j, _),
    convert ‚Üêcongr_arg (Œª f, G.map f) (w j),
    apply G.map_comp
  end }
def map_cone_equiv {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D]
  {K : J ‚•§ C} {F G : C ‚•§ D} (h : F ‚âÖ G) {c : cone K}
  (t : is_limit (F.map_cone c)) : is_limit (G.map_cone c) :=
begin
  apply postcompose_inv_equiv (iso_whisker_left K h : _) (G.map_cone c) _,
  apply t.of_iso_limit (postcompose_whisker_left_map_cone h.symm c).symm,
end
def iso_unique_cone_morphism {t : cone F} :
  is_limit t ‚âÖ Œ† s, unique (s ‚ü∂ t) :=
{ hom := Œª h s,
  { default := h.lift_cone_morphism s,
    uniq := Œª _, h.uniq_cone_morphism },
  inv := Œª h,
  { lift := Œª s, (h s).default.hom,
    uniq' := Œª s f w, congr_arg cone_morphism.hom ((h s).uniq ‚ü®f, w‚ü©) } }
namespace of_nat_iso
variables {X : C} (h : yoneda.obj X ‚ãô ulift_functor.{u‚ÇÅ} ‚âÖ F.cones)
def cone_of_hom {Y : C} (f : Y ‚ü∂ X) : cone F :=
{ X := Y, œÄ := h.hom.app (op Y) ‚ü®f‚ü© }
def hom_of_cone (s : cone F) : s.X ‚ü∂ X := (h.inv.app (op s.X) s.œÄ).down
@[simp] lemma cone_of_hom_of_cone (s : cone F) : cone_of_hom h (hom_of_cone h s) = s :=
begin
  dsimp [cone_of_hom, hom_of_cone], cases s, congr, dsimp,
  convert congr_fun (congr_fun (congr_arg nat_trans.app h.inv_hom_id) (op s_X)) s_œÄ,
  exact ulift.up_down _
end
@[simp] lemma hom_of_cone_of_hom {Y : C} (f : Y ‚ü∂ X) : hom_of_cone h (cone_of_hom h f) = f :=
congr_arg ulift.down (congr_fun (congr_fun (congr_arg nat_trans.app h.hom_inv_id) (op Y)) ‚ü®f‚ü© : _)
def limit_cone : cone F :=
cone_of_hom h (ùüô X)
lemma cone_of_hom_fac {Y : C} (f : Y ‚ü∂ X) :
cone_of_hom h f = (limit_cone h).extend f :=
begin
  dsimp [cone_of_hom, limit_cone, cone.extend],
  congr' with j,
  have t := congr_fun (h.hom.naturality f.op) ‚ü®ùüô X‚ü©,
  dsimp at t,
  simp only [comp_id] at t,
  rw congr_fun (congr_arg nat_trans.app t) j,
  refl,
end
lemma cone_fac (s : cone F) : (limit_cone h).extend (hom_of_cone h s) = s :=
begin
  rw ‚Üêcone_of_hom_of_cone h s,
  conv_lhs { simp only [hom_of_cone_of_hom] },
  apply (cone_of_hom_fac _ _).symm,
end
end of_nat_iso
section
open of_nat_iso
def of_nat_iso {X : C} (h : yoneda.obj X ‚ãô ulift_functor.{u‚ÇÅ} ‚âÖ F.cones) :
  is_limit (limit_cone h) :=
{ lift := Œª s, hom_of_cone h s,
  fac' := Œª s j,
  begin
    have h := cone_fac h s,
    cases s,
    injection h with h‚ÇÅ h‚ÇÇ,
    simp only [heq_iff_eq] at h‚ÇÇ,
    conv_rhs { rw ‚Üê h‚ÇÇ }, refl,
  end,
  uniq' := Œª s m w,
  begin
    rw ‚Üêhom_of_cone_of_hom h m,
    congr,
    rw cone_of_hom_fac,
    dsimp [cone.extend], cases s, congr' with j, exact w j,
  end }
end
end is_limit
@[nolint has_inhabited_instance]
structure is_colimit (t : cocone F) :=
(desc  : Œ† (s : cocone F), t.X ‚ü∂ s.X)
(fac'  : ‚àÄ (s : cocone F) (j : J), t.Œπ.app j ‚â´ desc s = s.Œπ.app j . obviously)
(uniq' : ‚àÄ (s : cocone F) (m : t.X ‚ü∂ s.X) (w : ‚àÄ j : J, t.Œπ.app j ‚â´ m = s.Œπ.app j),
  m = desc s . obviously)
restate_axiom is_colimit.fac'
attribute [simp,reassoc] is_colimit.fac
restate_axiom is_colimit.uniq'
namespace is_colimit
instance subsingleton {t : cocone F} : subsingleton (is_colimit t) :=
‚ü®by intros P Q; cases P; cases Q; congr; ext; solve_by_elim‚ü©
def map {F G : J ‚•§ C} {s : cocone F} (P : is_colimit s) (t : cocone G)
  (Œ± : F ‚ü∂ G) : s.X ‚ü∂ t.X :=
P.desc ((cocones.precompose Œ±).obj t)
@[simp, reassoc]
lemma Œπ_map {F G : J ‚•§ C} {c : cocone F} (hc : is_colimit c) (d : cocone G) (Œ± : F ‚ü∂ G)
  (j : J) : c.Œπ.app j ‚â´ is_colimit.map hc d Œ± = Œ±.app j ‚â´ d.Œπ.app j :=
fac _ _ _
@[simp]
lemma desc_self {t : cocone F} (h : is_colimit t) : h.desc t = ùüô t.X :=
(h.uniq _ _ (Œª j, comp_id _)).symm
@[simps]
def desc_cocone_morphism {t : cocone F} (h : is_colimit t) (s : cocone F) : t ‚ü∂ s :=
{ hom := h.desc s }
lemma uniq_cocone_morphism {s t : cocone F} (h : is_colimit t) {f f' : t ‚ü∂ s} :
  f = f' :=
have ‚àÄ {g : t ‚ü∂ s}, g = h.desc_cocone_morphism s, by intro g; ext; exact h.uniq _ _ g.w,
this.trans this.symm
lemma exists_unique {t : cocone F} (h : is_colimit t) (s : cocone F) :
  ‚àÉ! (d : t.X ‚ü∂ s.X), ‚àÄ j, t.Œπ.app j ‚â´ d = s.Œπ.app j :=
‚ü®h.desc s, h.fac s, h.uniq s‚ü©
def of_exists_unique {t : cocone F}
  (ht : ‚àÄ s : cocone F, ‚àÉ! d : t.X ‚ü∂ s.X, ‚àÄ j, t.Œπ.app j ‚â´ d = s.Œπ.app j) : is_colimit t :=
by { choose s hs hs' using ht, exact ‚ü®s, hs, hs'‚ü© }
@[simps]
def mk_cocone_morphism {t : cocone F}
  (desc : Œ† (s : cocone F), t ‚ü∂ s)
  (uniq' : ‚àÄ (s : cocone F) (m : t ‚ü∂ s), m = desc s) : is_colimit t :=
{ desc := Œª s, (desc s).hom,
  uniq' := Œª s m w,
    have cocone_morphism.mk m w = desc s, by apply uniq',
    congr_arg cocone_morphism.hom this }
@[simps]
def unique_up_to_iso {s t : cocone F} (P : is_colimit s) (Q : is_colimit t) : s ‚âÖ t :=
{ hom := P.desc_cocone_morphism t,
  inv := Q.desc_cocone_morphism s,
  hom_inv_id' := P.uniq_cocone_morphism,
  inv_hom_id' := Q.uniq_cocone_morphism }
lemma hom_is_iso {s t : cocone F} (P : is_colimit s) (Q : is_colimit t) (f : s ‚ü∂ t) : is_iso f :=
‚ü®‚ü®Q.desc_cocone_morphism s, ‚ü®P.uniq_cocone_morphism, Q.uniq_cocone_morphism‚ü©‚ü©‚ü©
def cocone_point_unique_up_to_iso {s t : cocone F} (P : is_colimit s) (Q : is_colimit t) :
  s.X ‚âÖ t.X :=
(cocones.forget F).map_iso (unique_up_to_iso P Q)
@[simp, reassoc] lemma comp_cocone_point_unique_up_to_iso_hom {s t : cocone F} (P : is_colimit s)
  (Q : is_colimit t) (j : J) : s.Œπ.app j ‚â´ (cocone_point_unique_up_to_iso P Q).hom = t.Œπ.app j :=
(unique_up_to_iso P Q).hom.w _
@[simp, reassoc] lemma comp_cocone_point_unique_up_to_iso_inv {s t : cocone F} (P : is_colimit s)
  (Q : is_colimit t) (j : J) : t.Œπ.app j ‚â´ (cocone_point_unique_up_to_iso P Q).inv = s.Œπ.app j :=
(unique_up_to_iso P Q).inv.w _
@[simp, reassoc] lemma cocone_point_unique_up_to_iso_hom_desc {r s t : cocone F} (P : is_colimit s)
  (Q : is_colimit t) : (cocone_point_unique_up_to_iso P Q).hom ‚â´ Q.desc r = P.desc r :=
P.uniq _ _ (by simp)
@[simp, reassoc] lemma cocone_point_unique_up_to_iso_inv_desc {r s t : cocone F} (P : is_colimit s)
  (Q : is_colimit t) : (cocone_point_unique_up_to_iso P Q).inv ‚â´ P.desc r = Q.desc r :=
Q.uniq _ _ (by simp)
def of_iso_colimit {r t : cocone F} (P : is_colimit r) (i : r ‚âÖ t) : is_colimit t :=
is_colimit.mk_cocone_morphism
  (Œª s, i.inv ‚â´ P.desc_cocone_morphism s)
  (Œª s m, by rw i.eq_inv_comp; apply P.uniq_cocone_morphism)
@[simp] lemma of_iso_colimit_desc {r t : cocone F} (P : is_colimit r) (i : r ‚âÖ t) (s) :
  (P.of_iso_colimit i).desc s = i.inv.hom ‚â´ P.desc s :=
rfl
def equiv_iso_colimit {r t : cocone F} (i : r ‚âÖ t) : is_colimit r ‚âÉ is_colimit t :=
{ to_fun := Œª h, h.of_iso_colimit i,
  inv_fun := Œª h, h.of_iso_colimit i.symm,
  left_inv := by tidy,
  right_inv := by tidy }
@[simp] lemma equiv_iso_colimit_apply {r t : cocone F} (i : r ‚âÖ t) (P : is_colimit r) :
  equiv_iso_colimit i P = P.of_iso_colimit i := rfl
@[simp] lemma equiv_iso_colimit_symm_apply {r t : cocone F} (i : r ‚âÖ t) (P : is_colimit t) :
  (equiv_iso_colimit i).symm P = P.of_iso_colimit i.symm := rfl
def of_point_iso {r t : cocone F} (P : is_colimit r) [i : is_iso (P.desc t)] : is_colimit t :=
of_iso_colimit P
begin
  haveI : is_iso (P.desc_cocone_morphism t).hom := i,
  haveI : is_iso (P.desc_cocone_morphism t) := cocones.cocone_iso_of_hom_iso _,
  apply as_iso (P.desc_cocone_morphism t),
end
variables {t : cocone F}
lemma hom_desc (h : is_colimit t) {W : C} (m : t.X ‚ü∂ W) :
  m = h.desc { X := W, Œπ := { app := Œª b, t.Œπ.app b ‚â´ m,
    naturality' := by intros; erw [‚Üêassoc, t.Œπ.naturality, comp_id, comp_id] } } :=
h.uniq { X := W, Œπ := { app := Œª b, t.Œπ.app b ‚â´ m, naturality' := _ } } m (Œª b, rfl)
lemma hom_ext (h : is_colimit t) {W : C} {f f' : t.X ‚ü∂ W}
  (w : ‚àÄ j, t.Œπ.app j ‚â´ f = t.Œπ.app j ‚â´ f') : f = f' :=
by rw [h.hom_desc f, h.hom_desc f']; congr; exact funext w
def of_left_adjoint {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] {G : K ‚•§ D}
  (h : cocone G ‚•§ cocone F) [is_left_adjoint h] {c : cocone G} (t : is_colimit c) :
  is_colimit (h.obj c) :=
mk_cocone_morphism
  (Œª s, ((adjunction.of_left_adjoint h).hom_equiv c s).symm (t.desc_cocone_morphism _))
  (Œª s m, (adjunction.hom_equiv_apply_eq _ _ _).1 t.uniq_cocone_morphism)
def of_cocone_equiv {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] {G : K ‚•§ D}
  (h : cocone G ‚âå cocone F) {c : cocone G} :
  is_colimit (h.functor.obj c) ‚âÉ is_colimit c :=
{ to_fun := Œª P, of_iso_colimit (of_left_adjoint h.inverse P) (h.unit_iso.symm.app c),
  inv_fun := of_left_adjoint h.functor,
  left_inv := by tidy,
  right_inv := by tidy, }
@[simp] lemma of_cocone_equiv_apply_desc {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] {G : K ‚•§ D}
  (h : cocone G ‚âå cocone F) {c : cocone G} (P : is_colimit (h.functor.obj c)) (s) :
  (of_cocone_equiv h P).desc s =
    (h.unit.app c).hom ‚â´
    (h.inverse.map (P.desc_cocone_morphism (h.functor.obj s))).hom ‚â´
    (h.unit_inv.app s).hom :=
rfl
@[simp] lemma of_cocone_equiv_symm_apply_desc {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] {G : K ‚•§ D}
  (h : cocone G ‚âå cocone F) {c : cocone G} (P : is_colimit c) (s) :
  ((of_cocone_equiv h).symm P).desc s =
    (h.functor.map (P.desc_cocone_morphism (h.inverse.obj s))).hom ‚â´ (h.counit.app s).hom :=
rfl
def precompose_hom_equiv {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : cocone G) :
  is_colimit ((cocones.precompose Œ±.hom).obj c) ‚âÉ is_colimit c :=
of_cocone_equiv (cocones.precompose_equivalence Œ±)
def precompose_inv_equiv {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : cocone F) :
  is_colimit ((cocones.precompose Œ±.inv).obj c) ‚âÉ is_colimit c :=
precompose_hom_equiv Œ±.symm c
def equiv_of_nat_iso_of_iso {F G : J ‚•§ C} (Œ± : F ‚âÖ G) (c : cocone F) (d : cocone G)
  (w : (cocones.precompose Œ±.inv).obj c ‚âÖ d) :
  is_colimit c ‚âÉ is_colimit d :=
(precompose_inv_equiv Œ± _).symm.trans (equiv_iso_colimit w)
@[simps]
def cocone_points_iso_of_nat_iso {F G : J ‚•§ C} {s : cocone F} {t : cocone G}
  (P : is_colimit s) (Q : is_colimit t) (w : F ‚âÖ G) : s.X ‚âÖ t.X :=
{ hom := P.map t w.hom,
  inv := Q.map s w.inv,
  hom_inv_id' := P.hom_ext (by tidy),
  inv_hom_id' := Q.hom_ext (by tidy) }
@[reassoc]
lemma comp_cocone_points_iso_of_nat_iso_hom {F G : J ‚•§ C} {s : cocone F} {t : cocone G}
  (P : is_colimit s) (Q : is_colimit t) (w : F ‚âÖ G) (j : J) :
  s.Œπ.app j ‚â´ (cocone_points_iso_of_nat_iso P Q w).hom = w.hom.app j ‚â´ t.Œπ.app j :=
by simp
@[reassoc]
lemma comp_cocone_points_iso_of_nat_iso_inv {F G : J ‚•§ C} {s : cocone F} {t : cocone G}
  (P : is_colimit s) (Q : is_colimit t) (w : F ‚âÖ G) (j : J) :
  t.Œπ.app j ‚â´ (cocone_points_iso_of_nat_iso P Q w).inv = w.inv.app j ‚â´ s.Œπ.app j :=
by simp
@[reassoc]
lemma cocone_points_iso_of_nat_iso_hom_desc {F G : J ‚•§ C} {s : cocone F} {r t : cocone G}
  (P : is_colimit s) (Q : is_colimit t) (w : F ‚âÖ G) :
  (cocone_points_iso_of_nat_iso P Q w).hom ‚â´ Q.desc r = P.map _ w.hom :=
P.hom_ext (by simp)
@[reassoc]
lemma cocone_points_iso_of_nat_iso_inv_desc {F G : J ‚•§ C} {s : cocone G} {r t : cocone F}
  (P : is_colimit t) (Q : is_colimit s) (w : F ‚âÖ G) :
  (cocone_points_iso_of_nat_iso P Q w).inv ‚â´ P.desc r = Q.map _ w.inv :=
Q.hom_ext (by simp)
section equivalence
open category_theory.equivalence
def whisker_equivalence {s : cocone F} (P : is_colimit s) (e : K ‚âå J) :
  is_colimit (s.whisker e.functor) :=
of_left_adjoint (cocones.whiskering_equivalence e).functor P
def of_whisker_equivalence {s : cocone F} (e : K ‚âå J) (P : is_colimit (s.whisker e.functor)) :
  is_colimit s :=
equiv_iso_colimit ((cocones.whiskering_equivalence e).unit_iso.app s).symm
  (of_left_adjoint (cocones.whiskering_equivalence e).inverse P : _)
def whisker_equivalence_equiv {s : cocone F} (e : K ‚âå J) :
  is_colimit s ‚âÉ is_colimit (s.whisker e.functor) :=
‚ü®Œª h, h.whisker_equivalence e, of_whisker_equivalence e, by tidy, by tidy‚ü©
@[simps]
def cocone_points_iso_of_equivalence {F : J ‚•§ C} {s : cocone F} {G : K ‚•§ C} {t : cocone G}
  (P : is_colimit s) (Q : is_colimit t) (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : s.X ‚âÖ t.X :=
let w' : e.inverse ‚ãô F ‚âÖ G := (iso_whisker_left e.inverse w).symm ‚â™‚â´ inv_fun_id_assoc e G in
{ hom := P.desc ((cocones.equivalence_of_reindexing e w).functor.obj t),
  inv := Q.desc ((cocones.equivalence_of_reindexing e.symm w').functor.obj s),
  hom_inv_id' :=
  begin
    apply hom_ext P, intros j,
    dsimp,
    simp only [limits.cocone.whisker_Œπ, fac, inv_fun_id_assoc_inv_app, whisker_left_app, assoc,
      comp_id, limits.cocones.precompose_obj_Œπ, fac_assoc, nat_trans.comp_app],
    rw [counit_inv_app_functor, ‚Üêfunctor.comp_map, ‚Üêw.inv.naturality_assoc],
    dsimp,
    simp,
  end,
  inv_hom_id' := by { apply hom_ext Q, tidy, }, }
end equivalence
def hom_iso (h : is_colimit t) (W : C) : ulift.{u‚ÇÅ} (t.X ‚ü∂ W : Type v‚ÇÉ) ‚âÖ (F ‚ü∂ (const J).obj W) :=
{ hom := Œª f, (t.extend f.down).Œπ,
  inv := Œª Œπ, ‚ü®h.desc { X := W, Œπ := Œπ }‚ü©,
  hom_inv_id' := by ext f; apply h.hom_ext; intro j; simp; dsimp; refl }
@[simp] lemma hom_iso_hom (h : is_colimit t) {W : C} (f : ulift (t.X ‚ü∂ W)) :
  (is_colimit.hom_iso h W).hom f = (t.extend f.down).Œπ := rfl
def nat_iso (h : is_colimit t) : coyoneda.obj (op t.X) ‚ãô ulift_functor.{u‚ÇÅ} ‚âÖ F.cocones :=
nat_iso.of_components (is_colimit.hom_iso h) (by intros; ext; dsimp; rw ‚Üêassoc; refl)
def hom_iso' (h : is_colimit t) (W : C) :
  ulift.{u‚ÇÅ} ((t.X ‚ü∂ W) : Type v‚ÇÉ) ‚âÖ
    { p : Œ† j, F.obj j ‚ü∂ W // ‚àÄ {j j' : J} (f : j ‚ü∂ j'), F.map f ‚â´ p j' = p j } :=
h.hom_iso W ‚â™‚â´
{ hom := Œª Œπ,
  ‚ü®Œª j, Œπ.app j, Œª j j' f,
   by convert ‚Üê(Œπ.naturality f); apply comp_id‚ü©,
  inv := Œª p,
  { app := Œª j, p.1 j,
    naturality' := Œª j j' f, begin dsimp, rw [comp_id], exact (p.2 f) end } }
def of_faithful {t : cocone F} {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] (G : C ‚•§ D) [faithful G]
  (ht : is_colimit (G.map_cocone t)) (desc : Œ† (s : cocone F), t.X ‚ü∂ s.X)
  (h : ‚àÄ s, G.map (desc s) = ht.desc (G.map_cocone s)) : is_colimit t :=
{ desc := desc,
  fac' := Œª s j, by apply G.map_injective; rw [G.map_comp, h]; apply ht.fac,
  uniq' := Œª s m w, begin
    apply G.map_injective, rw h,
    refine ht.uniq (G.map_cocone s) _ (Œª j, _),
    convert ‚Üêcongr_arg (Œª f, G.map f) (w j),
    apply G.map_comp
  end }
def map_cocone_equiv {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D] {K : J ‚•§ C} {F G : C ‚•§ D} (h : F ‚âÖ G)
  {c : cocone K} (t : is_colimit (F.map_cocone c)) : is_colimit (G.map_cocone c) :=
begin
  apply is_colimit.of_iso_colimit _ (precompose_whisker_left_map_cocone h c),
  apply (precompose_inv_equiv (iso_whisker_left K h : _) _).symm t,
end
def iso_unique_cocone_morphism {t : cocone F} :
  is_colimit t ‚âÖ Œ† s, unique (t ‚ü∂ s) :=
{ hom := Œª h s,
  { default := h.desc_cocone_morphism s,
    uniq := Œª _, h.uniq_cocone_morphism },
  inv := Œª h,
  { desc := Œª s, (h s).default.hom,
    uniq' := Œª s f w, congr_arg cocone_morphism.hom ((h s).uniq ‚ü®f, w‚ü©) } }
namespace of_nat_iso
variables {X : C} (h : coyoneda.obj (op X) ‚ãô ulift_functor.{u‚ÇÅ} ‚âÖ F.cocones)
def cocone_of_hom {Y : C} (f : X ‚ü∂ Y) : cocone F :=
{ X := Y, Œπ := h.hom.app Y ‚ü®f‚ü© }
def hom_of_cocone (s : cocone F) : X ‚ü∂ s.X := (h.inv.app s.X s.Œπ).down
@[simp] lemma cocone_of_hom_of_cocone (s : cocone F) : cocone_of_hom h (hom_of_cocone h s) = s :=
begin
  dsimp [cocone_of_hom, hom_of_cocone], cases s, congr, dsimp,
  convert congr_fun (congr_fun (congr_arg nat_trans.app h.inv_hom_id) s_X) s_Œπ,
  exact ulift.up_down _
end
@[simp] lemma hom_of_cocone_of_hom {Y : C} (f : X ‚ü∂ Y) : hom_of_cocone h (cocone_of_hom h f) = f :=
congr_arg ulift.down (congr_fun (congr_fun (congr_arg nat_trans.app h.hom_inv_id) Y) ‚ü®f‚ü© : _)
def colimit_cocone : cocone F :=
cocone_of_hom h (ùüô X)
lemma cocone_of_hom_fac {Y : C} (f : X ‚ü∂ Y) :
cocone_of_hom h f = (colimit_cocone h).extend f :=
begin
  dsimp [cocone_of_hom, colimit_cocone, cocone.extend],
  congr' with j,
  have t := congr_fun (h.hom.naturality f) ‚ü®ùüô X‚ü©,
  dsimp at t,
  simp only [id_comp] at t,
  rw congr_fun (congr_arg nat_trans.app t) j,
  refl,
end
lemma cocone_fac (s : cocone F) : (colimit_cocone h).extend (hom_of_cocone h s) = s :=
begin
  rw ‚Üêcocone_of_hom_of_cocone h s,
  conv_lhs { simp only [hom_of_cocone_of_hom] },
  apply (cocone_of_hom_fac _ _).symm,
end
end of_nat_iso
section
open of_nat_iso
def of_nat_iso {X : C} (h : coyoneda.obj (op X) ‚ãô ulift_functor.{u‚ÇÅ} ‚âÖ F.cocones) :
  is_colimit (colimit_cocone h) :=
{ desc := Œª s, hom_of_cocone h s,
  fac' := Œª s j,
  begin
    have h := cocone_fac h s,
    cases s,
    injection h with h‚ÇÅ h‚ÇÇ,
    simp only [heq_iff_eq] at h‚ÇÇ,
    conv_rhs { rw ‚Üê h‚ÇÇ }, refl,
  end,
  uniq' := Œª s m w,
  begin
    rw ‚Üêhom_of_cocone_of_hom h m,
    congr,
    rw cocone_of_hom_fac,
    dsimp [cocone.extend], cases s, congr' with j, exact w j,
  end }
end
end is_colimit
end category_theory.limits
