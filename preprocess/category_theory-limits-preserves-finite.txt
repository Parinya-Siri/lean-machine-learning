import category_theory.limits.preserves.basic
import category_theory.fin_category
open category_theory
namespace category_theory.limits
class preserves_finite_limits (F : C â¥¤ D) :=
(preserves_finite_limits : Î  (J : Type) [small_category J] [fin_category J],
  preserves_limits_of_shape J F . tactic.apply_instance)
attribute [instance] preserves_finite_limits.preserves_finite_limits
@[priority 100]
noncomputable instance preserves_limits_of_shape_of_preserves_finite_limits (F : C â¥¤ D)
  [preserves_finite_limits F] (J : Type w) [small_category J] [fin_category J] :
  preserves_limits_of_shape J F :=
by apply preserves_limits_of_shape_of_equiv (fin_category.equiv_as_type J)
@[priority 100]
noncomputable instance preserves_limits.preserves_finite_limits_of_size (F : C â¥¤ D)
  [preserves_limits_of_size.{w wâ‚‚} F] : preserves_finite_limits F :=
âŸ¨Î» J sJ fJ,
  begin
    haveI := preserves_smallest_limits_of_preserves_limits F,
    exact preserves_limits_of_shape_of_equiv (fin_category.equiv_as_type J) F,
  endâŸ©
@[priority 120]
noncomputable instance preserves_limits.preserves_finite_limits (F : C â¥¤ D)
  [preserves_limits F] : preserves_finite_limits F :=
preserves_limits.preserves_finite_limits_of_size F
def preserves_finite_limits_of_preserves_finite_limits_of_size (F : C â¥¤ D)
  (h : âˆ€ (J : Type w) {ğ’¥ : small_category J} (hJ : @fin_category J ğ’¥),
    by { resetI, exact preserves_limits_of_shape J F }) :
  preserves_finite_limits F :=
âŸ¨Î» J hJ hhJ,
  begin
    resetI,
    letI : category.{w w} (ulift_hom.{w} (ulift.{w 0} J)),
    { apply ulift_hom.category.{0}, exact category_theory.ulift_category J },
    haveI := h (ulift_hom.{w} (ulift.{w} J)) category_theory.fin_category_ulift,
    exact preserves_limits_of_shape_of_equiv (ulift_hom_ulift_category.equiv.{w w} J).symm F
  endâŸ©
instance id_preserves_finite_limits : preserves_finite_limits (ğŸ­ C) := {}
def comp_preserves_finite_limits (F : C â¥¤ D) (G : D â¥¤ E)
  [preserves_finite_limits F] [preserves_finite_limits G] : preserves_finite_limits (F â‹™ G) :=
âŸ¨Î» _ _ _, by { resetI, apply_instance }âŸ©
class preserves_finite_colimits (F : C â¥¤ D) :=
(preserves_finite_colimits : Î  (J : Type) [small_category J] [fin_category J],
  preserves_colimits_of_shape J F . tactic.apply_instance)
attribute [instance] preserves_finite_colimits.preserves_finite_colimits
@[priority 100]
noncomputable instance preserves_colimits_of_shape_of_preserves_finite_colimits (F : C â¥¤ D)
  [preserves_finite_colimits F] (J : Type w) [small_category J] [fin_category J] :
  preserves_colimits_of_shape J F :=
by apply preserves_colimits_of_shape_of_equiv (fin_category.equiv_as_type J)
@[priority 100]
noncomputable instance preserves_colimits.preserves_finite_colimits (F : C â¥¤ D)
  [preserves_colimits_of_size.{w wâ‚‚} F] : preserves_finite_colimits F :=
âŸ¨Î» J sJ fJ,
  begin
    haveI := preserves_smallest_colimits_of_preserves_colimits F,
    exact preserves_colimits_of_shape_of_equiv (fin_category.equiv_as_type J) F,
  endâŸ©
def preserves_finite_colimits_of_preserves_finite_colimits_of_size (F : C â¥¤ D)
  (h : âˆ€ (J : Type w) {ğ’¥ : small_category J} (hJ : @fin_category J ğ’¥),
    by { resetI, exact preserves_colimits_of_shape J F }) :
  preserves_finite_colimits F :=
âŸ¨Î» J hJ hhJ,
  begin
    resetI,
    letI : category.{w w} (ulift_hom.{w} (ulift.{w 0} J)),
    { apply ulift_hom.category.{0}, exact category_theory.ulift_category J },
    haveI := h (ulift_hom.{w} (ulift.{w} J)) category_theory.fin_category_ulift,
    exact preserves_colimits_of_shape_of_equiv (ulift_hom_ulift_category.equiv.{w w} J).symm F
  endâŸ©
instance id_preserves_finite_colimits : preserves_finite_colimits (ğŸ­ C) := {}
def comp_preserves_finite_colimits (F : C â¥¤ D) (G : D â¥¤ E)
  [preserves_finite_colimits F] [preserves_finite_colimits G] :
  preserves_finite_colimits (F â‹™ G) :=
âŸ¨Î» _ _ _, by { resetI, apply_instance }âŸ©
end category_theory.limits
