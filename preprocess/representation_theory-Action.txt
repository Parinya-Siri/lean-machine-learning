import algebra.category.Group.basic
import category_theory.single_obj
import category_theory.limits.functor_category
import category_theory.limits.preserves.basic
import category_theory.adjunction.limits
import category_theory.monoidal.functor_category
import category_theory.monoidal.transport
import category_theory.monoidal.rigid.of_equivalence
import category_theory.monoidal.rigid.functor_category
import category_theory.monoidal.linear
import category_theory.monoidal.braided
import category_theory.abelian.functor_category
import category_theory.abelian.transfer
import category_theory.conj
import category_theory.linear.functor_category
universes u
open category_theory
open category_theory.limits
variables (V : Type (u+1)) [large_category V]
@[simps]
def œÅ_Aut {G : Group.{u}} (A : Action V (Mon.of G)) : G ‚ü∂ Group.of (Aut A.V) :=
{ to_fun := Œª g,
  { hom := A.œÅ g,
    inv := A.œÅ (g‚Åª¬π : G),
    hom_inv_id' := ((A.œÅ).map_mul (g‚Åª¬π : G) g).symm.trans (by rw [inv_mul_self, œÅ_one]),
    inv_hom_id' := ((A.œÅ).map_mul g (g‚Åª¬π : G)).symm.trans (by rw [mul_inv_self, œÅ_one]), },
  map_one' := by { ext, exact A.œÅ.map_one },
  map_mul' := Œª x y, by { ext, exact A.œÅ.map_mul x y }, }
variable (G : Mon.{u})
section
def trivial : Action AddCommGroup G :=
{ V := AddCommGroup.of punit,
  œÅ := 1, }
instance : inhabited (Action AddCommGroup G) := ‚ü®trivial G‚ü©
end
variables {G V}
@[ext]
structure hom (M N : Action V G) :=
(hom : M.V ‚ü∂ N.V)
(comm' : ‚àÄ g : G, M.œÅ g ‚â´ hom = hom ‚â´ N.œÅ g . obviously)
restate_axiom hom.comm'
namespace hom
@[simps]
def id (M : Action V G) : Action.hom M M :=
{ hom := ùüô M.V }
instance (M : Action V G) : inhabited (Action.hom M M) := ‚ü®id M‚ü©
@[simps]
def comp {M N K : Action V G} (p : Action.hom M N) (q : Action.hom N K) :
  Action.hom M K :=
{ hom := p.hom ‚â´ q.hom,
  comm' := Œª g, by rw [‚Üêcategory.assoc, p.comm, category.assoc, q.comm, ‚Üêcategory.assoc] }
end hom
instance : category (Action V G) :=
{ hom := Œª M N, hom M N,
  id := Œª M, hom.id M,
  comp := Œª M N K f g, hom.comp f g, }
@[simp]
lemma id_hom (M : Action V G) : (ùüô M : hom M M).hom = ùüô M.V := rfl
@[simp]
lemma comp_hom {M N K : Action V G} (f : M ‚ü∂ N) (g : N ‚ü∂ K) :
  (f ‚â´ g : hom M K).hom = f.hom ‚â´ g.hom :=
rfl
@[simps]
def mk_iso {M N : Action V G} (f : M.V ‚âÖ N.V) (comm : ‚àÄ g : G, M.œÅ g ‚â´ f.hom = f.hom ‚â´ N.œÅ g) :
  M ‚âÖ N :=
{ hom :=
  { hom := f.hom,
    comm' := comm, },
  inv :=
  { hom := f.inv,
    comm' := Œª g, by { have w := comm g =‚â´ f.inv, simp at w, simp [w], }, }}
namespace functor_category_equivalence
@[simps]
def functor : Action V G ‚•§ (single_obj G ‚•§ V) :=
{ obj := Œª M,
  { obj := Œª _, M.V,
    map := Œª _ _ g, M.œÅ g,
    map_id' := Œª _, M.œÅ.map_one,
    map_comp' := Œª _ _ _ g h, M.œÅ.map_mul h g, },
  map := Œª M N f,
  { app := Œª _, f.hom,
    naturality' := Œª _ _ g, f.comm g, } }
@[simps]
def inverse : (single_obj G ‚•§ V) ‚•§ Action V G :=
{ obj := Œª F,
  { V := F.obj punit.star,
    œÅ :=
    { to_fun := Œª g, F.map g,
      map_one' := F.map_id punit.star,
      map_mul' := Œª g h, F.map_comp h g, } },
  map := Œª M N f,
  { hom := f.app punit.star,
    comm' := Œª g, f.naturality g, } }.
@[simps]
def unit_iso : ùü≠ (Action V G) ‚âÖ functor ‚ãô inverse :=
nat_iso.of_components (Œª M, mk_iso ((iso.refl _)) (by tidy)) (by tidy).
@[simps]
def counit_iso : inverse ‚ãô functor ‚âÖ ùü≠ (single_obj G ‚•§ V) :=
nat_iso.of_components (Œª M, nat_iso.of_components (by tidy) (by tidy)) (by tidy).
end functor_category_equivalence
section
open functor_category_equivalence
variables (V G)
def functor_category_equivalence : Action V G ‚âå (single_obj G ‚•§ V) :=
{ functor := functor,
  inverse := inverse,
  unit_iso := unit_iso,
  counit_iso := counit_iso, }
attribute [simps] functor_category_equivalence
instance [has_finite_products V] : has_finite_products (Action V G) :=
{ out := Œª J _, by exactI
  adjunction.has_limits_of_shape_of_equivalence (Action.functor_category_equivalence _ _).functor }
instance [has_limits V] : has_limits (Action V G) :=
adjunction.has_limits_of_equivalence (Action.functor_category_equivalence _ _).functor
instance [has_colimits V] : has_colimits (Action V G) :=
adjunction.has_colimits_of_equivalence (Action.functor_category_equivalence _ _).functor
end
section forget
variables (V G)
@[simps]
def forget : Action V G ‚•§ V :=
{ obj := Œª M, M.V,
  map := Œª M N f, f.hom, }
instance : faithful (forget V G) :=
{ map_injective' := Œª X Y f g w, hom.ext _ _ w, }
instance [concrete_category V] : concrete_category (Action V G) :=
{ forget := forget V G ‚ãô (concrete_category.forget V), }
instance has_forget_to_V [concrete_category V] : has_forget‚ÇÇ (Action V G) V :=
{ forget‚ÇÇ := forget V G }
def functor_category_equivalence_comp_evaluation :
  (functor_category_equivalence V G).functor ‚ãô (evaluation _ _).obj punit.star ‚âÖ forget V G :=
iso.refl _
noncomputable instance [has_limits V] : limits.preserves_limits (forget V G) :=
limits.preserves_limits_of_nat_iso
  (Action.functor_category_equivalence_comp_evaluation V G)
noncomputable instance [has_colimits V] : preserves_colimits (forget V G) :=
preserves_colimits_of_nat_iso
  (Action.functor_category_equivalence_comp_evaluation V G)
def abelian_aux : Action V G ‚âå (ulift.{u} (single_obj G) ‚•§ V) :=
(functor_category_equivalence V G).trans (equivalence.congr_left ulift.equivalence)
noncomputable instance [abelian V] : abelian (Action V G) :=
abelian_of_equivalence abelian_aux.functor
end abelian
section monoidal
variables [monoidal_category V]
instance : monoidal_category (Action V G) :=
monoidal.transport (Action.functor_category_equivalence _ _).symm
@[simp] lemma tensor_V {X Y : Action V G} : (X ‚äó Y).V = X.V ‚äó Y.V := rfl
@[simp] lemma tensor_rho {X Y : Action V G} {g : G} : (X ‚äó Y).œÅ g = X.œÅ g ‚äó Y.œÅ g := rfl
@[simp] lemma tensor_hom {W X Y Z : Action V G} (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) :
  (f ‚äó g).hom = f.hom ‚äó g.hom := rfl
@[simp] lemma associator_hom_hom {X Y Z : Action V G} :
  hom.hom (Œ±_ X Y Z).hom = (Œ±_ X.V Y.V Z.V).hom :=
begin
  dsimp [monoidal.transport_associator],
  simp,
end
@[simp] lemma associator_inv_hom {X Y Z : Action V G} :
  hom.hom (Œ±_ X Y Z).inv = (Œ±_ X.V Y.V Z.V).inv :=
begin
  dsimp [monoidal.transport_associator],
  simp,
end
@[simp] lemma left_unitor_hom_hom {X : Action V G} :
  hom.hom (Œª_ X).hom = (Œª_ X.V).hom :=
begin
  dsimp [monoidal.transport_left_unitor],
  simp,
end
@[simp] lemma left_unitor_inv_hom {X : Action V G} :
  hom.hom (Œª_ X).inv = (Œª_ X.V).inv :=
begin
  dsimp [monoidal.transport_left_unitor],
  simp,
end
@[simp] lemma right_unitor_hom_hom {X : Action V G} :
  hom.hom (œÅ_ X).hom = (œÅ_ X.V).hom :=
begin
  dsimp [monoidal.transport_right_unitor],
  simp,
end
@[simp] lemma right_unitor_inv_hom {X : Action V G} :
  hom.hom (œÅ_ X).inv = (œÅ_ X.V).inv :=
begin
  dsimp [monoidal.transport_right_unitor],
  simp,
end
variables (V G)
@[simps]
def forget_monoidal : monoidal_functor (Action V G) V :=
{ Œµ := ùüô _,
  Œº := Œª X Y, ùüô _,
  ..Action.forget _ _, }
instance forget_monoidal_faithful : faithful (forget_monoidal V G).to_functor :=
by { change faithful (forget V G), apply_instance, }
section
variables [braided_category V]
instance : braided_category (Action V G) :=
braided_category_of_faithful (forget_monoidal V G) (Œª X Y, mk_iso (Œ≤_ _ _) (by tidy)) (by tidy)
@[simps]
def forget_braided : braided_functor (Action V G) V :=
{ ..forget_monoidal _ _, }
instance forget_braided_faithful : faithful (forget_braided V G).to_functor :=
by { change faithful (forget V G), apply_instance, }
end
instance [symmetric_category V] : symmetric_category (Action V G) :=
symmetric_category_of_faithful (forget_braided V G)
section
local attribute [simp] monoidal_preadditive.tensor_add monoidal_preadditive.add_tensor
variables [preadditive V] [monoidal_preadditive V]
instance : monoidal_preadditive (Action V G) := {}
variables {R : Type*} [semiring R] [linear R V] [monoidal_linear R V]
instance : monoidal_linear R (Action V G) := {}
end
variables (V G)
noncomputable theory
def functor_category_monoidal_equivalence : monoidal_functor (Action V G) (single_obj G ‚•§ V) :=
monoidal.from_transported (Action.functor_category_equivalence _ _).symm
instance : is_equivalence ((functor_category_monoidal_equivalence V G).to_functor) :=
by { change is_equivalence (Action.functor_category_equivalence _ _).functor, apply_instance, }
variables (H : Group.{u})
instance [right_rigid_category V] : right_rigid_category (single_obj (H : Mon.{u}) ‚•§ V) :=
by { change right_rigid_category (single_obj H ‚•§ V), apply_instance }
instance [right_rigid_category V] : right_rigid_category (Action V H) :=
right_rigid_category_of_equivalence (functor_category_monoidal_equivalence V _)
instance [left_rigid_category V] : left_rigid_category (single_obj (H : Mon.{u}) ‚•§ V) :=
by { change left_rigid_category (single_obj H ‚•§ V), apply_instance }
instance [left_rigid_category V] : left_rigid_category (Action V H) :=
left_rigid_category_of_equivalence (functor_category_monoidal_equivalence V _)
instance [rigid_category V] : rigid_category (single_obj (H : Mon.{u}) ‚•§ V) :=
by { change rigid_category (single_obj H ‚•§ V), apply_instance }
instance [rigid_category V] : rigid_category (Action V H) :=
rigid_category_of_equivalence (functor_category_monoidal_equivalence V _)
variables {V H} (X : Action V H)
@[simp] lemma right_dual_V [right_rigid_category V] : (X·òÅ).V = (X.V)·òÅ := rfl
@[simp] lemma left_dual_V [left_rigid_category V] : (·òÅX).V = ·òÅ(X.V) := rfl
@[simp] lemma right_dual_œÅ [right_rigid_category V] (h : H) : (X·òÅ).œÅ h = (X.œÅ (h‚Åª¬π : H))·òÅ :=
by { rw ‚Üêsingle_obj.inv_as_inv, refl }
@[simp] lemma left_dual_œÅ [left_rigid_category V] (h : H) : (·òÅX).œÅ h = ·òÅ(X.œÅ (h‚Åª¬π : H)) :=
by { rw ‚Üêsingle_obj.inv_as_inv, refl }
end monoidal
def Action_punit_equivalence : Action V (Mon.of punit) ‚âå V :=
{ functor := forget V _,
  inverse :=
  { obj := Œª X, ‚ü®X, 1‚ü©,
    map := Œª X Y f, ‚ü®f, Œª ‚ü®‚ü©, by simp‚ü©, },
  unit_iso := nat_iso.of_components (Œª X, mk_iso (iso.refl _) (Œª ‚ü®‚ü©, by simpa using œÅ_one X))
    (by tidy),
  counit_iso := nat_iso.of_components (Œª X, iso.refl _) (by tidy), }
variables (V)
@[simps]
def res {G H : Mon} (f : G ‚ü∂ H) : Action V H ‚•§ Action V G :=
{ obj := Œª M,
  { V := M.V,
    œÅ := f ‚â´ M.œÅ },
  map := Œª M N p,
  { hom := p.hom,
    comm' := Œª g, p.comm (f g) } }
def res_id {G : Mon} : res V (ùüô G) ‚âÖ ùü≠ (Action V G) :=
nat_iso.of_components (Œª M, mk_iso (iso.refl _) (by tidy)) (by tidy)
attribute [simps] res_id
def res_comp {G H K : Mon} (f : G ‚ü∂ H) (g : H ‚ü∂ K) : res V g ‚ãô res V f ‚âÖ res V (f ‚â´ g) :=
nat_iso.of_components (Œª M, mk_iso (iso.refl _) (by tidy)) (by tidy)
attribute [simps] res_comp
@[simps]
def map_Action (F : V ‚•§ W) (G : Mon.{u}) : Action V G ‚•§ Action W G :=
{ obj := Œª M,
  { V := F.obj M.V,
    œÅ :=
    { to_fun := Œª g, F.map (M.œÅ g),
      map_one' := by simp only [End.one_def, Action.œÅ_one, F.map_id],
      map_mul' := Œª g h, by simp only [End.mul_def, F.map_comp, map_mul], }, },
  map := Œª M N f,
  { hom := F.map f.hom,
    comm' := Œª g, by { dsimp, rw [‚ÜêF.map_comp, f.comm, F.map_comp], }, },
  map_id' := Œª M, by { ext, simp only [Action.id_hom, F.map_id], },
  map_comp' := Œª M N P f g, by { ext, simp only [Action.comp_hom, F.map_comp], }, }
variables (F : V ‚•§ W) (G : Mon.{u}) [preadditive V] [preadditive W]
instance map_Action_preadditive [F.additive] : (F.map_Action G).additive := {}
variables {R : Type*} [semiring R] [category_theory.linear R V] [category_theory.linear R W]
instance map_Action_linear [F.additive] [F.linear R] : (F.map_Action G).linear R := {}
end category_theory.functor
