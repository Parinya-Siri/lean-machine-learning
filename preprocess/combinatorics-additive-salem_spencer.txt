import algebra.hom.freiman
import analysis.asymptotics.asymptotics
import analysis.convex.strict_convex_space
open finset function metric nat
open_locale pointwise
variables {F Œ± Œ≤ ùïú E : Type*}
section salem_spencer
open set
section monoid
variables [monoid Œ±] [monoid Œ≤] (s t : set Œ±)
@[to_additive "A Salem-Spencer, aka non averaging, set `s` in an additive monoid
is a set such that the average of any two distinct elements is not in the set."]
def mul_salem_spencer : Prop := ‚àÄ ‚¶Éa b c‚¶Ñ, a ‚àà s ‚Üí b ‚àà s ‚Üí c ‚àà s ‚Üí a * b = c * c ‚Üí a = b
@[to_additive]
instance {Œ± : Type*} [decidable_eq Œ±] [monoid Œ±] {s : finset Œ±} :
  decidable (mul_salem_spencer (s : set Œ±)) :=
decidable_of_iff (‚àÄ a ‚àà s, ‚àÄ b ‚àà s, ‚àÄ c ‚àà s, a * b = c * c ‚Üí a = b)
  ‚ü®Œª h a b c ha hb hc, h a ha b hb c hc, Œª h a ha b hb c hc, h ha hb hc‚ü©
variables {s t}
@[to_additive]
lemma mul_salem_spencer.mono (h : t ‚äÜ s) (hs : mul_salem_spencer s) : mul_salem_spencer t :=
Œª a b c ha hb hc, hs (h ha) (h hb) (h hc)
@[simp, to_additive]
lemma mul_salem_spencer_empty : mul_salem_spencer (‚àÖ : set Œ±) := Œª a _ _ ha, ha.elim
@[to_additive]
lemma set.subsingleton.mul_salem_spencer (hs : s.subsingleton) : mul_salem_spencer s :=
Œª a b _ ha hb _ _, hs ha hb
@[simp, to_additive]
lemma mul_salem_spencer_singleton (a : Œ±) : mul_salem_spencer ({a} : set Œ±) :=
subsingleton_singleton.mul_salem_spencer
@[to_additive add_salem_spencer.prod]
lemma mul_salem_spencer.prod {t : set Œ≤} (hs : mul_salem_spencer s) (ht : mul_salem_spencer t) :
  mul_salem_spencer (s √óÀ¢ t) :=
Œª a b c ha hb hc h,
  prod.ext (hs ha.1 hb.1 hc.1 (prod.ext_iff.1 h).1) (ht ha.2 hb.2 hc.2 (prod.ext_iff.1 h).2)
@[to_additive]
lemma mul_salem_spencer_pi {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [Œ† i, monoid (Œ± i)] {s : Œ† i, set (Œ± i)}
  (hs : ‚àÄ i, mul_salem_spencer (s i)) :
  mul_salem_spencer ((univ : set Œπ).pi s) :=
Œª a b c ha hb hc h, funext $ Œª i, hs i (ha i trivial) (hb i trivial) (hc i trivial) $ congr_fun h i
end monoid
section comm_monoid
variables [comm_monoid Œ±] [comm_monoid Œ≤] {s : set Œ±} {a : Œ±}
@[to_additive]
lemma mul_salem_spencer.of_image [fun_like F Œ± (Œª _, Œ≤)] [freiman_hom_class F s Œ≤ 2] (f : F)
  (hf : s.inj_on f) (h : mul_salem_spencer (f '' s)) :
  mul_salem_spencer s :=
Œª a b c ha hb hc habc, hf ha hb $ h (mem_image_of_mem _ ha) (mem_image_of_mem _ hb)
  (mem_image_of_mem _ hc) $ map_mul_map_eq_map_mul_map f ha hb hc hc habc
lemma add_salem_spencer_frontier [linear_ordered_field ùïú] [topological_space E] [add_comm_monoid E]
  [module ùïú E] {s : set E} (hs‚ÇÄ : is_closed s) (hs‚ÇÅ : strict_convex ùïú s) :
  add_salem_spencer (frontier s) :=
begin
  intros a b c ha hb hc habc,
  obtain rfl : (1 / 2 : ùïú) ‚Ä¢ a + (1 / 2 : ùïú) ‚Ä¢ b = c,
  { rwa [‚Üêsmul_add, one_div, inv_smul_eq_iff‚ÇÄ (show (2 : ùïú) ‚â† 0, by norm_num), two_smul] },
  exact hs‚ÇÅ.eq (hs‚ÇÄ.frontier_subset ha) (hs‚ÇÄ.frontier_subset hb) one_half_pos one_half_pos
    (add_halves _) hc.2,
end
lemma add_salem_spencer_sphere [normed_group E] [normed_space ‚Ñù E] [strict_convex_space ‚Ñù E] (x : E)
  (r : ‚Ñù) : add_salem_spencer (sphere x r) :=
begin
  obtain rfl | hr := eq_or_ne r 0,
  { rw sphere_zero,
    exact add_salem_spencer_singleton _ },
  { convert add_salem_spencer_frontier is_closed_ball (strict_convex_closed_ball ‚Ñù x r),
    exact (frontier_closed_ball _ hr).symm }
end
end salem_spencer
open finset
section roth_number
variables [decidable_eq Œ±]
section monoid
variables [monoid Œ±] [decidable_eq Œ≤] [monoid Œ≤] (s t : finset Œ±)
@[to_additive "The additive Roth number of a finset is the cardinality of its biggest additive
Salem-Spencer subset. The usual Roth number corresponds to `add_roth_number (finset.range n)`, see
`roth_number_nat`. "]
def mul_roth_number : finset Œ± ‚Üío ‚Ñï :=
‚ü®Œª s, nat.find_greatest (Œª m, ‚àÉ t ‚äÜ s, t.card = m ‚àß mul_salem_spencer (t : set Œ±)) s.card,
begin
  rintro t u htu,
  refine nat.find_greatest_mono (Œª m, _) (card_le_of_subset htu),
  rintro ‚ü®v, hvt, hv‚ü©,
  exact ‚ü®v, hvt.trans htu, hv‚ü©,
end‚ü©
@[to_additive]
lemma mul_roth_number_le : mul_roth_number s ‚â§ s.card := by convert nat.find_greatest_le s.card
@[to_additive]
lemma mul_roth_number_spec : ‚àÉ t ‚äÜ s, t.card = mul_roth_number s ‚àß mul_salem_spencer (t : set Œ±) :=
@nat.find_greatest_spec _ (Œª m, ‚àÉ t ‚äÜ s, t.card = m ‚àß mul_salem_spencer (t : set Œ±)) _ _
  (nat.zero_le _) ‚ü®‚àÖ, empty_subset _, card_empty, mul_salem_spencer_empty‚ü©
variables {s t} {n : ‚Ñï}
@[to_additive]
lemma mul_salem_spencer.le_mul_roth_number (hs : mul_salem_spencer (s : set Œ±)) (h : s ‚äÜ t) :
  s.card ‚â§ mul_roth_number t :=
le_find_greatest (card_le_of_subset h) ‚ü®s, h, rfl, hs‚ü©
@[to_additive]
lemma mul_salem_spencer.roth_number_eq (hs : mul_salem_spencer (s : set Œ±)) :
  mul_roth_number s = s.card :=
(mul_roth_number_le _).antisymm $ hs.le_mul_roth_number $ subset.refl _
@[simp, to_additive]
lemma mul_roth_number_empty : mul_roth_number (‚àÖ : finset Œ±) = 0 :=
nat.eq_zero_of_le_zero $ (mul_roth_number_le _).trans card_empty.le
@[simp, to_additive]
lemma mul_roth_number_singleton (a : Œ±) : mul_roth_number ({a} : finset Œ±) = 1 :=
begin
  convert mul_salem_spencer.roth_number_eq _,
  rw coe_singleton,
  exact mul_salem_spencer_singleton a,
end
@[to_additive]
lemma mul_roth_number_union_le (s t : finset Œ±) :
  mul_roth_number (s ‚à™ t) ‚â§ mul_roth_number s + mul_roth_number t :=
let ‚ü®u, hus, hcard, hu‚ü© := mul_roth_number_spec (s ‚à™ t) in
calc
  mul_roth_number (s ‚à™ t)
      = u.card : hcard.symm
  ... = (u ‚à© s ‚à™ u ‚à© t).card
      : by rw [‚Üêinter_distrib_left, (inter_eq_left_iff_subset _ _).2 hus]
  ... ‚â§ (u ‚à© s).card + (u ‚à© t).card : card_union_le _ _
  ... ‚â§ mul_roth_number s + mul_roth_number t
      : add_le_add ((hu.mono $ inter_subset_left _ _).le_mul_roth_number $ inter_subset_right _ _)
          ((hu.mono $ inter_subset_left _ _).le_mul_roth_number $ inter_subset_right _ _)
@[to_additive]
lemma le_mul_roth_number_product (s : finset Œ±) (t : finset Œ≤) :
  mul_roth_number s * mul_roth_number t ‚â§ mul_roth_number (s.product t) :=
begin
  obtain ‚ü®u, hus, hucard, hu‚ü© := mul_roth_number_spec s,
  obtain ‚ü®v, hvt, hvcard, hv‚ü© := mul_roth_number_spec t,
  rw [‚Üêhucard, ‚Üêhvcard, ‚Üêcard_product],
  refine mul_salem_spencer.le_mul_roth_number _ (product_subset_product hus hvt),
  rw coe_product,
  exact hu.prod hv,
end
@[to_additive]
lemma mul_roth_number_lt_of_forall_not_mul_salem_spencer
  (h : ‚àÄ t ‚àà powerset_len n s, ¬¨mul_salem_spencer ((t : finset Œ±) : set Œ±)) :
  mul_roth_number s < n :=
begin
  obtain ‚ü®t, hts, hcard, ht‚ü© := mul_roth_number_spec s,
  rw [‚Üêhcard, ‚Üênot_le],
  intro hn,
  obtain ‚ü®u, hut, rfl‚ü© := exists_smaller_set t n hn,
  exact h _ (mem_powerset_len.2 ‚ü®hut.trans hts, rfl‚ü©) (ht.mono hut),
end
end monoid
section cancel_comm_monoid
variables [cancel_comm_monoid Œ±] (s : finset Œ±) (a : Œ±)
@[simp, to_additive] lemma mul_roth_number_map_mul_left :
  mul_roth_number (s.map $ mul_left_embedding a) = mul_roth_number s :=
begin
  refine le_antisymm _ _,
  { obtain ‚ü®u, hus, hcard, hu‚ü© := mul_roth_number_spec (s.map $ mul_left_embedding a),
    rw subset_map_iff at hus,
    obtain ‚ü®u, hus, rfl‚ü© := hus,
    rw coe_map at hu,
    rw [‚Üêhcard, card_map],
    exact (mul_salem_spencer_mul_left_iff.1 hu).le_mul_roth_number hus },
  { obtain ‚ü®u, hus, hcard, hu‚ü© := mul_roth_number_spec s,
    have h : mul_salem_spencer (u.map $ mul_left_embedding a : set Œ±),
    { rw coe_map,
      exact hu.mul_left },
    convert h.le_mul_roth_number (map_subset_map.2 hus),
    rw [card_map, hcard] }
end
@[simp, to_additive] lemma mul_roth_number_map_mul_right :
  mul_roth_number (s.map $ mul_right_embedding a) = mul_roth_number s :=
by rw [‚Üêmul_left_embedding_eq_mul_right_embedding, mul_roth_number_map_mul_left s a]
end cancel_comm_monoid
end roth_number
section roth_number_nat
variables {s : finset ‚Ñï} {k n : ‚Ñï}
def roth_number_nat : ‚Ñï ‚Üío ‚Ñï :=
‚ü®Œª n, add_roth_number (range n), add_roth_number.mono.comp range_mono‚ü©
lemma roth_number_nat_def (n : ‚Ñï) : roth_number_nat n = add_roth_number (range n) := rfl
lemma roth_number_nat_le (N : ‚Ñï) : roth_number_nat N ‚â§ N :=
(add_roth_number_le _).trans (card_range _).le
lemma roth_number_nat_spec (n : ‚Ñï) :
  ‚àÉ t ‚äÜ range n, t.card = roth_number_nat n ‚àß add_salem_spencer (t : set ‚Ñï) :=
add_roth_number_spec _
lemma add_salem_spencer.le_roth_number_nat (s : finset ‚Ñï) (hs : add_salem_spencer (s : set ‚Ñï))
  (hsn : ‚àÄ x ‚àà s, x < n) (hsk : s.card = k) :
  k ‚â§ roth_number_nat n :=
hsk.ge.trans $ hs.le_add_roth_number $ Œª x hx, mem_range.2 $ hsn x hx
lemma roth_number_nat_add_le (M N : ‚Ñï) :
  roth_number_nat (M + N) ‚â§ roth_number_nat M + roth_number_nat N :=
begin
  simp_rw roth_number_nat_def,
  rw [range_add_eq_union, ‚Üêadd_roth_number_map_add_left (range N) M],
  exact add_roth_number_union_le _ _,
end
@[simp] lemma roth_number_nat_zero : roth_number_nat 0 = 0 := rfl
lemma add_roth_number_Ico (a b : ‚Ñï) : add_roth_number (Ico a b) = roth_number_nat (b - a) :=
begin
  obtain h | h := le_total b a,
  { rw [tsub_eq_zero_of_le h, Ico_eq_empty_of_le h, roth_number_nat_zero, add_roth_number_empty] },
  convert add_roth_number_map_add_left _ a,
  rw [range_eq_Ico, map_eq_image],
  convert (image_add_left_Ico 0 (b - a) _).symm,
  exact (add_tsub_cancel_of_le h).symm,
end
open asymptotics filter
lemma roth_number_nat_is_O_with_id :
  is_O_with 1 at_top (Œª N, (roth_number_nat N : ‚Ñù)) (Œª N, (N : ‚Ñù)) :=
is_O_with_of_le _ $ by simpa only [real.norm_coe_nat, nat.cast_le] using roth_number_nat_le
lemma roth_number_nat_is_O_id : (Œª N, (roth_number_nat N : ‚Ñù)) =O[at_top] (Œª N, (N : ‚Ñù)) :=
roth_number_nat_is_O_with_id.is_O
end roth_number_nat
