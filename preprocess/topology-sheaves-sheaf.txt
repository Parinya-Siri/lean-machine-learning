import topology.sheaves.sheaf_condition.equalizer_products
import category_theory.full_subcategory
import category_theory.limits.unit
universes w v u
noncomputable theory
open category_theory
open category_theory.limits
open topological_space
open opposite
open topological_space.opens
namespace Top
variables {C : Type u} [category.{v} C] [has_products.{v} C]
variables {X : Top.{w}} (F : presheaf C X) {Œπ : Type v} (U : Œπ ‚Üí opens X)
namespace presheaf
open sheaf_condition_equalizer_products
def is_sheaf (F : presheaf.{w v u} C X) : Prop :=
‚àÄ ‚¶ÉŒπ : Type v‚¶Ñ (U : Œπ ‚Üí opens X), nonempty (is_limit (sheaf_condition_equalizer_products.fork F U))
lemma is_sheaf_unit (F : presheaf (category_theory.discrete unit) X) : F.is_sheaf :=
Œª Œπ U, ‚ü®punit_cone_is_limit‚ü©
lemma is_sheaf_of_iso {F G : presheaf C X} (Œ± : F ‚âÖ G) (h : F.is_sheaf) : G.is_sheaf :=
Œª Œπ U, ‚ü®is_limit.of_iso_limit
  ((is_limit.postcompose_inv_equiv _ _).symm (h U).some)
  (sheaf_condition_equalizer_products.fork.iso_of_iso U Œ±.symm).symm‚ü©
lemma is_sheaf_iso_iff {F G : presheaf C X} (Œ± : F ‚âÖ G) : F.is_sheaf ‚Üî G.is_sheaf :=
‚ü®(Œª h, is_sheaf_of_iso Œ± h), (Œª h, is_sheaf_of_iso Œ±.symm h)‚ü©
end presheaf
variables (C X)
@[derive category]
def sheaf : Type (max u v w) := { F : presheaf C X // F.is_sheaf }
@[derive [full, faithful]]
def forget : Top.sheaf C X ‚•§ Top.presheaf C X :=
full_subcategory_inclusion presheaf.is_sheaf
@[simp] lemma id_app (F : sheaf C X) (t) : (ùüô F : F ‚ü∂ F).app t = ùüô _ := rfl
@[simp] lemma comp_app {F G H : sheaf C X} (f : F ‚ü∂ G) (g : G ‚ü∂ H) (t) :
  (f ‚â´ g).app t = f.app t ‚â´ g.app t := rfl
end sheaf
end Top
