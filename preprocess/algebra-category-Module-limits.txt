import algebra.category.Module.basic
import algebra.category.Group.limits
import algebra.direct_limit
open category_theory
open category_theory.limits
def sections_submodule (F : J ‚•§ Module.{max v w} R) :
  submodule R (Œ† j, F.obj j) :=
{ carrier := (F ‚ãô forget (Module R)).sections,
  smul_mem' := Œª r s sh j j' f,
  begin
    simp only [forget_map_eq_coe, functor.comp_map, pi.smul_apply, linear_map.map_smul],
    dsimp [functor.sections] at sh,
    rw sh f,
  end,
  ..(AddGroup.sections_add_subgroup
      (F ‚ãô forget‚ÇÇ (Module R) AddCommGroup.{max v w} ‚ãô forget‚ÇÇ AddCommGroup AddGroup.{max v w})) }
def limit_œÄ_linear_map (F : J ‚•§ Module R) (j) :
  (types.limit_cone (F ‚ãô forget (Module.{max v w} R))).X ‚Üí‚Çó[R] (F ‚ãô forget (Module R)).obj j :=
{ to_fun := (types.limit_cone (F ‚ãô forget (Module R))).œÄ.app j,
  map_smul' := Œª x y, rfl,
  map_add' := Œª x y, rfl }
namespace has_limits
def limit_cone (F : J ‚•§ Module.{max v w} R) : cone F :=
{ X := Module.of R (types.limit_cone (F ‚ãô forget _)).X,
  œÄ :=
  { app := limit_œÄ_linear_map F,
    naturality' := Œª j j' f,
      linear_map.coe_injective ((types.limit_cone (F ‚ãô forget _)).œÄ.naturality f) } }
def limit_cone_is_limit (F : J ‚•§ Module.{max v w} R) : is_limit (limit_cone F) :=
by refine is_limit.of_faithful
      (forget (Module R)) (types.limit_cone_is_limit _)
      (Œª s, ‚ü®_, _, _‚ü©) (Œª s, rfl);
    intros;
    ext j;
    simp only [subtype.coe_mk, functor.map_cone_œÄ_app, forget_map_eq_coe,
         linear_map.map_add, linear_map.map_smul];
    refl
end has_limits
open has_limits
@[irreducible]
instance has_limits_of_size : has_limits_of_size.{v v} (Module.{max v w} R) :=
{ has_limits_of_shape := Œª J ùí•, by exactI
  { has_limit := Œª F, has_limit.mk
    { cone     := limit_cone F,
      is_limit := limit_cone_is_limit F } } }
instance has_limits : has_limits (Module.{w} R) := Module.has_limits_of_size.{w w u}
def forget‚ÇÇ_AddCommGroup_preserves_limits_aux (F : J ‚•§ Module.{max v w} R) :
  is_limit ((forget‚ÇÇ (Module R) AddCommGroup).map_cone (limit_cone F)) :=
AddCommGroup.limit_cone_is_limit (F ‚ãô forget‚ÇÇ (Module R) AddCommGroup.{max v w})
instance forget‚ÇÇ_AddCommGroup_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget‚ÇÇ (Module R) AddCommGroup.{max v w}) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F, preserves_limit_of_preserves_limit_cone
      (limit_cone_is_limit F) (forget‚ÇÇ_AddCommGroup_preserves_limits_aux F) } }
instance forget‚ÇÇ_AddCommGroup_preserves_limits :
  preserves_limits (forget‚ÇÇ (Module R) AddCommGroup.{w}) :=
Module.forget‚ÇÇ_AddCommGroup_preserves_limits_of_size.{w w}
instance forget_preserves_limits_of_size :
  preserves_limits_of_size.{v v} (forget (Module.{max v w} R)) :=
{ preserves_limits_of_shape := Œª J ùí•, by exactI
  { preserves_limit := Œª F, preserves_limit_of_preserves_limit_cone
    (limit_cone_is_limit F) (types.limit_cone_is_limit (F ‚ãô forget _)) } }
instance forget_preserves_limits : preserves_limits (forget (Module.{w} R)) :=
Module.forget_preserves_limits_of_size.{w w}
section direct_limit
open module
variables {Œπ : Type v}
variables [dec_Œπ : decidable_eq Œπ] [preorder Œπ]
variables (G : Œπ ‚Üí Type v)
variables [Œ† i, add_comm_group (G i)] [Œ† i, module R (G i)]
variables (f : Œ† i j, i ‚â§ j ‚Üí G i ‚Üí‚Çó[R] G j) [directed_system G (Œª i j h, f i j h)]
@[simps]
def direct_limit_diagram : Œπ ‚•§ Module R :=
{ obj := Œª i, Module.of R (G i),
  map := Œª i j hij, f i j hij.le,
  map_id' := Œª i, by { apply linear_map.ext, intro x, apply module.directed_system.map_self },
  map_comp' := Œª i j k hij hjk,
  begin
    apply linear_map.ext,
    intro x,
    symmetry,
    apply module.directed_system.map_map
  end }
variables [decidable_eq Œπ]
@[simps]
def direct_limit_cocone : cocone (direct_limit_diagram G f) :=
{ X := Module.of R $ direct_limit G f,
  Œπ := { app := module.direct_limit.of R Œπ G f,
         naturality' := Œª i j hij, by { apply linear_map.ext, intro x, exact direct_limit.of_f } } }
@[simps]
def direct_limit_is_colimit [nonempty Œπ] [is_directed Œπ (‚â§)] :
  is_colimit (direct_limit_cocone G f) :=
{ desc := Œª s, direct_limit.lift R Œπ G f s.Œπ.app $ Œª i j h x, by { rw [‚Üês.w (hom_of_le h)], refl },
  fac' := Œª s i,
  begin
    apply linear_map.ext,
    intro x,
    dsimp,
    exact direct_limit.lift_of s.Œπ.app _ x,
  end,
  uniq' := Œª s m h,
  begin
    have : s.Œπ.app = Œª i, linear_map.comp m (direct_limit.of R Œπ (Œª i, G i) (Œª i j H, f i j H) i),
    { funext i, rw ‚Üê h, refl },
    apply linear_map.ext,
    intro x,
    simp only [this],
    apply module.direct_limit.lift_unique
  end }
end direct_limit
end Module
