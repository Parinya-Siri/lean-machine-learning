import category_theory.opposites
def const : C โฅค (J โฅค C) :=
{ obj := ฮป X,
  { obj := ฮป j, X,
    map := ฮป j j' f, ๐ X },
  map := ฮป X Y f, { app := ฮป j, f } }
namespace const
open opposite
variables {J}
@[simp] lemma obj_obj (X : C) (j : J) : ((const J).obj X).obj j = X := rfl
@[simp] lemma obj_map (X : C) {j j' : J} (f : j โถ j') : ((const J).obj X).map f = ๐ X := rfl
@[simp] lemma map_app {X Y : C} (f : X โถ Y) (j : J) : ((const J).map f).app j = f := rfl
def op_obj_op (X : C) :
  (const Jแตแต).obj (op X) โ ((const J).obj X).op :=
{ hom := { app := ฮป j, ๐ _ },
  inv := { app := ฮป j, ๐ _ } }
@[simp] lemma op_obj_op_hom_app (X : C) (j : Jแตแต) : (op_obj_op X).hom.app j = ๐ _ := rfl
@[simp] lemma op_obj_op_inv_app (X : C) (j : Jแตแต) : (op_obj_op X).inv.app j = ๐ _ := rfl
def op_obj_unop (X : Cแตแต) :
  (const Jแตแต).obj (unop X) โ ((const J).obj X).left_op :=
{ hom := { app := ฮป j, ๐ _ },
  inv := { app := ฮป j, ๐ _ } }
@[simps] def const_comp (X : C) (F : C โฅค D) :
  (const J).obj X โ F โ (const J).obj (F.obj X) :=
{ hom := { app := ฮป _, ๐ _ },
  inv := { app := ฮป _, ๐ _ } }
instance [nonempty J] : faithful (const J : C โฅค J โฅค C) :=
{ map_injective' := ฮป X Y f g e, nat_trans.congr_app e (classical.arbitrary J) }
end
end category_theory.functor
