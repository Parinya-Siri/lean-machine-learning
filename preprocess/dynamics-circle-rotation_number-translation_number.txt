import algebra.hom.iterate
import analysis.specific_limits.basic
import order.iterate
import order.semiconj_Sup
import topology.algebra.order.monotone_continuity
open filter set function (hiding commute) int
open_locale topological_space classical
structure circle_deg1_lift : Type :=
(to_fun : â„ â†’ â„)
(monotone' : monotone to_fun)
(map_add_one' : âˆ€ x, to_fun (x + 1) = to_fun x + 1)
namespace circle_deg1_lift
instance : has_coe_to_fun circle_deg1_lift (Î» _, â„ â†’ â„) := âŸ¨circle_deg1_lift.to_funâŸ©
@[simp] lemma coe_mk (f hâ‚ hâ‚‚) : â‡‘(mk f hâ‚ hâ‚‚) = f := rfl
variables (f g : circle_deg1_lift)
protected lemma monotone  : monotone f := f.monotone'
@[mono] lemma mono {x y} (h : x â‰¤ y) : f x â‰¤ f y := f.monotone h
lemma strict_mono_iff_injective : strict_mono f â†” injective f :=
f.monotone.strict_mono_iff_injective
@[simp] lemma map_add_one : âˆ€ x, f (x + 1) = f x + 1 := f.map_add_one'
@[simp] lemma map_one_add (x : â„) : f (1 + x) = 1 + f x := by rw [add_comm, map_add_one, add_comm]
theorem coe_inj : âˆ€ â¦ƒf g : circle_deg1_lift â¦„, (f : â„ â†’ â„) = g â†’ f = g :=
assume âŸ¨f, fm, fdâŸ© âŸ¨g, gm, gdâŸ© h, by congr; exact h
@[ext] theorem ext â¦ƒf g : circle_deg1_lift â¦„ (h : âˆ€ x, f x = g x) : f = g :=
coe_inj $ funext h
theorem ext_iff {f g : circle_deg1_lift} : f = g â†” âˆ€ x, f x = g x :=
âŸ¨Î» h x, h â–¸ rfl, Î» h, ext hâŸ©
instance : monoid circle_deg1_lift :=
{ mul := Î» f g,
  { to_fun := f âˆ˜ g,
    monotone' := f.monotone.comp g.monotone,
    map_add_one' := Î» x, by simp [map_add_one] },
  one := âŸ¨id, monotone_id, Î» _, rflâŸ©,
  mul_one := Î» f, coe_inj $ function.comp.right_id f,
  one_mul := Î» f, coe_inj $ function.comp.left_id f,
  mul_assoc := Î» fâ‚ fâ‚‚ fâ‚ƒ, coe_inj rfl }
instance : inhabited circle_deg1_lift := âŸ¨1âŸ©
@[simp] lemma coe_mul : â‡‘(f * g) = f âˆ˜ g := rfl
lemma mul_apply (x) : (f * g) x = f (g x) := rfl
@[simp] lemma coe_one : â‡‘(1 : circle_deg1_lift) = id := rfl
instance units_has_coe_to_fun : has_coe_to_fun (circle_deg1_liftË£) (Î» _, â„ â†’ â„) :=
âŸ¨Î» f, â‡‘(f : circle_deg1_lift)âŸ©
@[simp, norm_cast] lemma units_coe (f : circle_deg1_liftË£) : â‡‘(f : circle_deg1_lift) = f := rfl
@[simp] lemma units_inv_apply_apply (f : circle_deg1_liftË£) (x : â„) :
  (fâ»Â¹ : circle_deg1_liftË£) (f x) = x :=
by simp only [â† units_coe, â† mul_apply, f.inv_mul, coe_one, id]
@[simp] lemma units_apply_inv_apply (f : circle_deg1_liftË£) (x : â„) :
  f ((fâ»Â¹ : circle_deg1_liftË£) x) = x :=
by simp only [â† units_coe, â† mul_apply, f.mul_inv, coe_one, id]
def to_order_iso : circle_deg1_liftË£ â†’* â„ â‰ƒo â„ :=
{ to_fun := Î» f,
    { to_fun := f,
      inv_fun := â‡‘(fâ»Â¹),
      left_inv := units_inv_apply_apply f,
      right_inv := units_apply_inv_apply f,
      map_rel_iff' := Î» x y, âŸ¨Î» h, by simpa using mono â†‘(fâ»Â¹) h, mono fâŸ© },
  map_one' := rfl,
  map_mul' := Î» f g, rfl }
@[simp] lemma coe_to_order_iso (f : circle_deg1_liftË£) : â‡‘(to_order_iso f) = f := rfl
@[simp] lemma coe_to_order_iso_symm (f : circle_deg1_liftË£) :
  â‡‘(to_order_iso f).symm = (fâ»Â¹ : circle_deg1_liftË£) := rfl
@[simp] lemma coe_to_order_iso_inv (f : circle_deg1_liftË£) :
  â‡‘(to_order_iso f)â»Â¹ = (fâ»Â¹ : circle_deg1_liftË£) := rfl
lemma is_unit_iff_bijective {f : circle_deg1_lift} : is_unit f â†” bijective f :=
âŸ¨Î» âŸ¨u, hâŸ©, h â–¸ (to_order_iso u).bijective, Î» h, units.is_unit
  { val := f,
    inv := { to_fun := (equiv.of_bijective f h).symm,
             monotone' := Î» x y hxy, (f.strict_mono_iff_injective.2 h.1).le_iff_le.1
               (by simp only [equiv.of_bijective_apply_symm_apply f h, hxy]),
             map_add_one' := Î» x, h.1 $
               by simp only [equiv.of_bijective_apply_symm_apply f, f.map_add_one] },
    val_inv := ext $ equiv.of_bijective_apply_symm_apply f h,
    inv_val := ext $ equiv.of_bijective_symm_apply_apply f h }âŸ©
lemma coe_pow : âˆ€ n : â„•, â‡‘(f^n) = (f^[n])
| 0 := rfl
| (n+1) := by {ext x, simp [coe_pow n, pow_succ'] }
lemma semiconj_by_iff_semiconj {f gâ‚ gâ‚‚ : circle_deg1_lift} :
  semiconj_by f gâ‚ gâ‚‚ â†” semiconj f gâ‚ gâ‚‚ :=
ext_iff
lemma commute_iff_commute {f g : circle_deg1_lift} :
  commute f g â†” function.commute f g :=
ext_iff
def translate : multiplicative â„ â†’* circle_deg1_liftË£ :=
by refine (units.map _).comp to_units.to_monoid_hom; exact
{ to_fun := Î» x, âŸ¨Î» y, x.to_add + y, Î» yâ‚ yâ‚‚ h, add_le_add_left h _, Î» y, (add_assoc _ _ _).symmâŸ©,
  map_one' := ext $ zero_add,
  map_mul' := Î» x y, ext $ add_assoc _ _ }
@[simp] lemma translate_apply (x y : â„) : translate (multiplicative.of_add x) y = x + y := rfl
@[simp]
lemma translate_inv_apply (x y : â„) : (translate $ multiplicative.of_add x)â»Â¹ y = -x + y := rfl
@[simp] lemma translate_zpow (x : â„) (n : â„¤) :
  (translate (multiplicative.of_add x))^n = translate (multiplicative.of_add $ â†‘n * x) :=
by simp only [â† zsmul_eq_mul, of_add_zsmul, monoid_hom.map_zpow]
@[simp] lemma translate_pow (x : â„) (n : â„•) :
  (translate (multiplicative.of_add x))^n = translate (multiplicative.of_add $ â†‘n * x) :=
translate_zpow x n
@[simp] lemma translate_iterate (x : â„) (n : â„•) :
  (translate (multiplicative.of_add x))^[n] = translate (multiplicative.of_add $ â†‘n * x) :=
by rw [â† units_coe, â† coe_pow, â† units.coe_pow, translate_pow, units_coe]
lemma commute_nat_add (n : â„•) : function.commute f ((+) n) :=
by simpa only [nsmul_one, add_left_iterate] using function.commute.iterate_right f.map_one_add n
lemma commute_add_nat (n : â„•) : function.commute f (Î» x, x + n) :=
by simp only [add_comm _ (n:â„), f.commute_nat_add n]
lemma commute_sub_nat (n : â„•) : function.commute f (Î» x, x - n) :=
by simpa only [sub_eq_add_neg] using
  (f.commute_add_nat n).inverses_right (equiv.add_right _).right_inv (equiv.add_right _).left_inv
lemma commute_add_int : âˆ€ n : â„¤, function.commute f (Î» x, x + n)
| (n:â„•) := f.commute_add_nat n
| -[1+n] := by simpa [sub_eq_add_neg] using f.commute_sub_nat (n + 1)
lemma commute_int_add (n : â„¤) : function.commute f ((+) n) :=
by simpa only [add_comm _ (n:â„)] using f.commute_add_int n
lemma commute_sub_int (n : â„¤) : function.commute f (Î» x, x - n) :=
by simpa only [sub_eq_add_neg] using
  (f.commute_add_int n).inverses_right (equiv.add_right _).right_inv (equiv.add_right _).left_inv
@[simp] lemma map_int_add (m : â„¤) (x : â„) : f (m + x) = m + f x :=
f.commute_int_add m x
@[simp] lemma map_add_int (x : â„) (m : â„¤) : f (x + m) = f x + m :=
f.commute_add_int m x
@[simp] lemma map_sub_int (x : â„) (n : â„¤) : f (x - n) = f x - n :=
f.commute_sub_int n x
@[simp] lemma map_add_nat (x : â„) (n : â„•) : f (x + n) = f x + n :=
f.map_add_int x n
@[simp] lemma map_nat_add (n : â„•) (x : â„) : f (n + x) = n + f x :=
f.map_int_add n x
@[simp] lemma map_sub_nat (x : â„) (n : â„•) : f (x - n) = f x - n :=
f.map_sub_int x n
lemma map_int_of_map_zero (n : â„¤) : f n = f 0 + n :=
by rw [â† f.map_add_int, zero_add]
@[simp] lemma map_fract_sub_fract_eq (x : â„) :
  f (fract x) - fract x = f x - x :=
by rw [int.fract, f.map_sub_int, sub_sub_sub_cancel_right]
noncomputable instance : lattice circle_deg1_lift :=
{ sup := Î» f g,
  { to_fun := Î» x, max (f x) (g x),
lemma map_le_of_map_zero (x : â„) : f x â‰¤ f 0 + âŒˆxâŒ‰ :=
calc f x â‰¤ f âŒˆxâŒ‰     : f.monotone $ le_ceil _
     ... = f 0 + âŒˆxâŒ‰ : f.map_int_of_map_zero _
lemma map_map_zero_le : f (g 0) â‰¤ f 0 + âŒˆg 0âŒ‰ := f.map_le_of_map_zero (g 0)
lemma floor_map_map_zero_le : âŒŠf (g 0)âŒ‹ â‰¤ âŒŠf 0âŒ‹ + âŒˆg 0âŒ‰ :=
calc âŒŠf (g 0)âŒ‹ â‰¤ âŒŠf 0 + âŒˆg 0âŒ‰âŒ‹ : floor_mono $ f.map_map_zero_le g
           ... = âŒŠf 0âŒ‹ + âŒˆg 0âŒ‰ : floor_add_int _ _
lemma ceil_map_map_zero_le : âŒˆf (g 0)âŒ‰ â‰¤ âŒˆf 0âŒ‰ + âŒˆg 0âŒ‰ :=
calc âŒˆf (g 0)âŒ‰ â‰¤ âŒˆf 0 + âŒˆg 0âŒ‰âŒ‰ : ceil_mono $ f.map_map_zero_le g
           ... = âŒˆf 0âŒ‰ + âŒˆg 0âŒ‰ : ceil_add_int _ _
lemma map_map_zero_lt : f (g 0) < f 0 + g 0 + 1 :=
calc f (g 0) â‰¤ f 0 + âŒˆg 0âŒ‰     : f.map_map_zero_le g
         ... < f 0 + (g 0 + 1) : add_lt_add_left (ceil_lt_add_one _) _
         ... = f 0 + g 0 + 1   : (add_assoc _ _ _).symm
lemma le_map_of_map_zero (x : â„) : f 0 + âŒŠxâŒ‹ â‰¤ f x :=
calc f 0 + âŒŠxâŒ‹ = f âŒŠxâŒ‹ : (f.map_int_of_map_zero _).symm
           ... â‰¤ f x   : f.monotone $ floor_le _
lemma le_map_map_zero : f 0 + âŒŠg 0âŒ‹ â‰¤ f (g 0) := f.le_map_of_map_zero (g 0)
lemma le_floor_map_map_zero : âŒŠf 0âŒ‹ + âŒŠg 0âŒ‹ â‰¤ âŒŠf (g 0)âŒ‹ :=
calc âŒŠf 0âŒ‹ + âŒŠg 0âŒ‹ = âŒŠf 0 + âŒŠg 0âŒ‹âŒ‹ : (floor_add_int _ _).symm
               ... â‰¤ âŒŠf (g 0)âŒ‹     : floor_mono $ f.le_map_map_zero g
lemma le_ceil_map_map_zero : âŒˆf 0âŒ‰ + âŒŠg 0âŒ‹ â‰¤ âŒˆ(f * g) 0âŒ‰ :=
calc âŒˆf 0âŒ‰ + âŒŠg 0âŒ‹ = âŒˆf 0 + âŒŠg 0âŒ‹âŒ‰ : (ceil_add_int _ _).symm
               ... â‰¤ âŒˆf (g 0)âŒ‰     : ceil_mono $ f.le_map_map_zero g
lemma lt_map_map_zero : f 0 + g 0 - 1 < f (g 0) :=
calc f 0 + g 0 - 1 = f 0 + (g 0 - 1) : add_sub_assoc _ _ _
               ... < f 0 + âŒŠg 0âŒ‹     : add_lt_add_left (sub_one_lt_floor _) _
               ... â‰¤ f (g 0)         : f.le_map_map_zero g
lemma dist_map_map_zero_lt : dist (f 0 + g 0) (f (g 0)) < 1 :=
begin
  rw [dist_comm, real.dist_eq, abs_lt, lt_sub_iff_add_lt', sub_lt_iff_lt_add', â† sub_eq_add_neg],
  exact âŸ¨f.lt_map_map_zero g, f.map_map_zero_lt gâŸ©
end
lemma dist_map_zero_lt_of_semiconj {f gâ‚ gâ‚‚ : circle_deg1_lift} (h : function.semiconj f gâ‚ gâ‚‚) :
  dist (gâ‚ 0) (gâ‚‚ 0) < 2 :=
calc dist (gâ‚ 0) (gâ‚‚ 0) â‰¤ dist (gâ‚ 0) (f (gâ‚ 0) - f 0) + dist _ (gâ‚‚ 0) : dist_triangle _ _ _
... = dist (f 0 + gâ‚ 0) (f (gâ‚ 0)) + dist (gâ‚‚ 0 + f 0) (gâ‚‚ (f 0)) :
  by simp only [h.eq, real.dist_eq, sub_sub, add_comm (f 0), sub_sub_eq_add_sub, abs_sub_comm
    (gâ‚‚ (f 0))]
... < 2 : add_lt_add (f.dist_map_map_zero_lt gâ‚) (gâ‚‚.dist_map_map_zero_lt f)
lemma dist_map_zero_lt_of_semiconj_by {f gâ‚ gâ‚‚ : circle_deg1_lift} (h : semiconj_by f gâ‚ gâ‚‚) :
  dist (gâ‚ 0) (gâ‚‚ 0) < 2 :=
dist_map_zero_lt_of_semiconj $ semiconj_by_iff_semiconj.1 h
protected lemma tendsto_at_bot : tendsto f at_bot at_bot :=
tendsto_at_bot_mono f.map_le_of_map_zero $ tendsto_at_bot_add_const_left _ _ $
  tendsto_at_bot_mono (Î» x, (ceil_lt_add_one x).le) $ tendsto_at_bot_add_const_right _ _ tendsto_id
protected lemma tendsto_at_top : tendsto f at_top at_top :=
tendsto_at_top_mono f.le_map_of_map_zero $ tendsto_at_top_add_const_left _ _ $
  tendsto_at_top_mono (Î» x, (sub_one_lt_floor x).le) $
    by simpa [sub_eq_add_neg] using tendsto_at_top_add_const_right _ _ tendsto_id
lemma continuous_iff_surjective : continuous f â†” function.surjective f :=
âŸ¨Î» h, h.surjective f.tendsto_at_top f.tendsto_at_bot, f.monotone.continuous_of_surjectiveâŸ©
lemma iterate_le_of_map_le_add_int {x : â„} {m : â„¤} (h : f x â‰¤ x + m) (n : â„•) :
  f^[n] x â‰¤ x + n * m :=
by simpa only [nsmul_eq_mul, add_right_iterate]
using (f.commute_add_int m).iterate_le_of_map_le f.monotone (monotone_id.add_const m) h n
lemma le_iterate_of_add_int_le_map {x : â„} {m : â„¤} (h : x + m â‰¤ f x) (n : â„•) :
  x + n * m â‰¤ (f^[n]) x :=
by simpa only [nsmul_eq_mul, add_right_iterate]
using (f.commute_add_int m).symm.iterate_le_of_map_le (monotone_id.add_const m) f.monotone h n
lemma iterate_eq_of_map_eq_add_int {x : â„} {m : â„¤} (h : f x = x + m) (n : â„•) :
  f^[n] x = x + n * m :=
by simpa only [nsmul_eq_mul, add_right_iterate]
using (f.commute_add_int m).iterate_eq_of_map_eq n h
lemma iterate_pos_le_iff {x : â„} {m : â„¤} {n : â„•} (hn : 0 < n) :
  f^[n] x â‰¤ x + n * m â†” f x â‰¤ x + m :=
by simpa only [nsmul_eq_mul, add_right_iterate]
using (f.commute_add_int m).iterate_pos_le_iff_map_le f.monotone (strict_mono_id.add_const m) hn
lemma iterate_pos_lt_iff {x : â„} {m : â„¤} {n : â„•} (hn : 0 < n) :
  f^[n] x < x + n * m â†” f x < x + m :=
by simpa only [nsmul_eq_mul, add_right_iterate]
using (f.commute_add_int m).iterate_pos_lt_iff_map_lt f.monotone (strict_mono_id.add_const m) hn
lemma iterate_pos_eq_iff {x : â„} {m : â„¤} {n : â„•} (hn : 0 < n) :
  f^[n] x = x + n * m â†” f x = x + m :=
by simpa only [nsmul_eq_mul, add_right_iterate]
using (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strict_mono_id.add_const m) hn
lemma le_iterate_pos_iff {x : â„} {m : â„¤} {n : â„•} (hn : 0 < n) :
  x + n * m â‰¤ (f^[n]) x â†” x + m â‰¤ f x :=
by simpa only [not_lt] using not_congr (f.iterate_pos_lt_iff hn)
lemma lt_iterate_pos_iff {x : â„} {m : â„¤} {n : â„•} (hn : 0 < n) :
  x + n * m < (f^[n]) x â†” x + m < f x :=
by simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)
lemma mul_floor_map_zero_le_floor_iterate_zero (n : â„•) : â†‘n * âŒŠf 0âŒ‹ â‰¤ âŒŠ(f^[n] 0)âŒ‹ :=
begin
  rw [le_floor, int.cast_mul, int.cast_coe_nat, â† zero_add ((n : â„) * _)],
  apply le_iterate_of_add_int_le_map,
  simp [floor_le]
end
noncomputable theory
def transnum_aux_seq (n : â„•) : â„ := (f^(2^n)) 0 / 2^n
def translation_number : â„ :=
lim at_top f.transnum_aux_seq
lemma tendsto_translation_number (x : â„) :
  tendsto (Î» n:â„•, ((f^n) x - x) / n) at_top (ğ“ $ Ï„ f) :=
begin
  rw [â† translation_number_conj_eq' (translate $ multiplicative.of_add x)],
  convert tendsto_translation_numberâ‚€ _,
  ext n,
  simp [sub_eq_neg_add, units.conj_pow']
end
lemma tendsto_translation_number' (x : â„) :
  tendsto (Î» n:â„•, ((f^(n+1)) x - x) / (n+1)) at_top (ğ“ $ Ï„ f) :=
by exact_mod_cast (tendsto_add_at_top_iff_nat 1).2 (f.tendsto_translation_number x)
lemma translation_number_mono : monotone Ï„ :=
Î» f g h, le_of_tendsto_of_tendsto' f.tendsto_translation_numberâ‚€
  g.tendsto_translation_numberâ‚€ $ Î» n, div_le_div_of_le_of_nonneg (pow_mono h n 0) n.cast_nonneg
lemma translation_number_translate (x : â„) :
  Ï„ (translate $ multiplicative.of_add x) = x :=
translation_number_eq_of_tendstoâ‚€' _ $
  by simp [nat.cast_add_one_ne_zero, mul_div_cancel_left, tendsto_const_nhds]
lemma translation_number_le_of_le_add {z : â„} (hz : âˆ€ x, f x â‰¤ x + z) : Ï„ f â‰¤ z :=
translation_number_translate z â–¸ translation_number_mono
  (Î» x, trans_rel_left _ (hz x) (add_comm _ _))
lemma le_translation_number_of_add_le {z : â„} (hz : âˆ€ x, x + z â‰¤ f x) : z â‰¤ Ï„ f :=
translation_number_translate z â–¸ translation_number_mono
  (Î» x, trans_rel_right _ (add_comm _ _) (hz x))
lemma translation_number_le_of_le_add_int {x : â„} {m : â„¤} (h : f x â‰¤ x + m) : Ï„ f â‰¤ m :=
le_of_tendsto' (f.tendsto_translation_number' x) $ Î» n,
(div_le_iff' (n.cast_add_one_pos : (0 : â„) < _)).mpr $ sub_le_iff_le_add'.2 $
(coe_pow f (n + 1)).symm â–¸ @nat.cast_add_one â„ _ n â–¸ f.iterate_le_of_map_le_add_int h (n + 1)
lemma translation_number_le_of_le_add_nat {x : â„} {m : â„•} (h : f x â‰¤ x + m) : Ï„ f â‰¤ m :=
@translation_number_le_of_le_add_int f x m h
lemma le_translation_number_of_add_int_le {x : â„} {m : â„¤} (h : x + m â‰¤ f x) : â†‘m â‰¤ Ï„ f :=
ge_of_tendsto' (f.tendsto_translation_number' x) $ Î» n,
(le_div_iff (n.cast_add_one_pos : (0 : â„) < _)).mpr $ le_sub_iff_add_le'.2 $
by simp only [coe_pow, mul_comm (m:â„), â† nat.cast_add_one, f.le_iterate_of_add_int_le_map h]
lemma le_translation_number_of_add_nat_le {x : â„} {m : â„•} (h : x + m â‰¤ f x) : â†‘m â‰¤ Ï„ f :=
@le_translation_number_of_add_int_le f x m h
lemma translation_number_of_eq_add_int {x : â„} {m : â„¤} (h : f x = x + m) : Ï„ f = m :=
le_antisymm (translation_number_le_of_le_add_int f $ le_of_eq h)
  (le_translation_number_of_add_int_le f $ le_of_eq h.symm)
lemma floor_sub_le_translation_number (x : â„) : â†‘âŒŠf x - xâŒ‹ â‰¤ Ï„ f :=
le_translation_number_of_add_int_le f $ le_sub_iff_add_le'.1 (floor_le $ f x - x)
lemma translation_number_le_ceil_sub (x : â„) : Ï„ f â‰¤ âŒˆf x - xâŒ‰ :=
translation_number_le_of_le_add_int f $ sub_le_iff_le_add'.1 (le_ceil $ f x - x)
lemma map_lt_of_translation_number_lt_int {n : â„¤} (h : Ï„ f < n) (x : â„) : f x < x + n :=
not_le.1 $ mt f.le_translation_number_of_add_int_le $ not_le.2 h
lemma map_lt_of_translation_number_lt_nat {n : â„•} (h : Ï„ f < n) (x : â„) : f x < x + n :=
@map_lt_of_translation_number_lt_int f n h x
lemma map_lt_add_floor_translation_number_add_one (x : â„) : f x < x + âŒŠÏ„ fâŒ‹ + 1 :=
begin
  rw [add_assoc],
  norm_cast,
  refine map_lt_of_translation_number_lt_int _ _ _,
  push_cast,
  exact lt_floor_add_one _
end
lemma map_lt_add_translation_number_add_one (x : â„) : f x < x + Ï„ f + 1 :=
calc f x < x + âŒŠÏ„ fâŒ‹ + 1 : f.map_lt_add_floor_translation_number_add_one x
... â‰¤ x + Ï„ f + 1 : by { mono*, exact floor_le (Ï„ f) }
lemma lt_map_of_int_lt_translation_number {n : â„¤} (h : â†‘n < Ï„ f) (x : â„) : x + n < f x :=
not_le.1 $ mt f.translation_number_le_of_le_add_int $ not_le.2 h
lemma lt_map_of_nat_lt_translation_number {n : â„•} (h : â†‘n < Ï„ f) (x : â„) : x + n < f x :=
@lt_map_of_int_lt_translation_number f n h x
lemma translation_number_of_map_pow_eq_add_int {x : â„} {n : â„•} {m : â„¤}
  (h : (f^n) x = x + m) (hn : 0 < n) :
  Ï„ f = m / n :=
begin
  have := (f^n).translation_number_of_eq_add_int h,
  rwa [translation_number_pow, mul_comm, â† eq_div_iff] at this,
  exact nat.cast_ne_zero.2 (ne_of_gt hn)
end
lemma forall_map_sub_of_Icc (P : â„ â†’ Prop)
  (h : âˆ€ x âˆˆ Icc (0:â„) 1, P (f x - x)) (x : â„) : P (f x - x) :=
f.map_fract_sub_fract_eq x â–¸ h _ âŸ¨fract_nonneg _, le_of_lt (fract_lt_one _)âŸ©
lemma translation_number_lt_of_forall_lt_add (hf : continuous f) {z : â„}
  (hz : âˆ€ x, f x < x + z) : Ï„ f < z :=
begin
  obtain âŸ¨x, xmem, hxâŸ© : âˆƒ x âˆˆ Icc (0:â„) 1, âˆ€ y âˆˆ Icc (0:â„) 1, f y - y â‰¤ f x - x,
    from is_compact_Icc.exists_forall_ge (nonempty_Icc.2 zero_le_one)
      (hf.sub continuous_id).continuous_on,
  refine lt_of_le_of_lt _ (sub_lt_iff_lt_add'.2 $ hz x),
  apply translation_number_le_of_le_add,
  simp only [â† sub_le_iff_le_add'],
  exact f.forall_map_sub_of_Icc (Î» a, a â‰¤ f x - x) hx
end
lemma lt_translation_number_of_forall_add_lt (hf : continuous f) {z : â„}
  (hz : âˆ€ x, x + z < f x) : z < Ï„ f :=
begin
  obtain âŸ¨x, xmem, hxâŸ© : âˆƒ x âˆˆ Icc (0:â„) 1, âˆ€ y âˆˆ Icc (0:â„) 1, f x - x â‰¤ f y - y,
    from is_compact_Icc.exists_forall_le (nonempty_Icc.2 zero_le_one)
      (hf.sub continuous_id).continuous_on,
  refine lt_of_lt_of_le (lt_sub_iff_add_lt'.2 $ hz x) _,
  apply le_translation_number_of_add_le,
  simp only [â† le_sub_iff_add_le'],
  exact f.forall_map_sub_of_Icc _ hx
end
lemma exists_eq_add_translation_number (hf : continuous f) :
  âˆƒ x, f x = x + Ï„ f :=
begin
  obtain âŸ¨a, haâŸ© : âˆƒ x, f x â‰¤ x + f.translation_number,
  { by_contra' H,
    exact lt_irrefl _ (f.lt_translation_number_of_forall_add_lt hf H) },
  obtain âŸ¨b, hbâŸ© : âˆƒ x, x + Ï„ f â‰¤ f x,
  { by_contra' H,
    exact lt_irrefl _ (f.translation_number_lt_of_forall_lt_add hf H) },
  exact intermediate_value_univâ‚‚ hf (continuous_id.add continuous_const) ha hb
end
lemma translation_number_eq_int_iff (hf : continuous f) {m : â„¤} :
  Ï„ f = m â†” âˆƒ x, f x = x + m :=
begin
  refine âŸ¨Î» h, h â–¸ f.exists_eq_add_translation_number hf, _âŸ©,
  rintros âŸ¨x, hxâŸ©,
  exact f.translation_number_of_eq_add_int hx
end
lemma continuous_pow (hf : continuous f) (n : â„•) :
  continuous â‡‘(f^n : circle_deg1_lift) :=
by { rw coe_pow, exact hf.iterate n }
lemma translation_number_eq_rat_iff (hf : continuous f) {m : â„¤}
  {n : â„•} (hn : 0 < n) :
  Ï„ f = m / n â†” âˆƒ x, (f^n) x = x + m :=
begin
  rw [eq_div_iff, mul_comm, â† translation_number_pow]; [skip, exact ne_of_gt (nat.cast_pos.2 hn)],
  exact (f^n).translation_number_eq_int_iff (f.continuous_pow hf n)
end
lemma semiconj_of_group_action_of_forall_translation_number_eq
  {G : Type*} [group G] (fâ‚ fâ‚‚ : G â†’* circle_deg1_lift)
  (h : âˆ€ g, Ï„ (fâ‚ g) = Ï„ (fâ‚‚ g)) :
  âˆƒ F : circle_deg1_lift, âˆ€ g, semiconj F (fâ‚ g) (fâ‚‚ g) :=
begin
lemma units_semiconj_of_translation_number_eq {fâ‚ fâ‚‚ : circle_deg1_liftË£}
  (h : Ï„ fâ‚ = Ï„ fâ‚‚) :
  âˆƒ F : circle_deg1_lift, semiconj F fâ‚ fâ‚‚ :=
begin
  have : âˆ€ n : multiplicative â„¤, Ï„ ((units.coe_hom _).comp (zpowers_hom _ fâ‚) n) =
    Ï„ ((units.coe_hom _).comp (zpowers_hom _ fâ‚‚) n),
  { intro n, simp [h] },
  exact (semiconj_of_group_action_of_forall_translation_number_eq _ _ this).imp
    (Î» F hF, hF (multiplicative.of_add 1))
end
lemma semiconj_of_is_unit_of_translation_number_eq {fâ‚ fâ‚‚ : circle_deg1_lift}
  (hâ‚ : is_unit fâ‚) (hâ‚‚ : is_unit fâ‚‚) (h : Ï„ fâ‚ = Ï„ fâ‚‚) :
  âˆƒ F : circle_deg1_lift, semiconj F fâ‚ fâ‚‚ :=
by { rcases âŸ¨hâ‚, hâ‚‚âŸ© with âŸ¨âŸ¨fâ‚, rflâŸ©, âŸ¨fâ‚‚, rflâŸ©âŸ©, exact units_semiconj_of_translation_number_eq h }
lemma semiconj_of_bijective_of_translation_number_eq {fâ‚ fâ‚‚ : circle_deg1_lift}
  (hâ‚ : bijective fâ‚) (hâ‚‚ : bijective fâ‚‚) (h : Ï„ fâ‚ = Ï„ fâ‚‚) :
  âˆƒ F : circle_deg1_lift, semiconj F fâ‚ fâ‚‚ :=
semiconj_of_is_unit_of_translation_number_eq
  (is_unit_iff_bijective.2 hâ‚) (is_unit_iff_bijective.2 hâ‚‚) h
end circle_deg1_lift
