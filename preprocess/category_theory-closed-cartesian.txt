import category_theory.epi_mono
import category_theory.limits.shapes.finite_products
import category_theory.monoidal.of_has_finite_products
import category_theory.limits.preserves.shapes.binary_products
import category_theory.adjunction.limits
import category_theory.adjunction.mates
import category_theory.closed.monoidal
universes v u uâ‚‚
noncomputable theory
namespace category_theory
open category_theory category_theory.category category_theory.limits
local attribute [instance] monoidal_of_has_finite_products
abbreviation exponentiable {C : Type u} [category.{v} C] [has_finite_products C] (X : C) :=
closed X
def binary_product_exponentiable {C : Type u} [category.{v} C] [has_finite_products C] {X Y : C}
  (hX : exponentiable X) (hY : exponentiable Y) : exponentiable (X â¨¯ Y) :=
tensor_closed hX hY
def terminal_exponentiable {C : Type u} [category.{v} C] [has_finite_products C] :
  exponentiable âŠ¤_ C :=
unit_closed
abbreviation cartesian_closed (C : Type u) [category.{v} C] [has_finite_products C] :=
monoidal_closed C
variables {C : Type u} [category.{v} C] (A B : C) {X X' Y Y' Z : C}
variables [has_finite_products C] [exponentiable A]
abbreviation exp : C â¥¤ C :=
ihom A
namespace exp
abbreviation adjunction : prod.functor.obj A âŠ£ exp A :=
ihom.adjunction A
abbreviation ev : exp A â‹™ prod.functor.obj A âŸ¶ ğŸ­ C :=
ihom.ev A
abbreviation coev : ğŸ­ C âŸ¶ prod.functor.obj A â‹™ exp A :=
ihom.coev A
notation A ` âŸ¹ `:20 B:19 := (exp A).obj B
notation B ` ^^ `:30 A:30 := (exp A).obj B
@[simp, reassoc] lemma ev_coev :
  limits.prod.map (ğŸ™ A) ((coev A).app B) â‰« (ev A).app (A â¨¯ B) = ğŸ™ (A â¨¯ B) :=
ihom.ev_coev A B
@[simp, reassoc] lemma coev_ev : (coev A).app (A âŸ¹ B) â‰« (exp A).map ((ev A).app B) = ğŸ™ (A âŸ¹ B) :=
ihom.coev_ev A B
end exp
instance : preserves_colimits (prod.functor.obj A) :=
(ihom.adjunction A).left_adjoint_preserves_colimits
variables {A}
def curry : (A â¨¯ Y âŸ¶ X) â†’ (Y âŸ¶ A âŸ¹ X) :=
(exp.adjunction A).hom_equiv _ _
def uncurry : (Y âŸ¶ A âŸ¹ X) â†’ (A â¨¯ Y âŸ¶ X) :=
((exp.adjunction A).hom_equiv _ _).symm
@[simp] lemma hom_equiv_apply_eq (f : A â¨¯ Y âŸ¶ X) :
  (exp.adjunction A).hom_equiv _ _ f = curry f := rfl
@[simp] lemma hom_equiv_symm_apply_eq (f : Y âŸ¶ A âŸ¹ X) :
  ((exp.adjunction A).hom_equiv _ _).symm f = uncurry f := rfl
@[reassoc]
lemma curry_natural_left (f : X âŸ¶ X') (g : A â¨¯ X' âŸ¶ Y) :
  curry (limits.prod.map (ğŸ™ _) f â‰« g) = f â‰« curry g :=
adjunction.hom_equiv_naturality_left _ _ _
@[reassoc]
lemma curry_natural_right (f : A â¨¯ X âŸ¶ Y) (g : Y âŸ¶ Y') :
  curry (f â‰« g) = curry f â‰« (exp _).map g :=
adjunction.hom_equiv_naturality_right _ _ _
@[reassoc]
lemma uncurry_natural_right  (f : X âŸ¶ AâŸ¹Y) (g : Y âŸ¶ Y') :
  uncurry (f â‰« (exp _).map g) = uncurry f â‰« g :=
adjunction.hom_equiv_naturality_right_symm _ _ _
@[reassoc]
lemma uncurry_natural_left  (f : X âŸ¶ X') (g : X' âŸ¶ AâŸ¹Y) :
  uncurry (f â‰« g) = limits.prod.map (ğŸ™ _) f â‰« uncurry g :=
adjunction.hom_equiv_naturality_left_symm _ _ _
@[simp]
lemma uncurry_curry (f : A â¨¯ X âŸ¶ Y) : uncurry (curry f) = f :=
(closed.is_adj.adj.hom_equiv _ _).left_inv f
@[simp]
lemma curry_uncurry (f : X âŸ¶ AâŸ¹Y) : curry (uncurry f) = f :=
(closed.is_adj.adj.hom_equiv _ _).right_inv f
lemma curry_eq_iff (f : A â¨¯ Y âŸ¶ X) (g : Y âŸ¶ A âŸ¹ X) :
  curry f = g â†” f = uncurry g :=
adjunction.hom_equiv_apply_eq _ f g
lemma eq_curry_iff (f : A â¨¯ Y âŸ¶ X) (g : Y âŸ¶ A âŸ¹ X) :
  g = curry f â†” uncurry g = f :=
adjunction.eq_hom_equiv_apply _ f g
def exp_terminal_iso_self [exponentiable âŠ¤_ C] : (âŠ¤_ C âŸ¹ X) â‰… X :=
yoneda.ext (âŠ¤_ C âŸ¹ X) X
  (Î» Y f, (prod.left_unitor Y).inv â‰« cartesian_closed.uncurry f)
  (Î» Y f, cartesian_closed.curry ((prod.left_unitor Y).hom â‰« f))
  (Î» Z g, by rw [curry_eq_iff, iso.hom_inv_id_assoc] )
  (Î» Z g, by simp)
  (Î» Z W f g, by rw [uncurry_natural_left, prod.left_unitor_inv_naturality_assoc f] )
def internalize_hom (f : A âŸ¶ Y) : âŠ¤_ C âŸ¶ (A âŸ¹ Y) :=
cartesian_closed.curry (limits.prod.fst â‰« f)
section pre
variables {B}
def pre (f : B âŸ¶ A) [exponentiable B] : exp A âŸ¶ exp B :=
transfer_nat_trans_self (exp.adjunction _) (exp.adjunction _) (prod.functor.map f)
lemma prod_map_pre_app_comp_ev (f : B âŸ¶ A) [exponentiable B] (X : C) :
  limits.prod.map (ğŸ™ B) ((pre f).app X) â‰« (exp.ev B).app X =
    limits.prod.map f (ğŸ™ (A âŸ¹ X)) â‰« (exp.ev A).app X :=
transfer_nat_trans_self_counit _ _ (prod.functor.map f) X
lemma uncurry_pre (f : B âŸ¶ A) [exponentiable B] (X : C) :
  cartesian_closed.uncurry ((pre f).app X) = limits.prod.map f (ğŸ™ _) â‰« (exp.ev A).app X :=
begin
  rw [uncurry_eq, prod_map_pre_app_comp_ev]
end
lemma coev_app_comp_pre_app (f : B âŸ¶ A) [exponentiable B] :
  (exp.coev A).app X â‰« (pre f).app (A â¨¯ X) =
    (exp.coev B).app X â‰« (exp B).map (limits.prod.map f (ğŸ™ _)) :=
unit_transfer_nat_trans_self _ _ (prod.functor.map f) X
@[simp]
lemma pre_id (A : C) [exponentiable A] : pre (ğŸ™ A) = ğŸ™ _ :=
by simp [pre]
@[simp]
lemma pre_map {Aâ‚ Aâ‚‚ Aâ‚ƒ : C} [exponentiable Aâ‚] [exponentiable Aâ‚‚] [exponentiable Aâ‚ƒ]
  (f : Aâ‚ âŸ¶ Aâ‚‚) (g : Aâ‚‚ âŸ¶ Aâ‚ƒ) :
  pre (f â‰« g) = pre g â‰« pre f :=
by rw [pre, pre, pre, transfer_nat_trans_self_comp, prod.functor.map_comp]
end pre
def internal_hom [cartesian_closed C] : Cáµ’áµ– â¥¤ C â¥¤ C :=
{ obj := Î» X, exp X.unop,
  map := Î» X Y f, pre f.unop }
@[simps]
def zero_mul {I : C} (t : is_initial I) : A â¨¯ I â‰… I :=
{ hom := limits.prod.snd,
  inv := t.to _,
  hom_inv_id' :=
  begin
    have: (limits.prod.snd : A â¨¯ I âŸ¶ I) = cartesian_closed.uncurry (t.to _),
      rw â† curry_eq_iff,
      apply t.hom_ext,
    rw [this, â† uncurry_natural_right, â† eq_curry_iff],
    apply t.hom_ext,
  end,
  inv_hom_id' := t.hom_ext _ _ }
def mul_zero {I : C} (t : is_initial I) : I â¨¯ A â‰… I :=
limits.prod.braiding _ _ â‰ªâ‰« zero_mul t
def pow_zero {I : C} (t : is_initial I) [cartesian_closed C] : I âŸ¹ B â‰… âŠ¤_ C :=
{ hom := default,
  inv := cartesian_closed.curry ((mul_zero t).hom â‰« t.to _),
  hom_inv_id' :=
  begin
    rw [â† curry_natural_left, curry_eq_iff, â† cancel_epi (mul_zero t).inv],
    { apply t.hom_ext },
    { apply_instance },
    { apply_instance },
  end }
def prod_coprod_distrib [has_binary_coproducts C] [cartesian_closed C] (X Y Z : C) :
  (Z â¨¯ X) â¨¿ (Z â¨¯ Y) â‰… Z â¨¯ (X â¨¿ Y) :=
{ hom := coprod.desc (limits.prod.map (ğŸ™ _) coprod.inl) (limits.prod.map (ğŸ™ _) coprod.inr),
  inv := cartesian_closed.uncurry
    (coprod.desc (cartesian_closed.curry coprod.inl) (cartesian_closed.curry coprod.inr)),
  hom_inv_id' :=
  begin
    apply coprod.hom_ext,
    rw [coprod.inl_desc_assoc, comp_id, â†uncurry_natural_left, coprod.inl_desc, uncurry_curry],
    rw [coprod.inr_desc_assoc, comp_id, â†uncurry_natural_left, coprod.inr_desc, uncurry_curry],
  end,
  inv_hom_id' :=
  begin
    rw [â† uncurry_natural_right, â†eq_curry_iff],
    apply coprod.hom_ext,
    rw [coprod.inl_desc_assoc, â†curry_natural_right, coprod.inl_desc, â†curry_natural_left, comp_id],
    rw [coprod.inr_desc_assoc, â†curry_natural_right, coprod.inr_desc, â†curry_natural_left, comp_id],
  end }
lemma strict_initial {I : C} (t : is_initial I) (f : A âŸ¶ I) : is_iso f :=
begin
  haveI : mono (limits.prod.lift (ğŸ™ A) f â‰« (zero_mul t).hom) := mono_comp _ _,
  rw [zero_mul_hom, prod.lift_snd] at _inst,
  haveI: split_epi f := âŸ¨t.to _, t.hom_ext _ _âŸ©,
  apply is_iso_of_mono_of_split_epi
end
instance to_initial_is_iso [has_initial C] (f : A âŸ¶ âŠ¥_ C) : is_iso f :=
strict_initial initial_is_initial _
lemma initial_mono {I : C} (B : C) (t : is_initial I) [cartesian_closed C] : mono (t.to B) :=
âŸ¨Î» B g h _,
begin
  haveI := strict_initial t g,
  haveI := strict_initial t h,
  exact eq_of_inv_eq_inv (t.hom_ext _ _)
endâŸ©
instance initial.mono_to [has_initial C] (B : C) [cartesian_closed C] : mono (initial.to B) :=
initial_mono B initial_is_initial
variables {D : Type uâ‚‚} [category.{v} D]
section functor
variables [has_finite_products D]
def cartesian_closed_of_equiv (e : C â‰Œ D) [h : cartesian_closed C] : cartesian_closed D :=
{ closed' := Î» X,
  { is_adj :=
    begin
      haveI q : exponentiable (e.inverse.obj X) := infer_instance,
      have : is_left_adjoint (prod.functor.obj (e.inverse.obj X)) := q.is_adj,
      have : e.functor â‹™ prod.functor.obj X â‹™ e.inverse â‰… prod.functor.obj (e.inverse.obj X),
      apply nat_iso.of_components _ _,
      intro Y,
      { apply as_iso (prod_comparison e.inverse X (e.functor.obj Y)) â‰ªâ‰« _,
        apply prod.map_iso (iso.refl _) (e.unit_iso.app Y).symm },
      { intros Y Z g,
        dsimp [prod_comparison],
        simp [prod.comp_lift, â† e.inverse.map_comp, â† e.inverse.map_comp_assoc],
