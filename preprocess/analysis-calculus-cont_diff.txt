import analysis.calculus.mean_value
import analysis.normed_space.multilinear
import analysis.calculus.formal_multilinear_series
import tactic.congrm
noncomputable theory
open_locale classical big_operators nnreal
local notation `∞` := (⊤ : with_top ℕ)
universes u v w
local attribute [instance, priority 1001]
normed_group.to_add_comm_group normed_space.to_module' add_comm_group.to_add_comm_monoid
open set fin filter
open_locale topological_space
variables {𝕜 : Type*} [nondiscrete_normed_field 𝕜]
{E : Type*} [normed_group E] [normed_space 𝕜 E]
{F : Type*} [normed_group F] [normed_space 𝕜 F]
{G : Type*} [normed_group G] [normed_space 𝕜 G]
{X : Type*} [normed_group X] [normed_space 𝕜 X]
{s s₁ t u : set E} {f f₁ : E → F} {g : F → G} {x : E} {c : F}
{b : E × F → G} {m n : with_top ℕ}
variable {p : E → formal_multilinear_series 𝕜 E F}
structure has_ftaylor_series_up_to_on (n : with_top ℕ)
  (f : E → F) (p : E → formal_multilinear_series 𝕜 E F) (s : set E) : Prop :=
(zero_eq       : ∀ x ∈ s, (p x 0).uncurry0 = f x)
(fderiv_within : ∀ (m : ℕ) (hm : (m : with_top ℕ) < n), ∀ x ∈ s,
   has_fderiv_within_at (λ y, p y m) (p x m.succ).curry_left s x)
(cont          : ∀ (m : ℕ) (hm : (m : with_top ℕ) ≤ n), continuous_on (λ x, p x m) s)
lemma has_ftaylor_series_up_to_on.zero_eq'
  (h : has_ftaylor_series_up_to_on n f p s) {x : E} (hx : x ∈ s) :
  p x 0 = (continuous_multilinear_curry_fin0 𝕜 E F).symm (f x) :=
by { rw ← h.zero_eq x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
lemma has_ftaylor_series_up_to_on.congr
  (h : has_ftaylor_series_up_to_on n f p s) (h₁ : ∀ x ∈ s, f₁ x = f x) :
  has_ftaylor_series_up_to_on n f₁ p s :=
begin
  refine ⟨λ x hx, _, h.fderiv_within, h.cont⟩,
  rw h₁ x hx,
  exact h.zero_eq x hx
end
lemma has_ftaylor_series_up_to_on.mono
  (h : has_ftaylor_series_up_to_on n f p s) {t : set E} (hst : t ⊆ s) :
  has_ftaylor_series_up_to_on n f p t :=
⟨λ x hx, h.zero_eq x (hst hx),
λ m hm x hx, (h.fderiv_within m hm x (hst hx)).mono hst,
λ m hm, (h.cont m hm).mono hst⟩
lemma has_ftaylor_series_up_to_on.of_le
  (h : has_ftaylor_series_up_to_on n f p s) (hmn : m ≤ n) :
  has_ftaylor_series_up_to_on m f p s :=
⟨h.zero_eq,
λ k hk x hx, h.fderiv_within k (lt_of_lt_of_le hk hmn) x hx,
λ k hk, h.cont k (le_trans hk hmn)⟩
lemma has_ftaylor_series_up_to_on.continuous_on
  (h : has_ftaylor_series_up_to_on n f p s) : continuous_on f s :=
begin
  have := (h.cont 0 bot_le).congr (λ x hx, (h.zero_eq' hx).symm),
  rwa linear_isometry_equiv.comp_continuous_on_iff at this
end
lemma has_ftaylor_series_up_to_on_zero_iff :
  has_ftaylor_series_up_to_on 0 f p s ↔ continuous_on f s ∧ (∀ x ∈ s, (p x 0).uncurry0 = f x) :=
begin
  refine ⟨λ H, ⟨H.continuous_on, H.zero_eq⟩,
          λ H, ⟨H.2, λ m hm, false.elim (not_le.2 hm bot_le), _⟩⟩,
  assume m hm,
  obtain rfl : m = 0, by exact_mod_cast (hm.antisymm (zero_le _)),
  have : ∀ x ∈ s, p x 0 = (continuous_multilinear_curry_fin0 𝕜 E F).symm (f x),
    by { assume x hx, rw ← H.2 x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ },
  rw [continuous_on_congr this, linear_isometry_equiv.comp_continuous_on_iff],
  exact H.1
end
lemma has_ftaylor_series_up_to_on_top_iff :
  (has_ftaylor_series_up_to_on ∞ f p s) ↔ (∀ (n : ℕ), has_ftaylor_series_up_to_on n f p s) :=
begin
  split,
  { assume H n, exact H.of_le le_top },
  { assume H,
    split,
    { exact (H 0).zero_eq },
    { assume m hm,
      apply (H m.succ).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m)) },
    { assume m hm,
      apply (H m).cont m le_rfl } }
end
lemma has_ftaylor_series_up_to_on.has_fderiv_within_at
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hx : x ∈ s) :
  has_fderiv_within_at f (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) s x :=
begin
  have A : ∀ y ∈ s, f y = (continuous_multilinear_curry_fin0 𝕜 E F) (p y 0),
  { assume y hy, rw ← h.zero_eq y hy, refl },
  suffices H : has_fderiv_within_at
      (λ y, continuous_multilinear_curry_fin0 𝕜 E F (p y 0))
      (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) s x,
    by exact H.congr A (A x hx),
  rw linear_isometry_equiv.comp_has_fderiv_within_at_iff',
  have : ((0 : ℕ) : with_top ℕ) < n :=
    lt_of_lt_of_le (with_top.coe_lt_coe.2 nat.zero_lt_one) hn,
  convert h.fderiv_within _ this x hx,
  ext y v,
  change (p x 1) (snoc 0 y) = (p x 1) (cons y v),
  unfold_coes,
  congr' with i,
  rw unique.eq_default i,
  refl
end
lemma has_ftaylor_series_up_to_on.differentiable_on
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) : differentiable_on 𝕜 f s :=
λ x hx, (h.has_fderiv_within_at hn hx).differentiable_within_at
lemma has_ftaylor_series_up_to_on.has_fderiv_at
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hx : s ∈ 𝓝 x) :
  has_fderiv_at f (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) x :=
(h.has_fderiv_within_at hn (mem_of_mem_nhds hx)).has_fderiv_at hx
lemma has_ftaylor_series_up_to_on.eventually_has_fderiv_at
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hx : s ∈ 𝓝 x) :
  ∀ᶠ y in 𝓝 x, has_fderiv_at f (continuous_multilinear_curry_fin1 𝕜 E F (p y 1)) y :=
(eventually_eventually_nhds.2 hx).mono $ λ y hy, h.has_fderiv_at hn hy
lemma has_ftaylor_series_up_to_on.differentiable_at
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hx : s ∈ 𝓝 x) :
  differentiable_at 𝕜 f x :=
(h.has_fderiv_at hn hx).differentiable_at
theorem has_ftaylor_series_up_to_on_succ_iff_left {n : ℕ} :
  has_ftaylor_series_up_to_on (n + 1) f p s ↔
  has_ftaylor_series_up_to_on n f p s
  ∧ (∀ x ∈ s, has_fderiv_within_at (λ y, p y n) (p x n.succ).curry_left s x)
  ∧ continuous_on (λ x, p x (n + 1)) s :=
begin
  split,
  { assume h,
    exact ⟨h.of_le (with_top.coe_le_coe.2 (nat.le_succ n)),
           h.fderiv_within _ (with_top.coe_lt_coe.2 (lt_add_one n)),
           h.cont (n + 1) le_rfl⟩ },
  { assume h,
    split,
    { exact h.1.zero_eq },
    { assume m hm,
      by_cases h' : m < n,
      { exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h') },
      { have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h',
        rw this,
        exact h.2.1 } },
    { assume m hm,
      by_cases h' : m ≤ n,
      { apply h.1.cont m (with_top.coe_le_coe.2 h') },
      { have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h'),
        rw this,
        exact h.2.2 } } }
end
theorem has_ftaylor_series_up_to_on_succ_iff_right {n : ℕ} :
  has_ftaylor_series_up_to_on ((n + 1) : ℕ) f p s ↔
  (∀ x ∈ s, (p x 0).uncurry0 = f x)
  ∧ (∀ x ∈ s, has_fderiv_within_at (λ y, p y 0) (p x 1).curry_left s x)
  ∧ has_ftaylor_series_up_to_on n
    (λ x, continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) (λ x, (p x).shift) s :=
begin
  split,
  { assume H,
    refine ⟨H.zero_eq, H.fderiv_within 0 (with_top.coe_lt_coe.2 (nat.succ_pos n)), _⟩,
    split,
    { assume x hx, refl },
    { assume m (hm : (m : with_top ℕ) < n) x (hx : x ∈ s),
      have A : (m.succ : with_top ℕ) < n.succ,
        by { rw with_top.coe_lt_coe at ⊢ hm, exact nat.lt_succ_iff.mpr hm },
      change has_fderiv_within_at
        ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm
           ∘ (λ (y : E), p y m.succ))
        (p x m.succ.succ).curry_right.curry_left s x,
      rw linear_isometry_equiv.comp_has_fderiv_within_at_iff',
      convert H.fderiv_within _ A x hx,
      ext y v,
      change (p x m.succ.succ) (snoc (cons y (init v)) (v (last _)))
        = (p x (nat.succ (nat.succ m))) (cons y v),
      rw [← cons_snoc_eq_snoc_cons, snoc_init_self] },
    { assume m (hm : (m : with_top ℕ) ≤ n),
      have A : (m.succ : with_top ℕ) ≤ n.succ,
        by { rw with_top.coe_le_coe at ⊢ hm, exact nat.pred_le_iff.mp hm },
      change continuous_on ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm
           ∘ (λ (y : E), p y m.succ)) s,
      rw linear_isometry_equiv.comp_continuous_on_iff,
      exact H.cont _ A } },
  { rintros ⟨Hzero_eq, Hfderiv_zero, Htaylor⟩,
    split,
    { exact Hzero_eq },
    { assume m (hm : (m : with_top ℕ) < n.succ) x (hx : x ∈ s),
      cases m,
      { exact Hfderiv_zero x hx },
      { have A : (m : with_top ℕ) < n,
          by { rw with_top.coe_lt_coe at hm ⊢, exact nat.lt_of_succ_lt_succ hm },
        have : has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm
           ∘ (λ (y : E), p y m.succ)) ((p x).shift m.succ).curry_left s x :=
          Htaylor.fderiv_within _ A x hx,
        rw linear_isometry_equiv.comp_has_fderiv_within_at_iff' at this,
        convert this,
        ext y v,
        change (p x (nat.succ (nat.succ m))) (cons y v)
          = (p x m.succ.succ) (snoc (cons y (init v)) (v (last _))),
        rw [← cons_snoc_eq_snoc_cons, snoc_init_self] } },
    { assume m (hm : (m : with_top ℕ) ≤ n.succ),
      cases m,
      { have : differentiable_on 𝕜 (λ x, p x 0) s :=
          λ x hx, (Hfderiv_zero x hx).differentiable_within_at,
        exact this.continuous_on },
      { have A : (m : with_top ℕ) ≤ n,
          by { rw with_top.coe_le_coe at hm ⊢, exact nat.lt_succ_iff.mp hm },
        have : continuous_on ((continuous_multilinear_curry_right_equiv' 𝕜 m E F).symm
           ∘ (λ (y : E), p y m.succ)) s :=
        Htaylor.cont _ A,
        rwa linear_isometry_equiv.comp_continuous_on_iff at this } } }
end
variable (𝕜)
def cont_diff_within_at (n : with_top ℕ) (f : E → F) (s : set E) (x : E) :=
∀ (m : ℕ), (m : with_top ℕ) ≤ n →
  ∃ u ∈ 𝓝[insert x s] x, ∃ p : E → formal_multilinear_series 𝕜 E F,
    has_ftaylor_series_up_to_on m f p u
variable {𝕜}
lemma cont_diff_within_at_nat {n : ℕ} :
  cont_diff_within_at 𝕜 n f s x ↔
  ∃ u ∈ 𝓝[insert x s] x, ∃ p : E → formal_multilinear_series 𝕜 E F,
  has_ftaylor_series_up_to_on n f p u :=
⟨λ H, H n le_rfl, λ ⟨u, hu, p, hp⟩ m hm, ⟨u, hu, p, hp.of_le hm⟩⟩
lemma cont_diff_within_at.of_le
  (h : cont_diff_within_at 𝕜 n f s x) (hmn : m ≤ n) :
  cont_diff_within_at 𝕜 m f s x :=
λ k hk, h k (le_trans hk hmn)
lemma cont_diff_within_at_iff_forall_nat_le :
  cont_diff_within_at 𝕜 n f s x ↔ ∀ m : ℕ, ↑m ≤ n → cont_diff_within_at 𝕜 m f s x :=
⟨λ H m hm, H.of_le hm, λ H m hm, H m hm _ le_rfl⟩
lemma cont_diff_within_at_top :
  cont_diff_within_at 𝕜 ∞ f s x ↔ ∀ (n : ℕ), cont_diff_within_at 𝕜 n f s x :=
cont_diff_within_at_iff_forall_nat_le.trans $ by simp only [forall_prop_of_true, le_top]
lemma cont_diff_within_at.continuous_within_at
  (h : cont_diff_within_at 𝕜 n f s x) : continuous_within_at f s x :=
begin
  rcases h 0 bot_le with ⟨u, hu, p, H⟩,
  rw [mem_nhds_within_insert] at hu,
  exact (H.continuous_on.continuous_within_at hu.1).mono_of_mem hu.2
end
lemma cont_diff_within_at.congr_of_eventually_eq
  (h : cont_diff_within_at 𝕜 n f s x) (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : f₁ x = f x) :
  cont_diff_within_at 𝕜 n f₁ s x :=
λ m hm, let ⟨u, hu, p, H⟩ := h m hm in
⟨{x ∈ u | f₁ x = f x}, filter.inter_mem hu (mem_nhds_within_insert.2 ⟨hx, h₁⟩), p,
  (H.mono (sep_subset _ _)).congr (λ _, and.right)⟩
lemma cont_diff_within_at.congr_of_eventually_eq'
  (h : cont_diff_within_at 𝕜 n f s x) (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : x ∈ s) :
  cont_diff_within_at 𝕜 n f₁ s x :=
h.congr_of_eventually_eq h₁ $ h₁.self_of_nhds_within hx
lemma filter.eventually_eq.cont_diff_within_at_iff
  (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : f₁ x = f x) :
  cont_diff_within_at 𝕜 n f₁ s x ↔ cont_diff_within_at 𝕜 n f s x :=
⟨λ H, cont_diff_within_at.congr_of_eventually_eq H h₁.symm hx.symm,
λ H, H.congr_of_eventually_eq h₁ hx⟩
lemma cont_diff_within_at.congr
  (h : cont_diff_within_at 𝕜 n f s x) (h₁ : ∀ y ∈ s, f₁ y = f y) (hx : f₁ x = f x) :
  cont_diff_within_at 𝕜 n f₁ s x :=
h.congr_of_eventually_eq (filter.eventually_eq_of_mem self_mem_nhds_within h₁) hx
lemma cont_diff_within_at.congr'
  (h : cont_diff_within_at 𝕜 n f s x) (h₁ : ∀ y ∈ s, f₁ y = f y) (hx : x ∈ s) :
  cont_diff_within_at 𝕜 n f₁ s x :=
h.congr h₁ (h₁ _ hx)
lemma cont_diff_within_at.mono_of_mem
  (h : cont_diff_within_at 𝕜 n f s x) {t : set E} (hst : s ∈ 𝓝[t] x) :
  cont_diff_within_at 𝕜 n f t x :=
begin
  assume m hm,
  rcases h m hm with ⟨u, hu, p, H⟩,
  exact ⟨u, nhds_within_le_of_mem (insert_mem_nhds_within_insert hst) hu, p, H⟩
end
lemma cont_diff_within_at.mono
  (h : cont_diff_within_at 𝕜 n f s x) {t : set E} (hst : t ⊆ s) :
  cont_diff_within_at 𝕜 n f t x :=
h.mono_of_mem $ filter.mem_of_superset self_mem_nhds_within hst
lemma cont_diff_within_at.congr_nhds
  (h : cont_diff_within_at 𝕜 n f s x) {t : set E} (hst : 𝓝[s] x = 𝓝[t] x) :
  cont_diff_within_at 𝕜 n f t x :=
h.mono_of_mem $ hst ▸ self_mem_nhds_within
lemma cont_diff_within_at_congr_nhds {t : set E} (hst : 𝓝[s] x = 𝓝[t] x) :
  cont_diff_within_at 𝕜 n f s x ↔ cont_diff_within_at 𝕜 n f t x :=
⟨λ h, h.congr_nhds hst, λ h, h.congr_nhds hst.symm⟩
lemma cont_diff_within_at_inter' (h : t ∈ 𝓝[s] x) :
  cont_diff_within_at 𝕜 n f (s ∩ t) x ↔ cont_diff_within_at 𝕜 n f s x :=
cont_diff_within_at_congr_nhds $ eq.symm $ nhds_within_restrict'' _ h
lemma cont_diff_within_at_inter (h : t ∈ 𝓝 x) :
  cont_diff_within_at 𝕜 n f (s ∩ t) x ↔ cont_diff_within_at 𝕜 n f s x :=
cont_diff_within_at_inter' (mem_nhds_within_of_mem_nhds h)
lemma cont_diff_within_at.differentiable_within_at'
  (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :
  differentiable_within_at 𝕜 f (insert x s) x :=
begin
  rcases h 1 hn with ⟨u, hu, p, H⟩,
  rcases mem_nhds_within.1 hu with ⟨t, t_open, xt, tu⟩,
  rw inter_comm at tu,
  have := ((H.mono tu).differentiable_on le_rfl) x ⟨mem_insert x s, xt⟩,
  exact (differentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 this,
end
lemma cont_diff_within_at.differentiable_within_at
  (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :
  differentiable_within_at 𝕜 f s x :=
(h.differentiable_within_at' hn).mono  (subset_insert x s)
theorem cont_diff_within_at_succ_iff_has_fderiv_within_at {n : ℕ} :
  cont_diff_within_at 𝕜 ((n + 1) : ℕ) f s x
  ↔ ∃ u ∈ 𝓝[insert x s] x, ∃ f' : E → (E →L[𝕜] F),
    (∀ x ∈ u, has_fderiv_within_at f (f' x) u x) ∧ (cont_diff_within_at 𝕜 n f' u x) :=
begin
  split,
  { assume h,
    rcases h n.succ le_rfl with ⟨u, hu, p, Hp⟩,
    refine ⟨u, hu, λ y, (continuous_multilinear_curry_fin1 𝕜 E F) (p y 1),
      λ y hy, Hp.has_fderiv_within_at (with_top.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _⟩,
    assume m hm,
    refine ⟨u, _, λ (y : E), (p y).shift, _⟩,
    { convert self_mem_nhds_within,
      have : x ∈ insert x s, by simp,
      exact (insert_eq_of_mem (mem_of_mem_nhds_within this hu)) },
    { rw has_ftaylor_series_up_to_on_succ_iff_right at Hp,
      exact Hp.2.2.of_le hm } },
  { rintros ⟨u, hu, f', f'_eq_deriv, Hf'⟩,
    rw cont_diff_within_at_nat,
    rcases Hf' n le_rfl with ⟨v, hv, p', Hp'⟩,
    refine ⟨v ∩ u, _, λ x, (p' x).unshift (f x), _⟩,
    { apply filter.inter_mem _ hu,
      apply nhds_within_le_of_mem hu,
      exact nhds_within_mono _ (subset_insert x u) hv },
    { rw has_ftaylor_series_up_to_on_succ_iff_right,
      refine ⟨λ y hy, rfl, λ y hy, _, _⟩,
      { change has_fderiv_within_at (λ z, (continuous_multilinear_curry_fin0 𝕜 E F).symm (f z))
          ((formal_multilinear_series.unshift (p' y) (f y) 1).curry_left) (v ∩ u) y,
        rw linear_isometry_equiv.comp_has_fderiv_within_at_iff',
        convert (f'_eq_deriv y hy.2).mono (inter_subset_right v u),
        rw ← Hp'.zero_eq y hy.1,
        ext z,
        change ((p' y 0) (init (@cons 0 (λ i, E) z 0))) (@cons 0 (λ i, E) z 0 (last 0))
          = ((p' y 0) 0) z,
        unfold_coes,
        congr },
      { convert (Hp'.mono (inter_subset_left v u)).congr (λ x hx, Hp'.zero_eq x hx.1),
        { ext x y,
          change p' x 0 (init (@snoc 0 (λ i : fin 1, E) 0 y)) y = p' x 0 0 y,
          rw init_snoc },
        { ext x k v y,
          change p' x k (init (@snoc k (λ i : fin k.succ, E) v y))
            (@snoc k (λ i : fin k.succ, E) v y (last k)) = p' x k v y,
          rw [snoc_last, init_snoc] } } } }
end
variable (𝕜)
definition cont_diff_on (n : with_top ℕ) (f : E → F) (s : set E) :=
∀ x ∈ s, cont_diff_within_at 𝕜 n f s x
variable {𝕜}
lemma cont_diff_on.cont_diff_within_at (h : cont_diff_on 𝕜 n f s) (hx : x ∈ s) :
  cont_diff_within_at 𝕜 n f s x :=
h x hx
lemma cont_diff_within_at.cont_diff_on {m : ℕ}
  (hm : (m : with_top ℕ) ≤ n) (h : cont_diff_within_at 𝕜 n f s x) :
  ∃ u ∈ 𝓝[insert x s] x, u ⊆ insert x s ∧ cont_diff_on 𝕜 m f u :=
begin
  rcases h m hm with ⟨u, u_nhd, p, hp⟩,
  refine ⟨u ∩ insert x s, filter.inter_mem u_nhd self_mem_nhds_within,
    inter_subset_right _ _, _⟩,
  assume y hy m' hm',
  refine ⟨u ∩ insert x s, _, p, (hp.mono (inter_subset_left _ _)).of_le hm'⟩,
  convert self_mem_nhds_within,
  exact insert_eq_of_mem hy
end
protected lemma cont_diff_within_at.eventually {n : ℕ}
  (h : cont_diff_within_at 𝕜 n f s x) :
  ∀ᶠ y in 𝓝[insert x s] x, cont_diff_within_at 𝕜 n f s y :=
begin
  rcases h.cont_diff_on le_rfl with ⟨u, hu, hu_sub, hd⟩,
  have : ∀ᶠ (y : E) in 𝓝[insert x s] x, u ∈ 𝓝[insert x s] y ∧ y ∈ u,
    from (eventually_nhds_within_nhds_within.2 hu).and hu,
  refine this.mono (λ y hy, (hd y hy.2).mono_of_mem _),
  exact nhds_within_mono y (subset_insert _ _) hy.1
end
lemma cont_diff_on.of_le (h : cont_diff_on 𝕜 n f s) (hmn : m ≤ n) :
  cont_diff_on 𝕜 m f s :=
λ x hx, (h x hx).of_le hmn
lemma cont_diff_on_iff_forall_nat_le :
  cont_diff_on 𝕜 n f s ↔ ∀ m : ℕ, ↑m ≤ n → cont_diff_on 𝕜 m f s :=
⟨λ H m hm, H.of_le hm, λ H x hx m hm, H m hm x hx m le_rfl⟩
lemma cont_diff_on_top :
  cont_diff_on 𝕜 ∞ f s ↔ ∀ (n : ℕ), cont_diff_on 𝕜 n f s :=
cont_diff_on_iff_forall_nat_le.trans $ by simp only [le_top, forall_prop_of_true]
lemma cont_diff_on_all_iff_nat :
  (∀ n, cont_diff_on 𝕜 n f s) ↔ (∀ n : ℕ, cont_diff_on 𝕜 n f s) :=
begin
  refine ⟨λ H n, H n, _⟩,
  rintro H (_|n),
  exacts [cont_diff_on_top.2 H, H n]
end
lemma cont_diff_on.continuous_on
  (h : cont_diff_on 𝕜 n f s) : continuous_on f s :=
λ x hx, (h x hx).continuous_within_at
lemma cont_diff_on.congr
  (h : cont_diff_on 𝕜 n f s) (h₁ : ∀ x ∈ s, f₁ x = f x) :
  cont_diff_on 𝕜 n f₁ s :=
λ x hx, (h x hx).congr h₁ (h₁ x hx)
lemma cont_diff_on_congr (h₁ : ∀ x ∈ s, f₁ x = f x) :
  cont_diff_on 𝕜 n f₁ s ↔ cont_diff_on 𝕜 n f s :=
⟨λ H, H.congr (λ x hx, (h₁ x hx).symm), λ H, H.congr h₁⟩
lemma cont_diff_on.mono
  (h : cont_diff_on 𝕜 n f s) {t : set E} (hst : t ⊆ s) :
  cont_diff_on 𝕜 n f t :=
λ x hx, (h x (hst hx)).mono hst
lemma cont_diff_on.congr_mono
  (hf : cont_diff_on 𝕜 n f s) (h₁ : ∀ x ∈ s₁, f₁ x = f x) (hs : s₁ ⊆ s) :
  cont_diff_on 𝕜 n f₁ s₁ :=
(hf.mono hs).congr h₁
lemma cont_diff_on.differentiable_on
  (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) : differentiable_on 𝕜 f s :=
λ x hx, (h x hx).differentiable_within_at hn
lemma cont_diff_on_of_locally_cont_diff_on
  (h : ∀ x ∈ s, ∃u, is_open u ∧ x ∈ u ∧ cont_diff_on 𝕜 n f (s ∩ u)) :
  cont_diff_on 𝕜 n f s :=
begin
  assume x xs,
  rcases h x xs with ⟨u, u_open, xu, hu⟩,
  apply (cont_diff_within_at_inter _).1 (hu x ⟨xs, xu⟩),
  exact is_open.mem_nhds u_open xu
end
theorem cont_diff_on_succ_iff_has_fderiv_within_at {n : ℕ} :
  cont_diff_on 𝕜 ((n + 1) : ℕ) f s
  ↔ ∀ x ∈ s, ∃ u ∈ 𝓝[insert x s] x, ∃ f' : E → (E →L[𝕜] F),
    (∀ x ∈ u, has_fderiv_within_at f (f' x) u x) ∧ (cont_diff_on 𝕜 n f' u) :=
begin
  split,
  { assume h x hx,
    rcases (h x hx) n.succ le_rfl with ⟨u, hu, p, Hp⟩,
    refine ⟨u, hu, λ y, (continuous_multilinear_curry_fin1 𝕜 E F) (p y 1),
      λ y hy, Hp.has_fderiv_within_at (with_top.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _⟩,
    rw has_ftaylor_series_up_to_on_succ_iff_right at Hp,
    assume z hz m hm,
    refine ⟨u, _, λ (x : E), (p x).shift, Hp.2.2.of_le hm⟩,
    convert self_mem_nhds_within,
    exact insert_eq_of_mem hz, },
  { assume h x hx,
    rw cont_diff_within_at_succ_iff_has_fderiv_within_at,
    rcases h x hx with ⟨u, u_nhbd, f', hu, hf'⟩,
    have : x ∈ u := mem_of_mem_nhds_within (mem_insert _ _) u_nhbd,
    exact ⟨u, u_nhbd, f', hu, hf' x this⟩ }
end
variable (𝕜)
noncomputable def iterated_fderiv_within (n : ℕ) (f : E → F) (s : set E) :
  E → (E [×n]→L[𝕜] F) :=
nat.rec_on n
  (λ x, continuous_multilinear_map.curry0 𝕜 E (f x))
  (λ n rec x, continuous_linear_map.uncurry_left (fderiv_within 𝕜 rec s x))
def ftaylor_series_within (f : E → F) (s : set E) (x : E) : formal_multilinear_series 𝕜 E F :=
λ n, iterated_fderiv_within 𝕜 n f s x
variable {𝕜}
@[simp] lemma iterated_fderiv_within_zero_apply (m : (fin 0) → E) :
  (iterated_fderiv_within 𝕜 0 f s x : ((fin 0) →  E) → F) m = f x := rfl
lemma iterated_fderiv_within_zero_eq_comp :
  iterated_fderiv_within 𝕜 0 f s = (continuous_multilinear_curry_fin0 𝕜 E F).symm ∘ f := rfl
lemma iterated_fderiv_within_succ_apply_left {n : ℕ} (m : fin (n + 1) → E):
  (iterated_fderiv_within 𝕜 (n + 1) f s x : (fin (n + 1) → E) → F) m
  = (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s x : E → (E [×n]→L[𝕜] F))
      (m 0) (tail m) := rfl
lemma iterated_fderiv_within_succ_eq_comp_left {n : ℕ} :
  iterated_fderiv_within 𝕜 (n + 1) f s =
  (continuous_multilinear_curry_left_equiv 𝕜 (λ(i : fin (n + 1)), E) F)
    ∘ (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n f s) s) := rfl
theorem iterated_fderiv_within_succ_apply_right {n : ℕ}
  (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) (m : fin (n + 1) → E) :
  (iterated_fderiv_within 𝕜 (n + 1) f s x : (fin (n + 1) → E) → F) m
    = iterated_fderiv_within 𝕜 n (λy, fderiv_within 𝕜 f s y) s x (init m) (m (last n)) :=
begin
  induction n with n IH generalizing x,
  { rw [iterated_fderiv_within_succ_eq_comp_left, iterated_fderiv_within_zero_eq_comp,
        iterated_fderiv_within_zero_apply,
        function.comp_apply, linear_isometry_equiv.comp_fderiv_within _ (hs x hx)],
    refl },
  { let I := continuous_multilinear_curry_right_equiv' 𝕜 n E F,
    have A : ∀ y ∈ s, iterated_fderiv_within 𝕜 n.succ f s y
        = (I ∘ (iterated_fderiv_within 𝕜 n (λy, fderiv_within 𝕜 f s y) s)) y,
      by { assume y hy, ext m, rw @IH m y hy, refl },
    calc
    (iterated_fderiv_within 𝕜 (n+2) f s x : (fin (n+2) → E) → F) m =
    (fderiv_within 𝕜 (iterated_fderiv_within 𝕜 n.succ f s) s x
              : E → (E [×(n + 1)]→L[𝕜] F)) (m 0) (tail m) : rfl
    ... = (fderiv_within 𝕜 (I ∘ (iterated_fderiv_within 𝕜 n (fderiv_within 𝕜 f s) s)) s x
              : E → (E [×(n + 1)]→L[𝕜] F)) (m 0) (tail m) :
      by rw fderiv_within_congr (hs x hx) A (A x hx)
    ... = (I ∘ fderiv_within 𝕜 ((iterated_fderiv_within 𝕜 n (fderiv_within 𝕜 f s) s)) s x
              : E → (E [×(n + 1)]→L[𝕜] F)) (m 0) (tail m) :
      by { rw linear_isometry_equiv.comp_fderiv_within _ (hs x hx), refl }
    ... = (fderiv_within 𝕜 ((iterated_fderiv_within 𝕜 n (λ y, fderiv_within 𝕜 f s y) s)) s x
              : E → (E [×n]→L[𝕜] (E →L[𝕜] F))) (m 0) (init (tail m)) ((tail m) (last n)) : rfl
    ... = iterated_fderiv_within 𝕜 (nat.succ n) (λ y, fderiv_within 𝕜 f s y) s x
              (init m) (m (last (n + 1))) :
      by { rw [iterated_fderiv_within_succ_apply_left, tail_init_eq_init_tail], refl } }
end
lemma iterated_fderiv_within_succ_eq_comp_right {n : ℕ} (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) :
  iterated_fderiv_within 𝕜 (n + 1) f s x =
  ((continuous_multilinear_curry_right_equiv' 𝕜 n E F)
    ∘ (iterated_fderiv_within 𝕜 n (λy, fderiv_within 𝕜 f s y) s)) x :=
by { ext m, rw iterated_fderiv_within_succ_apply_right hs hx, refl }
@[simp] lemma iterated_fderiv_within_one_apply
  (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) (m : (fin 1) → E) :
  (iterated_fderiv_within 𝕜 1 f s x : ((fin 1) → E) → F) m
  = (fderiv_within 𝕜 f s x : E → F) (m 0) :=
by { rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply], refl }
lemma iterated_fderiv_within_congr {n : ℕ}
  (hs : unique_diff_on 𝕜 s) (hL : ∀y∈s, f₁ y = f y) (hx : x ∈ s) :
  iterated_fderiv_within 𝕜 n f₁ s x = iterated_fderiv_within 𝕜 n f s x :=
begin
  induction n with n IH generalizing x,
  { ext m, simp [hL x hx] },
  { have : fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f₁ s y) s x
           = fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) s x :=
      fderiv_within_congr (hs x hx) (λ y hy, IH hy) (IH hx),
    ext m,
    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this] }
end
lemma iterated_fderiv_within_inter_open {n : ℕ} (hu : is_open u)
  (hs : unique_diff_on 𝕜 (s ∩ u)) (hx : x ∈ s ∩ u) :
  iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x :=
begin
  induction n with n IH generalizing x,
  { ext m, simp },
  { have A : fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f (s ∩ u) y) (s ∩ u) x
           = fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x :=
      fderiv_within_congr (hs x hx) (λ y hy, IH hy) (IH hx),
    have B : fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x
           = fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) s x :=
      fderiv_within_inter (is_open.mem_nhds hu hx.2)
        ((unique_diff_within_at_inter (is_open.mem_nhds hu hx.2)).1 (hs x hx)),
    ext m,
    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B] }
end
lemma iterated_fderiv_within_inter' {n : ℕ}
  (hu : u ∈ 𝓝[s] x) (hs : unique_diff_on 𝕜 s) (xs : x ∈ s) :
  iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x :=
begin
  obtain ⟨v, v_open, xv, vu⟩ : ∃ v, is_open v ∧ x ∈ v ∧ v ∩ s ⊆ u := mem_nhds_within.1 hu,
  have A : (s ∩ u) ∩ v = s ∩ v,
  { apply subset.antisymm (inter_subset_inter (inter_subset_left _ _) (subset.refl _)),
    exact λ y ⟨ys, yv⟩, ⟨⟨ys, vu ⟨yv, ys⟩⟩, yv⟩ },
  have : iterated_fderiv_within 𝕜 n f (s ∩ v) x = iterated_fderiv_within 𝕜 n f s x :=
    iterated_fderiv_within_inter_open v_open (hs.inter v_open) ⟨xs, xv⟩,
  rw ← this,
  have : iterated_fderiv_within 𝕜 n f ((s ∩ u) ∩ v) x = iterated_fderiv_within 𝕜 n f (s ∩ u) x,
  { refine iterated_fderiv_within_inter_open v_open  _ ⟨⟨xs, vu ⟨xv, xs⟩⟩, xv⟩,
    rw A,
    exact hs.inter v_open },
  rw A at this,
  rw ← this
end
lemma iterated_fderiv_within_inter {n : ℕ}
  (hu : u ∈ 𝓝 x) (hs : unique_diff_on 𝕜 s) (xs : x ∈ s) :
  iterated_fderiv_within 𝕜 n f (s ∩ u) x = iterated_fderiv_within 𝕜 n f s x :=
iterated_fderiv_within_inter' (mem_nhds_within_of_mem_nhds hu) hs xs
@[simp] lemma cont_diff_on_zero :
  cont_diff_on 𝕜 0 f s ↔ continuous_on f s :=
begin
  refine ⟨λ H, H.continuous_on, λ H, _⟩,
  assume x hx m hm,
  have : (m : with_top ℕ) = 0 := le_antisymm hm bot_le,
  rw this,
  refine ⟨insert x s, self_mem_nhds_within, ftaylor_series_within 𝕜 f s, _⟩,
  rw has_ftaylor_series_up_to_on_zero_iff,
  exact ⟨by rwa insert_eq_of_mem hx, λ x hx, by simp [ftaylor_series_within]⟩
end
lemma cont_diff_within_at_zero (hx : x ∈ s) :
  cont_diff_within_at 𝕜 0 f s x ↔ ∃ u ∈ 𝓝[s] x, continuous_on f (s ∩ u) :=
begin
  split,
  { intros h,
    obtain ⟨u, H, p, hp⟩ := h 0 (by norm_num),
    refine ⟨u, _, _⟩,
    { simpa [hx] using H },
    { simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp,
      exact hp.1.mono (inter_subset_right s u) } },
  { rintros ⟨u, H, hu⟩,
    rw ← cont_diff_within_at_inter' H,
    have h' : x ∈ s ∩ u := ⟨hx, mem_of_mem_nhds_within hx H⟩,
    exact (cont_diff_on_zero.mpr hu).cont_diff_within_at h' }
end
theorem has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on
  (h : has_ftaylor_series_up_to_on n f p s)
  {m : ℕ} (hmn : (m : with_top ℕ) ≤ n) (hs : unique_diff_on 𝕜 s) (hx : x ∈ s) :
  p x m = iterated_fderiv_within 𝕜 m f s x :=
begin
  induction m with m IH generalizing x,
  { rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp] },
  { have A : (m : with_top ℕ) < n := lt_of_lt_of_le (with_top.coe_lt_coe.2 (lt_add_one m)) hmn,
    have : has_fderiv_within_at (λ (y : E), iterated_fderiv_within 𝕜 m f s y)
      (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x :=
    (h.fderiv_within m A x hx).congr (λ y hy, (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm,
    rw [iterated_fderiv_within_succ_eq_comp_left, function.comp_apply,
      this.fderiv_within (hs x hx)],
    exact (continuous_multilinear_map.uncurry_curry_left _).symm }
end
theorem cont_diff_on.ftaylor_series_within
  (h : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) :
  has_ftaylor_series_up_to_on n f (ftaylor_series_within 𝕜 f s) s :=
begin
  split,
  { assume x hx,
    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply,
               iterated_fderiv_within_zero_apply] },
  { assume m hm x hx,
    rcases (h x hx) m.succ (with_top.add_one_le_of_lt hm) with ⟨u, hu, p, Hp⟩,
    rw insert_eq_of_mem hx at hu,
    rcases mem_nhds_within.1 hu with ⟨o, o_open, xo, ho⟩,
    rw inter_comm at ho,
    have : p x m.succ = ftaylor_series_within 𝕜 f s x m.succ,
    { change p x m.succ = iterated_fderiv_within 𝕜 m.succ f s x,
      rw ← iterated_fderiv_within_inter (is_open.mem_nhds o_open xo) hs hx,
      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl
        (hs.inter o_open) ⟨hx, xo⟩ },
    rw [← this, ← has_fderiv_within_at_inter (is_open.mem_nhds o_open xo)],
    have A : ∀ y ∈ s ∩ o, p y m = ftaylor_series_within 𝕜 f s y m,
    { rintros y ⟨hy, yo⟩,
      change p y m = iterated_fderiv_within 𝕜 m f s y,
      rw ← iterated_fderiv_within_inter (is_open.mem_nhds o_open yo) hs hy,
      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on (with_top.coe_le_coe.2 (nat.le_succ m))
        (hs.inter o_open) ⟨hy, yo⟩ },
    exact ((Hp.mono ho).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m)) x ⟨hx, xo⟩).congr
      (λ y hy, (A y hy).symm) (A x ⟨hx, xo⟩).symm },
  { assume m hm,
    apply continuous_on_of_locally_continuous_on,
    assume x hx,
    rcases h x hx m hm with ⟨u, hu, p, Hp⟩,
    rcases mem_nhds_within.1 hu with ⟨o, o_open, xo, ho⟩,
    rw insert_eq_of_mem hx at ho,
    rw inter_comm at ho,
    refine ⟨o, o_open, xo, _⟩,
    have A : ∀ y ∈ s ∩ o, p y m = ftaylor_series_within 𝕜 f s y m,
    { rintros y ⟨hy, yo⟩,
      change p y m = iterated_fderiv_within 𝕜 m f s y,
      rw ← iterated_fderiv_within_inter (is_open.mem_nhds o_open yo) hs hy,
      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl
        (hs.inter o_open) ⟨hy, yo⟩ },
    exact ((Hp.mono ho).cont m le_rfl).congr (λ y hy, (A y hy).symm) }
end
lemma cont_diff_on_of_continuous_on_differentiable_on
  (Hcont : ∀ (m : ℕ), (m : with_top ℕ) ≤ n →
    continuous_on (λ x, iterated_fderiv_within 𝕜 m f s x) s)
  (Hdiff : ∀ (m : ℕ), (m : with_top ℕ) < n →
    differentiable_on 𝕜 (λ x, iterated_fderiv_within 𝕜 m f s x) s) :
  cont_diff_on 𝕜 n f s :=
begin
  assume x hx m hm,
  rw insert_eq_of_mem hx,
  refine ⟨s, self_mem_nhds_within, ftaylor_series_within 𝕜 f s, _⟩,
  split,
  { assume y hy,
    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply,
                iterated_fderiv_within_zero_apply] },
  { assume k hk y hy,
    convert (Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at,
    simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left,
                continuous_linear_equiv.coe_apply, function.comp_app, coe_fn_coe_base],
    exact continuous_linear_map.curry_uncurry_left _ },
  { assume k hk,
    exact Hcont k (le_trans hk hm) }
end
lemma cont_diff_on_of_differentiable_on
  (h : ∀(m : ℕ), (m : with_top ℕ) ≤ n → differentiable_on 𝕜 (iterated_fderiv_within 𝕜 m f s) s) :
  cont_diff_on 𝕜 n f s :=
cont_diff_on_of_continuous_on_differentiable_on
  (λ m hm, (h m hm).continuous_on) (λ m hm, (h m (le_of_lt hm)))
lemma cont_diff_on.continuous_on_iterated_fderiv_within {m : ℕ}
  (h : cont_diff_on 𝕜 n f s) (hmn : (m : with_top ℕ) ≤ n) (hs : unique_diff_on 𝕜 s) :
  continuous_on (iterated_fderiv_within 𝕜 m f s) s :=
(h.ftaylor_series_within hs).cont m hmn
lemma cont_diff_on.differentiable_on_iterated_fderiv_within {m : ℕ}
  (h : cont_diff_on 𝕜 n f s) (hmn : (m : with_top ℕ) < n) (hs : unique_diff_on 𝕜 s) :
  differentiable_on 𝕜 (iterated_fderiv_within 𝕜 m f s) s :=
λ x hx, ((h.ftaylor_series_within hs).fderiv_within m hmn x hx).differentiable_within_at
lemma cont_diff_on_iff_continuous_on_differentiable_on
  (hs : unique_diff_on 𝕜 s) :
  cont_diff_on 𝕜 n f s ↔
  (∀ (m : ℕ), (m : with_top ℕ) ≤ n →
    continuous_on (λ x, iterated_fderiv_within 𝕜 m f s x) s)
  ∧ (∀ (m : ℕ), (m : with_top ℕ) < n →
    differentiable_on 𝕜 (λ x, iterated_fderiv_within 𝕜 m f s x) s) :=
begin
  split,
  { assume h,
    split,
    { assume m hm, exact h.continuous_on_iterated_fderiv_within hm hs },
    { assume m hm, exact h.differentiable_on_iterated_fderiv_within hm hs } },
  { assume h,
    exact cont_diff_on_of_continuous_on_differentiable_on h.1 h.2 }
end
lemma cont_diff_on_succ_of_fderiv_within {n : ℕ} (hf : differentiable_on 𝕜 f s)
  (h : cont_diff_on 𝕜 n (λ y, fderiv_within 𝕜 f s y) s) :
  cont_diff_on 𝕜 ((n + 1) : ℕ) f s :=
begin
  intros x hx,
  rw [cont_diff_within_at_succ_iff_has_fderiv_within_at, insert_eq_of_mem hx],
  exact ⟨s, self_mem_nhds_within, fderiv_within 𝕜 f s,
    λ y hy, (hf y hy).has_fderiv_within_at, h x hx⟩
end
theorem cont_diff_on_succ_iff_fderiv_within {n : ℕ} (hs : unique_diff_on 𝕜 s) :
  cont_diff_on 𝕜 ((n + 1) : ℕ) f s ↔
  differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 n (λ y, fderiv_within 𝕜 f s y) s :=
begin
  refine ⟨λ H, _, λ h, cont_diff_on_succ_of_fderiv_within h.1 h.2⟩,
  refine ⟨H.differentiable_on (with_top.coe_le_coe.2 (nat.le_add_left 1 n)), λ x hx, _⟩,
  rcases cont_diff_within_at_succ_iff_has_fderiv_within_at.1 (H x hx)
    with ⟨u, hu, f', hff', hf'⟩,
  rcases mem_nhds_within.1 hu with ⟨o, o_open, xo, ho⟩,
  rw [inter_comm, insert_eq_of_mem hx] at ho,
  have := hf'.mono ho,
  rw cont_diff_within_at_inter' (mem_nhds_within_of_mem_nhds (is_open.mem_nhds o_open xo))
    at this,
  apply this.congr_of_eventually_eq' _ hx,
  have : o ∩ s ∈ 𝓝[s] x := mem_nhds_within.2 ⟨o, o_open, xo, subset.refl _⟩,
  rw inter_comm at this,
  apply filter.eventually_eq_of_mem this (λ y hy, _),
  have A : fderiv_within 𝕜 f (s ∩ o) y = f' y :=
    ((hff' y (ho hy)).mono ho).fderiv_within (hs.inter o_open y hy),
  rwa fderiv_within_inter (is_open.mem_nhds o_open hy.2) (hs y hy.1) at A
end
theorem cont_diff_on_succ_iff_fderiv_of_open {n : ℕ} (hs : is_open s) :
  cont_diff_on 𝕜 ((n + 1) : ℕ) f s ↔
  differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 n (λ y, fderiv 𝕜 f y) s :=
begin
  rw cont_diff_on_succ_iff_fderiv_within hs.unique_diff_on,
  congrm _ ∧ _,
  apply cont_diff_on_congr,
  assume x hx,
  exact fderiv_within_of_open hs hx
end
theorem cont_diff_on_top_iff_fderiv_within (hs : unique_diff_on 𝕜 s) :
  cont_diff_on 𝕜 ∞ f s ↔
  differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 ∞ (λ y, fderiv_within 𝕜 f s y) s :=
begin
  split,
  { assume h,
    refine ⟨h.differentiable_on le_top, _⟩,
    apply cont_diff_on_top.2 (λ n, ((cont_diff_on_succ_iff_fderiv_within hs).1 _).2),
    exact h.of_le le_top },
  { assume h,
    refine cont_diff_on_top.2 (λ n, _),
    have A : (n : with_top ℕ) ≤ ∞ := le_top,
    apply ((cont_diff_on_succ_iff_fderiv_within hs).2 ⟨h.1, h.2.of_le A⟩).of_le,
    exact with_top.coe_le_coe.2 (nat.le_succ n) }
end
theorem cont_diff_on_top_iff_fderiv_of_open (hs : is_open s) :
  cont_diff_on 𝕜 ∞ f s ↔
  differentiable_on 𝕜 f s ∧ cont_diff_on 𝕜 ∞ (λ y, fderiv 𝕜 f y) s :=
begin
  rw cont_diff_on_top_iff_fderiv_within hs.unique_diff_on,
  congrm _ ∧ _,
  apply cont_diff_on_congr,
  assume x hx,
  exact fderiv_within_of_open hs hx
end
lemma cont_diff_on.fderiv_within
  (hf : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) (hmn : m + 1 ≤ n) :
  cont_diff_on 𝕜 m (λ y, fderiv_within 𝕜 f s y) s :=
begin
  cases m,
  { change ∞ + 1 ≤ n at hmn,
    have : n = ∞, by simpa using hmn,
    rw this at hf,
    exact ((cont_diff_on_top_iff_fderiv_within hs).1 hf).2 },
  { change (m.succ : with_top ℕ) ≤ n at hmn,
    exact ((cont_diff_on_succ_iff_fderiv_within hs).1 (hf.of_le hmn)).2 }
end
lemma cont_diff_on.fderiv_of_open
  (hf : cont_diff_on 𝕜 n f s) (hs : is_open s) (hmn : m + 1 ≤ n) :
  cont_diff_on 𝕜 m (λ y, fderiv 𝕜 f y) s :=
(hf.fderiv_within hs.unique_diff_on hmn).congr (λ x hx, (fderiv_within_of_open hs hx).symm)
lemma cont_diff_on.continuous_on_fderiv_within
  (h : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) (hn : 1 ≤ n) :
  continuous_on (λ x, fderiv_within 𝕜 f s x) s :=
((cont_diff_on_succ_iff_fderiv_within hs).1 (h.of_le hn)).2.continuous_on
lemma cont_diff_on.continuous_on_fderiv_of_open
  (h : cont_diff_on 𝕜 n f s) (hs : is_open s) (hn : 1 ≤ n) :
  continuous_on (λ x, fderiv 𝕜 f x) s :=
((cont_diff_on_succ_iff_fderiv_of_open hs).1 (h.of_le hn)).2.continuous_on
lemma cont_diff_on.continuous_on_fderiv_within_apply
  (h : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) (hn : 1 ≤ n) :
  continuous_on (λp : E × E, (fderiv_within 𝕜 f s p.1 : E → F) p.2) (s ×ˢ (univ : set E)) :=
begin
  have A : continuous (λq : (E →L[𝕜] F) × E, q.1 q.2) := is_bounded_bilinear_map_apply.continuous,
  have B : continuous_on (λp : E × E, (fderiv_within 𝕜 f s p.1, p.2)) (s ×ˢ (univ : set E)),
  { apply continuous_on.prod _ continuous_snd.continuous_on,
    exact continuous_on.comp (h.continuous_on_fderiv_within hs hn) continuous_fst.continuous_on
      (prod_subset_preimage_fst _ _) },
  exact A.comp_continuous_on B
end
structure has_ftaylor_series_up_to (n : with_top ℕ)
  (f : E → F) (p : E → formal_multilinear_series 𝕜 E F) : Prop :=
(zero_eq : ∀ x, (p x 0).uncurry0 = f x)
(fderiv  : ∀ (m : ℕ) (hm : (m : with_top ℕ) < n), ∀ x,
    has_fderiv_at (λ y, p y m) (p x m.succ).curry_left x)
(cont    : ∀ (m : ℕ) (hm : (m : with_top ℕ) ≤ n), continuous (λ x, p x m))
lemma has_ftaylor_series_up_to.zero_eq'
  (h : has_ftaylor_series_up_to n f p) (x : E) :
  p x 0 = (continuous_multilinear_curry_fin0 𝕜 E F).symm (f x) :=
by { rw ← h.zero_eq x, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
lemma has_ftaylor_series_up_to_on_univ_iff :
  has_ftaylor_series_up_to_on n f p univ ↔ has_ftaylor_series_up_to n f p :=
begin
  split,
  { assume H,
    split,
    { exact λ x, H.zero_eq x (mem_univ x) },
    { assume m hm x,
      rw ← has_fderiv_within_at_univ,
      exact H.fderiv_within m hm x (mem_univ x) },
    { assume m hm,
      rw continuous_iff_continuous_on_univ,
      exact H.cont m hm } },
  { assume H,
    split,
    { exact λ x hx, H.zero_eq x },
    { assume m hm x hx,
      rw has_fderiv_within_at_univ,
      exact H.fderiv m hm x },
    { assume m hm,
      rw ← continuous_iff_continuous_on_univ,
      exact H.cont m hm } }
end
lemma has_ftaylor_series_up_to.has_ftaylor_series_up_to_on
  (h : has_ftaylor_series_up_to n f p) (s : set E) :
  has_ftaylor_series_up_to_on n f p s :=
(has_ftaylor_series_up_to_on_univ_iff.2 h).mono (subset_univ _)
lemma has_ftaylor_series_up_to.of_le
  (h : has_ftaylor_series_up_to n f p) (hmn : m ≤ n) :
  has_ftaylor_series_up_to m f p :=
by { rw ← has_ftaylor_series_up_to_on_univ_iff at h ⊢, exact h.of_le hmn }
lemma has_ftaylor_series_up_to.continuous
  (h : has_ftaylor_series_up_to n f p) : continuous f :=
begin
  rw ← has_ftaylor_series_up_to_on_univ_iff at h,
  rw continuous_iff_continuous_on_univ,
  exact h.continuous_on
end
lemma has_ftaylor_series_up_to_zero_iff :
  has_ftaylor_series_up_to 0 f p ↔ continuous f ∧ (∀ x, (p x 0).uncurry0 = f x) :=
by simp [has_ftaylor_series_up_to_on_univ_iff.symm, continuous_iff_continuous_on_univ,
         has_ftaylor_series_up_to_on_zero_iff]
lemma has_ftaylor_series_up_to.has_fderiv_at
  (h : has_ftaylor_series_up_to n f p) (hn : 1 ≤ n) (x : E) :
  has_fderiv_at f (continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) x :=
begin
  rw [← has_fderiv_within_at_univ],
  exact (has_ftaylor_series_up_to_on_univ_iff.2 h).has_fderiv_within_at hn (mem_univ _)
end
lemma has_ftaylor_series_up_to.differentiable
  (h : has_ftaylor_series_up_to n f p) (hn : 1 ≤ n) : differentiable 𝕜 f :=
λ x, (h.has_fderiv_at hn x).differentiable_at
theorem has_ftaylor_series_up_to_succ_iff_right {n : ℕ} :
  has_ftaylor_series_up_to ((n + 1) : ℕ) f p ↔
  (∀ x, (p x 0).uncurry0 = f x)
  ∧ (∀ x, has_fderiv_at (λ y, p y 0) (p x 1).curry_left x)
  ∧ has_ftaylor_series_up_to n
    (λ x, continuous_multilinear_curry_fin1 𝕜 E F (p x 1)) (λ x, (p x).shift) :=
by simp only [has_ftaylor_series_up_to_on_succ_iff_right, ← has_ftaylor_series_up_to_on_univ_iff,
  mem_univ, forall_true_left, has_fderiv_within_at_univ]
variable (𝕜)
def cont_diff_at (n : with_top ℕ) (f : E → F) (x : E) :=
cont_diff_within_at 𝕜 n f univ x
variable {𝕜}
theorem cont_diff_within_at_univ :
  cont_diff_within_at 𝕜 n f univ x ↔ cont_diff_at 𝕜 n f x :=
iff.rfl
lemma cont_diff_at_top :
  cont_diff_at 𝕜 ∞ f x ↔ ∀ (n : ℕ), cont_diff_at 𝕜 n f x :=
by simp [← cont_diff_within_at_univ, cont_diff_within_at_top]
lemma cont_diff_at.cont_diff_within_at
  (h : cont_diff_at 𝕜 n f x) : cont_diff_within_at 𝕜 n f s x :=
h.mono (subset_univ _)
lemma cont_diff_within_at.cont_diff_at
  (h : cont_diff_within_at 𝕜 n f s x) (hx : s ∈ 𝓝 x) :
  cont_diff_at 𝕜 n f x :=
by rwa [cont_diff_at, ← cont_diff_within_at_inter hx, univ_inter]
lemma cont_diff_at.congr_of_eventually_eq
  (h : cont_diff_at 𝕜 n f x) (hg : f₁ =ᶠ[𝓝 x] f) :
  cont_diff_at 𝕜 n f₁ x :=
h.congr_of_eventually_eq' (by rwa nhds_within_univ) (mem_univ x)
lemma cont_diff_at.of_le
  (h : cont_diff_at 𝕜 n f x) (hmn : m ≤ n) :
  cont_diff_at 𝕜 m f x :=
h.of_le hmn
lemma cont_diff_at.continuous_at
  (h : cont_diff_at 𝕜 n f x) : continuous_at f x :=
by simpa [continuous_within_at_univ] using h.continuous_within_at
lemma cont_diff_at.differentiable_at
  (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) : differentiable_at 𝕜 f x :=
by simpa [hn, differentiable_within_at_univ] using h.differentiable_within_at
theorem cont_diff_at_succ_iff_has_fderiv_at {n : ℕ} :
  cont_diff_at 𝕜 ((n + 1) : ℕ) f x
  ↔ (∃ f' : E → E →L[𝕜] F, (∃ u ∈ 𝓝 x, ∀ x ∈ u, has_fderiv_at f (f' x) x)
      ∧ cont_diff_at 𝕜 n f' x) :=
begin
  rw [← cont_diff_within_at_univ, cont_diff_within_at_succ_iff_has_fderiv_within_at],
  simp only [nhds_within_univ, exists_prop, mem_univ, insert_eq_of_mem],
  split,
  { rintros ⟨u, H, f', h_fderiv, h_cont_diff⟩,
    rcases mem_nhds_iff.mp H with ⟨t, htu, ht, hxt⟩,
    refine ⟨f', ⟨t, _⟩, h_cont_diff.cont_diff_at H⟩,
    refine ⟨mem_nhds_iff.mpr ⟨t, subset.rfl, ht, hxt⟩, _⟩,
    intros y hyt,
    refine (h_fderiv y (htu hyt)).has_fderiv_at _,
    exact mem_nhds_iff.mpr ⟨t, htu, ht, hyt⟩ },
  { rintros ⟨f', ⟨u, H, h_fderiv⟩, h_cont_diff⟩,
    refine ⟨u, H, f', _, h_cont_diff.cont_diff_within_at⟩,
    intros x hxu,
    exact (h_fderiv x hxu).has_fderiv_within_at }
end
protected theorem cont_diff_at.eventually {n : ℕ} (h : cont_diff_at 𝕜 n f x) :
  ∀ᶠ y in 𝓝 x, cont_diff_at 𝕜 n f y :=
by simpa [nhds_within_univ] using h.eventually
variable (𝕜)
definition cont_diff (n : with_top ℕ) (f : E → F) :=
∃ p : E → formal_multilinear_series 𝕜 E F, has_ftaylor_series_up_to n f p
variable {𝕜}
theorem cont_diff_on_univ : cont_diff_on 𝕜 n f univ ↔ cont_diff 𝕜 n f :=
begin
  split,
  { assume H,
    use ftaylor_series_within 𝕜 f univ,
    rw ← has_ftaylor_series_up_to_on_univ_iff,
    exact H.ftaylor_series_within unique_diff_on_univ },
  { rintros ⟨p, hp⟩ x hx m hm,
    exact ⟨univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hm⟩ }
end
lemma cont_diff_iff_cont_diff_at : cont_diff 𝕜 n f ↔ ∀ x, cont_diff_at 𝕜 n f x :=
by simp [← cont_diff_on_univ, cont_diff_on, cont_diff_at]
lemma cont_diff.cont_diff_at (h : cont_diff 𝕜 n f) : cont_diff_at 𝕜 n f x :=
cont_diff_iff_cont_diff_at.1 h x
lemma cont_diff.cont_diff_within_at (h : cont_diff 𝕜 n f) : cont_diff_within_at 𝕜 n f s x :=
h.cont_diff_at.cont_diff_within_at
lemma cont_diff_top : cont_diff 𝕜 ∞ f ↔ ∀ (n : ℕ), cont_diff 𝕜 n f :=
by simp [cont_diff_on_univ.symm, cont_diff_on_top]
lemma cont_diff_all_iff_nat : (∀ n, cont_diff 𝕜 n f) ↔ (∀ n : ℕ, cont_diff 𝕜 n f) :=
by simp only [← cont_diff_on_univ, cont_diff_on_all_iff_nat]
lemma cont_diff.cont_diff_on (h : cont_diff 𝕜 n f) : cont_diff_on 𝕜 n f s :=
(cont_diff_on_univ.2 h).mono (subset_univ _)
@[simp] lemma cont_diff_zero : cont_diff 𝕜 0 f ↔ continuous f :=
begin
  rw [← cont_diff_on_univ, continuous_iff_continuous_on_univ],
  exact cont_diff_on_zero
end
lemma cont_diff_at_zero : cont_diff_at 𝕜 0 f x ↔ ∃ u ∈ 𝓝 x, continuous_on f u :=
by { rw ← cont_diff_within_at_univ, simp [cont_diff_within_at_zero, nhds_within_univ] }
theorem cont_diff_at_one_iff : cont_diff_at 𝕜 1 f x ↔
  ∃ f' : E → (E →L[𝕜] F), ∃ u ∈ 𝓝 x, continuous_on f' u ∧ ∀ x ∈ u, has_fderiv_at f (f' x) x :=
by simp_rw [show (1 : with_top ℕ) = (0 + 1 : ℕ), from (zero_add 1).symm,
  cont_diff_at_succ_iff_has_fderiv_at, show ((0 : ℕ) : with_top ℕ) = 0, from rfl,
  cont_diff_at_zero, exists_mem_and_iff antitone_bforall antitone_continuous_on, and_comm]
lemma cont_diff.of_le (h : cont_diff 𝕜 n f) (hmn : m ≤ n) : cont_diff 𝕜 m f :=
cont_diff_on_univ.1 $ (cont_diff_on_univ.2 h).of_le hmn
lemma cont_diff.of_succ {n : ℕ} (h : cont_diff 𝕜 (n + 1) f) : cont_diff 𝕜 n f :=
h.of_le $ with_top.coe_le_coe.mpr le_self_add
lemma cont_diff.one_of_succ {n : ℕ} (h : cont_diff 𝕜 (n + 1) f) : cont_diff 𝕜 1 f :=
h.of_le $ with_top.coe_le_coe.mpr le_add_self
lemma cont_diff.continuous (h : cont_diff 𝕜 n f) : continuous f :=
cont_diff_zero.1 (h.of_le bot_le)
lemma cont_diff.differentiable (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : differentiable 𝕜 f :=
differentiable_on_univ.1 $ (cont_diff_on_univ.2 h).differentiable_on hn
variable (𝕜)
noncomputable def iterated_fderiv (n : ℕ) (f : E → F) :
  E → (E [×n]→L[𝕜] F) :=
nat.rec_on n
  (λ x, continuous_multilinear_map.curry0 𝕜 E (f x))
  (λ n rec x, continuous_linear_map.uncurry_left (fderiv 𝕜 rec x))
def ftaylor_series (f : E → F) (x : E) : formal_multilinear_series 𝕜 E F :=
λ n, iterated_fderiv 𝕜 n f x
variable {𝕜}
@[simp] lemma iterated_fderiv_zero_apply (m : (fin 0) → E) :
  (iterated_fderiv 𝕜 0 f x : ((fin 0) →  E) → F) m = f x := rfl
lemma iterated_fderiv_zero_eq_comp :
  iterated_fderiv 𝕜 0 f = (continuous_multilinear_curry_fin0 𝕜 E F).symm ∘ f := rfl
lemma iterated_fderiv_succ_apply_left {n : ℕ} (m : fin (n + 1) → E):
  (iterated_fderiv 𝕜 (n + 1) f x : (fin (n + 1) → E) → F) m
  = (fderiv 𝕜 (iterated_fderiv 𝕜 n f) x : E → (E [×n]→L[𝕜] F)) (m 0) (tail m) := rfl
lemma iterated_fderiv_succ_eq_comp_left {n : ℕ} :
  iterated_fderiv 𝕜 (n + 1) f =
  (continuous_multilinear_curry_left_equiv 𝕜 (λ(i : fin (n + 1)), E) F)
    ∘ (fderiv 𝕜 (iterated_fderiv 𝕜 n f)) := rfl
lemma iterated_fderiv_within_univ {n : ℕ} :
  iterated_fderiv_within 𝕜 n f univ = iterated_fderiv 𝕜 n f :=
begin
  induction n with n IH,
  { ext x, simp },
  { ext x m,
    rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH,
        fderiv_within_univ] }
end
lemma iterated_fderiv_within_of_is_open (n : ℕ) (hs : is_open s) :
  eq_on (iterated_fderiv_within 𝕜 n f s) (iterated_fderiv 𝕜 n f) s :=
begin
  induction n with n IH,
  { assume x hx,
    ext1 m,
    simp only [iterated_fderiv_within_zero_apply, iterated_fderiv_zero_apply] },
  { assume x hx,
    rw [iterated_fderiv_succ_eq_comp_left, iterated_fderiv_within_succ_eq_comp_left],
    dsimp,
    congr' 1,
    rw fderiv_within_of_open hs hx,
    apply filter.eventually_eq.fderiv_eq,
    filter_upwards [hs.mem_nhds hx],
    exact IH }
end
lemma ftaylor_series_within_univ :
  ftaylor_series_within 𝕜 f univ = ftaylor_series 𝕜 f :=
begin
  ext1 x, ext1 n,
  change iterated_fderiv_within 𝕜 n f univ x = iterated_fderiv 𝕜 n f x,
  rw iterated_fderiv_within_univ
end
theorem iterated_fderiv_succ_apply_right {n : ℕ} (m : fin (n + 1) → E) :
  (iterated_fderiv 𝕜 (n + 1) f x : (fin (n + 1) → E) → F) m
    = iterated_fderiv 𝕜 n (λy, fderiv 𝕜 f y) x (init m) (m (last n)) :=
begin
  rw [← iterated_fderiv_within_univ, ← iterated_fderiv_within_univ, ← fderiv_within_univ],
  exact iterated_fderiv_within_succ_apply_right unique_diff_on_univ (mem_univ _) _
end
lemma iterated_fderiv_succ_eq_comp_right {n : ℕ} :
  iterated_fderiv 𝕜 (n + 1) f x =
  ((continuous_multilinear_curry_right_equiv' 𝕜 n E F)
    ∘ (iterated_fderiv 𝕜 n (λy, fderiv 𝕜 f y))) x :=
by { ext m, rw iterated_fderiv_succ_apply_right, refl }
@[simp] lemma iterated_fderiv_one_apply (m : (fin 1) → E) :
  (iterated_fderiv 𝕜 1 f x : ((fin 1) → E) → F) m
  = (fderiv 𝕜 f x : E → F) (m 0) :=
by { rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply], refl }
theorem cont_diff_on_iff_ftaylor_series :
  cont_diff 𝕜 n f ↔ has_ftaylor_series_up_to n f (ftaylor_series 𝕜 f) :=
begin
  split,
  { rw [← cont_diff_on_univ, ← has_ftaylor_series_up_to_on_univ_iff,
        ← ftaylor_series_within_univ],
    exact λ h, cont_diff_on.ftaylor_series_within h unique_diff_on_univ },
  { assume h, exact ⟨ftaylor_series 𝕜 f, h⟩ }
end
lemma cont_diff_iff_continuous_differentiable :
  cont_diff 𝕜 n f ↔
  (∀ (m : ℕ), (m : with_top ℕ) ≤ n → continuous (λ x, iterated_fderiv 𝕜 m f x))
  ∧ (∀ (m : ℕ), (m : with_top ℕ) < n → differentiable 𝕜 (λ x, iterated_fderiv 𝕜 m f x)) :=
by simp [cont_diff_on_univ.symm, continuous_iff_continuous_on_univ,
    differentiable_on_univ.symm, iterated_fderiv_within_univ,
    cont_diff_on_iff_continuous_on_differentiable_on unique_diff_on_univ]
lemma cont_diff_of_differentiable_iterated_fderiv
  (h : ∀(m : ℕ), (m : with_top ℕ) ≤ n → differentiable 𝕜 (iterated_fderiv 𝕜 m f)) :
  cont_diff 𝕜 n f :=
cont_diff_iff_continuous_differentiable.2
⟨λ m hm, (h m hm).continuous, λ m hm, (h m (le_of_lt hm))⟩
theorem cont_diff_succ_iff_fderiv {n : ℕ} :
  cont_diff 𝕜 ((n + 1) : ℕ) f ↔
  differentiable 𝕜 f ∧ cont_diff 𝕜 n (λ y, fderiv 𝕜 f y) :=
by simp only [← cont_diff_on_univ, ← differentiable_on_univ, ← fderiv_within_univ,
  cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ]
theorem cont_diff_one_iff_fderiv :
  cont_diff 𝕜 1 f ↔ differentiable 𝕜 f ∧ continuous (fderiv 𝕜 f) :=
cont_diff_succ_iff_fderiv.trans $ iff.rfl.and cont_diff_zero
theorem cont_diff_top_iff_fderiv :
  cont_diff 𝕜 ∞ f ↔
  differentiable 𝕜 f ∧ cont_diff 𝕜 ∞ (λ y, fderiv 𝕜 f y) :=
begin
  simp [cont_diff_on_univ.symm, differentiable_on_univ.symm, fderiv_within_univ.symm,
        - fderiv_within_univ],
  rw cont_diff_on_top_iff_fderiv_within unique_diff_on_univ,
end
lemma cont_diff.continuous_fderiv
  (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) :
  continuous (λ x, fderiv 𝕜 f x) :=
((cont_diff_succ_iff_fderiv).1 (h.of_le hn)).2.continuous
lemma cont_diff.continuous_fderiv_apply
  (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) :
  continuous (λp : E × E, (fderiv 𝕜 f p.1 : E → F) p.2) :=
begin
  have A : continuous (λq : (E →L[𝕜] F) × E, q.1 q.2) := is_bounded_bilinear_map_apply.continuous,
  have B : continuous (λp : E × E, (fderiv 𝕜 f p.1, p.2)),
  { apply continuous.prod_mk _ continuous_snd,
    exact continuous.comp (h.continuous_fderiv hn) continuous_fst },
  exact A.comp B
end
lemma iterated_fderiv_within_zero_fun {n : ℕ} :
  iterated_fderiv 𝕜 n (λ x : E, (0 : F)) = 0 :=
begin
  induction n with n IH,
  { ext m, simp },
  { ext x m,
    rw [iterated_fderiv_succ_apply_left, IH],
    change (fderiv 𝕜 (λ (x : E), (0 : (E [×n]→L[𝕜] F))) x : E → (E [×n]→L[𝕜] F)) (m 0) (tail m) = _,
    rw fderiv_const,
    refl }
end
lemma cont_diff_zero_fun :
  cont_diff 𝕜 n (λ x : E, (0 : F)) :=
begin
  apply cont_diff_of_differentiable_iterated_fderiv (λm hm, _),
  rw iterated_fderiv_within_zero_fun,
  apply differentiable_const (0 : (E [×m]→L[𝕜] F))
end
lemma cont_diff_const {c : F} : cont_diff 𝕜 n (λx : E, c) :=
begin
  suffices h : cont_diff 𝕜 ∞ (λx : E, c), by exact h.of_le le_top,
  rw cont_diff_top_iff_fderiv,
  refine ⟨differentiable_const c, _⟩,
  rw fderiv_const,
  exact cont_diff_zero_fun
end
lemma cont_diff_on_const {c : F} {s : set E} :
  cont_diff_on 𝕜 n (λx : E, c) s :=
cont_diff_const.cont_diff_on
lemma cont_diff_at_const {c : F} :
  cont_diff_at 𝕜 n (λx : E, c) x :=
cont_diff_const.cont_diff_at
lemma cont_diff_within_at_const {c : F} :
  cont_diff_within_at 𝕜 n (λx : E, c) s x :=
cont_diff_at_const.cont_diff_within_at
@[nontriviality] lemma cont_diff_of_subsingleton [subsingleton F] :
  cont_diff 𝕜 n f :=
by { rw [subsingleton.elim f (λ _, 0)], exact cont_diff_const }
@[nontriviality] lemma cont_diff_at_of_subsingleton [subsingleton F] :
  cont_diff_at 𝕜 n f x :=
by { rw [subsingleton.elim f (λ _, 0)], exact cont_diff_at_const }
@[nontriviality] lemma cont_diff_within_at_of_subsingleton [subsingleton F] :
  cont_diff_within_at 𝕜 n f s x :=
by { rw [subsingleton.elim f (λ _, 0)], exact cont_diff_within_at_const }
@[nontriviality] lemma cont_diff_on_of_subsingleton [subsingleton F] :
  cont_diff_on 𝕜 n f s :=
by { rw [subsingleton.elim f (λ _, 0)], exact cont_diff_on_const }
lemma is_bounded_linear_map.cont_diff (hf : is_bounded_linear_map 𝕜 f) :
  cont_diff 𝕜 n f :=
begin
  suffices h : cont_diff 𝕜 ∞ f, by exact h.of_le le_top,
  rw cont_diff_top_iff_fderiv,
  refine ⟨hf.differentiable, _⟩,
  simp_rw [hf.fderiv],
  exact cont_diff_const
end
lemma continuous_linear_map.cont_diff (f : E →L[𝕜] F) : cont_diff 𝕜 n f :=
f.is_bounded_linear_map.cont_diff
lemma continuous_linear_equiv.cont_diff (f : E ≃L[𝕜] F) : cont_diff 𝕜 n f :=
(f : E →L[𝕜] F).cont_diff
lemma linear_isometry.cont_diff (f : E →ₗᵢ[𝕜] F) : cont_diff 𝕜 n f :=
f.to_continuous_linear_map.cont_diff
lemma linear_isometry_equiv.cont_diff (f : E ≃ₗᵢ[𝕜] F) : cont_diff 𝕜 n f :=
(f : E →L[𝕜] F).cont_diff
lemma cont_diff_id : cont_diff 𝕜 n (id : E → E) :=
is_bounded_linear_map.id.cont_diff
lemma cont_diff_within_at_id {s x} : cont_diff_within_at 𝕜 n (id : E → E) s x :=
cont_diff_id.cont_diff_within_at
lemma cont_diff_at_id {x} : cont_diff_at 𝕜 n (id : E → E) x :=
cont_diff_id.cont_diff_at
lemma cont_diff_on_id {s} : cont_diff_on 𝕜 n (id : E → E) s :=
cont_diff_id.cont_diff_on
lemma is_bounded_bilinear_map.cont_diff (hb : is_bounded_bilinear_map 𝕜 b) :
  cont_diff 𝕜 n b :=
begin
  suffices h : cont_diff 𝕜 ∞ b, by exact h.of_le le_top,
  rw cont_diff_top_iff_fderiv,
  refine ⟨hb.differentiable, _⟩,
  simp [hb.fderiv],
  exact hb.is_bounded_linear_map_deriv.cont_diff
end
lemma has_ftaylor_series_up_to_on.continuous_linear_map_comp (g : F →L[𝕜] G)
  (hf : has_ftaylor_series_up_to_on n f p s) :
  has_ftaylor_series_up_to_on n (g ∘ f) (λ x k, g.comp_continuous_multilinear_map (p x k)) s :=
begin
  set L : Π m : ℕ, (E [×m]→L[𝕜] F) →L[𝕜] (E [×m]→L[𝕜] G) :=
    λ m, continuous_linear_map.comp_continuous_multilinear_mapL 𝕜 (λ _, E) F G g,
  split,
  { exact λ x hx, congr_arg g (hf.zero_eq x hx) },
  { intros m hm x hx,
    convert (L m).has_fderiv_at.comp_has_fderiv_within_at x (hf.fderiv_within m hm x hx) },
  { intros m hm,
    convert (L m).continuous.comp_continuous_on (hf.cont m hm) }
end
lemma cont_diff_within_at.continuous_linear_map_comp (g : F →L[𝕜] G)
  (hf : cont_diff_within_at 𝕜 n f s x) :
  cont_diff_within_at 𝕜 n (g ∘ f) s x :=
begin
  assume m hm,
  rcases hf m hm with ⟨u, hu, p, hp⟩,
  exact ⟨u, hu, _, hp.continuous_linear_map_comp g⟩,
end
lemma cont_diff_at.continuous_linear_map_comp (g : F →L[𝕜] G) (hf : cont_diff_at 𝕜 n f x) :
  cont_diff_at 𝕜 n (g ∘ f) x :=
cont_diff_within_at.continuous_linear_map_comp g hf
lemma cont_diff_on.continuous_linear_map_comp (g : F →L[𝕜] G) (hf : cont_diff_on 𝕜 n f s) :
  cont_diff_on 𝕜 n (g ∘ f) s :=
λ x hx, (hf x hx).continuous_linear_map_comp g
lemma cont_diff.continuous_linear_map_comp {f : E → F} (g : F →L[𝕜] G)
  (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λx, g (f x)) :=
cont_diff_on_univ.1 $ cont_diff_on.continuous_linear_map_comp
  _ (cont_diff_on_univ.2 hf)
lemma continuous_linear_equiv.comp_cont_diff_within_at_iff
  (e : F ≃L[𝕜] G) :
  cont_diff_within_at 𝕜 n (e ∘ f) s x ↔ cont_diff_within_at 𝕜 n f s x :=
⟨λ H, by simpa only [(∘), e.symm.coe_coe, e.symm_apply_apply]
  using H.continuous_linear_map_comp (e.symm : G →L[𝕜] F),
  λ H, H.continuous_linear_map_comp (e : F →L[𝕜] G)⟩
lemma continuous_linear_equiv.comp_cont_diff_on_iff
  (e : F ≃L[𝕜] G) :
  cont_diff_on 𝕜 n (e ∘ f) s ↔ cont_diff_on 𝕜 n f s :=
by simp [cont_diff_on, e.comp_cont_diff_within_at_iff]
lemma has_ftaylor_series_up_to_on.comp_continuous_linear_map
  (hf : has_ftaylor_series_up_to_on n f p s) (g : G →L[𝕜] E) :
  has_ftaylor_series_up_to_on n (f ∘ g)
    (λ x k, (p (g x) k).comp_continuous_linear_map (λ _, g)) (g ⁻¹' s) :=
begin
  let A : Π m : ℕ, (E [×m]→L[𝕜] F) → (G [×m]→L[𝕜] F) :=
    λ m h, h.comp_continuous_linear_map (λ _, g),
  have hA : ∀ m, is_bounded_linear_map 𝕜 (A m) :=
    λ m, is_bounded_linear_map_continuous_multilinear_map_comp_linear g,
  split,
  { assume x hx,
    simp only [(hf.zero_eq (g x) hx).symm, function.comp_app],
    change p (g x) 0 (λ (i : fin 0), g 0) = p (g x) 0 0,
    rw continuous_linear_map.map_zero,
    refl },
  { assume m hm x hx,
    convert ((hA m).has_fderiv_at).comp_has_fderiv_within_at x
      ((hf.fderiv_within m hm (g x) hx).comp x (g.has_fderiv_within_at) (subset.refl _)),
    ext y v,
    change p (g x) (nat.succ m) (g ∘ (cons y v)) = p (g x) m.succ (cons (g y) (g ∘ v)),
    rw comp_cons },
  { assume m hm,
    exact (hA m).continuous.comp_continuous_on
      ((hf.cont m hm).comp g.continuous.continuous_on (subset.refl _)) }
end
lemma cont_diff_within_at.comp_continuous_linear_map {x : G}
  (g : G →L[𝕜] E) (hf : cont_diff_within_at 𝕜 n f s (g x)) :
  cont_diff_within_at 𝕜 n (f ∘ g) (g ⁻¹' s) x :=
begin
  assume m hm,
  rcases hf m hm with ⟨u, hu, p, hp⟩,
  refine ⟨g ⁻¹' u, _, _, hp.comp_continuous_linear_map g⟩,
  apply continuous_within_at.preimage_mem_nhds_within',
  { exact g.continuous.continuous_within_at },
  { apply nhds_within_mono (g x) _ hu,
    rw image_insert_eq,
    exact insert_subset_insert (image_preimage_subset g s) }
end
lemma cont_diff_on.comp_continuous_linear_map
  (hf : cont_diff_on 𝕜 n f s) (g : G →L[𝕜] E) :
  cont_diff_on 𝕜 n (f ∘ g) (g ⁻¹' s) :=
λ x hx, (hf (g x) hx).comp_continuous_linear_map g
lemma cont_diff.comp_continuous_linear_map {f : E → F} {g : G →L[𝕜] E}
  (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (f ∘ g) :=
cont_diff_on_univ.1 $
cont_diff_on.comp_continuous_linear_map (cont_diff_on_univ.2 hf) _
lemma continuous_linear_equiv.cont_diff_within_at_comp_iff (e : G ≃L[𝕜] E) :
  cont_diff_within_at 𝕜 n (f ∘ e) (e ⁻¹' s) (e.symm x) ↔
  cont_diff_within_at 𝕜 n f s x :=
begin
  split,
  { assume H,
    simpa [← preimage_comp, (∘)] using H.comp_continuous_linear_map (e.symm : E →L[𝕜] G) },
  { assume H,
    rw [← e.apply_symm_apply x, ← e.coe_coe] at H,
    exact H.comp_continuous_linear_map _ },
end
lemma continuous_linear_equiv.cont_diff_on_comp_iff (e : G ≃L[𝕜] E) :
  cont_diff_on 𝕜 n (f ∘ e) (e ⁻¹' s) ↔ cont_diff_on 𝕜 n f s :=
begin
  refine ⟨λ H, _, λ H, H.comp_continuous_linear_map (e : G →L[𝕜] E)⟩,
  have A : f = (f ∘ e) ∘ e.symm,
    by { ext y, simp only [function.comp_app], rw e.apply_symm_apply y },
  have B : e.symm ⁻¹' (e ⁻¹' s) = s,
    by { rw [← preimage_comp, e.self_comp_symm], refl },
  rw [A, ← B],
  exact H.comp_continuous_linear_map (e.symm : E →L[𝕜] G)
end
lemma has_ftaylor_series_up_to_on.prod (hf : has_ftaylor_series_up_to_on n f p s)
  {g : E → G} {q : E → formal_multilinear_series 𝕜 E G} (hg : has_ftaylor_series_up_to_on n g q s) :
  has_ftaylor_series_up_to_on n (λ y, (f y, g y)) (λ y k, (p y k).prod (q y k)) s :=
begin
  set L := λ m, continuous_multilinear_map.prodL 𝕜 (λ i : fin m, E) F G,
  split,
  { assume x hx, rw [← hf.zero_eq x hx, ← hg.zero_eq x hx], refl },
  { assume m hm x hx,
    convert (L m).has_fderiv_at.comp_has_fderiv_within_at x
      ((hf.fderiv_within m hm x hx).prod (hg.fderiv_within m hm x hx)) },
  { assume m hm,
    exact (L m).continuous.comp_continuous_on ((hf.cont m hm).prod (hg.cont m hm)) }
end
lemma cont_diff_within_at.prod {s : set E} {f : E → F} {g : E → G}
  (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) :
  cont_diff_within_at 𝕜 n (λx:E, (f x, g x)) s x :=
begin
  assume m hm,
  rcases hf m hm with ⟨u, hu, p, hp⟩,
  rcases hg m hm with ⟨v, hv, q, hq⟩,
  exact ⟨u ∩ v, filter.inter_mem hu hv, _,
        (hp.mono (inter_subset_left u v)).prod (hq.mono (inter_subset_right u v))⟩
end
lemma cont_diff_on.prod {s : set E} {f : E → F} {g : E → G}
  (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) :
  cont_diff_on 𝕜 n (λ x : E, (f x, g x)) s :=
λ x hx, (hf x hx).prod (hg x hx)
lemma cont_diff_at.prod {f : E → F} {g : E → G}
  (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) :
  cont_diff_at 𝕜 n (λ x : E, (f x, g x)) x :=
cont_diff_within_at_univ.1 $ cont_diff_within_at.prod
  (cont_diff_within_at_univ.2 hf)
  (cont_diff_within_at_univ.2 hg)
lemma cont_diff.prod {f : E → F} {g : E → G} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) :
  cont_diff 𝕜 n (λ x : E, (f x, g x)) :=
cont_diff_on_univ.1 $ cont_diff_on.prod (cont_diff_on_univ.2 hf)
  (cont_diff_on_univ.2 hg)
private lemma cont_diff_on.comp_same_univ
  {Eu : Type u} [normed_group Eu] [normed_space 𝕜 Eu]
  {Fu : Type u} [normed_group Fu] [normed_space 𝕜 Fu]
  {Gu : Type u} [normed_group Gu] [normed_space 𝕜 Gu]
  {s : set Eu} {t : set Fu} {g : Fu → Gu} {f : Eu → Fu}
  (hg : cont_diff_on 𝕜 n g t) (hf : cont_diff_on 𝕜 n f s) (st : s ⊆ f ⁻¹' t) :
  cont_diff_on 𝕜 n (g ∘ f) s :=
begin
  unfreezingI { induction n using with_top.nat_induction with n IH Itop generalizing Eu Fu Gu },
  { rw cont_diff_on_zero at hf hg ⊢,
    exact continuous_on.comp hg hf st },
  { rw cont_diff_on_succ_iff_has_fderiv_within_at at hg ⊢,
    assume x hx,
    rcases (cont_diff_on_succ_iff_has_fderiv_within_at.1 hf) x hx
      with ⟨u, hu, f', hf', f'_diff⟩,
    rcases hg (f x) (st hx) with ⟨v, hv, g', hg', g'_diff⟩,
    rw insert_eq_of_mem hx at hu ⊢,
    have xu : x ∈ u := mem_of_mem_nhds_within hx hu,
    let w := s ∩ (u ∩ f⁻¹' v),
    have wv : w ⊆ f ⁻¹' v := λ y hy, hy.2.2,
    have wu : w ⊆ u := λ y hy, hy.2.1,
    have ws : w ⊆ s := λ y hy, hy.1,
    refine ⟨w, _, λ y, (g' (f y)).comp (f' y), _, _⟩,
    show w ∈ 𝓝[s] x,
    { apply filter.inter_mem self_mem_nhds_within,
      apply filter.inter_mem hu,
      apply continuous_within_at.preimage_mem_nhds_within',
      { rw ← continuous_within_at_inter' hu,
        exact (hf' x xu).differentiable_within_at.continuous_within_at.mono
          (inter_subset_right _ _) },
      { apply nhds_within_mono _ _ hv,
        exact subset.trans (image_subset_iff.mpr st) (subset_insert (f x) t) } },
    show ∀ y ∈ w,
      has_fderiv_within_at (g ∘ f) ((g' (f y)).comp (f' y)) w y,
    { rintros y ⟨ys, yu, yv⟩,
      exact (hg' (f y) yv).comp y ((hf' y yu).mono wu) wv },
    show cont_diff_on 𝕜 n (λ y, (g' (f y)).comp (f' y)) w,
    { have A : cont_diff_on 𝕜 n (λ y, g' (f y)) w :=
        IH g'_diff ((hf.of_le (with_top.coe_le_coe.2 (nat.le_succ n))).mono ws) wv,
      have B : cont_diff_on 𝕜 n f' w := f'_diff.mono wu,
      have C : cont_diff_on 𝕜 n (λ y, (g' (f y), f' y)) w := A.prod B,
      have D : cont_diff_on 𝕜 n (λ p : (Fu →L[𝕜] Gu) × (Eu →L[𝕜] Fu), p.1.comp p.2) univ :=
        is_bounded_bilinear_map_comp.cont_diff.cont_diff_on,
      exact IH D C (subset_univ _) } },
  { rw cont_diff_on_top at hf hg ⊢,
    exact λ n, Itop n (hg n) (hf n) st }
end
lemma cont_diff_on.comp
  {s : set E} {t : set F} {g : F → G} {f : E → F}
  (hg : cont_diff_on 𝕜 n g t) (hf : cont_diff_on 𝕜 n f s) (st : s ⊆ f ⁻¹' t) :
  cont_diff_on 𝕜 n (g ∘ f) s :=
begin
  let Eu := continuous_multilinear_map 𝕜 (λ (i : fin 0), (E × F × G)) E,
  letI : normed_group Eu := by apply_instance,
  letI : normed_space 𝕜 Eu := by apply_instance,
  let Fu := continuous_multilinear_map 𝕜 (λ (i : fin 0), (E × F × G)) F,
  letI : normed_group Fu := by apply_instance,
  letI : normed_space 𝕜 Fu := by apply_instance,
  let Gu := continuous_multilinear_map 𝕜 (λ (i : fin 0), (E × F × G)) G,
  letI : normed_group Gu := by apply_instance,
  letI : normed_space 𝕜 Gu := by apply_instance,
lemma cont_diff_on.comp'
  {s : set E} {t : set F} {g : F → G} {f : E → F}
  (hg : cont_diff_on 𝕜 n g t) (hf : cont_diff_on 𝕜 n f s) :
  cont_diff_on 𝕜 n (g ∘ f) (s ∩ f⁻¹' t) :=
hg.comp (hf.mono (inter_subset_left _ _)) (inter_subset_right _ _)
lemma cont_diff.comp_cont_diff_on {s : set E} {g : F → G} {f : E → F}
  (hg : cont_diff 𝕜 n g) (hf : cont_diff_on 𝕜 n f s) :
  cont_diff_on 𝕜 n (g ∘ f) s :=
(cont_diff_on_univ.2 hg).comp hf subset_preimage_univ
lemma cont_diff.comp {g : F → G} {f : E → F}
  (hg : cont_diff 𝕜 n g) (hf : cont_diff 𝕜 n f) :
  cont_diff 𝕜 n (g ∘ f) :=
cont_diff_on_univ.1 $ cont_diff_on.comp (cont_diff_on_univ.2 hg)
  (cont_diff_on_univ.2 hf) (subset_univ _)
lemma cont_diff_within_at.comp
  {s : set E} {t : set F} {g : F → G} {f : E → F} (x : E)
  (hg : cont_diff_within_at 𝕜 n g t (f x))
  (hf : cont_diff_within_at 𝕜 n f s x) (st : s ⊆ f ⁻¹' t) :
  cont_diff_within_at 𝕜 n (g ∘ f) s x :=
begin
  assume m hm,
  rcases hg.cont_diff_on hm with ⟨u, u_nhd, ut, hu⟩,
  rcases hf.cont_diff_on hm with ⟨v, v_nhd, vs, hv⟩,
  have xmem : x ∈ f ⁻¹' u ∩ v :=
    ⟨(mem_of_mem_nhds_within (mem_insert (f x) _) u_nhd : _),
    mem_of_mem_nhds_within (mem_insert x s) v_nhd⟩,
  have : f ⁻¹' u ∈ 𝓝[insert x s] x,
  { apply hf.continuous_within_at.insert_self.preimage_mem_nhds_within',
    apply nhds_within_mono _ _ u_nhd,
    rw image_insert_eq,
    exact insert_subset_insert (image_subset_iff.mpr st) },
  have Z := ((hu.comp (hv.mono (inter_subset_right (f ⁻¹' u) v)) (inter_subset_left _ _))
    .cont_diff_within_at) xmem m le_rfl,
  have : 𝓝[f ⁻¹' u ∩ v] x = 𝓝[insert x s] x,
  { have A : f ⁻¹' u ∩ v = (insert x s) ∩ (f ⁻¹' u ∩ v),
    { apply subset.antisymm _ (inter_subset_right _ _),
      rintros y ⟨hy1, hy2⟩,
      simp [hy1, hy2, vs hy2] },
    rw [A, ← nhds_within_restrict''],
    exact filter.inter_mem this v_nhd },
  rwa [insert_eq_of_mem xmem, this] at Z,
end
lemma cont_diff_within_at.comp' {s : set E} {t : set F} {g : F → G}
  {f : E → F} (x : E)
  (hg : cont_diff_within_at 𝕜 n g t (f x)) (hf : cont_diff_within_at 𝕜 n f s x) :
  cont_diff_within_at 𝕜 n (g ∘ f) (s ∩ f⁻¹' t) x :=
hg.comp x (hf.mono (inter_subset_left _ _)) (inter_subset_right _ _)
lemma cont_diff_at.comp_cont_diff_within_at {n} (x : E)
  (hg : cont_diff_at 𝕜 n g (f x)) (hf : cont_diff_within_at 𝕜 n f s x) :
  cont_diff_within_at 𝕜 n (g ∘ f) s x :=
hg.comp x hf (maps_to_univ _ _)
lemma cont_diff_at.comp (x : E)
  (hg : cont_diff_at 𝕜 n g (f x))
  (hf : cont_diff_at 𝕜 n f x) :
  cont_diff_at 𝕜 n (g ∘ f) x :=
hg.comp x hf subset_preimage_univ
lemma cont_diff.comp_cont_diff_within_at
  {g : F → G} {f : E → F} (h : cont_diff 𝕜 n g)
  (hf : cont_diff_within_at 𝕜 n f t x) :
  cont_diff_within_at 𝕜 n (g ∘ f) t x :=
begin
  have : cont_diff_within_at 𝕜 n g univ (f x) :=
    h.cont_diff_at.cont_diff_within_at,
  exact this.comp x hf (subset_univ _),
end
lemma cont_diff.comp_cont_diff_at {g : F → G} {f : E → F} (x : E)
  (hg : cont_diff 𝕜 n g) (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (g ∘ f) x :=
hg.comp_cont_diff_within_at hf
lemma cont_diff_fst : cont_diff 𝕜 n (prod.fst : E × F → E) :=
is_bounded_linear_map.cont_diff is_bounded_linear_map.fst
lemma cont_diff.fst {f : E → F × G} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ x, (f x).1) :=
cont_diff_fst.comp hf
lemma cont_diff.fst' {f : E → G} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ x : E × F, f x.1) :=
hf.comp cont_diff_fst
lemma cont_diff_on_fst {s : set (E × F)} : cont_diff_on 𝕜 n (prod.fst : E × F → E) s :=
cont_diff.cont_diff_on cont_diff_fst
lemma cont_diff_on.fst {f : E → F × G} {s : set E} (hf : cont_diff_on 𝕜 n f s) :
  cont_diff_on 𝕜 n (λ x, (f x).1) s :=
cont_diff_fst.comp_cont_diff_on hf
lemma cont_diff_at_fst {p : E × F} : cont_diff_at 𝕜 n (prod.fst : E × F → E) p :=
cont_diff_fst.cont_diff_at
lemma cont_diff_at.fst {f : E → F × G} {x : E} (hf : cont_diff_at 𝕜 n f x) :
  cont_diff_at 𝕜 n (λ x, (f x).1) x :=
cont_diff_at_fst.comp x hf
lemma cont_diff_at.fst' {f : E → G} {x : E} {y : F} (hf : cont_diff_at 𝕜 n f x) :
  cont_diff_at 𝕜 n (λ x : E × F, f x.1) (x, y) :=
cont_diff_at.comp (x, y) hf cont_diff_at_fst
lemma cont_diff_at.fst'' {f : E → G} {x : E × F} (hf : cont_diff_at 𝕜 n f x.1) :
  cont_diff_at 𝕜 n (λ x : E × F, f x.1) x :=
hf.comp x cont_diff_at_fst
lemma cont_diff_within_at_fst {s : set (E × F)} {p : E × F} :
  cont_diff_within_at 𝕜 n (prod.fst : E × F → E) s p :=
cont_diff_fst.cont_diff_within_at
lemma cont_diff_snd : cont_diff 𝕜 n (prod.snd : E × F → F) :=
is_bounded_linear_map.cont_diff is_bounded_linear_map.snd
lemma cont_diff.snd {f : E → F × G} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ x, (f x).2) :=
cont_diff_snd.comp hf
lemma cont_diff.snd' {f : F → G} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λ x : E × F, f x.2) :=
hf.comp cont_diff_snd
lemma cont_diff_on_snd {s : set (E × F)} : cont_diff_on 𝕜 n (prod.snd : E × F → F) s :=
cont_diff.cont_diff_on cont_diff_snd
lemma cont_diff_on.snd {f : E → F × G} {s : set E} (hf : cont_diff_on 𝕜 n f s) :
  cont_diff_on 𝕜 n (λ x, (f x).2) s :=
cont_diff_snd.comp_cont_diff_on hf
lemma cont_diff_at_snd {p : E × F} : cont_diff_at 𝕜 n (prod.snd : E × F → F) p :=
cont_diff_snd.cont_diff_at
lemma cont_diff_at.snd {f : E → F × G} {x : E} (hf : cont_diff_at 𝕜 n f x) :
  cont_diff_at 𝕜 n (λ x, (f x).2) x :=
cont_diff_at_snd.comp x hf
lemma cont_diff_at.snd' {f : F → G} {x : E} {y : F} (hf : cont_diff_at 𝕜 n f y) :
  cont_diff_at 𝕜 n (λ x : E × F, f x.2) (x, y) :=
cont_diff_at.comp (x, y) hf cont_diff_at_snd
lemma cont_diff_at.snd'' {f : F → G} {x : E × F} (hf : cont_diff_at 𝕜 n f x.2) :
  cont_diff_at 𝕜 n (λ x : E × F, f x.2) x :=
hf.comp x cont_diff_at_snd
lemma cont_diff_within_at_snd {s : set (E × F)} {p : E × F} :
  cont_diff_within_at 𝕜 n (prod.snd : E × F → F) s p :=
cont_diff_snd.cont_diff_within_at
section n_ary
variables {E₁ E₂ E₃ E₄ : Type*}
variables [normed_group E₁] [normed_group E₂] [normed_group E₃] [normed_group E₄]
variables [normed_space 𝕜 E₁] [normed_space 𝕜 E₂] [normed_space 𝕜 E₃] [normed_space 𝕜 E₄]
lemma cont_diff.comp₂ {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂}
  (hg : cont_diff 𝕜 n g) (hf₁ : cont_diff 𝕜 n f₁) (hf₂ : cont_diff 𝕜 n f₂) :
  cont_diff 𝕜 n (λ x, g (f₁ x, f₂ x)) :=
hg.comp $ hf₁.prod hf₂
lemma cont_diff.comp₃ {g : E₁ × E₂ × E₃ → G} {f₁ : F → E₁} {f₂ : F → E₂} {f₃ : F → E₃}
  (hg : cont_diff 𝕜 n g) (hf₁ : cont_diff 𝕜 n f₁) (hf₂ : cont_diff 𝕜 n f₂)
  (hf₃ : cont_diff 𝕜 n f₃) : cont_diff 𝕜 n (λ x, g (f₁ x, f₂ x, f₃ x)) :=
hg.comp₂ hf₁ $ hf₂.prod hf₃
lemma cont_diff.comp_cont_diff_on₂ {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂} {s : set F}
  (hg : cont_diff 𝕜 n g) (hf₁ : cont_diff_on 𝕜 n f₁ s) (hf₂ : cont_diff_on 𝕜 n f₂ s) :
  cont_diff_on 𝕜 n (λ x, g (f₁ x, f₂ x)) s :=
hg.comp_cont_diff_on $ hf₁.prod hf₂
lemma cont_diff.comp_cont_diff_on₃ {g : E₁ × E₂ × E₃ → G} {f₁ : F → E₁} {f₂ : F → E₂} {f₃ : F → E₃}
  {s : set F} (hg : cont_diff 𝕜 n g) (hf₁ : cont_diff_on 𝕜 n f₁ s) (hf₂ : cont_diff_on 𝕜 n f₂ s)
  (hf₃ : cont_diff_on 𝕜 n f₃ s) : cont_diff_on 𝕜 n (λ x, g (f₁ x, f₂ x, f₃ x)) s :=
hg.comp_cont_diff_on₂ hf₁ $ hf₂.prod hf₃
end n_ary
lemma cont_diff_prod_assoc : cont_diff 𝕜 ⊤ $ equiv.prod_assoc E F G :=
(linear_isometry_equiv.prod_assoc 𝕜 E F G).cont_diff
lemma cont_diff_prod_assoc_symm : cont_diff 𝕜 ⊤ $ (equiv.prod_assoc E F G).symm :=
(linear_isometry_equiv.prod_assoc 𝕜 E F G).symm.cont_diff
lemma cont_diff_on_fderiv_within_apply {m n : with_top  ℕ} {s : set E}
  {f : E → F} (hf : cont_diff_on 𝕜 n f s) (hs : unique_diff_on 𝕜 s) (hmn : m + 1 ≤ n) :
  cont_diff_on 𝕜 m (λp : E × E, (fderiv_within 𝕜 f s p.1 : E →L[𝕜] F) p.2)
  (s ×ˢ (univ : set E)) :=
begin
  have A : cont_diff 𝕜 m (λp : (E →L[𝕜] F) × E, p.1 p.2),
  { apply is_bounded_bilinear_map.cont_diff,
    exact is_bounded_bilinear_map_apply },
  have B : cont_diff_on 𝕜 m
    (λ (p : E × E), ((fderiv_within 𝕜 f s p.fst), p.snd)) (s ×ˢ univ),
  { apply cont_diff_on.prod _ _,
    { have I : cont_diff_on 𝕜 m (λ (x : E), fderiv_within 𝕜 f s x) s :=
        hf.fderiv_within hs hmn,
      have J : cont_diff_on 𝕜 m (λ (x : E × E), x.1) (s ×ˢ univ) :=
        cont_diff_fst.cont_diff_on,
      exact cont_diff_on.comp I J (prod_subset_preimage_fst _ _) },
    { apply cont_diff.cont_diff_on _ ,
      apply is_bounded_linear_map.snd.cont_diff } },
  exact A.comp_cont_diff_on B
end
lemma cont_diff.cont_diff_fderiv_apply {f : E → F}
  (hf : cont_diff 𝕜 n f) (hmn : m + 1 ≤ n) :
  cont_diff 𝕜 m (λp : E × E, (fderiv 𝕜 f p.1 : E →L[𝕜] F) p.2) :=
begin
  rw ← cont_diff_on_univ at ⊢ hf,
  rw [← fderiv_within_univ, ← univ_prod_univ],
  exact cont_diff_on_fderiv_within_apply hf unique_diff_on_univ hmn
end
section pi
variables {ι ι' : Type*} [fintype ι] [fintype ι'] {F' : ι → Type*} [Π i, normed_group (F' i)]
  [Π i, normed_space 𝕜 (F' i)] {φ : Π i, E → F' i}
  {p' : Π i, E → formal_multilinear_series 𝕜 E (F' i)}
  {Φ : E → Π i, F' i} {P' : E → formal_multilinear_series 𝕜 E (Π i, F' i)}
lemma has_ftaylor_series_up_to_on_pi :
  has_ftaylor_series_up_to_on n (λ x i, φ i x)
    (λ x m, continuous_multilinear_map.pi (λ i, p' i x m)) s ↔
    ∀ i, has_ftaylor_series_up_to_on n (φ i) (p' i) s :=
begin
  set pr := @continuous_linear_map.proj 𝕜 _ ι F' _ _ _,
  letI : Π (m : ℕ) (i : ι), normed_space 𝕜 (E [×m]→L[𝕜] (F' i)) := λ m i, infer_instance,
  set L : Π m : ℕ, (Π i, E [×m]→L[𝕜] (F' i)) ≃ₗᵢ[𝕜] (E [×m]→L[𝕜] (Π i, F' i)) :=
    λ m, continuous_multilinear_map.piₗᵢ _ _,
  refine ⟨λ h i, _, λ h, ⟨λ x hx, _, _, _⟩⟩,
  { convert h.continuous_linear_map_comp (pr i),
    ext, refl },
  { ext1 i,
    exact (h i).zero_eq x hx },
  { intros m hm x hx,
    have := has_fderiv_within_at_pi.2 (λ i, (h i).fderiv_within m hm x hx),
    convert (L m).has_fderiv_at.comp_has_fderiv_within_at x this },
  { intros m hm,
    have := continuous_on_pi.2 (λ i, (h i).cont m hm),
    convert (L m).continuous.comp_continuous_on this }
end
@[simp] lemma has_ftaylor_series_up_to_on_pi' :
  has_ftaylor_series_up_to_on n Φ P' s ↔
    ∀ i, has_ftaylor_series_up_to_on n (λ x, Φ x i)
      (λ x m, (@continuous_linear_map.proj 𝕜 _ ι F' _ _ _ i).comp_continuous_multilinear_map
        (P' x m)) s :=
by { convert has_ftaylor_series_up_to_on_pi, ext, refl }
lemma cont_diff_within_at_pi :
  cont_diff_within_at 𝕜 n Φ s x ↔
    ∀ i, cont_diff_within_at 𝕜 n (λ x, Φ x i) s x :=
begin
  set pr := @continuous_linear_map.proj 𝕜 _ ι F' _ _ _,
  refine ⟨λ h i, h.continuous_linear_map_comp (pr i), λ h m hm, _⟩,
  choose u hux p hp using λ i, h i m hm,
  exact ⟨⋂ i, u i, filter.Inter_mem.2 hux, _,
    has_ftaylor_series_up_to_on_pi.2 (λ i, (hp i).mono $ Inter_subset _ _)⟩,
end
lemma cont_diff_on_pi :
  cont_diff_on 𝕜 n Φ s ↔ ∀ i, cont_diff_on 𝕜 n (λ x, Φ x i) s :=
⟨λ h i x hx, cont_diff_within_at_pi.1 (h x hx) _,
  λ h x hx, cont_diff_within_at_pi.2 (λ i, h i x hx)⟩
lemma cont_diff_at_pi :
  cont_diff_at 𝕜 n Φ x ↔ ∀ i, cont_diff_at 𝕜 n (λ x, Φ x i) x :=
cont_diff_within_at_pi
lemma cont_diff_pi :
  cont_diff 𝕜 n Φ ↔ ∀ i, cont_diff 𝕜 n (λ x, Φ x i) :=
by simp only [← cont_diff_on_univ, cont_diff_on_pi]
variables (𝕜 E)
lemma cont_diff_apply (i : ι) : cont_diff 𝕜 n (λ (f : ι → E), f i) :=
cont_diff_pi.mp cont_diff_id i
lemma cont_diff_apply_apply (i : ι) (j : ι') : cont_diff 𝕜 n (λ (f : ι → ι' → E), f i j) :=
cont_diff_pi.mp (cont_diff_apply 𝕜 (ι' → E) i) j
variables {𝕜 E}
end pi
lemma cont_diff_add : cont_diff 𝕜 n (λp : F × F, p.1 + p.2) :=
(is_bounded_linear_map.fst.add is_bounded_linear_map.snd).cont_diff
lemma cont_diff_within_at.add {s : set E} {f g : E → F}
  (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) :
  cont_diff_within_at 𝕜 n (λx, f x + g x) s x :=
cont_diff_add.cont_diff_within_at.comp x (hf.prod hg) subset_preimage_univ
lemma cont_diff_at.add {f g : E → F} (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) :
  cont_diff_at 𝕜 n (λx, f x + g x) x :=
by rw [← cont_diff_within_at_univ] at *; exact hf.add hg
lemma cont_diff.add {f g : E → F} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) :
  cont_diff 𝕜 n (λx, f x + g x) :=
cont_diff_add.comp (hf.prod hg)
lemma cont_diff_on.add {s : set E} {f g : E → F}
  (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) :
  cont_diff_on 𝕜 n (λx, f x + g x) s :=
λ x hx, (hf x hx).add (hg x hx)
lemma cont_diff_neg : cont_diff 𝕜 n (λp : F, -p) :=
is_bounded_linear_map.id.neg.cont_diff
lemma cont_diff_within_at.neg {s : set E} {f : E → F}
  (hf : cont_diff_within_at 𝕜 n f s x) : cont_diff_within_at 𝕜 n (λx, -f x) s x :=
cont_diff_neg.cont_diff_within_at.comp x hf subset_preimage_univ
lemma cont_diff_at.neg {f : E → F}
  (hf : cont_diff_at 𝕜 n f x) : cont_diff_at 𝕜 n (λx, -f x) x :=
by rw ← cont_diff_within_at_univ at *; exact hf.neg
lemma cont_diff.neg {f : E → F} (hf : cont_diff 𝕜 n f) : cont_diff 𝕜 n (λx, -f x) :=
cont_diff_neg.comp hf
lemma cont_diff_on.neg {s : set E} {f : E → F}
  (hf : cont_diff_on 𝕜 n f s) : cont_diff_on 𝕜 n (λx, -f x) s :=
λ x hx, (hf x hx).neg
lemma cont_diff_within_at.sub {s : set E} {f g : E → F}
  (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) :
  cont_diff_within_at 𝕜 n (λx, f x - g x) s x :=
by simpa only [sub_eq_add_neg] using hf.add hg.neg
lemma cont_diff_at.sub {f g : E → F}
  (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) :
  cont_diff_at 𝕜 n (λx, f x - g x) x :=
by simpa only [sub_eq_add_neg] using hf.add hg.neg
lemma cont_diff_on.sub {s : set E} {f g : E → F}
  (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) :
  cont_diff_on 𝕜 n (λx, f x - g x) s :=
by simpa only [sub_eq_add_neg] using hf.add hg.neg
lemma cont_diff.sub {f g : E → F}
  (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) : cont_diff 𝕜 n (λx, f x - g x) :=
by simpa only [sub_eq_add_neg] using hf.add hg.neg
lemma cont_diff_within_at.sum
  {ι : Type*} {f : ι → E → F} {s : finset ι} {t : set E} {x : E}
  (h : ∀ i ∈ s, cont_diff_within_at 𝕜 n (λ x, f i x) t x) :
  cont_diff_within_at 𝕜 n (λ x, (∑ i in s, f i x)) t x :=
begin
  classical,
  induction s using finset.induction_on with i s is IH,
  { simp [cont_diff_within_at_const] },
  { simp only [is, finset.sum_insert, not_false_iff],
    exact (h _ (finset.mem_insert_self i s)).add (IH (λ j hj, h _ (finset.mem_insert_of_mem hj))) }
end
lemma cont_diff_at.sum
  {ι : Type*} {f : ι → E → F} {s : finset ι} {x : E}
  (h : ∀ i ∈ s, cont_diff_at 𝕜 n (λ x, f i x) x) :
  cont_diff_at 𝕜 n (λ x, (∑ i in s, f i x)) x :=
by rw [← cont_diff_within_at_univ] at *; exact cont_diff_within_at.sum h
lemma cont_diff_on.sum
  {ι : Type*} {f : ι → E → F} {s : finset ι} {t : set E}
  (h : ∀ i ∈ s, cont_diff_on 𝕜 n (λ x, f i x) t) :
  cont_diff_on 𝕜 n (λ x, (∑ i in s, f i x)) t :=
λ x hx, cont_diff_within_at.sum (λ i hi, h i hi x hx)
lemma cont_diff.sum
  {ι : Type*} {f : ι → E → F} {s : finset ι}
  (h : ∀ i ∈ s, cont_diff 𝕜 n (λ x, f i x)) :
  cont_diff 𝕜 n (λ x, (∑ i in s, f i x)) :=
by simp [← cont_diff_on_univ] at *; exact cont_diff_on.sum h
lemma cont_diff_mul : cont_diff 𝕜 n (λ p : 𝕜 × 𝕜, p.1 * p.2) :=
is_bounded_bilinear_map_mul.cont_diff
lemma cont_diff_within_at.mul {s : set E} {f g : E → 𝕜}
  (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) :
  cont_diff_within_at 𝕜 n (λ x, f x * g x) s x :=
cont_diff_mul.cont_diff_within_at.comp x (hf.prod hg) subset_preimage_univ
lemma cont_diff_at.mul {f g : E → 𝕜}
  (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) :
  cont_diff_at 𝕜 n (λ x, f x * g x) x :=
by rw [← cont_diff_within_at_univ] at *; exact hf.mul hg
lemma cont_diff_on.mul {s : set E} {f g : E → 𝕜}
  (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) :
  cont_diff_on 𝕜 n (λ x, f x * g x) s :=
λ x hx, (hf x hx).mul (hg x hx)
lemma cont_diff.mul {f g : E → 𝕜} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) :
  cont_diff 𝕜 n (λ x, f x * g x) :=
cont_diff_mul.comp (hf.prod hg)
lemma cont_diff_within_at.div_const {f : E → 𝕜} {n} {c : 𝕜}
  (hf : cont_diff_within_at 𝕜 n f s x) :
  cont_diff_within_at 𝕜 n (λ x, f x / c) s x :=
by simpa only [div_eq_mul_inv] using hf.mul cont_diff_within_at_const
lemma cont_diff_at.div_const {f : E → 𝕜} {n} {c : 𝕜} (hf : cont_diff_at 𝕜 n f x) :
  cont_diff_at 𝕜 n (λ x, f x / c) x :=
by simpa only [div_eq_mul_inv] using hf.mul cont_diff_at_const
lemma cont_diff_on.div_const {f : E → 𝕜} {n} {c : 𝕜} (hf : cont_diff_on 𝕜 n f s) :
  cont_diff_on 𝕜 n (λ x, f x / c) s :=
by simpa only [div_eq_mul_inv] using hf.mul cont_diff_on_const
lemma cont_diff.div_const {f : E → 𝕜} {n} {c : 𝕜} (hf : cont_diff 𝕜 n f) :
  cont_diff 𝕜 n (λ x, f x / c) :=
by simpa only [div_eq_mul_inv] using hf.mul cont_diff_const
lemma cont_diff.pow {f : E → 𝕜}
  (hf : cont_diff 𝕜 n f) :
  ∀ m : ℕ, cont_diff 𝕜 n (λ x, (f x) ^ m)
| 0       := by simpa using cont_diff_const
| (m + 1) := by simpa [pow_succ] using hf.mul (cont_diff.pow m)
lemma cont_diff_at.pow {f : E → 𝕜} (hf : cont_diff_at 𝕜 n f x)
  (m : ℕ) : cont_diff_at 𝕜 n (λ y, f y ^ m) x :=
(cont_diff_id.pow m).cont_diff_at.comp x hf
lemma cont_diff_within_at.pow {f : E → 𝕜}
  (hf : cont_diff_within_at 𝕜 n f s x) (m : ℕ) :
  cont_diff_within_at 𝕜 n (λ y, f y ^ m) s x :=
(cont_diff_id.pow m).cont_diff_at.comp_cont_diff_within_at x hf
lemma cont_diff_on.pow {f : E → 𝕜}
  (hf : cont_diff_on 𝕜 n f s) (m : ℕ) :
  cont_diff_on 𝕜 n (λ y, f y ^ m) s :=
λ y hy, (hf y hy).pow m
lemma cont_diff_smul : cont_diff 𝕜 n (λ p : 𝕜 × F, p.1 • p.2) :=
is_bounded_bilinear_map_smul.cont_diff
lemma cont_diff_within_at.smul {s : set E} {f : E → 𝕜} {g : E → F}
  (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g s x) :
  cont_diff_within_at 𝕜 n (λ x, f x • g x) s x :=
cont_diff_smul.cont_diff_within_at.comp x (hf.prod hg) subset_preimage_univ
lemma cont_diff_at.smul {f : E → 𝕜} {g : E → F}
  (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g x) :
  cont_diff_at 𝕜 n (λ x, f x • g x) x :=
by rw [← cont_diff_within_at_univ] at *; exact hf.smul hg
lemma cont_diff.smul {f : E → 𝕜} {g : E → F} (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) :
  cont_diff 𝕜 n (λ x, f x • g x) :=
cont_diff_smul.comp (hf.prod hg)
lemma cont_diff_on.smul {s : set E} {f : E → 𝕜} {g : E → F}
  (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g s) :
  cont_diff_on 𝕜 n (λ x, f x • g x) s :=
λ x hx, (hf x hx).smul (hg x hx)
section prod_map
variables {E' : Type*} [normed_group E'] [normed_space 𝕜 E']
variables {F' : Type*} [normed_group F'] [normed_space 𝕜 F']
lemma cont_diff_within_at.prod_map'
  {s : set E} {t : set E'} {f : E → F} {g : E' → F'} {p : E × E'}
  (hf : cont_diff_within_at 𝕜 n f s p.1) (hg : cont_diff_within_at 𝕜 n g t p.2) :
  cont_diff_within_at 𝕜 n (prod.map f g) (s ×ˢ t) p :=
(hf.comp p cont_diff_within_at_fst (prod_subset_preimage_fst _ _)).prod
  (hg.comp p cont_diff_within_at_snd (prod_subset_preimage_snd _ _))
lemma cont_diff_within_at.prod_map
  {s : set E} {t : set E'} {f : E → F} {g : E' → F'} {x : E} {y : E'}
  (hf : cont_diff_within_at 𝕜 n f s x) (hg : cont_diff_within_at 𝕜 n g t y) :
  cont_diff_within_at 𝕜 n (prod.map f g) (s ×ˢ t) (x, y) :=
cont_diff_within_at.prod_map' hf hg
lemma cont_diff_on.prod_map {E' : Type*} [normed_group E'] [normed_space 𝕜 E']
  {F' : Type*} [normed_group F'] [normed_space 𝕜 F']
  {s : set E} {t : set E'} {f : E → F} {g : E' → F'}
  (hf : cont_diff_on 𝕜 n f s) (hg : cont_diff_on 𝕜 n g t) :
  cont_diff_on 𝕜 n (prod.map f g) (s ×ˢ t) :=
(hf.comp cont_diff_on_fst (prod_subset_preimage_fst _ _)).prod
  (hg.comp (cont_diff_on_snd) (prod_subset_preimage_snd _ _))
lemma cont_diff_at.prod_map {f : E → F} {g : E' → F'} {x : E} {y : E'}
  (hf : cont_diff_at 𝕜 n f x) (hg : cont_diff_at 𝕜 n g y) :
  cont_diff_at 𝕜 n (prod.map f g) (x, y) :=
begin
  rw cont_diff_at at *,
  convert hf.prod_map hg,
  simp only [univ_prod_univ]
end
lemma cont_diff_at.prod_map' {f : E → F} {g : E' → F'} {p : E × E'}
  (hf : cont_diff_at 𝕜 n f p.1) (hg : cont_diff_at 𝕜 n g p.2) :
  cont_diff_at 𝕜 n (prod.map f g) p :=
begin
  rcases p,
  exact cont_diff_at.prod_map hf hg
end
lemma cont_diff.prod_map {f : E → F} {g : E' → F'}
  (hf : cont_diff 𝕜 n f) (hg : cont_diff 𝕜 n g) :
  cont_diff 𝕜 n (prod.map f g) :=
begin
  rw cont_diff_iff_cont_diff_at at *,
  exact λ ⟨x, y⟩, (hf x).prod_map (hg y)
end
lemma cont_diff_prod_mk_left (f₀ : F) : cont_diff 𝕜 n (λ e : E, (e, f₀)) :=
cont_diff_id.prod cont_diff_const
lemma cont_diff_prod_mk_right (e₀ : E) : cont_diff 𝕜 n (λ f : F, (e₀, f)) :=
cont_diff_const.prod cont_diff_id
end prod_map
lemma cont_diff.clm_comp {g : X → F →L[𝕜] G} {f : X → E →L[𝕜] F}
  (hg : cont_diff 𝕜 n g) (hf : cont_diff 𝕜 n f) :
  cont_diff 𝕜 n (λ x, (g x).comp (f x)) :=
is_bounded_bilinear_map_comp.cont_diff.comp₂ hg hf
lemma cont_diff_on.clm_comp {g : X → F →L[𝕜] G} {f : X → E →L[𝕜] F}
  {s : set X} (hg : cont_diff_on 𝕜 n g s) (hf : cont_diff_on 𝕜 n f s) :
  cont_diff_on 𝕜 n (λ x, (g x).comp (f x)) s :=
is_bounded_bilinear_map_comp.cont_diff.comp_cont_diff_on₂ hg hf
section algebra_inverse
variables (𝕜) {R : Type*} [normed_ring R] [normed_algebra 𝕜 R]
open normed_ring continuous_linear_map ring
lemma cont_diff_at_ring_inverse [complete_space R] (x : Rˣ) :
  cont_diff_at 𝕜 n ring.inverse (x : R) :=
begin
  induction n using with_top.nat_induction with n IH Itop,
  { intros m hm,
    refine ⟨{y : R | is_unit y}, _, _⟩,
    { simp [nhds_within_univ],
      exact x.nhds },
    { use (ftaylor_series_within 𝕜 inverse univ),
      rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff],
      split,
      { rintros _ ⟨x', rfl⟩,
        exact (inverse_continuous_at x').continuous_within_at },
      { simp [ftaylor_series_within] } } },
  { apply cont_diff_at_succ_iff_has_fderiv_at.mpr,
    refine ⟨λ (x : R), - lmul_left_right 𝕜 R (inverse x) (inverse x), _, _⟩,
    { refine ⟨{y : R | is_unit y}, x.nhds, _⟩,
      rintros _ ⟨y, rfl⟩,
      rw [inverse_unit],
      exact has_fderiv_at_ring_inverse y },
    { convert (lmul_left_right_is_bounded_bilinear 𝕜 R).cont_diff.neg.comp_cont_diff_at
        (x : R) (IH.prod IH) } },
  { exact cont_diff_at_top.mpr Itop }
end
variables (𝕜) {𝕜' : Type*} [normed_field 𝕜'] [normed_algebra 𝕜 𝕜'] [complete_space 𝕜']
lemma cont_diff_at_inv {x : 𝕜'} (hx : x ≠ 0) {n} :
  cont_diff_at 𝕜 n has_inv.inv x :=
by simpa only [ring.inverse_eq_inv'] using cont_diff_at_ring_inverse 𝕜 (units.mk0 x hx)
lemma cont_diff_on_inv {n} : cont_diff_on 𝕜 n (has_inv.inv : 𝕜' → 𝕜') {0}ᶜ :=
λ x hx, (cont_diff_at_inv 𝕜 hx).cont_diff_within_at
variable {𝕜}
section map_inverse
open continuous_linear_map
lemma cont_diff_at_map_inverse [complete_space E] (e : E ≃L[𝕜] F) :
  cont_diff_at 𝕜 n inverse (e : E →L[𝕜] F) :=
begin
  nontriviality E,
theorem local_homeomorph.cont_diff_at_symm [complete_space E]
  (f : local_homeomorph E F) {f₀' : E ≃L[𝕜] F} {a : F} (ha : a ∈ f.target)
  (hf₀' : has_fderiv_at f (f₀' : E →L[𝕜] F) (f.symm a)) (hf : cont_diff_at 𝕜 n f (f.symm a)) :
  cont_diff_at 𝕜 n f.symm a :=
begin
theorem homeomorph.cont_diff_symm [complete_space E] (f : E ≃ₜ F) {f₀' : E → E ≃L[𝕜] F}
  (hf₀' : ∀ a, has_fderiv_at f (f₀' a : E →L[𝕜] F) a) (hf : cont_diff 𝕜 n (f : E → F)) :
  cont_diff 𝕜 n (f.symm : F → E) :=
cont_diff_iff_cont_diff_at.2 $ λ x,
  f.to_local_homeomorph.cont_diff_at_symm (mem_univ x) (hf₀' _) hf.cont_diff_at
theorem local_homeomorph.cont_diff_at_symm_deriv [complete_space 𝕜]
  (f : local_homeomorph 𝕜 𝕜) {f₀' a : 𝕜} (h₀ : f₀' ≠ 0) (ha : a ∈ f.target)
  (hf₀' : has_deriv_at f f₀' (f.symm a)) (hf : cont_diff_at 𝕜 n f (f.symm a)) :
  cont_diff_at 𝕜 n f.symm a :=
f.cont_diff_at_symm ha (hf₀'.has_fderiv_at_equiv h₀) hf
theorem homeomorph.cont_diff_symm_deriv [complete_space 𝕜] (f : 𝕜 ≃ₜ 𝕜) {f' : 𝕜 → 𝕜}
  (h₀ : ∀ x, f' x ≠ 0) (hf' : ∀ x, has_deriv_at f (f' x) x) (hf : cont_diff 𝕜 n (f : 𝕜 → 𝕜)) :
  cont_diff 𝕜 n (f.symm : 𝕜 → 𝕜) :=
cont_diff_iff_cont_diff_at.2 $ λ x,
  f.to_local_homeomorph.cont_diff_at_symm_deriv (h₀ _) (mem_univ x) (hf' _) hf.cont_diff_at
end function_inverse
section finite_dimensional
open function finite_dimensional
variables [complete_space 𝕜]
lemma cont_diff_on_clm_apply {n : with_top ℕ} {f : E → F →L[𝕜] G}
  {s : set E} [finite_dimensional 𝕜 F] :
  cont_diff_on 𝕜 n f s ↔ ∀ y, cont_diff_on 𝕜 n (λ x, f x y) s :=
begin
  refine ⟨λ h y, (continuous_linear_map.apply 𝕜 G y).cont_diff.comp_cont_diff_on h, λ h, _⟩,
  let d := finrank 𝕜 F,
  have hd : d = finrank 𝕜 (fin d → 𝕜) := (finrank_fin_fun 𝕜).symm,
  let e₁ := continuous_linear_equiv.of_finrank_eq hd,
  let e₂ := (e₁.arrow_congr (1 : G ≃L[𝕜] G)).trans (continuous_linear_equiv.pi_ring (fin d)),
  rw [← comp.left_id f, ← e₂.symm_comp_self],
  exact e₂.symm.cont_diff.comp_cont_diff_on (cont_diff_on_pi.mpr (λ i, h _))
end
lemma cont_diff_clm_apply {n : with_top ℕ} {f : E → F →L[𝕜] G} [finite_dimensional 𝕜 F] :
  cont_diff 𝕜 n f ↔ ∀ y, cont_diff 𝕜 n (λ x, f x y) :=
by simp_rw [← cont_diff_on_univ, cont_diff_on_clm_apply]
lemma cont_diff_succ_iff_fderiv_apply [finite_dimensional 𝕜 E] {n : ℕ} {f : E → F} :
  cont_diff 𝕜 ((n + 1) : ℕ) f ↔
  differentiable 𝕜 f ∧ ∀ y, cont_diff 𝕜 n (λ x, fderiv 𝕜 f x y) :=
by rw [cont_diff_succ_iff_fderiv, cont_diff_clm_apply]
lemma cont_diff_on_succ_of_fderiv_apply [finite_dimensional 𝕜 E] {n : ℕ} {f : E → F}
  {s : set E} (hf : differentiable_on 𝕜 f s)
  (h : ∀ y, cont_diff_on 𝕜 n (λ x, fderiv_within 𝕜 f s x y) s) :
  cont_diff_on 𝕜 ((n + 1) : ℕ) f s :=
cont_diff_on_succ_of_fderiv_within hf $ cont_diff_on_clm_apply.mpr h
lemma cont_diff_on_succ_iff_fderiv_apply [finite_dimensional 𝕜 E] {n : ℕ} {f : E → F}
  {s : set E} (hs : unique_diff_on 𝕜 s) : cont_diff_on 𝕜 ((n + 1) : ℕ) f s ↔
  differentiable_on 𝕜 f s ∧ ∀ y, cont_diff_on 𝕜 n (λ x, fderiv_within 𝕜 f s x y) s :=
by rw [cont_diff_on_succ_iff_fderiv_within hs, cont_diff_on_clm_apply]
end finite_dimensional
section real
variables
{𝕂 : Type*} [is_R_or_C 𝕂]
{E' : Type*} [normed_group E'] [normed_space 𝕂 E']
{F' : Type*} [normed_group F'] [normed_space 𝕂 F']
lemma has_ftaylor_series_up_to_on.has_strict_fderiv_at
  {s : set E'} {f : E' → F'} {x : E'} {p : E' → formal_multilinear_series 𝕂 E' F'}
  (hf : has_ftaylor_series_up_to_on n f p s) (hn : 1 ≤ n) (hs : s ∈ 𝓝 x) :
  has_strict_fderiv_at f ((continuous_multilinear_curry_fin1 𝕂 E' F') (p x 1)) x :=
has_strict_fderiv_at_of_has_fderiv_at_of_continuous_at (hf.eventually_has_fderiv_at hn hs) $
  (continuous_multilinear_curry_fin1 𝕂 E' F').continuous_at.comp $
    (hf.cont 1 hn).continuous_at hs
lemma cont_diff_at.has_strict_fderiv_at'
  {f : E' → F'} {f' : E' →L[𝕂] F'} {x : E'}
  (hf : cont_diff_at 𝕂 n f x) (hf' : has_fderiv_at f f' x) (hn : 1 ≤ n) :
  has_strict_fderiv_at f f' x :=
begin
  rcases hf 1 hn with ⟨u, H, p, hp⟩,
  simp only [nhds_within_univ, mem_univ, insert_eq_of_mem] at H,
  have := hp.has_strict_fderiv_at le_rfl H,
  rwa hf'.unique this.has_fderiv_at
end
lemma cont_diff_at.has_strict_deriv_at' {f : 𝕂 → F'} {f' : F'} {x : 𝕂}
  (hf : cont_diff_at 𝕂 n f x) (hf' : has_deriv_at f f' x) (hn : 1 ≤ n) :
  has_strict_deriv_at f f' x :=
hf.has_strict_fderiv_at' hf' hn
lemma cont_diff_at.has_strict_fderiv_at {f : E' → F'} {x : E'}
  (hf : cont_diff_at 𝕂 n f x) (hn : 1 ≤ n) :
  has_strict_fderiv_at f (fderiv 𝕂 f x) x :=
hf.has_strict_fderiv_at' (hf.differentiable_at hn).has_fderiv_at hn
lemma cont_diff_at.has_strict_deriv_at {f : 𝕂 → F'} {x : 𝕂}
  (hf : cont_diff_at 𝕂 n f x) (hn : 1 ≤ n) :
  has_strict_deriv_at f (deriv f x) x :=
(hf.has_strict_fderiv_at hn).has_strict_deriv_at
lemma cont_diff.has_strict_fderiv_at
  {f : E' → F'} {x : E'} (hf : cont_diff 𝕂 n f) (hn : 1 ≤ n) :
  has_strict_fderiv_at f (fderiv 𝕂 f x) x :=
hf.cont_diff_at.has_strict_fderiv_at hn
lemma cont_diff.has_strict_deriv_at
  {f : 𝕂 → F'} {x : 𝕂} (hf : cont_diff 𝕂 n f) (hn : 1 ≤ n) :
  has_strict_deriv_at f (deriv f x) x :=
hf.cont_diff_at.has_strict_deriv_at hn
lemma has_ftaylor_series_up_to_on.exists_lipschitz_on_with_of_nnnorm_lt {E F : Type*}
  [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {f : E → F}
  {p : E → formal_multilinear_series ℝ E F} {s : set E} {x : E}
  (hf : has_ftaylor_series_up_to_on 1 f p (insert x s)) (hs : convex ℝ s) (K : ℝ≥0)
  (hK : ∥p x 1∥₊ < K) :
  ∃ t ∈ 𝓝[s] x, lipschitz_on_with K f t :=
begin
  set f' := λ y, continuous_multilinear_curry_fin1 ℝ E F (p y 1),
  have hder : ∀ y ∈ s, has_fderiv_within_at f (f' y) s y,
    from λ y hy, (hf.has_fderiv_within_at le_rfl (subset_insert x s hy)).mono (subset_insert x s),
  have hcont : continuous_within_at f' s x,
    from (continuous_multilinear_curry_fin1 ℝ E F).continuous_at.comp_continuous_within_at
      ((hf.cont _ le_rfl _ (mem_insert _ _)).mono (subset_insert x s)),
  replace hK : ∥f' x∥₊ < K, by simpa only [linear_isometry_equiv.nnnorm_map],
  exact hs.exists_nhds_within_lipschitz_on_with_of_has_fderiv_within_at_of_nnnorm_lt
    (eventually_nhds_within_iff.2 $ eventually_of_forall hder) hcont K hK
end
lemma has_ftaylor_series_up_to_on.exists_lipschitz_on_with {E F : Type*}
  [normed_group E] [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {f : E → F}
  {p : E → formal_multilinear_series ℝ E F} {s : set E} {x : E}
  (hf : has_ftaylor_series_up_to_on 1 f p (insert x s)) (hs : convex ℝ s) :
  ∃ K (t ∈ 𝓝[s] x), lipschitz_on_with K f t :=
(exists_gt _).imp $ hf.exists_lipschitz_on_with_of_nnnorm_lt hs
lemma cont_diff_within_at.exists_lipschitz_on_with {E F : Type*} [normed_group E]
  [normed_space ℝ E] [normed_group F] [normed_space ℝ F] {f : E → F} {s : set E}
  {x : E} (hf : cont_diff_within_at ℝ 1 f s x) (hs : convex ℝ s) :
  ∃ (K : ℝ≥0) (t ∈ 𝓝[s] x), lipschitz_on_with K f t :=
begin
  rcases hf 1 le_rfl with ⟨t, hst, p, hp⟩,
  rcases metric.mem_nhds_within_iff.mp hst with ⟨ε, ε0, hε⟩,
  replace hp : has_ftaylor_series_up_to_on 1 f p (metric.ball x ε ∩ insert x s) := hp.mono hε,
  clear hst hε t,
  rw [← insert_eq_of_mem (metric.mem_ball_self ε0), ← insert_inter_distrib] at hp,
  rcases hp.exists_lipschitz_on_with ((convex_ball _ _).inter hs) with ⟨K, t, hst, hft⟩,
  rw [inter_comm, ← nhds_within_restrict' _ (metric.ball_mem_nhds _ ε0)] at hst,
  exact ⟨K, t, hst, hft⟩
end
lemma cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt {f : E' → F'} {x : E'}
  (hf : cont_diff_at 𝕂 1 f x) (K : ℝ≥0) (hK : ∥fderiv 𝕂 f x∥₊ < K) :
  ∃ t ∈ 𝓝 x, lipschitz_on_with K f t :=
(hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with_of_nnnorm_lt K hK
lemma cont_diff_at.exists_lipschitz_on_with {f : E' → F'} {x : E'}
  (hf : cont_diff_at 𝕂 1 f x) :
  ∃ K (t ∈ 𝓝 x), lipschitz_on_with K f t :=
(hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with
end real
section deriv
variables {f₂ : 𝕜 → F} {s₂ : set 𝕜}
open continuous_linear_map (smul_right)
theorem cont_diff_on_succ_iff_deriv_within {n : ℕ} (hs : unique_diff_on 𝕜 s₂) :
  cont_diff_on 𝕜 ((n + 1) : ℕ) f₂ s₂ ↔
  differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 n (deriv_within f₂ s₂) s₂ :=
begin
  rw cont_diff_on_succ_iff_fderiv_within hs,
  congr' 2,
  apply le_antisymm,
  { assume h,
    have : deriv_within f₂ s₂ = (λ u : 𝕜 →L[𝕜] F, u 1) ∘ (fderiv_within 𝕜 f₂ s₂),
      by { ext x, refl },
    simp only [this],
    apply cont_diff.comp_cont_diff_on _ h,
    exact (is_bounded_bilinear_map_apply.is_bounded_linear_map_left _).cont_diff },
  { assume h,
    have : fderiv_within 𝕜 f₂ s₂ = smul_right (1 : 𝕜 →L[𝕜] 𝕜) ∘ deriv_within f₂ s₂,
      by { ext x, simp [deriv_within] },
    simp only [this],
    apply cont_diff.comp_cont_diff_on _ h,
    have : is_bounded_bilinear_map 𝕜 (λ _ : (𝕜 →L[𝕜] 𝕜) × F, _) :=
      is_bounded_bilinear_map_smul_right,
    exact (this.is_bounded_linear_map_right _).cont_diff }
end
theorem cont_diff_on_succ_iff_deriv_of_open {n : ℕ} (hs : is_open s₂) :
  cont_diff_on 𝕜 ((n + 1) : ℕ) f₂ s₂ ↔
  differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 n (deriv f₂) s₂ :=
begin
  rw cont_diff_on_succ_iff_deriv_within hs.unique_diff_on,
  congrm _ ∧ _,
  apply cont_diff_on_congr,
  assume x hx,
  exact deriv_within_of_open hs hx
end
theorem cont_diff_on_top_iff_deriv_within (hs : unique_diff_on 𝕜 s₂) :
  cont_diff_on 𝕜 ∞ f₂ s₂ ↔
  differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 ∞ (deriv_within f₂ s₂) s₂ :=
begin
  split,
  { assume h,
    refine ⟨h.differentiable_on le_top, _⟩,
    apply cont_diff_on_top.2 (λ n, ((cont_diff_on_succ_iff_deriv_within hs).1 _).2),
    exact h.of_le le_top },
  { assume h,
    refine cont_diff_on_top.2 (λ n, _),
    have A : (n : with_top ℕ) ≤ ∞ := le_top,
    apply ((cont_diff_on_succ_iff_deriv_within hs).2 ⟨h.1, h.2.of_le A⟩).of_le,
    exact with_top.coe_le_coe.2 (nat.le_succ n) }
end
theorem cont_diff_on_top_iff_deriv_of_open (hs : is_open s₂) :
  cont_diff_on 𝕜 ∞ f₂ s₂ ↔
  differentiable_on 𝕜 f₂ s₂ ∧ cont_diff_on 𝕜 ∞ (deriv f₂) s₂ :=
begin
  rw cont_diff_on_top_iff_deriv_within hs.unique_diff_on,
  congrm _ ∧ _,
  apply cont_diff_on_congr,
  assume x hx,
  exact deriv_within_of_open hs hx
end
lemma cont_diff_on.deriv_within
  (hf : cont_diff_on 𝕜 n f₂ s₂) (hs : unique_diff_on 𝕜 s₂) (hmn : m + 1 ≤ n) :
  cont_diff_on 𝕜 m (deriv_within f₂ s₂) s₂ :=
begin
  cases m,
  { change ∞ + 1 ≤ n at hmn,
    have : n = ∞, by simpa using hmn,
    rw this at hf,
    exact ((cont_diff_on_top_iff_deriv_within hs).1 hf).2 },
  { change (m.succ : with_top ℕ) ≤ n at hmn,
    exact ((cont_diff_on_succ_iff_deriv_within hs).1 (hf.of_le hmn)).2 }
end
lemma cont_diff_on.deriv_of_open
  (hf : cont_diff_on 𝕜 n f₂ s₂) (hs : is_open s₂) (hmn : m + 1 ≤ n) :
  cont_diff_on 𝕜 m (deriv f₂) s₂ :=
(hf.deriv_within hs.unique_diff_on hmn).congr (λ x hx, (deriv_within_of_open hs hx).symm)
lemma cont_diff_on.continuous_on_deriv_within
  (h : cont_diff_on 𝕜 n f₂ s₂) (hs : unique_diff_on 𝕜 s₂) (hn : 1 ≤ n) :
  continuous_on (deriv_within f₂ s₂) s₂ :=
((cont_diff_on_succ_iff_deriv_within hs).1 (h.of_le hn)).2.continuous_on
lemma cont_diff_on.continuous_on_deriv_of_open
  (h : cont_diff_on 𝕜 n f₂ s₂) (hs : is_open s₂) (hn : 1 ≤ n) :
  continuous_on (deriv f₂) s₂ :=
((cont_diff_on_succ_iff_deriv_of_open hs).1 (h.of_le hn)).2.continuous_on
theorem cont_diff_succ_iff_deriv {n : ℕ} :
  cont_diff 𝕜 ((n + 1) : ℕ) f₂ ↔
    differentiable 𝕜 f₂ ∧ cont_diff 𝕜 n (deriv f₂) :=
by simp only [← cont_diff_on_univ, cont_diff_on_succ_iff_deriv_of_open, is_open_univ,
  differentiable_on_univ]
theorem cont_diff_one_iff_deriv :
  cont_diff 𝕜 1 f₂ ↔ differentiable 𝕜 f₂ ∧ continuous (deriv f₂) :=
cont_diff_succ_iff_deriv.trans $ iff.rfl.and cont_diff_zero
theorem cont_diff_top_iff_deriv :
  cont_diff 𝕜 ∞ f₂ ↔
  differentiable 𝕜 f₂ ∧ cont_diff 𝕜 ∞ (deriv f₂) :=
begin
  simp [cont_diff_on_univ.symm, differentiable_on_univ.symm, deriv_within_univ.symm,
        - deriv_within_univ],
  rw cont_diff_on_top_iff_deriv_within unique_diff_on_univ,
end
lemma cont_diff.continuous_deriv (h : cont_diff 𝕜 n f₂) (hn : 1 ≤ n) :
  continuous (deriv f₂) :=
(cont_diff_succ_iff_deriv.mp (h.of_le hn)).2.continuous
end deriv
section restrict_scalars
variables (𝕜) {𝕜' : Type*} [nondiscrete_normed_field 𝕜'] [normed_algebra 𝕜 𝕜']
variables [normed_space 𝕜' E] [is_scalar_tower 𝕜 𝕜' E]
variables [normed_space 𝕜' F] [is_scalar_tower 𝕜 𝕜' F]
variables {p' : E → formal_multilinear_series 𝕜' E F}
lemma has_ftaylor_series_up_to_on.restrict_scalars
  (h : has_ftaylor_series_up_to_on n f p' s) :
  has_ftaylor_series_up_to_on n f (λ x, (p' x).restrict_scalars 𝕜) s :=
{ zero_eq := λ x hx, h.zero_eq x hx,
  fderiv_within :=
    begin
      intros m hm x hx,
      convert ((continuous_multilinear_map.restrict_scalars_linear 𝕜).has_fderiv_at)
        .comp_has_fderiv_within_at _ ((h.fderiv_within m hm x hx).restrict_scalars 𝕜),
    end,
  cont := λ m hm, continuous_multilinear_map.continuous_restrict_scalars.comp_continuous_on
    (h.cont m hm) }
lemma cont_diff_within_at.restrict_scalars (h : cont_diff_within_at 𝕜' n f s x) :
  cont_diff_within_at 𝕜 n f s x :=
begin
  intros m hm,
  rcases h m hm with ⟨u, u_mem, p', hp'⟩,
  exact ⟨u, u_mem, _, hp'.restrict_scalars _⟩
end
lemma cont_diff_on.restrict_scalars (h : cont_diff_on 𝕜' n f s) :
  cont_diff_on 𝕜 n f s :=
λ x hx, (h x hx).restrict_scalars _
lemma cont_diff_at.restrict_scalars (h : cont_diff_at 𝕜' n f x) :
  cont_diff_at 𝕜 n f x :=
cont_diff_within_at_univ.1 $ h.cont_diff_within_at.restrict_scalars _
lemma cont_diff.restrict_scalars (h : cont_diff 𝕜' n f) :
  cont_diff 𝕜 n f :=
cont_diff_iff_cont_diff_at.2 $ λ x, h.cont_diff_at.restrict_scalars _
end restrict_scalars
