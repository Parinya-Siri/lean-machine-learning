import analysis.calculus.mean_value
import analysis.normed_space.multilinear
import analysis.calculus.formal_multilinear_series
import tactic.congrm
noncomputable theory
open_locale classical big_operators nnreal
local notation `âˆ` := (âŠ¤ : with_top â„•)
universes u v w
local attribute [instance, priority 1001]
normed_group.to_add_comm_group normed_space.to_module' add_comm_group.to_add_comm_monoid
open set fin filter
open_locale topological_space
variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
{E : Type*} [normed_group E] [normed_space ğ•œ E]
{F : Type*} [normed_group F] [normed_space ğ•œ F]
{G : Type*} [normed_group G] [normed_space ğ•œ G]
{X : Type*} [normed_group X] [normed_space ğ•œ X]
{s sâ‚ t u : set E} {f fâ‚ : E â†’ F} {g : F â†’ G} {x : E} {c : F}
{b : E Ã— F â†’ G} {m n : with_top â„•}
variable {p : E â†’ formal_multilinear_series ğ•œ E F}
structure has_ftaylor_series_up_to_on (n : with_top â„•)
  (f : E â†’ F) (p : E â†’ formal_multilinear_series ğ•œ E F) (s : set E) : Prop :=
(zero_eq       : âˆ€ x âˆˆ s, (p x 0).uncurry0 = f x)
(fderiv_within : âˆ€ (m : â„•) (hm : (m : with_top â„•) < n), âˆ€ x âˆˆ s,
   has_fderiv_within_at (Î» y, p y m) (p x m.succ).curry_left s x)
(cont          : âˆ€ (m : â„•) (hm : (m : with_top â„•) â‰¤ n), continuous_on (Î» x, p x m) s)
lemma has_ftaylor_series_up_to_on.zero_eq'
  (h : has_ftaylor_series_up_to_on n f p s) {x : E} (hx : x âˆˆ s) :
  p x 0 = (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f x) :=
by { rw â† h.zero_eq x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
lemma has_ftaylor_series_up_to_on.congr
  (h : has_ftaylor_series_up_to_on n f p s) (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) :
  has_ftaylor_series_up_to_on n fâ‚ p s :=
begin
  refine âŸ¨Î» x hx, _, h.fderiv_within, h.contâŸ©,
  rw hâ‚ x hx,
  exact h.zero_eq x hx
end
lemma has_ftaylor_series_up_to_on.mono
  (h : has_ftaylor_series_up_to_on n f p s) {t : set E} (hst : t âŠ† s) :
  has_ftaylor_series_up_to_on n f p t :=
âŸ¨Î» x hx, h.zero_eq x (hst hx),
Î» m hm x hx, (h.fderiv_within m hm x (hst hx)).mono hst,
Î» m hm, (h.cont m hm).mono hstâŸ©
lemma has_ftaylor_series_up_to_on.of_le
  (h : has_ftaylor_series_up_to_on n f p s) (hmn : m â‰¤ n) :
  has_ftaylor_series_up_to_on m f p s :=
âŸ¨h.zero_eq,
Î» k hk x hx, h.fderiv_within k (lt_of_lt_of_le hk hmn) x hx,
Î» k hk, h.cont k (le_trans hk hmn)âŸ©
lemma has_ftaylor_series_up_to_on.continuous_on
  (h : has_ftaylor_series_up_to_on n f p s) : continuous_on f s :=
begin
  have := (h.cont 0 bot_le).congr (Î» x hx, (h.zero_eq' hx).symm),
  rwa linear_isometry_equiv.comp_continuous_on_iff at this
end
lemma has_ftaylor_series_up_to_on_zero_iff :
  has_ftaylor_series_up_to_on 0 f p s â†” continuous_on f s âˆ§ (âˆ€ x âˆˆ s, (p x 0).uncurry0 = f x) :=
begin
  refine âŸ¨Î» H, âŸ¨H.continuous_on, H.zero_eqâŸ©,
          Î» H, âŸ¨H.2, Î» m hm, false.elim (not_le.2 hm bot_le), _âŸ©âŸ©,
  assume m hm,
  obtain rfl : m = 0, by exact_mod_cast (hm.antisymm (zero_le _)),
  have : âˆ€ x âˆˆ s, p x 0 = (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f x),
    by { assume x hx, rw â† H.2 x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ },
  rw [continuous_on_congr this, linear_isometry_equiv.comp_continuous_on_iff],
  exact H.1
end
lemma has_ftaylor_series_up_to_on_top_iff :
  (has_ftaylor_series_up_to_on âˆ f p s) â†” (âˆ€ (n : â„•), has_ftaylor_series_up_to_on n f p s) :=
begin
  split,
  { assume H n, exact H.of_le le_top },
  { assume H,
    split,
    { exact (H 0).zero_eq },
    { assume m hm,
      apply (H m.succ).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m)) },
    { assume m hm,
      apply (H m).cont m le_rfl } }
end
lemma has_ftaylor_series_up_to_on.has_fderiv_within_at
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hx : x âˆˆ s) :
  has_fderiv_within_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) s x :=
begin
  have A : âˆ€ y âˆˆ s, f y = (continuous_multilinear_curry_fin0 ğ•œ E F) (p y 0),
  { assume y hy, rw â† h.zero_eq y hy, refl },
  suffices H : has_fderiv_within_at
      (Î» y, continuous_multilinear_curry_fin0 ğ•œ E F (p y 0))
      (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) s x,
    by exact H.congr A (A x hx),
  rw linear_isometry_equiv.comp_has_fderiv_within_at_iff',
  have : ((0 : â„•) : with_top â„•) < n :=
    lt_of_lt_of_le (with_top.coe_lt_coe.2 nat.zero_lt_one) hn,
  convert h.fderiv_within _ this x hx,
  ext y v,
  change (p x 1) (snoc 0 y) = (p x 1) (cons y v),
  unfold_coes,
  congr' with i,
  rw unique.eq_default i,
  refl
end
lemma has_ftaylor_series_up_to_on.differentiable_on
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) : differentiable_on ğ•œ f s :=
Î» x hx, (h.has_fderiv_within_at hn hx).differentiable_within_at
lemma has_ftaylor_series_up_to_on.has_fderiv_at
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hx : s âˆˆ ğ“ x) :
  has_fderiv_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) x :=
(h.has_fderiv_within_at hn (mem_of_mem_nhds hx)).has_fderiv_at hx
lemma has_ftaylor_series_up_to_on.eventually_has_fderiv_at
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hx : s âˆˆ ğ“ x) :
  âˆ€á¶  y in ğ“ x, has_fderiv_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p y 1)) y :=
(eventually_eventually_nhds.2 hx).mono $ Î» y hy, h.has_fderiv_at hn hy
lemma has_ftaylor_series_up_to_on.differentiable_at
  (h : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hx : s âˆˆ ğ“ x) :
  differentiable_at ğ•œ f x :=
(h.has_fderiv_at hn hx).differentiable_at
theorem has_ftaylor_series_up_to_on_succ_iff_left {n : â„•} :
  has_ftaylor_series_up_to_on (n + 1) f p s â†”
  has_ftaylor_series_up_to_on n f p s
  âˆ§ (âˆ€ x âˆˆ s, has_fderiv_within_at (Î» y, p y n) (p x n.succ).curry_left s x)
  âˆ§ continuous_on (Î» x, p x (n + 1)) s :=
begin
  split,
  { assume h,
    exact âŸ¨h.of_le (with_top.coe_le_coe.2 (nat.le_succ n)),
           h.fderiv_within _ (with_top.coe_lt_coe.2 (lt_add_one n)),
           h.cont (n + 1) le_rflâŸ© },
  { assume h,
    split,
    { exact h.1.zero_eq },
    { assume m hm,
      by_cases h' : m < n,
      { exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h') },
      { have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h',
        rw this,
        exact h.2.1 } },
    { assume m hm,
      by_cases h' : m â‰¤ n,
      { apply h.1.cont m (with_top.coe_le_coe.2 h') },
      { have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h'),
        rw this,
        exact h.2.2 } } }
end
theorem has_ftaylor_series_up_to_on_succ_iff_right {n : â„•} :
  has_ftaylor_series_up_to_on ((n + 1) : â„•) f p s â†”
  (âˆ€ x âˆˆ s, (p x 0).uncurry0 = f x)
  âˆ§ (âˆ€ x âˆˆ s, has_fderiv_within_at (Î» y, p y 0) (p x 1).curry_left s x)
  âˆ§ has_ftaylor_series_up_to_on n
    (Î» x, continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) (Î» x, (p x).shift) s :=
begin
  split,
  { assume H,
    refine âŸ¨H.zero_eq, H.fderiv_within 0 (with_top.coe_lt_coe.2 (nat.succ_pos n)), _âŸ©,
    split,
    { assume x hx, refl },
    { assume m (hm : (m : with_top â„•) < n) x (hx : x âˆˆ s),
      have A : (m.succ : with_top â„•) < n.succ,
        by { rw with_top.coe_lt_coe at âŠ¢ hm, exact nat.lt_succ_iff.mpr hm },
      change has_fderiv_within_at
        ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm
           âˆ˜ (Î» (y : E), p y m.succ))
        (p x m.succ.succ).curry_right.curry_left s x,
      rw linear_isometry_equiv.comp_has_fderiv_within_at_iff',
      convert H.fderiv_within _ A x hx,
      ext y v,
      change (p x m.succ.succ) (snoc (cons y (init v)) (v (last _)))
        = (p x (nat.succ (nat.succ m))) (cons y v),
      rw [â† cons_snoc_eq_snoc_cons, snoc_init_self] },
    { assume m (hm : (m : with_top â„•) â‰¤ n),
      have A : (m.succ : with_top â„•) â‰¤ n.succ,
        by { rw with_top.coe_le_coe at âŠ¢ hm, exact nat.pred_le_iff.mp hm },
      change continuous_on ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm
           âˆ˜ (Î» (y : E), p y m.succ)) s,
      rw linear_isometry_equiv.comp_continuous_on_iff,
      exact H.cont _ A } },
  { rintros âŸ¨Hzero_eq, Hfderiv_zero, HtaylorâŸ©,
    split,
    { exact Hzero_eq },
    { assume m (hm : (m : with_top â„•) < n.succ) x (hx : x âˆˆ s),
      cases m,
      { exact Hfderiv_zero x hx },
      { have A : (m : with_top â„•) < n,
          by { rw with_top.coe_lt_coe at hm âŠ¢, exact nat.lt_of_succ_lt_succ hm },
        have : has_fderiv_within_at ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm
           âˆ˜ (Î» (y : E), p y m.succ)) ((p x).shift m.succ).curry_left s x :=
          Htaylor.fderiv_within _ A x hx,
        rw linear_isometry_equiv.comp_has_fderiv_within_at_iff' at this,
        convert this,
        ext y v,
        change (p x (nat.succ (nat.succ m))) (cons y v)
          = (p x m.succ.succ) (snoc (cons y (init v)) (v (last _))),
        rw [â† cons_snoc_eq_snoc_cons, snoc_init_self] } },
    { assume m (hm : (m : with_top â„•) â‰¤ n.succ),
      cases m,
      { have : differentiable_on ğ•œ (Î» x, p x 0) s :=
          Î» x hx, (Hfderiv_zero x hx).differentiable_within_at,
        exact this.continuous_on },
      { have A : (m : with_top â„•) â‰¤ n,
          by { rw with_top.coe_le_coe at hm âŠ¢, exact nat.lt_succ_iff.mp hm },
        have : continuous_on ((continuous_multilinear_curry_right_equiv' ğ•œ m E F).symm
           âˆ˜ (Î» (y : E), p y m.succ)) s :=
        Htaylor.cont _ A,
        rwa linear_isometry_equiv.comp_continuous_on_iff at this } } }
end
variable (ğ•œ)
def cont_diff_within_at (n : with_top â„•) (f : E â†’ F) (s : set E) (x : E) :=
âˆ€ (m : â„•), (m : with_top â„•) â‰¤ n â†’
  âˆƒ u âˆˆ ğ“[insert x s] x, âˆƒ p : E â†’ formal_multilinear_series ğ•œ E F,
    has_ftaylor_series_up_to_on m f p u
variable {ğ•œ}
lemma cont_diff_within_at_nat {n : â„•} :
  cont_diff_within_at ğ•œ n f s x â†”
  âˆƒ u âˆˆ ğ“[insert x s] x, âˆƒ p : E â†’ formal_multilinear_series ğ•œ E F,
  has_ftaylor_series_up_to_on n f p u :=
âŸ¨Î» H, H n le_rfl, Î» âŸ¨u, hu, p, hpâŸ© m hm, âŸ¨u, hu, p, hp.of_le hmâŸ©âŸ©
lemma cont_diff_within_at.of_le
  (h : cont_diff_within_at ğ•œ n f s x) (hmn : m â‰¤ n) :
  cont_diff_within_at ğ•œ m f s x :=
Î» k hk, h k (le_trans hk hmn)
lemma cont_diff_within_at_iff_forall_nat_le :
  cont_diff_within_at ğ•œ n f s x â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ cont_diff_within_at ğ•œ m f s x :=
âŸ¨Î» H m hm, H.of_le hm, Î» H m hm, H m hm _ le_rflâŸ©
lemma cont_diff_within_at_top :
  cont_diff_within_at ğ•œ âˆ f s x â†” âˆ€ (n : â„•), cont_diff_within_at ğ•œ n f s x :=
cont_diff_within_at_iff_forall_nat_le.trans $ by simp only [forall_prop_of_true, le_top]
lemma cont_diff_within_at.continuous_within_at
  (h : cont_diff_within_at ğ•œ n f s x) : continuous_within_at f s x :=
begin
  rcases h 0 bot_le with âŸ¨u, hu, p, HâŸ©,
  rw [mem_nhds_within_insert] at hu,
  exact (H.continuous_on.continuous_within_at hu.1).mono_of_mem hu.2
end
lemma cont_diff_within_at.congr_of_eventually_eq
  (h : cont_diff_within_at ğ•œ n f s x) (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) :
  cont_diff_within_at ğ•œ n fâ‚ s x :=
Î» m hm, let âŸ¨u, hu, p, HâŸ© := h m hm in
âŸ¨{x âˆˆ u | fâ‚ x = f x}, filter.inter_mem hu (mem_nhds_within_insert.2 âŸ¨hx, hâ‚âŸ©), p,
  (H.mono (sep_subset _ _)).congr (Î» _, and.right)âŸ©
lemma cont_diff_within_at.congr_of_eventually_eq'
  (h : cont_diff_within_at ğ•œ n f s x) (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : x âˆˆ s) :
  cont_diff_within_at ğ•œ n fâ‚ s x :=
h.congr_of_eventually_eq hâ‚ $ hâ‚.self_of_nhds_within hx
lemma filter.eventually_eq.cont_diff_within_at_iff
  (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) :
  cont_diff_within_at ğ•œ n fâ‚ s x â†” cont_diff_within_at ğ•œ n f s x :=
âŸ¨Î» H, cont_diff_within_at.congr_of_eventually_eq H hâ‚.symm hx.symm,
Î» H, H.congr_of_eventually_eq hâ‚ hxâŸ©
lemma cont_diff_within_at.congr
  (h : cont_diff_within_at ğ•œ n f s x) (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : fâ‚ x = f x) :
  cont_diff_within_at ğ•œ n fâ‚ s x :=
h.congr_of_eventually_eq (filter.eventually_eq_of_mem self_mem_nhds_within hâ‚) hx
lemma cont_diff_within_at.congr'
  (h : cont_diff_within_at ğ•œ n f s x) (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : x âˆˆ s) :
  cont_diff_within_at ğ•œ n fâ‚ s x :=
h.congr hâ‚ (hâ‚ _ hx)
lemma cont_diff_within_at.mono_of_mem
  (h : cont_diff_within_at ğ•œ n f s x) {t : set E} (hst : s âˆˆ ğ“[t] x) :
  cont_diff_within_at ğ•œ n f t x :=
begin
  assume m hm,
  rcases h m hm with âŸ¨u, hu, p, HâŸ©,
  exact âŸ¨u, nhds_within_le_of_mem (insert_mem_nhds_within_insert hst) hu, p, HâŸ©
end
lemma cont_diff_within_at.mono
  (h : cont_diff_within_at ğ•œ n f s x) {t : set E} (hst : t âŠ† s) :
  cont_diff_within_at ğ•œ n f t x :=
h.mono_of_mem $ filter.mem_of_superset self_mem_nhds_within hst
lemma cont_diff_within_at.congr_nhds
  (h : cont_diff_within_at ğ•œ n f s x) {t : set E} (hst : ğ“[s] x = ğ“[t] x) :
  cont_diff_within_at ğ•œ n f t x :=
h.mono_of_mem $ hst â–¸ self_mem_nhds_within
lemma cont_diff_within_at_congr_nhds {t : set E} (hst : ğ“[s] x = ğ“[t] x) :
  cont_diff_within_at ğ•œ n f s x â†” cont_diff_within_at ğ•œ n f t x :=
âŸ¨Î» h, h.congr_nhds hst, Î» h, h.congr_nhds hst.symmâŸ©
lemma cont_diff_within_at_inter' (h : t âˆˆ ğ“[s] x) :
  cont_diff_within_at ğ•œ n f (s âˆ© t) x â†” cont_diff_within_at ğ•œ n f s x :=
cont_diff_within_at_congr_nhds $ eq.symm $ nhds_within_restrict'' _ h
lemma cont_diff_within_at_inter (h : t âˆˆ ğ“ x) :
  cont_diff_within_at ğ•œ n f (s âˆ© t) x â†” cont_diff_within_at ğ•œ n f s x :=
cont_diff_within_at_inter' (mem_nhds_within_of_mem_nhds h)
lemma cont_diff_within_at.differentiable_within_at'
  (h : cont_diff_within_at ğ•œ n f s x) (hn : 1 â‰¤ n) :
  differentiable_within_at ğ•œ f (insert x s) x :=
begin
  rcases h 1 hn with âŸ¨u, hu, p, HâŸ©,
  rcases mem_nhds_within.1 hu with âŸ¨t, t_open, xt, tuâŸ©,
  rw inter_comm at tu,
  have := ((H.mono tu).differentiable_on le_rfl) x âŸ¨mem_insert x s, xtâŸ©,
  exact (differentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 this,
end
lemma cont_diff_within_at.differentiable_within_at
  (h : cont_diff_within_at ğ•œ n f s x) (hn : 1 â‰¤ n) :
  differentiable_within_at ğ•œ f s x :=
(h.differentiable_within_at' hn).mono  (subset_insert x s)
theorem cont_diff_within_at_succ_iff_has_fderiv_within_at {n : â„•} :
  cont_diff_within_at ğ•œ ((n + 1) : â„•) f s x
  â†” âˆƒ u âˆˆ ğ“[insert x s] x, âˆƒ f' : E â†’ (E â†’L[ğ•œ] F),
    (âˆ€ x âˆˆ u, has_fderiv_within_at f (f' x) u x) âˆ§ (cont_diff_within_at ğ•œ n f' u x) :=
begin
  split,
  { assume h,
    rcases h n.succ le_rfl with âŸ¨u, hu, p, HpâŸ©,
    refine âŸ¨u, hu, Î» y, (continuous_multilinear_curry_fin1 ğ•œ E F) (p y 1),
      Î» y hy, Hp.has_fderiv_within_at (with_top.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _âŸ©,
    assume m hm,
    refine âŸ¨u, _, Î» (y : E), (p y).shift, _âŸ©,
    { convert self_mem_nhds_within,
      have : x âˆˆ insert x s, by simp,
      exact (insert_eq_of_mem (mem_of_mem_nhds_within this hu)) },
    { rw has_ftaylor_series_up_to_on_succ_iff_right at Hp,
      exact Hp.2.2.of_le hm } },
  { rintros âŸ¨u, hu, f', f'_eq_deriv, Hf'âŸ©,
    rw cont_diff_within_at_nat,
    rcases Hf' n le_rfl with âŸ¨v, hv, p', Hp'âŸ©,
    refine âŸ¨v âˆ© u, _, Î» x, (p' x).unshift (f x), _âŸ©,
    { apply filter.inter_mem _ hu,
      apply nhds_within_le_of_mem hu,
      exact nhds_within_mono _ (subset_insert x u) hv },
    { rw has_ftaylor_series_up_to_on_succ_iff_right,
      refine âŸ¨Î» y hy, rfl, Î» y hy, _, _âŸ©,
      { change has_fderiv_within_at (Î» z, (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f z))
          ((formal_multilinear_series.unshift (p' y) (f y) 1).curry_left) (v âˆ© u) y,
        rw linear_isometry_equiv.comp_has_fderiv_within_at_iff',
        convert (f'_eq_deriv y hy.2).mono (inter_subset_right v u),
        rw â† Hp'.zero_eq y hy.1,
        ext z,
        change ((p' y 0) (init (@cons 0 (Î» i, E) z 0))) (@cons 0 (Î» i, E) z 0 (last 0))
          = ((p' y 0) 0) z,
        unfold_coes,
        congr },
      { convert (Hp'.mono (inter_subset_left v u)).congr (Î» x hx, Hp'.zero_eq x hx.1),
        { ext x y,
          change p' x 0 (init (@snoc 0 (Î» i : fin 1, E) 0 y)) y = p' x 0 0 y,
          rw init_snoc },
        { ext x k v y,
          change p' x k (init (@snoc k (Î» i : fin k.succ, E) v y))
            (@snoc k (Î» i : fin k.succ, E) v y (last k)) = p' x k v y,
          rw [snoc_last, init_snoc] } } } }
end
variable (ğ•œ)
definition cont_diff_on (n : with_top â„•) (f : E â†’ F) (s : set E) :=
âˆ€ x âˆˆ s, cont_diff_within_at ğ•œ n f s x
variable {ğ•œ}
lemma cont_diff_on.cont_diff_within_at (h : cont_diff_on ğ•œ n f s) (hx : x âˆˆ s) :
  cont_diff_within_at ğ•œ n f s x :=
h x hx
lemma cont_diff_within_at.cont_diff_on {m : â„•}
  (hm : (m : with_top â„•) â‰¤ n) (h : cont_diff_within_at ğ•œ n f s x) :
  âˆƒ u âˆˆ ğ“[insert x s] x, u âŠ† insert x s âˆ§ cont_diff_on ğ•œ m f u :=
begin
  rcases h m hm with âŸ¨u, u_nhd, p, hpâŸ©,
  refine âŸ¨u âˆ© insert x s, filter.inter_mem u_nhd self_mem_nhds_within,
    inter_subset_right _ _, _âŸ©,
  assume y hy m' hm',
  refine âŸ¨u âˆ© insert x s, _, p, (hp.mono (inter_subset_left _ _)).of_le hm'âŸ©,
  convert self_mem_nhds_within,
  exact insert_eq_of_mem hy
end
protected lemma cont_diff_within_at.eventually {n : â„•}
  (h : cont_diff_within_at ğ•œ n f s x) :
  âˆ€á¶  y in ğ“[insert x s] x, cont_diff_within_at ğ•œ n f s y :=
begin
  rcases h.cont_diff_on le_rfl with âŸ¨u, hu, hu_sub, hdâŸ©,
  have : âˆ€á¶  (y : E) in ğ“[insert x s] x, u âˆˆ ğ“[insert x s] y âˆ§ y âˆˆ u,
    from (eventually_nhds_within_nhds_within.2 hu).and hu,
  refine this.mono (Î» y hy, (hd y hy.2).mono_of_mem _),
  exact nhds_within_mono y (subset_insert _ _) hy.1
end
lemma cont_diff_on.of_le (h : cont_diff_on ğ•œ n f s) (hmn : m â‰¤ n) :
  cont_diff_on ğ•œ m f s :=
Î» x hx, (h x hx).of_le hmn
lemma cont_diff_on_iff_forall_nat_le :
  cont_diff_on ğ•œ n f s â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ cont_diff_on ğ•œ m f s :=
âŸ¨Î» H m hm, H.of_le hm, Î» H x hx m hm, H m hm x hx m le_rflâŸ©
lemma cont_diff_on_top :
  cont_diff_on ğ•œ âˆ f s â†” âˆ€ (n : â„•), cont_diff_on ğ•œ n f s :=
cont_diff_on_iff_forall_nat_le.trans $ by simp only [le_top, forall_prop_of_true]
lemma cont_diff_on_all_iff_nat :
  (âˆ€ n, cont_diff_on ğ•œ n f s) â†” (âˆ€ n : â„•, cont_diff_on ğ•œ n f s) :=
begin
  refine âŸ¨Î» H n, H n, _âŸ©,
  rintro H (_|n),
  exacts [cont_diff_on_top.2 H, H n]
end
lemma cont_diff_on.continuous_on
  (h : cont_diff_on ğ•œ n f s) : continuous_on f s :=
Î» x hx, (h x hx).continuous_within_at
lemma cont_diff_on.congr
  (h : cont_diff_on ğ•œ n f s) (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) :
  cont_diff_on ğ•œ n fâ‚ s :=
Î» x hx, (h x hx).congr hâ‚ (hâ‚ x hx)
lemma cont_diff_on_congr (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) :
  cont_diff_on ğ•œ n fâ‚ s â†” cont_diff_on ğ•œ n f s :=
âŸ¨Î» H, H.congr (Î» x hx, (hâ‚ x hx).symm), Î» H, H.congr hâ‚âŸ©
lemma cont_diff_on.mono
  (h : cont_diff_on ğ•œ n f s) {t : set E} (hst : t âŠ† s) :
  cont_diff_on ğ•œ n f t :=
Î» x hx, (h x (hst hx)).mono hst
lemma cont_diff_on.congr_mono
  (hf : cont_diff_on ğ•œ n f s) (hâ‚ : âˆ€ x âˆˆ sâ‚, fâ‚ x = f x) (hs : sâ‚ âŠ† s) :
  cont_diff_on ğ•œ n fâ‚ sâ‚ :=
(hf.mono hs).congr hâ‚
lemma cont_diff_on.differentiable_on
  (h : cont_diff_on ğ•œ n f s) (hn : 1 â‰¤ n) : differentiable_on ğ•œ f s :=
Î» x hx, (h x hx).differentiable_within_at hn
lemma cont_diff_on_of_locally_cont_diff_on
  (h : âˆ€ x âˆˆ s, âˆƒu, is_open u âˆ§ x âˆˆ u âˆ§ cont_diff_on ğ•œ n f (s âˆ© u)) :
  cont_diff_on ğ•œ n f s :=
begin
  assume x xs,
  rcases h x xs with âŸ¨u, u_open, xu, huâŸ©,
  apply (cont_diff_within_at_inter _).1 (hu x âŸ¨xs, xuâŸ©),
  exact is_open.mem_nhds u_open xu
end
theorem cont_diff_on_succ_iff_has_fderiv_within_at {n : â„•} :
  cont_diff_on ğ•œ ((n + 1) : â„•) f s
  â†” âˆ€ x âˆˆ s, âˆƒ u âˆˆ ğ“[insert x s] x, âˆƒ f' : E â†’ (E â†’L[ğ•œ] F),
    (âˆ€ x âˆˆ u, has_fderiv_within_at f (f' x) u x) âˆ§ (cont_diff_on ğ•œ n f' u) :=
begin
  split,
  { assume h x hx,
    rcases (h x hx) n.succ le_rfl with âŸ¨u, hu, p, HpâŸ©,
    refine âŸ¨u, hu, Î» y, (continuous_multilinear_curry_fin1 ğ•œ E F) (p y 1),
      Î» y hy, Hp.has_fderiv_within_at (with_top.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _âŸ©,
    rw has_ftaylor_series_up_to_on_succ_iff_right at Hp,
    assume z hz m hm,
    refine âŸ¨u, _, Î» (x : E), (p x).shift, Hp.2.2.of_le hmâŸ©,
    convert self_mem_nhds_within,
    exact insert_eq_of_mem hz, },
  { assume h x hx,
    rw cont_diff_within_at_succ_iff_has_fderiv_within_at,
    rcases h x hx with âŸ¨u, u_nhbd, f', hu, hf'âŸ©,
    have : x âˆˆ u := mem_of_mem_nhds_within (mem_insert _ _) u_nhbd,
    exact âŸ¨u, u_nhbd, f', hu, hf' x thisâŸ© }
end
variable (ğ•œ)
noncomputable def iterated_fderiv_within (n : â„•) (f : E â†’ F) (s : set E) :
  E â†’ (E [Ã—n]â†’L[ğ•œ] F) :=
nat.rec_on n
  (Î» x, continuous_multilinear_map.curry0 ğ•œ E (f x))
  (Î» n rec x, continuous_linear_map.uncurry_left (fderiv_within ğ•œ rec s x))
def ftaylor_series_within (f : E â†’ F) (s : set E) (x : E) : formal_multilinear_series ğ•œ E F :=
Î» n, iterated_fderiv_within ğ•œ n f s x
variable {ğ•œ}
@[simp] lemma iterated_fderiv_within_zero_apply (m : (fin 0) â†’ E) :
  (iterated_fderiv_within ğ•œ 0 f s x : ((fin 0) â†’  E) â†’ F) m = f x := rfl
lemma iterated_fderiv_within_zero_eq_comp :
  iterated_fderiv_within ğ•œ 0 f s = (continuous_multilinear_curry_fin0 ğ•œ E F).symm âˆ˜ f := rfl
lemma iterated_fderiv_within_succ_apply_left {n : â„•} (m : fin (n + 1) â†’ E):
  (iterated_fderiv_within ğ•œ (n + 1) f s x : (fin (n + 1) â†’ E) â†’ F) m
  = (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s x : E â†’ (E [Ã—n]â†’L[ğ•œ] F))
      (m 0) (tail m) := rfl
lemma iterated_fderiv_within_succ_eq_comp_left {n : â„•} :
  iterated_fderiv_within ğ•œ (n + 1) f s =
  (continuous_multilinear_curry_left_equiv ğ•œ (Î»(i : fin (n + 1)), E) F)
    âˆ˜ (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n f s) s) := rfl
theorem iterated_fderiv_within_succ_apply_right {n : â„•}
  (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (m : fin (n + 1) â†’ E) :
  (iterated_fderiv_within ğ•œ (n + 1) f s x : (fin (n + 1) â†’ E) â†’ F) m
    = iterated_fderiv_within ğ•œ n (Î»y, fderiv_within ğ•œ f s y) s x (init m) (m (last n)) :=
begin
  induction n with n IH generalizing x,
  { rw [iterated_fderiv_within_succ_eq_comp_left, iterated_fderiv_within_zero_eq_comp,
        iterated_fderiv_within_zero_apply,
        function.comp_apply, linear_isometry_equiv.comp_fderiv_within _ (hs x hx)],
    refl },
  { let I := continuous_multilinear_curry_right_equiv' ğ•œ n E F,
    have A : âˆ€ y âˆˆ s, iterated_fderiv_within ğ•œ n.succ f s y
        = (I âˆ˜ (iterated_fderiv_within ğ•œ n (Î»y, fderiv_within ğ•œ f s y) s)) y,
      by { assume y hy, ext m, rw @IH m y hy, refl },
    calc
    (iterated_fderiv_within ğ•œ (n+2) f s x : (fin (n+2) â†’ E) â†’ F) m =
    (fderiv_within ğ•œ (iterated_fderiv_within ğ•œ n.succ f s) s x
              : E â†’ (E [Ã—(n + 1)]â†’L[ğ•œ] F)) (m 0) (tail m) : rfl
    ... = (fderiv_within ğ•œ (I âˆ˜ (iterated_fderiv_within ğ•œ n (fderiv_within ğ•œ f s) s)) s x
              : E â†’ (E [Ã—(n + 1)]â†’L[ğ•œ] F)) (m 0) (tail m) :
      by rw fderiv_within_congr (hs x hx) A (A x hx)
    ... = (I âˆ˜ fderiv_within ğ•œ ((iterated_fderiv_within ğ•œ n (fderiv_within ğ•œ f s) s)) s x
              : E â†’ (E [Ã—(n + 1)]â†’L[ğ•œ] F)) (m 0) (tail m) :
      by { rw linear_isometry_equiv.comp_fderiv_within _ (hs x hx), refl }
    ... = (fderiv_within ğ•œ ((iterated_fderiv_within ğ•œ n (Î» y, fderiv_within ğ•œ f s y) s)) s x
              : E â†’ (E [Ã—n]â†’L[ğ•œ] (E â†’L[ğ•œ] F))) (m 0) (init (tail m)) ((tail m) (last n)) : rfl
    ... = iterated_fderiv_within ğ•œ (nat.succ n) (Î» y, fderiv_within ğ•œ f s y) s x
              (init m) (m (last (n + 1))) :
      by { rw [iterated_fderiv_within_succ_apply_left, tail_init_eq_init_tail], refl } }
end
lemma iterated_fderiv_within_succ_eq_comp_right {n : â„•} (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :
  iterated_fderiv_within ğ•œ (n + 1) f s x =
  ((continuous_multilinear_curry_right_equiv' ğ•œ n E F)
    âˆ˜ (iterated_fderiv_within ğ•œ n (Î»y, fderiv_within ğ•œ f s y) s)) x :=
by { ext m, rw iterated_fderiv_within_succ_apply_right hs hx, refl }
@[simp] lemma iterated_fderiv_within_one_apply
  (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) (m : (fin 1) â†’ E) :
  (iterated_fderiv_within ğ•œ 1 f s x : ((fin 1) â†’ E) â†’ F) m
  = (fderiv_within ğ•œ f s x : E â†’ F) (m 0) :=
by { rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply], refl }
lemma iterated_fderiv_within_congr {n : â„•}
  (hs : unique_diff_on ğ•œ s) (hL : âˆ€yâˆˆs, fâ‚ y = f y) (hx : x âˆˆ s) :
  iterated_fderiv_within ğ•œ n fâ‚ s x = iterated_fderiv_within ğ•œ n f s x :=
begin
  induction n with n IH generalizing x,
  { ext m, simp [hL x hx] },
  { have : fderiv_within ğ•œ (Î» y, iterated_fderiv_within ğ•œ n fâ‚ s y) s x
           = fderiv_within ğ•œ (Î» y, iterated_fderiv_within ğ•œ n f s y) s x :=
      fderiv_within_congr (hs x hx) (Î» y hy, IH hy) (IH hx),
    ext m,
    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this] }
end
lemma iterated_fderiv_within_inter_open {n : â„•} (hu : is_open u)
  (hs : unique_diff_on ğ•œ (s âˆ© u)) (hx : x âˆˆ s âˆ© u) :
  iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x :=
begin
  induction n with n IH generalizing x,
  { ext m, simp },
  { have A : fderiv_within ğ•œ (Î» y, iterated_fderiv_within ğ•œ n f (s âˆ© u) y) (s âˆ© u) x
           = fderiv_within ğ•œ (Î» y, iterated_fderiv_within ğ•œ n f s y) (s âˆ© u) x :=
      fderiv_within_congr (hs x hx) (Î» y hy, IH hy) (IH hx),
    have B : fderiv_within ğ•œ (Î» y, iterated_fderiv_within ğ•œ n f s y) (s âˆ© u) x
           = fderiv_within ğ•œ (Î» y, iterated_fderiv_within ğ•œ n f s y) s x :=
      fderiv_within_inter (is_open.mem_nhds hu hx.2)
        ((unique_diff_within_at_inter (is_open.mem_nhds hu hx.2)).1 (hs x hx)),
    ext m,
    rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B] }
end
lemma iterated_fderiv_within_inter' {n : â„•}
  (hu : u âˆˆ ğ“[s] x) (hs : unique_diff_on ğ•œ s) (xs : x âˆˆ s) :
  iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x :=
begin
  obtain âŸ¨v, v_open, xv, vuâŸ© : âˆƒ v, is_open v âˆ§ x âˆˆ v âˆ§ v âˆ© s âŠ† u := mem_nhds_within.1 hu,
  have A : (s âˆ© u) âˆ© v = s âˆ© v,
  { apply subset.antisymm (inter_subset_inter (inter_subset_left _ _) (subset.refl _)),
    exact Î» y âŸ¨ys, yvâŸ©, âŸ¨âŸ¨ys, vu âŸ¨yv, ysâŸ©âŸ©, yvâŸ© },
  have : iterated_fderiv_within ğ•œ n f (s âˆ© v) x = iterated_fderiv_within ğ•œ n f s x :=
    iterated_fderiv_within_inter_open v_open (hs.inter v_open) âŸ¨xs, xvâŸ©,
  rw â† this,
  have : iterated_fderiv_within ğ•œ n f ((s âˆ© u) âˆ© v) x = iterated_fderiv_within ğ•œ n f (s âˆ© u) x,
  { refine iterated_fderiv_within_inter_open v_open  _ âŸ¨âŸ¨xs, vu âŸ¨xv, xsâŸ©âŸ©, xvâŸ©,
    rw A,
    exact hs.inter v_open },
  rw A at this,
  rw â† this
end
lemma iterated_fderiv_within_inter {n : â„•}
  (hu : u âˆˆ ğ“ x) (hs : unique_diff_on ğ•œ s) (xs : x âˆˆ s) :
  iterated_fderiv_within ğ•œ n f (s âˆ© u) x = iterated_fderiv_within ğ•œ n f s x :=
iterated_fderiv_within_inter' (mem_nhds_within_of_mem_nhds hu) hs xs
@[simp] lemma cont_diff_on_zero :
  cont_diff_on ğ•œ 0 f s â†” continuous_on f s :=
begin
  refine âŸ¨Î» H, H.continuous_on, Î» H, _âŸ©,
  assume x hx m hm,
  have : (m : with_top â„•) = 0 := le_antisymm hm bot_le,
  rw this,
  refine âŸ¨insert x s, self_mem_nhds_within, ftaylor_series_within ğ•œ f s, _âŸ©,
  rw has_ftaylor_series_up_to_on_zero_iff,
  exact âŸ¨by rwa insert_eq_of_mem hx, Î» x hx, by simp [ftaylor_series_within]âŸ©
end
lemma cont_diff_within_at_zero (hx : x âˆˆ s) :
  cont_diff_within_at ğ•œ 0 f s x â†” âˆƒ u âˆˆ ğ“[s] x, continuous_on f (s âˆ© u) :=
begin
  split,
  { intros h,
    obtain âŸ¨u, H, p, hpâŸ© := h 0 (by norm_num),
    refine âŸ¨u, _, _âŸ©,
    { simpa [hx] using H },
    { simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp,
      exact hp.1.mono (inter_subset_right s u) } },
  { rintros âŸ¨u, H, huâŸ©,
    rw â† cont_diff_within_at_inter' H,
    have h' : x âˆˆ s âˆ© u := âŸ¨hx, mem_of_mem_nhds_within hx HâŸ©,
    exact (cont_diff_on_zero.mpr hu).cont_diff_within_at h' }
end
theorem has_ftaylor_series_up_to_on.eq_ftaylor_series_of_unique_diff_on
  (h : has_ftaylor_series_up_to_on n f p s)
  {m : â„•} (hmn : (m : with_top â„•) â‰¤ n) (hs : unique_diff_on ğ•œ s) (hx : x âˆˆ s) :
  p x m = iterated_fderiv_within ğ•œ m f s x :=
begin
  induction m with m IH generalizing x,
  { rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp] },
  { have A : (m : with_top â„•) < n := lt_of_lt_of_le (with_top.coe_lt_coe.2 (lt_add_one m)) hmn,
    have : has_fderiv_within_at (Î» (y : E), iterated_fderiv_within ğ•œ m f s y)
      (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x :=
    (h.fderiv_within m A x hx).congr (Î» y hy, (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm,
    rw [iterated_fderiv_within_succ_eq_comp_left, function.comp_apply,
      this.fderiv_within (hs x hx)],
    exact (continuous_multilinear_map.uncurry_curry_left _).symm }
end
theorem cont_diff_on.ftaylor_series_within
  (h : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) :
  has_ftaylor_series_up_to_on n f (ftaylor_series_within ğ•œ f s) s :=
begin
  split,
  { assume x hx,
    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply,
               iterated_fderiv_within_zero_apply] },
  { assume m hm x hx,
    rcases (h x hx) m.succ (with_top.add_one_le_of_lt hm) with âŸ¨u, hu, p, HpâŸ©,
    rw insert_eq_of_mem hx at hu,
    rcases mem_nhds_within.1 hu with âŸ¨o, o_open, xo, hoâŸ©,
    rw inter_comm at ho,
    have : p x m.succ = ftaylor_series_within ğ•œ f s x m.succ,
    { change p x m.succ = iterated_fderiv_within ğ•œ m.succ f s x,
      rw â† iterated_fderiv_within_inter (is_open.mem_nhds o_open xo) hs hx,
      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl
        (hs.inter o_open) âŸ¨hx, xoâŸ© },
    rw [â† this, â† has_fderiv_within_at_inter (is_open.mem_nhds o_open xo)],
    have A : âˆ€ y âˆˆ s âˆ© o, p y m = ftaylor_series_within ğ•œ f s y m,
    { rintros y âŸ¨hy, yoâŸ©,
      change p y m = iterated_fderiv_within ğ•œ m f s y,
      rw â† iterated_fderiv_within_inter (is_open.mem_nhds o_open yo) hs hy,
      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on (with_top.coe_le_coe.2 (nat.le_succ m))
        (hs.inter o_open) âŸ¨hy, yoâŸ© },
    exact ((Hp.mono ho).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m)) x âŸ¨hx, xoâŸ©).congr
      (Î» y hy, (A y hy).symm) (A x âŸ¨hx, xoâŸ©).symm },
  { assume m hm,
    apply continuous_on_of_locally_continuous_on,
    assume x hx,
    rcases h x hx m hm with âŸ¨u, hu, p, HpâŸ©,
    rcases mem_nhds_within.1 hu with âŸ¨o, o_open, xo, hoâŸ©,
    rw insert_eq_of_mem hx at ho,
    rw inter_comm at ho,
    refine âŸ¨o, o_open, xo, _âŸ©,
    have A : âˆ€ y âˆˆ s âˆ© o, p y m = ftaylor_series_within ğ•œ f s y m,
    { rintros y âŸ¨hy, yoâŸ©,
      change p y m = iterated_fderiv_within ğ•œ m f s y,
      rw â† iterated_fderiv_within_inter (is_open.mem_nhds o_open yo) hs hy,
      exact (Hp.mono ho).eq_ftaylor_series_of_unique_diff_on le_rfl
        (hs.inter o_open) âŸ¨hy, yoâŸ© },
    exact ((Hp.mono ho).cont m le_rfl).congr (Î» y hy, (A y hy).symm) }
end
lemma cont_diff_on_of_continuous_on_differentiable_on
  (Hcont : âˆ€ (m : â„•), (m : with_top â„•) â‰¤ n â†’
    continuous_on (Î» x, iterated_fderiv_within ğ•œ m f s x) s)
  (Hdiff : âˆ€ (m : â„•), (m : with_top â„•) < n â†’
    differentiable_on ğ•œ (Î» x, iterated_fderiv_within ğ•œ m f s x) s) :
  cont_diff_on ğ•œ n f s :=
begin
  assume x hx m hm,
  rw insert_eq_of_mem hx,
  refine âŸ¨s, self_mem_nhds_within, ftaylor_series_within ğ•œ f s, _âŸ©,
  split,
  { assume y hy,
    simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply,
                iterated_fderiv_within_zero_apply] },
  { assume k hk y hy,
    convert (Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at,
    simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left,
                continuous_linear_equiv.coe_apply, function.comp_app, coe_fn_coe_base],
    exact continuous_linear_map.curry_uncurry_left _ },
  { assume k hk,
    exact Hcont k (le_trans hk hm) }
end
lemma cont_diff_on_of_differentiable_on
  (h : âˆ€(m : â„•), (m : with_top â„•) â‰¤ n â†’ differentiable_on ğ•œ (iterated_fderiv_within ğ•œ m f s) s) :
  cont_diff_on ğ•œ n f s :=
cont_diff_on_of_continuous_on_differentiable_on
  (Î» m hm, (h m hm).continuous_on) (Î» m hm, (h m (le_of_lt hm)))
lemma cont_diff_on.continuous_on_iterated_fderiv_within {m : â„•}
  (h : cont_diff_on ğ•œ n f s) (hmn : (m : with_top â„•) â‰¤ n) (hs : unique_diff_on ğ•œ s) :
  continuous_on (iterated_fderiv_within ğ•œ m f s) s :=
(h.ftaylor_series_within hs).cont m hmn
lemma cont_diff_on.differentiable_on_iterated_fderiv_within {m : â„•}
  (h : cont_diff_on ğ•œ n f s) (hmn : (m : with_top â„•) < n) (hs : unique_diff_on ğ•œ s) :
  differentiable_on ğ•œ (iterated_fderiv_within ğ•œ m f s) s :=
Î» x hx, ((h.ftaylor_series_within hs).fderiv_within m hmn x hx).differentiable_within_at
lemma cont_diff_on_iff_continuous_on_differentiable_on
  (hs : unique_diff_on ğ•œ s) :
  cont_diff_on ğ•œ n f s â†”
  (âˆ€ (m : â„•), (m : with_top â„•) â‰¤ n â†’
    continuous_on (Î» x, iterated_fderiv_within ğ•œ m f s x) s)
  âˆ§ (âˆ€ (m : â„•), (m : with_top â„•) < n â†’
    differentiable_on ğ•œ (Î» x, iterated_fderiv_within ğ•œ m f s x) s) :=
begin
  split,
  { assume h,
    split,
    { assume m hm, exact h.continuous_on_iterated_fderiv_within hm hs },
    { assume m hm, exact h.differentiable_on_iterated_fderiv_within hm hs } },
  { assume h,
    exact cont_diff_on_of_continuous_on_differentiable_on h.1 h.2 }
end
lemma cont_diff_on_succ_of_fderiv_within {n : â„•} (hf : differentiable_on ğ•œ f s)
  (h : cont_diff_on ğ•œ n (Î» y, fderiv_within ğ•œ f s y) s) :
  cont_diff_on ğ•œ ((n + 1) : â„•) f s :=
begin
  intros x hx,
  rw [cont_diff_within_at_succ_iff_has_fderiv_within_at, insert_eq_of_mem hx],
  exact âŸ¨s, self_mem_nhds_within, fderiv_within ğ•œ f s,
    Î» y hy, (hf y hy).has_fderiv_within_at, h x hxâŸ©
end
theorem cont_diff_on_succ_iff_fderiv_within {n : â„•} (hs : unique_diff_on ğ•œ s) :
  cont_diff_on ğ•œ ((n + 1) : â„•) f s â†”
  differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ n (Î» y, fderiv_within ğ•œ f s y) s :=
begin
  refine âŸ¨Î» H, _, Î» h, cont_diff_on_succ_of_fderiv_within h.1 h.2âŸ©,
  refine âŸ¨H.differentiable_on (with_top.coe_le_coe.2 (nat.le_add_left 1 n)), Î» x hx, _âŸ©,
  rcases cont_diff_within_at_succ_iff_has_fderiv_within_at.1 (H x hx)
    with âŸ¨u, hu, f', hff', hf'âŸ©,
  rcases mem_nhds_within.1 hu with âŸ¨o, o_open, xo, hoâŸ©,
  rw [inter_comm, insert_eq_of_mem hx] at ho,
  have := hf'.mono ho,
  rw cont_diff_within_at_inter' (mem_nhds_within_of_mem_nhds (is_open.mem_nhds o_open xo))
    at this,
  apply this.congr_of_eventually_eq' _ hx,
  have : o âˆ© s âˆˆ ğ“[s] x := mem_nhds_within.2 âŸ¨o, o_open, xo, subset.refl _âŸ©,
  rw inter_comm at this,
  apply filter.eventually_eq_of_mem this (Î» y hy, _),
  have A : fderiv_within ğ•œ f (s âˆ© o) y = f' y :=
    ((hff' y (ho hy)).mono ho).fderiv_within (hs.inter o_open y hy),
  rwa fderiv_within_inter (is_open.mem_nhds o_open hy.2) (hs y hy.1) at A
end
theorem cont_diff_on_succ_iff_fderiv_of_open {n : â„•} (hs : is_open s) :
  cont_diff_on ğ•œ ((n + 1) : â„•) f s â†”
  differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ n (Î» y, fderiv ğ•œ f y) s :=
begin
  rw cont_diff_on_succ_iff_fderiv_within hs.unique_diff_on,
  congrm _ âˆ§ _,
  apply cont_diff_on_congr,
  assume x hx,
  exact fderiv_within_of_open hs hx
end
theorem cont_diff_on_top_iff_fderiv_within (hs : unique_diff_on ğ•œ s) :
  cont_diff_on ğ•œ âˆ f s â†”
  differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ âˆ (Î» y, fderiv_within ğ•œ f s y) s :=
begin
  split,
  { assume h,
    refine âŸ¨h.differentiable_on le_top, _âŸ©,
    apply cont_diff_on_top.2 (Î» n, ((cont_diff_on_succ_iff_fderiv_within hs).1 _).2),
    exact h.of_le le_top },
  { assume h,
    refine cont_diff_on_top.2 (Î» n, _),
    have A : (n : with_top â„•) â‰¤ âˆ := le_top,
    apply ((cont_diff_on_succ_iff_fderiv_within hs).2 âŸ¨h.1, h.2.of_le AâŸ©).of_le,
    exact with_top.coe_le_coe.2 (nat.le_succ n) }
end
theorem cont_diff_on_top_iff_fderiv_of_open (hs : is_open s) :
  cont_diff_on ğ•œ âˆ f s â†”
  differentiable_on ğ•œ f s âˆ§ cont_diff_on ğ•œ âˆ (Î» y, fderiv ğ•œ f y) s :=
begin
  rw cont_diff_on_top_iff_fderiv_within hs.unique_diff_on,
  congrm _ âˆ§ _,
  apply cont_diff_on_congr,
  assume x hx,
  exact fderiv_within_of_open hs hx
end
lemma cont_diff_on.fderiv_within
  (hf : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) (hmn : m + 1 â‰¤ n) :
  cont_diff_on ğ•œ m (Î» y, fderiv_within ğ•œ f s y) s :=
begin
  cases m,
  { change âˆ + 1 â‰¤ n at hmn,
    have : n = âˆ, by simpa using hmn,
    rw this at hf,
    exact ((cont_diff_on_top_iff_fderiv_within hs).1 hf).2 },
  { change (m.succ : with_top â„•) â‰¤ n at hmn,
    exact ((cont_diff_on_succ_iff_fderiv_within hs).1 (hf.of_le hmn)).2 }
end
lemma cont_diff_on.fderiv_of_open
  (hf : cont_diff_on ğ•œ n f s) (hs : is_open s) (hmn : m + 1 â‰¤ n) :
  cont_diff_on ğ•œ m (Î» y, fderiv ğ•œ f y) s :=
(hf.fderiv_within hs.unique_diff_on hmn).congr (Î» x hx, (fderiv_within_of_open hs hx).symm)
lemma cont_diff_on.continuous_on_fderiv_within
  (h : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) (hn : 1 â‰¤ n) :
  continuous_on (Î» x, fderiv_within ğ•œ f s x) s :=
((cont_diff_on_succ_iff_fderiv_within hs).1 (h.of_le hn)).2.continuous_on
lemma cont_diff_on.continuous_on_fderiv_of_open
  (h : cont_diff_on ğ•œ n f s) (hs : is_open s) (hn : 1 â‰¤ n) :
  continuous_on (Î» x, fderiv ğ•œ f x) s :=
((cont_diff_on_succ_iff_fderiv_of_open hs).1 (h.of_le hn)).2.continuous_on
lemma cont_diff_on.continuous_on_fderiv_within_apply
  (h : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) (hn : 1 â‰¤ n) :
  continuous_on (Î»p : E Ã— E, (fderiv_within ğ•œ f s p.1 : E â†’ F) p.2) (s Ã—Ë¢ (univ : set E)) :=
begin
  have A : continuous (Î»q : (E â†’L[ğ•œ] F) Ã— E, q.1 q.2) := is_bounded_bilinear_map_apply.continuous,
  have B : continuous_on (Î»p : E Ã— E, (fderiv_within ğ•œ f s p.1, p.2)) (s Ã—Ë¢ (univ : set E)),
  { apply continuous_on.prod _ continuous_snd.continuous_on,
    exact continuous_on.comp (h.continuous_on_fderiv_within hs hn) continuous_fst.continuous_on
      (prod_subset_preimage_fst _ _) },
  exact A.comp_continuous_on B
end
structure has_ftaylor_series_up_to (n : with_top â„•)
  (f : E â†’ F) (p : E â†’ formal_multilinear_series ğ•œ E F) : Prop :=
(zero_eq : âˆ€ x, (p x 0).uncurry0 = f x)
(fderiv  : âˆ€ (m : â„•) (hm : (m : with_top â„•) < n), âˆ€ x,
    has_fderiv_at (Î» y, p y m) (p x m.succ).curry_left x)
(cont    : âˆ€ (m : â„•) (hm : (m : with_top â„•) â‰¤ n), continuous (Î» x, p x m))
lemma has_ftaylor_series_up_to.zero_eq'
  (h : has_ftaylor_series_up_to n f p) (x : E) :
  p x 0 = (continuous_multilinear_curry_fin0 ğ•œ E F).symm (f x) :=
by { rw â† h.zero_eq x, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
lemma has_ftaylor_series_up_to_on_univ_iff :
  has_ftaylor_series_up_to_on n f p univ â†” has_ftaylor_series_up_to n f p :=
begin
  split,
  { assume H,
    split,
    { exact Î» x, H.zero_eq x (mem_univ x) },
    { assume m hm x,
      rw â† has_fderiv_within_at_univ,
      exact H.fderiv_within m hm x (mem_univ x) },
    { assume m hm,
      rw continuous_iff_continuous_on_univ,
      exact H.cont m hm } },
  { assume H,
    split,
    { exact Î» x hx, H.zero_eq x },
    { assume m hm x hx,
      rw has_fderiv_within_at_univ,
      exact H.fderiv m hm x },
    { assume m hm,
      rw â† continuous_iff_continuous_on_univ,
      exact H.cont m hm } }
end
lemma has_ftaylor_series_up_to.has_ftaylor_series_up_to_on
  (h : has_ftaylor_series_up_to n f p) (s : set E) :
  has_ftaylor_series_up_to_on n f p s :=
(has_ftaylor_series_up_to_on_univ_iff.2 h).mono (subset_univ _)
lemma has_ftaylor_series_up_to.of_le
  (h : has_ftaylor_series_up_to n f p) (hmn : m â‰¤ n) :
  has_ftaylor_series_up_to m f p :=
by { rw â† has_ftaylor_series_up_to_on_univ_iff at h âŠ¢, exact h.of_le hmn }
lemma has_ftaylor_series_up_to.continuous
  (h : has_ftaylor_series_up_to n f p) : continuous f :=
begin
  rw â† has_ftaylor_series_up_to_on_univ_iff at h,
  rw continuous_iff_continuous_on_univ,
  exact h.continuous_on
end
lemma has_ftaylor_series_up_to_zero_iff :
  has_ftaylor_series_up_to 0 f p â†” continuous f âˆ§ (âˆ€ x, (p x 0).uncurry0 = f x) :=
by simp [has_ftaylor_series_up_to_on_univ_iff.symm, continuous_iff_continuous_on_univ,
         has_ftaylor_series_up_to_on_zero_iff]
lemma has_ftaylor_series_up_to.has_fderiv_at
  (h : has_ftaylor_series_up_to n f p) (hn : 1 â‰¤ n) (x : E) :
  has_fderiv_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) x :=
begin
  rw [â† has_fderiv_within_at_univ],
  exact (has_ftaylor_series_up_to_on_univ_iff.2 h).has_fderiv_within_at hn (mem_univ _)
end
lemma has_ftaylor_series_up_to.differentiable
  (h : has_ftaylor_series_up_to n f p) (hn : 1 â‰¤ n) : differentiable ğ•œ f :=
Î» x, (h.has_fderiv_at hn x).differentiable_at
theorem has_ftaylor_series_up_to_succ_iff_right {n : â„•} :
  has_ftaylor_series_up_to ((n + 1) : â„•) f p â†”
  (âˆ€ x, (p x 0).uncurry0 = f x)
  âˆ§ (âˆ€ x, has_fderiv_at (Î» y, p y 0) (p x 1).curry_left x)
  âˆ§ has_ftaylor_series_up_to n
    (Î» x, continuous_multilinear_curry_fin1 ğ•œ E F (p x 1)) (Î» x, (p x).shift) :=
by simp only [has_ftaylor_series_up_to_on_succ_iff_right, â† has_ftaylor_series_up_to_on_univ_iff,
  mem_univ, forall_true_left, has_fderiv_within_at_univ]
variable (ğ•œ)
def cont_diff_at (n : with_top â„•) (f : E â†’ F) (x : E) :=
cont_diff_within_at ğ•œ n f univ x
variable {ğ•œ}
theorem cont_diff_within_at_univ :
  cont_diff_within_at ğ•œ n f univ x â†” cont_diff_at ğ•œ n f x :=
iff.rfl
lemma cont_diff_at_top :
  cont_diff_at ğ•œ âˆ f x â†” âˆ€ (n : â„•), cont_diff_at ğ•œ n f x :=
by simp [â† cont_diff_within_at_univ, cont_diff_within_at_top]
lemma cont_diff_at.cont_diff_within_at
  (h : cont_diff_at ğ•œ n f x) : cont_diff_within_at ğ•œ n f s x :=
h.mono (subset_univ _)
lemma cont_diff_within_at.cont_diff_at
  (h : cont_diff_within_at ğ•œ n f s x) (hx : s âˆˆ ğ“ x) :
  cont_diff_at ğ•œ n f x :=
by rwa [cont_diff_at, â† cont_diff_within_at_inter hx, univ_inter]
lemma cont_diff_at.congr_of_eventually_eq
  (h : cont_diff_at ğ•œ n f x) (hg : fâ‚ =á¶ [ğ“ x] f) :
  cont_diff_at ğ•œ n fâ‚ x :=
h.congr_of_eventually_eq' (by rwa nhds_within_univ) (mem_univ x)
lemma cont_diff_at.of_le
  (h : cont_diff_at ğ•œ n f x) (hmn : m â‰¤ n) :
  cont_diff_at ğ•œ m f x :=
h.of_le hmn
lemma cont_diff_at.continuous_at
  (h : cont_diff_at ğ•œ n f x) : continuous_at f x :=
by simpa [continuous_within_at_univ] using h.continuous_within_at
lemma cont_diff_at.differentiable_at
  (h : cont_diff_at ğ•œ n f x) (hn : 1 â‰¤ n) : differentiable_at ğ•œ f x :=
by simpa [hn, differentiable_within_at_univ] using h.differentiable_within_at
theorem cont_diff_at_succ_iff_has_fderiv_at {n : â„•} :
  cont_diff_at ğ•œ ((n + 1) : â„•) f x
  â†” (âˆƒ f' : E â†’ E â†’L[ğ•œ] F, (âˆƒ u âˆˆ ğ“ x, âˆ€ x âˆˆ u, has_fderiv_at f (f' x) x)
      âˆ§ cont_diff_at ğ•œ n f' x) :=
begin
  rw [â† cont_diff_within_at_univ, cont_diff_within_at_succ_iff_has_fderiv_within_at],
  simp only [nhds_within_univ, exists_prop, mem_univ, insert_eq_of_mem],
  split,
  { rintros âŸ¨u, H, f', h_fderiv, h_cont_diffâŸ©,
    rcases mem_nhds_iff.mp H with âŸ¨t, htu, ht, hxtâŸ©,
    refine âŸ¨f', âŸ¨t, _âŸ©, h_cont_diff.cont_diff_at HâŸ©,
    refine âŸ¨mem_nhds_iff.mpr âŸ¨t, subset.rfl, ht, hxtâŸ©, _âŸ©,
    intros y hyt,
    refine (h_fderiv y (htu hyt)).has_fderiv_at _,
    exact mem_nhds_iff.mpr âŸ¨t, htu, ht, hytâŸ© },
  { rintros âŸ¨f', âŸ¨u, H, h_fderivâŸ©, h_cont_diffâŸ©,
    refine âŸ¨u, H, f', _, h_cont_diff.cont_diff_within_atâŸ©,
    intros x hxu,
    exact (h_fderiv x hxu).has_fderiv_within_at }
end
protected theorem cont_diff_at.eventually {n : â„•} (h : cont_diff_at ğ•œ n f x) :
  âˆ€á¶  y in ğ“ x, cont_diff_at ğ•œ n f y :=
by simpa [nhds_within_univ] using h.eventually
variable (ğ•œ)
definition cont_diff (n : with_top â„•) (f : E â†’ F) :=
âˆƒ p : E â†’ formal_multilinear_series ğ•œ E F, has_ftaylor_series_up_to n f p
variable {ğ•œ}
theorem cont_diff_on_univ : cont_diff_on ğ•œ n f univ â†” cont_diff ğ•œ n f :=
begin
  split,
  { assume H,
    use ftaylor_series_within ğ•œ f univ,
    rw â† has_ftaylor_series_up_to_on_univ_iff,
    exact H.ftaylor_series_within unique_diff_on_univ },
  { rintros âŸ¨p, hpâŸ© x hx m hm,
    exact âŸ¨univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hmâŸ© }
end
lemma cont_diff_iff_cont_diff_at : cont_diff ğ•œ n f â†” âˆ€ x, cont_diff_at ğ•œ n f x :=
by simp [â† cont_diff_on_univ, cont_diff_on, cont_diff_at]
lemma cont_diff.cont_diff_at (h : cont_diff ğ•œ n f) : cont_diff_at ğ•œ n f x :=
cont_diff_iff_cont_diff_at.1 h x
lemma cont_diff.cont_diff_within_at (h : cont_diff ğ•œ n f) : cont_diff_within_at ğ•œ n f s x :=
h.cont_diff_at.cont_diff_within_at
lemma cont_diff_top : cont_diff ğ•œ âˆ f â†” âˆ€ (n : â„•), cont_diff ğ•œ n f :=
by simp [cont_diff_on_univ.symm, cont_diff_on_top]
lemma cont_diff_all_iff_nat : (âˆ€ n, cont_diff ğ•œ n f) â†” (âˆ€ n : â„•, cont_diff ğ•œ n f) :=
by simp only [â† cont_diff_on_univ, cont_diff_on_all_iff_nat]
lemma cont_diff.cont_diff_on (h : cont_diff ğ•œ n f) : cont_diff_on ğ•œ n f s :=
(cont_diff_on_univ.2 h).mono (subset_univ _)
@[simp] lemma cont_diff_zero : cont_diff ğ•œ 0 f â†” continuous f :=
begin
  rw [â† cont_diff_on_univ, continuous_iff_continuous_on_univ],
  exact cont_diff_on_zero
end
lemma cont_diff_at_zero : cont_diff_at ğ•œ 0 f x â†” âˆƒ u âˆˆ ğ“ x, continuous_on f u :=
by { rw â† cont_diff_within_at_univ, simp [cont_diff_within_at_zero, nhds_within_univ] }
theorem cont_diff_at_one_iff : cont_diff_at ğ•œ 1 f x â†”
  âˆƒ f' : E â†’ (E â†’L[ğ•œ] F), âˆƒ u âˆˆ ğ“ x, continuous_on f' u âˆ§ âˆ€ x âˆˆ u, has_fderiv_at f (f' x) x :=
by simp_rw [show (1 : with_top â„•) = (0 + 1 : â„•), from (zero_add 1).symm,
  cont_diff_at_succ_iff_has_fderiv_at, show ((0 : â„•) : with_top â„•) = 0, from rfl,
  cont_diff_at_zero, exists_mem_and_iff antitone_bforall antitone_continuous_on, and_comm]
lemma cont_diff.of_le (h : cont_diff ğ•œ n f) (hmn : m â‰¤ n) : cont_diff ğ•œ m f :=
cont_diff_on_univ.1 $ (cont_diff_on_univ.2 h).of_le hmn
lemma cont_diff.of_succ {n : â„•} (h : cont_diff ğ•œ (n + 1) f) : cont_diff ğ•œ n f :=
h.of_le $ with_top.coe_le_coe.mpr le_self_add
lemma cont_diff.one_of_succ {n : â„•} (h : cont_diff ğ•œ (n + 1) f) : cont_diff ğ•œ 1 f :=
h.of_le $ with_top.coe_le_coe.mpr le_add_self
lemma cont_diff.continuous (h : cont_diff ğ•œ n f) : continuous f :=
cont_diff_zero.1 (h.of_le bot_le)
lemma cont_diff.differentiable (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) : differentiable ğ•œ f :=
differentiable_on_univ.1 $ (cont_diff_on_univ.2 h).differentiable_on hn
variable (ğ•œ)
noncomputable def iterated_fderiv (n : â„•) (f : E â†’ F) :
  E â†’ (E [Ã—n]â†’L[ğ•œ] F) :=
nat.rec_on n
  (Î» x, continuous_multilinear_map.curry0 ğ•œ E (f x))
  (Î» n rec x, continuous_linear_map.uncurry_left (fderiv ğ•œ rec x))
def ftaylor_series (f : E â†’ F) (x : E) : formal_multilinear_series ğ•œ E F :=
Î» n, iterated_fderiv ğ•œ n f x
variable {ğ•œ}
@[simp] lemma iterated_fderiv_zero_apply (m : (fin 0) â†’ E) :
  (iterated_fderiv ğ•œ 0 f x : ((fin 0) â†’  E) â†’ F) m = f x := rfl
lemma iterated_fderiv_zero_eq_comp :
  iterated_fderiv ğ•œ 0 f = (continuous_multilinear_curry_fin0 ğ•œ E F).symm âˆ˜ f := rfl
lemma iterated_fderiv_succ_apply_left {n : â„•} (m : fin (n + 1) â†’ E):
  (iterated_fderiv ğ•œ (n + 1) f x : (fin (n + 1) â†’ E) â†’ F) m
  = (fderiv ğ•œ (iterated_fderiv ğ•œ n f) x : E â†’ (E [Ã—n]â†’L[ğ•œ] F)) (m 0) (tail m) := rfl
lemma iterated_fderiv_succ_eq_comp_left {n : â„•} :
  iterated_fderiv ğ•œ (n + 1) f =
  (continuous_multilinear_curry_left_equiv ğ•œ (Î»(i : fin (n + 1)), E) F)
    âˆ˜ (fderiv ğ•œ (iterated_fderiv ğ•œ n f)) := rfl
lemma iterated_fderiv_within_univ {n : â„•} :
  iterated_fderiv_within ğ•œ n f univ = iterated_fderiv ğ•œ n f :=
begin
  induction n with n IH,
  { ext x, simp },
  { ext x m,
    rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH,
        fderiv_within_univ] }
end
lemma iterated_fderiv_within_of_is_open (n : â„•) (hs : is_open s) :
  eq_on (iterated_fderiv_within ğ•œ n f s) (iterated_fderiv ğ•œ n f) s :=
begin
  induction n with n IH,
  { assume x hx,
    ext1 m,
    simp only [iterated_fderiv_within_zero_apply, iterated_fderiv_zero_apply] },
  { assume x hx,
    rw [iterated_fderiv_succ_eq_comp_left, iterated_fderiv_within_succ_eq_comp_left],
    dsimp,
    congr' 1,
    rw fderiv_within_of_open hs hx,
    apply filter.eventually_eq.fderiv_eq,
    filter_upwards [hs.mem_nhds hx],
    exact IH }
end
lemma ftaylor_series_within_univ :
  ftaylor_series_within ğ•œ f univ = ftaylor_series ğ•œ f :=
begin
  ext1 x, ext1 n,
  change iterated_fderiv_within ğ•œ n f univ x = iterated_fderiv ğ•œ n f x,
  rw iterated_fderiv_within_univ
end
theorem iterated_fderiv_succ_apply_right {n : â„•} (m : fin (n + 1) â†’ E) :
  (iterated_fderiv ğ•œ (n + 1) f x : (fin (n + 1) â†’ E) â†’ F) m
    = iterated_fderiv ğ•œ n (Î»y, fderiv ğ•œ f y) x (init m) (m (last n)) :=
begin
  rw [â† iterated_fderiv_within_univ, â† iterated_fderiv_within_univ, â† fderiv_within_univ],
  exact iterated_fderiv_within_succ_apply_right unique_diff_on_univ (mem_univ _) _
end
lemma iterated_fderiv_succ_eq_comp_right {n : â„•} :
  iterated_fderiv ğ•œ (n + 1) f x =
  ((continuous_multilinear_curry_right_equiv' ğ•œ n E F)
    âˆ˜ (iterated_fderiv ğ•œ n (Î»y, fderiv ğ•œ f y))) x :=
by { ext m, rw iterated_fderiv_succ_apply_right, refl }
@[simp] lemma iterated_fderiv_one_apply (m : (fin 1) â†’ E) :
  (iterated_fderiv ğ•œ 1 f x : ((fin 1) â†’ E) â†’ F) m
  = (fderiv ğ•œ f x : E â†’ F) (m 0) :=
by { rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply], refl }
theorem cont_diff_on_iff_ftaylor_series :
  cont_diff ğ•œ n f â†” has_ftaylor_series_up_to n f (ftaylor_series ğ•œ f) :=
begin
  split,
  { rw [â† cont_diff_on_univ, â† has_ftaylor_series_up_to_on_univ_iff,
        â† ftaylor_series_within_univ],
    exact Î» h, cont_diff_on.ftaylor_series_within h unique_diff_on_univ },
  { assume h, exact âŸ¨ftaylor_series ğ•œ f, hâŸ© }
end
lemma cont_diff_iff_continuous_differentiable :
  cont_diff ğ•œ n f â†”
  (âˆ€ (m : â„•), (m : with_top â„•) â‰¤ n â†’ continuous (Î» x, iterated_fderiv ğ•œ m f x))
  âˆ§ (âˆ€ (m : â„•), (m : with_top â„•) < n â†’ differentiable ğ•œ (Î» x, iterated_fderiv ğ•œ m f x)) :=
by simp [cont_diff_on_univ.symm, continuous_iff_continuous_on_univ,
    differentiable_on_univ.symm, iterated_fderiv_within_univ,
    cont_diff_on_iff_continuous_on_differentiable_on unique_diff_on_univ]
lemma cont_diff_of_differentiable_iterated_fderiv
  (h : âˆ€(m : â„•), (m : with_top â„•) â‰¤ n â†’ differentiable ğ•œ (iterated_fderiv ğ•œ m f)) :
  cont_diff ğ•œ n f :=
cont_diff_iff_continuous_differentiable.2
âŸ¨Î» m hm, (h m hm).continuous, Î» m hm, (h m (le_of_lt hm))âŸ©
theorem cont_diff_succ_iff_fderiv {n : â„•} :
  cont_diff ğ•œ ((n + 1) : â„•) f â†”
  differentiable ğ•œ f âˆ§ cont_diff ğ•œ n (Î» y, fderiv ğ•œ f y) :=
by simp only [â† cont_diff_on_univ, â† differentiable_on_univ, â† fderiv_within_univ,
  cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ]
theorem cont_diff_one_iff_fderiv :
  cont_diff ğ•œ 1 f â†” differentiable ğ•œ f âˆ§ continuous (fderiv ğ•œ f) :=
cont_diff_succ_iff_fderiv.trans $ iff.rfl.and cont_diff_zero
theorem cont_diff_top_iff_fderiv :
  cont_diff ğ•œ âˆ f â†”
  differentiable ğ•œ f âˆ§ cont_diff ğ•œ âˆ (Î» y, fderiv ğ•œ f y) :=
begin
  simp [cont_diff_on_univ.symm, differentiable_on_univ.symm, fderiv_within_univ.symm,
        - fderiv_within_univ],
  rw cont_diff_on_top_iff_fderiv_within unique_diff_on_univ,
end
lemma cont_diff.continuous_fderiv
  (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) :
  continuous (Î» x, fderiv ğ•œ f x) :=
((cont_diff_succ_iff_fderiv).1 (h.of_le hn)).2.continuous
lemma cont_diff.continuous_fderiv_apply
  (h : cont_diff ğ•œ n f) (hn : 1 â‰¤ n) :
  continuous (Î»p : E Ã— E, (fderiv ğ•œ f p.1 : E â†’ F) p.2) :=
begin
  have A : continuous (Î»q : (E â†’L[ğ•œ] F) Ã— E, q.1 q.2) := is_bounded_bilinear_map_apply.continuous,
  have B : continuous (Î»p : E Ã— E, (fderiv ğ•œ f p.1, p.2)),
  { apply continuous.prod_mk _ continuous_snd,
    exact continuous.comp (h.continuous_fderiv hn) continuous_fst },
  exact A.comp B
end
lemma iterated_fderiv_within_zero_fun {n : â„•} :
  iterated_fderiv ğ•œ n (Î» x : E, (0 : F)) = 0 :=
begin
  induction n with n IH,
  { ext m, simp },
  { ext x m,
    rw [iterated_fderiv_succ_apply_left, IH],
    change (fderiv ğ•œ (Î» (x : E), (0 : (E [Ã—n]â†’L[ğ•œ] F))) x : E â†’ (E [Ã—n]â†’L[ğ•œ] F)) (m 0) (tail m) = _,
    rw fderiv_const,
    refl }
end
lemma cont_diff_zero_fun :
  cont_diff ğ•œ n (Î» x : E, (0 : F)) :=
begin
  apply cont_diff_of_differentiable_iterated_fderiv (Î»m hm, _),
  rw iterated_fderiv_within_zero_fun,
  apply differentiable_const (0 : (E [Ã—m]â†’L[ğ•œ] F))
end
lemma cont_diff_const {c : F} : cont_diff ğ•œ n (Î»x : E, c) :=
begin
  suffices h : cont_diff ğ•œ âˆ (Î»x : E, c), by exact h.of_le le_top,
  rw cont_diff_top_iff_fderiv,
  refine âŸ¨differentiable_const c, _âŸ©,
  rw fderiv_const,
  exact cont_diff_zero_fun
end
lemma cont_diff_on_const {c : F} {s : set E} :
  cont_diff_on ğ•œ n (Î»x : E, c) s :=
cont_diff_const.cont_diff_on
lemma cont_diff_at_const {c : F} :
  cont_diff_at ğ•œ n (Î»x : E, c) x :=
cont_diff_const.cont_diff_at
lemma cont_diff_within_at_const {c : F} :
  cont_diff_within_at ğ•œ n (Î»x : E, c) s x :=
cont_diff_at_const.cont_diff_within_at
@[nontriviality] lemma cont_diff_of_subsingleton [subsingleton F] :
  cont_diff ğ•œ n f :=
by { rw [subsingleton.elim f (Î» _, 0)], exact cont_diff_const }
@[nontriviality] lemma cont_diff_at_of_subsingleton [subsingleton F] :
  cont_diff_at ğ•œ n f x :=
by { rw [subsingleton.elim f (Î» _, 0)], exact cont_diff_at_const }
@[nontriviality] lemma cont_diff_within_at_of_subsingleton [subsingleton F] :
  cont_diff_within_at ğ•œ n f s x :=
by { rw [subsingleton.elim f (Î» _, 0)], exact cont_diff_within_at_const }
@[nontriviality] lemma cont_diff_on_of_subsingleton [subsingleton F] :
  cont_diff_on ğ•œ n f s :=
by { rw [subsingleton.elim f (Î» _, 0)], exact cont_diff_on_const }
lemma is_bounded_linear_map.cont_diff (hf : is_bounded_linear_map ğ•œ f) :
  cont_diff ğ•œ n f :=
begin
  suffices h : cont_diff ğ•œ âˆ f, by exact h.of_le le_top,
  rw cont_diff_top_iff_fderiv,
  refine âŸ¨hf.differentiable, _âŸ©,
  simp_rw [hf.fderiv],
  exact cont_diff_const
end
lemma continuous_linear_map.cont_diff (f : E â†’L[ğ•œ] F) : cont_diff ğ•œ n f :=
f.is_bounded_linear_map.cont_diff
lemma continuous_linear_equiv.cont_diff (f : E â‰ƒL[ğ•œ] F) : cont_diff ğ•œ n f :=
(f : E â†’L[ğ•œ] F).cont_diff
lemma linear_isometry.cont_diff (f : E â†’â‚—áµ¢[ğ•œ] F) : cont_diff ğ•œ n f :=
f.to_continuous_linear_map.cont_diff
lemma linear_isometry_equiv.cont_diff (f : E â‰ƒâ‚—áµ¢[ğ•œ] F) : cont_diff ğ•œ n f :=
(f : E â†’L[ğ•œ] F).cont_diff
lemma cont_diff_id : cont_diff ğ•œ n (id : E â†’ E) :=
is_bounded_linear_map.id.cont_diff
lemma cont_diff_within_at_id {s x} : cont_diff_within_at ğ•œ n (id : E â†’ E) s x :=
cont_diff_id.cont_diff_within_at
lemma cont_diff_at_id {x} : cont_diff_at ğ•œ n (id : E â†’ E) x :=
cont_diff_id.cont_diff_at
lemma cont_diff_on_id {s} : cont_diff_on ğ•œ n (id : E â†’ E) s :=
cont_diff_id.cont_diff_on
lemma is_bounded_bilinear_map.cont_diff (hb : is_bounded_bilinear_map ğ•œ b) :
  cont_diff ğ•œ n b :=
begin
  suffices h : cont_diff ğ•œ âˆ b, by exact h.of_le le_top,
  rw cont_diff_top_iff_fderiv,
  refine âŸ¨hb.differentiable, _âŸ©,
  simp [hb.fderiv],
  exact hb.is_bounded_linear_map_deriv.cont_diff
end
lemma has_ftaylor_series_up_to_on.continuous_linear_map_comp (g : F â†’L[ğ•œ] G)
  (hf : has_ftaylor_series_up_to_on n f p s) :
  has_ftaylor_series_up_to_on n (g âˆ˜ f) (Î» x k, g.comp_continuous_multilinear_map (p x k)) s :=
begin
  set L : Î  m : â„•, (E [Ã—m]â†’L[ğ•œ] F) â†’L[ğ•œ] (E [Ã—m]â†’L[ğ•œ] G) :=
    Î» m, continuous_linear_map.comp_continuous_multilinear_mapL ğ•œ (Î» _, E) F G g,
  split,
  { exact Î» x hx, congr_arg g (hf.zero_eq x hx) },
  { intros m hm x hx,
    convert (L m).has_fderiv_at.comp_has_fderiv_within_at x (hf.fderiv_within m hm x hx) },
  { intros m hm,
    convert (L m).continuous.comp_continuous_on (hf.cont m hm) }
end
lemma cont_diff_within_at.continuous_linear_map_comp (g : F â†’L[ğ•œ] G)
  (hf : cont_diff_within_at ğ•œ n f s x) :
  cont_diff_within_at ğ•œ n (g âˆ˜ f) s x :=
begin
  assume m hm,
  rcases hf m hm with âŸ¨u, hu, p, hpâŸ©,
  exact âŸ¨u, hu, _, hp.continuous_linear_map_comp gâŸ©,
end
lemma cont_diff_at.continuous_linear_map_comp (g : F â†’L[ğ•œ] G) (hf : cont_diff_at ğ•œ n f x) :
  cont_diff_at ğ•œ n (g âˆ˜ f) x :=
cont_diff_within_at.continuous_linear_map_comp g hf
lemma cont_diff_on.continuous_linear_map_comp (g : F â†’L[ğ•œ] G) (hf : cont_diff_on ğ•œ n f s) :
  cont_diff_on ğ•œ n (g âˆ˜ f) s :=
Î» x hx, (hf x hx).continuous_linear_map_comp g
lemma cont_diff.continuous_linear_map_comp {f : E â†’ F} (g : F â†’L[ğ•œ] G)
  (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î»x, g (f x)) :=
cont_diff_on_univ.1 $ cont_diff_on.continuous_linear_map_comp
  _ (cont_diff_on_univ.2 hf)
lemma continuous_linear_equiv.comp_cont_diff_within_at_iff
  (e : F â‰ƒL[ğ•œ] G) :
  cont_diff_within_at ğ•œ n (e âˆ˜ f) s x â†” cont_diff_within_at ğ•œ n f s x :=
âŸ¨Î» H, by simpa only [(âˆ˜), e.symm.coe_coe, e.symm_apply_apply]
  using H.continuous_linear_map_comp (e.symm : G â†’L[ğ•œ] F),
  Î» H, H.continuous_linear_map_comp (e : F â†’L[ğ•œ] G)âŸ©
lemma continuous_linear_equiv.comp_cont_diff_on_iff
  (e : F â‰ƒL[ğ•œ] G) :
  cont_diff_on ğ•œ n (e âˆ˜ f) s â†” cont_diff_on ğ•œ n f s :=
by simp [cont_diff_on, e.comp_cont_diff_within_at_iff]
lemma has_ftaylor_series_up_to_on.comp_continuous_linear_map
  (hf : has_ftaylor_series_up_to_on n f p s) (g : G â†’L[ğ•œ] E) :
  has_ftaylor_series_up_to_on n (f âˆ˜ g)
    (Î» x k, (p (g x) k).comp_continuous_linear_map (Î» _, g)) (g â»Â¹' s) :=
begin
  let A : Î  m : â„•, (E [Ã—m]â†’L[ğ•œ] F) â†’ (G [Ã—m]â†’L[ğ•œ] F) :=
    Î» m h, h.comp_continuous_linear_map (Î» _, g),
  have hA : âˆ€ m, is_bounded_linear_map ğ•œ (A m) :=
    Î» m, is_bounded_linear_map_continuous_multilinear_map_comp_linear g,
  split,
  { assume x hx,
    simp only [(hf.zero_eq (g x) hx).symm, function.comp_app],
    change p (g x) 0 (Î» (i : fin 0), g 0) = p (g x) 0 0,
    rw continuous_linear_map.map_zero,
    refl },
  { assume m hm x hx,
    convert ((hA m).has_fderiv_at).comp_has_fderiv_within_at x
      ((hf.fderiv_within m hm (g x) hx).comp x (g.has_fderiv_within_at) (subset.refl _)),
    ext y v,
    change p (g x) (nat.succ m) (g âˆ˜ (cons y v)) = p (g x) m.succ (cons (g y) (g âˆ˜ v)),
    rw comp_cons },
  { assume m hm,
    exact (hA m).continuous.comp_continuous_on
      ((hf.cont m hm).comp g.continuous.continuous_on (subset.refl _)) }
end
lemma cont_diff_within_at.comp_continuous_linear_map {x : G}
  (g : G â†’L[ğ•œ] E) (hf : cont_diff_within_at ğ•œ n f s (g x)) :
  cont_diff_within_at ğ•œ n (f âˆ˜ g) (g â»Â¹' s) x :=
begin
  assume m hm,
  rcases hf m hm with âŸ¨u, hu, p, hpâŸ©,
  refine âŸ¨g â»Â¹' u, _, _, hp.comp_continuous_linear_map gâŸ©,
  apply continuous_within_at.preimage_mem_nhds_within',
  { exact g.continuous.continuous_within_at },
  { apply nhds_within_mono (g x) _ hu,
    rw image_insert_eq,
    exact insert_subset_insert (image_preimage_subset g s) }
end
lemma cont_diff_on.comp_continuous_linear_map
  (hf : cont_diff_on ğ•œ n f s) (g : G â†’L[ğ•œ] E) :
  cont_diff_on ğ•œ n (f âˆ˜ g) (g â»Â¹' s) :=
Î» x hx, (hf (g x) hx).comp_continuous_linear_map g
lemma cont_diff.comp_continuous_linear_map {f : E â†’ F} {g : G â†’L[ğ•œ] E}
  (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (f âˆ˜ g) :=
cont_diff_on_univ.1 $
cont_diff_on.comp_continuous_linear_map (cont_diff_on_univ.2 hf) _
lemma continuous_linear_equiv.cont_diff_within_at_comp_iff (e : G â‰ƒL[ğ•œ] E) :
  cont_diff_within_at ğ•œ n (f âˆ˜ e) (e â»Â¹' s) (e.symm x) â†”
  cont_diff_within_at ğ•œ n f s x :=
begin
  split,
  { assume H,
    simpa [â† preimage_comp, (âˆ˜)] using H.comp_continuous_linear_map (e.symm : E â†’L[ğ•œ] G) },
  { assume H,
    rw [â† e.apply_symm_apply x, â† e.coe_coe] at H,
    exact H.comp_continuous_linear_map _ },
end
lemma continuous_linear_equiv.cont_diff_on_comp_iff (e : G â‰ƒL[ğ•œ] E) :
  cont_diff_on ğ•œ n (f âˆ˜ e) (e â»Â¹' s) â†” cont_diff_on ğ•œ n f s :=
begin
  refine âŸ¨Î» H, _, Î» H, H.comp_continuous_linear_map (e : G â†’L[ğ•œ] E)âŸ©,
  have A : f = (f âˆ˜ e) âˆ˜ e.symm,
    by { ext y, simp only [function.comp_app], rw e.apply_symm_apply y },
  have B : e.symm â»Â¹' (e â»Â¹' s) = s,
    by { rw [â† preimage_comp, e.self_comp_symm], refl },
  rw [A, â† B],
  exact H.comp_continuous_linear_map (e.symm : E â†’L[ğ•œ] G)
end
lemma has_ftaylor_series_up_to_on.prod (hf : has_ftaylor_series_up_to_on n f p s)
  {g : E â†’ G} {q : E â†’ formal_multilinear_series ğ•œ E G} (hg : has_ftaylor_series_up_to_on n g q s) :
  has_ftaylor_series_up_to_on n (Î» y, (f y, g y)) (Î» y k, (p y k).prod (q y k)) s :=
begin
  set L := Î» m, continuous_multilinear_map.prodL ğ•œ (Î» i : fin m, E) F G,
  split,
  { assume x hx, rw [â† hf.zero_eq x hx, â† hg.zero_eq x hx], refl },
  { assume m hm x hx,
    convert (L m).has_fderiv_at.comp_has_fderiv_within_at x
      ((hf.fderiv_within m hm x hx).prod (hg.fderiv_within m hm x hx)) },
  { assume m hm,
    exact (L m).continuous.comp_continuous_on ((hf.cont m hm).prod (hg.cont m hm)) }
end
lemma cont_diff_within_at.prod {s : set E} {f : E â†’ F} {g : E â†’ G}
  (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) :
  cont_diff_within_at ğ•œ n (Î»x:E, (f x, g x)) s x :=
begin
  assume m hm,
  rcases hf m hm with âŸ¨u, hu, p, hpâŸ©,
  rcases hg m hm with âŸ¨v, hv, q, hqâŸ©,
  exact âŸ¨u âˆ© v, filter.inter_mem hu hv, _,
        (hp.mono (inter_subset_left u v)).prod (hq.mono (inter_subset_right u v))âŸ©
end
lemma cont_diff_on.prod {s : set E} {f : E â†’ F} {g : E â†’ G}
  (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) :
  cont_diff_on ğ•œ n (Î» x : E, (f x, g x)) s :=
Î» x hx, (hf x hx).prod (hg x hx)
lemma cont_diff_at.prod {f : E â†’ F} {g : E â†’ G}
  (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) :
  cont_diff_at ğ•œ n (Î» x : E, (f x, g x)) x :=
cont_diff_within_at_univ.1 $ cont_diff_within_at.prod
  (cont_diff_within_at_univ.2 hf)
  (cont_diff_within_at_univ.2 hg)
lemma cont_diff.prod {f : E â†’ F} {g : E â†’ G} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) :
  cont_diff ğ•œ n (Î» x : E, (f x, g x)) :=
cont_diff_on_univ.1 $ cont_diff_on.prod (cont_diff_on_univ.2 hf)
  (cont_diff_on_univ.2 hg)
private lemma cont_diff_on.comp_same_univ
  {Eu : Type u} [normed_group Eu] [normed_space ğ•œ Eu]
  {Fu : Type u} [normed_group Fu] [normed_space ğ•œ Fu]
  {Gu : Type u} [normed_group Gu] [normed_space ğ•œ Gu]
  {s : set Eu} {t : set Fu} {g : Fu â†’ Gu} {f : Eu â†’ Fu}
  (hg : cont_diff_on ğ•œ n g t) (hf : cont_diff_on ğ•œ n f s) (st : s âŠ† f â»Â¹' t) :
  cont_diff_on ğ•œ n (g âˆ˜ f) s :=
begin
  unfreezingI { induction n using with_top.nat_induction with n IH Itop generalizing Eu Fu Gu },
  { rw cont_diff_on_zero at hf hg âŠ¢,
    exact continuous_on.comp hg hf st },
  { rw cont_diff_on_succ_iff_has_fderiv_within_at at hg âŠ¢,
    assume x hx,
    rcases (cont_diff_on_succ_iff_has_fderiv_within_at.1 hf) x hx
      with âŸ¨u, hu, f', hf', f'_diffâŸ©,
    rcases hg (f x) (st hx) with âŸ¨v, hv, g', hg', g'_diffâŸ©,
    rw insert_eq_of_mem hx at hu âŠ¢,
    have xu : x âˆˆ u := mem_of_mem_nhds_within hx hu,
    let w := s âˆ© (u âˆ© fâ»Â¹' v),
    have wv : w âŠ† f â»Â¹' v := Î» y hy, hy.2.2,
    have wu : w âŠ† u := Î» y hy, hy.2.1,
    have ws : w âŠ† s := Î» y hy, hy.1,
    refine âŸ¨w, _, Î» y, (g' (f y)).comp (f' y), _, _âŸ©,
    show w âˆˆ ğ“[s] x,
    { apply filter.inter_mem self_mem_nhds_within,
      apply filter.inter_mem hu,
      apply continuous_within_at.preimage_mem_nhds_within',
      { rw â† continuous_within_at_inter' hu,
        exact (hf' x xu).differentiable_within_at.continuous_within_at.mono
          (inter_subset_right _ _) },
      { apply nhds_within_mono _ _ hv,
        exact subset.trans (image_subset_iff.mpr st) (subset_insert (f x) t) } },
    show âˆ€ y âˆˆ w,
      has_fderiv_within_at (g âˆ˜ f) ((g' (f y)).comp (f' y)) w y,
    { rintros y âŸ¨ys, yu, yvâŸ©,
      exact (hg' (f y) yv).comp y ((hf' y yu).mono wu) wv },
    show cont_diff_on ğ•œ n (Î» y, (g' (f y)).comp (f' y)) w,
    { have A : cont_diff_on ğ•œ n (Î» y, g' (f y)) w :=
        IH g'_diff ((hf.of_le (with_top.coe_le_coe.2 (nat.le_succ n))).mono ws) wv,
      have B : cont_diff_on ğ•œ n f' w := f'_diff.mono wu,
      have C : cont_diff_on ğ•œ n (Î» y, (g' (f y), f' y)) w := A.prod B,
      have D : cont_diff_on ğ•œ n (Î» p : (Fu â†’L[ğ•œ] Gu) Ã— (Eu â†’L[ğ•œ] Fu), p.1.comp p.2) univ :=
        is_bounded_bilinear_map_comp.cont_diff.cont_diff_on,
      exact IH D C (subset_univ _) } },
  { rw cont_diff_on_top at hf hg âŠ¢,
    exact Î» n, Itop n (hg n) (hf n) st }
end
lemma cont_diff_on.comp
  {s : set E} {t : set F} {g : F â†’ G} {f : E â†’ F}
  (hg : cont_diff_on ğ•œ n g t) (hf : cont_diff_on ğ•œ n f s) (st : s âŠ† f â»Â¹' t) :
  cont_diff_on ğ•œ n (g âˆ˜ f) s :=
begin
  let Eu := continuous_multilinear_map ğ•œ (Î» (i : fin 0), (E Ã— F Ã— G)) E,
  letI : normed_group Eu := by apply_instance,
  letI : normed_space ğ•œ Eu := by apply_instance,
  let Fu := continuous_multilinear_map ğ•œ (Î» (i : fin 0), (E Ã— F Ã— G)) F,
  letI : normed_group Fu := by apply_instance,
  letI : normed_space ğ•œ Fu := by apply_instance,
  let Gu := continuous_multilinear_map ğ•œ (Î» (i : fin 0), (E Ã— F Ã— G)) G,
  letI : normed_group Gu := by apply_instance,
  letI : normed_space ğ•œ Gu := by apply_instance,
lemma cont_diff_on.comp'
  {s : set E} {t : set F} {g : F â†’ G} {f : E â†’ F}
  (hg : cont_diff_on ğ•œ n g t) (hf : cont_diff_on ğ•œ n f s) :
  cont_diff_on ğ•œ n (g âˆ˜ f) (s âˆ© fâ»Â¹' t) :=
hg.comp (hf.mono (inter_subset_left _ _)) (inter_subset_right _ _)
lemma cont_diff.comp_cont_diff_on {s : set E} {g : F â†’ G} {f : E â†’ F}
  (hg : cont_diff ğ•œ n g) (hf : cont_diff_on ğ•œ n f s) :
  cont_diff_on ğ•œ n (g âˆ˜ f) s :=
(cont_diff_on_univ.2 hg).comp hf subset_preimage_univ
lemma cont_diff.comp {g : F â†’ G} {f : E â†’ F}
  (hg : cont_diff ğ•œ n g) (hf : cont_diff ğ•œ n f) :
  cont_diff ğ•œ n (g âˆ˜ f) :=
cont_diff_on_univ.1 $ cont_diff_on.comp (cont_diff_on_univ.2 hg)
  (cont_diff_on_univ.2 hf) (subset_univ _)
lemma cont_diff_within_at.comp
  {s : set E} {t : set F} {g : F â†’ G} {f : E â†’ F} (x : E)
  (hg : cont_diff_within_at ğ•œ n g t (f x))
  (hf : cont_diff_within_at ğ•œ n f s x) (st : s âŠ† f â»Â¹' t) :
  cont_diff_within_at ğ•œ n (g âˆ˜ f) s x :=
begin
  assume m hm,
  rcases hg.cont_diff_on hm with âŸ¨u, u_nhd, ut, huâŸ©,
  rcases hf.cont_diff_on hm with âŸ¨v, v_nhd, vs, hvâŸ©,
  have xmem : x âˆˆ f â»Â¹' u âˆ© v :=
    âŸ¨(mem_of_mem_nhds_within (mem_insert (f x) _) u_nhd : _),
    mem_of_mem_nhds_within (mem_insert x s) v_nhdâŸ©,
  have : f â»Â¹' u âˆˆ ğ“[insert x s] x,
  { apply hf.continuous_within_at.insert_self.preimage_mem_nhds_within',
    apply nhds_within_mono _ _ u_nhd,
    rw image_insert_eq,
    exact insert_subset_insert (image_subset_iff.mpr st) },
  have Z := ((hu.comp (hv.mono (inter_subset_right (f â»Â¹' u) v)) (inter_subset_left _ _))
    .cont_diff_within_at) xmem m le_rfl,
  have : ğ“[f â»Â¹' u âˆ© v] x = ğ“[insert x s] x,
  { have A : f â»Â¹' u âˆ© v = (insert x s) âˆ© (f â»Â¹' u âˆ© v),
    { apply subset.antisymm _ (inter_subset_right _ _),
      rintros y âŸ¨hy1, hy2âŸ©,
      simp [hy1, hy2, vs hy2] },
    rw [A, â† nhds_within_restrict''],
    exact filter.inter_mem this v_nhd },
  rwa [insert_eq_of_mem xmem, this] at Z,
end
lemma cont_diff_within_at.comp' {s : set E} {t : set F} {g : F â†’ G}
  {f : E â†’ F} (x : E)
  (hg : cont_diff_within_at ğ•œ n g t (f x)) (hf : cont_diff_within_at ğ•œ n f s x) :
  cont_diff_within_at ğ•œ n (g âˆ˜ f) (s âˆ© fâ»Â¹' t) x :=
hg.comp x (hf.mono (inter_subset_left _ _)) (inter_subset_right _ _)
lemma cont_diff_at.comp_cont_diff_within_at {n} (x : E)
  (hg : cont_diff_at ğ•œ n g (f x)) (hf : cont_diff_within_at ğ•œ n f s x) :
  cont_diff_within_at ğ•œ n (g âˆ˜ f) s x :=
hg.comp x hf (maps_to_univ _ _)
lemma cont_diff_at.comp (x : E)
  (hg : cont_diff_at ğ•œ n g (f x))
  (hf : cont_diff_at ğ•œ n f x) :
  cont_diff_at ğ•œ n (g âˆ˜ f) x :=
hg.comp x hf subset_preimage_univ
lemma cont_diff.comp_cont_diff_within_at
  {g : F â†’ G} {f : E â†’ F} (h : cont_diff ğ•œ n g)
  (hf : cont_diff_within_at ğ•œ n f t x) :
  cont_diff_within_at ğ•œ n (g âˆ˜ f) t x :=
begin
  have : cont_diff_within_at ğ•œ n g univ (f x) :=
    h.cont_diff_at.cont_diff_within_at,
  exact this.comp x hf (subset_univ _),
end
lemma cont_diff.comp_cont_diff_at {g : F â†’ G} {f : E â†’ F} (x : E)
  (hg : cont_diff ğ•œ n g) (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (g âˆ˜ f) x :=
hg.comp_cont_diff_within_at hf
lemma cont_diff_fst : cont_diff ğ•œ n (prod.fst : E Ã— F â†’ E) :=
is_bounded_linear_map.cont_diff is_bounded_linear_map.fst
lemma cont_diff.fst {f : E â†’ F Ã— G} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» x, (f x).1) :=
cont_diff_fst.comp hf
lemma cont_diff.fst' {f : E â†’ G} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» x : E Ã— F, f x.1) :=
hf.comp cont_diff_fst
lemma cont_diff_on_fst {s : set (E Ã— F)} : cont_diff_on ğ•œ n (prod.fst : E Ã— F â†’ E) s :=
cont_diff.cont_diff_on cont_diff_fst
lemma cont_diff_on.fst {f : E â†’ F Ã— G} {s : set E} (hf : cont_diff_on ğ•œ n f s) :
  cont_diff_on ğ•œ n (Î» x, (f x).1) s :=
cont_diff_fst.comp_cont_diff_on hf
lemma cont_diff_at_fst {p : E Ã— F} : cont_diff_at ğ•œ n (prod.fst : E Ã— F â†’ E) p :=
cont_diff_fst.cont_diff_at
lemma cont_diff_at.fst {f : E â†’ F Ã— G} {x : E} (hf : cont_diff_at ğ•œ n f x) :
  cont_diff_at ğ•œ n (Î» x, (f x).1) x :=
cont_diff_at_fst.comp x hf
lemma cont_diff_at.fst' {f : E â†’ G} {x : E} {y : F} (hf : cont_diff_at ğ•œ n f x) :
  cont_diff_at ğ•œ n (Î» x : E Ã— F, f x.1) (x, y) :=
cont_diff_at.comp (x, y) hf cont_diff_at_fst
lemma cont_diff_at.fst'' {f : E â†’ G} {x : E Ã— F} (hf : cont_diff_at ğ•œ n f x.1) :
  cont_diff_at ğ•œ n (Î» x : E Ã— F, f x.1) x :=
hf.comp x cont_diff_at_fst
lemma cont_diff_within_at_fst {s : set (E Ã— F)} {p : E Ã— F} :
  cont_diff_within_at ğ•œ n (prod.fst : E Ã— F â†’ E) s p :=
cont_diff_fst.cont_diff_within_at
lemma cont_diff_snd : cont_diff ğ•œ n (prod.snd : E Ã— F â†’ F) :=
is_bounded_linear_map.cont_diff is_bounded_linear_map.snd
lemma cont_diff.snd {f : E â†’ F Ã— G} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» x, (f x).2) :=
cont_diff_snd.comp hf
lemma cont_diff.snd' {f : F â†’ G} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î» x : E Ã— F, f x.2) :=
hf.comp cont_diff_snd
lemma cont_diff_on_snd {s : set (E Ã— F)} : cont_diff_on ğ•œ n (prod.snd : E Ã— F â†’ F) s :=
cont_diff.cont_diff_on cont_diff_snd
lemma cont_diff_on.snd {f : E â†’ F Ã— G} {s : set E} (hf : cont_diff_on ğ•œ n f s) :
  cont_diff_on ğ•œ n (Î» x, (f x).2) s :=
cont_diff_snd.comp_cont_diff_on hf
lemma cont_diff_at_snd {p : E Ã— F} : cont_diff_at ğ•œ n (prod.snd : E Ã— F â†’ F) p :=
cont_diff_snd.cont_diff_at
lemma cont_diff_at.snd {f : E â†’ F Ã— G} {x : E} (hf : cont_diff_at ğ•œ n f x) :
  cont_diff_at ğ•œ n (Î» x, (f x).2) x :=
cont_diff_at_snd.comp x hf
lemma cont_diff_at.snd' {f : F â†’ G} {x : E} {y : F} (hf : cont_diff_at ğ•œ n f y) :
  cont_diff_at ğ•œ n (Î» x : E Ã— F, f x.2) (x, y) :=
cont_diff_at.comp (x, y) hf cont_diff_at_snd
lemma cont_diff_at.snd'' {f : F â†’ G} {x : E Ã— F} (hf : cont_diff_at ğ•œ n f x.2) :
  cont_diff_at ğ•œ n (Î» x : E Ã— F, f x.2) x :=
hf.comp x cont_diff_at_snd
lemma cont_diff_within_at_snd {s : set (E Ã— F)} {p : E Ã— F} :
  cont_diff_within_at ğ•œ n (prod.snd : E Ã— F â†’ F) s p :=
cont_diff_snd.cont_diff_within_at
section n_ary
variables {Eâ‚ Eâ‚‚ Eâ‚ƒ Eâ‚„ : Type*}
variables [normed_group Eâ‚] [normed_group Eâ‚‚] [normed_group Eâ‚ƒ] [normed_group Eâ‚„]
variables [normed_space ğ•œ Eâ‚] [normed_space ğ•œ Eâ‚‚] [normed_space ğ•œ Eâ‚ƒ] [normed_space ğ•œ Eâ‚„]
lemma cont_diff.compâ‚‚ {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚}
  (hg : cont_diff ğ•œ n g) (hfâ‚ : cont_diff ğ•œ n fâ‚) (hfâ‚‚ : cont_diff ğ•œ n fâ‚‚) :
  cont_diff ğ•œ n (Î» x, g (fâ‚ x, fâ‚‚ x)) :=
hg.comp $ hfâ‚.prod hfâ‚‚
lemma cont_diff.compâ‚ƒ {g : Eâ‚ Ã— Eâ‚‚ Ã— Eâ‚ƒ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {fâ‚ƒ : F â†’ Eâ‚ƒ}
  (hg : cont_diff ğ•œ n g) (hfâ‚ : cont_diff ğ•œ n fâ‚) (hfâ‚‚ : cont_diff ğ•œ n fâ‚‚)
  (hfâ‚ƒ : cont_diff ğ•œ n fâ‚ƒ) : cont_diff ğ•œ n (Î» x, g (fâ‚ x, fâ‚‚ x, fâ‚ƒ x)) :=
hg.compâ‚‚ hfâ‚ $ hfâ‚‚.prod hfâ‚ƒ
lemma cont_diff.comp_cont_diff_onâ‚‚ {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {s : set F}
  (hg : cont_diff ğ•œ n g) (hfâ‚ : cont_diff_on ğ•œ n fâ‚ s) (hfâ‚‚ : cont_diff_on ğ•œ n fâ‚‚ s) :
  cont_diff_on ğ•œ n (Î» x, g (fâ‚ x, fâ‚‚ x)) s :=
hg.comp_cont_diff_on $ hfâ‚.prod hfâ‚‚
lemma cont_diff.comp_cont_diff_onâ‚ƒ {g : Eâ‚ Ã— Eâ‚‚ Ã— Eâ‚ƒ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {fâ‚ƒ : F â†’ Eâ‚ƒ}
  {s : set F} (hg : cont_diff ğ•œ n g) (hfâ‚ : cont_diff_on ğ•œ n fâ‚ s) (hfâ‚‚ : cont_diff_on ğ•œ n fâ‚‚ s)
  (hfâ‚ƒ : cont_diff_on ğ•œ n fâ‚ƒ s) : cont_diff_on ğ•œ n (Î» x, g (fâ‚ x, fâ‚‚ x, fâ‚ƒ x)) s :=
hg.comp_cont_diff_onâ‚‚ hfâ‚ $ hfâ‚‚.prod hfâ‚ƒ
end n_ary
lemma cont_diff_prod_assoc : cont_diff ğ•œ âŠ¤ $ equiv.prod_assoc E F G :=
(linear_isometry_equiv.prod_assoc ğ•œ E F G).cont_diff
lemma cont_diff_prod_assoc_symm : cont_diff ğ•œ âŠ¤ $ (equiv.prod_assoc E F G).symm :=
(linear_isometry_equiv.prod_assoc ğ•œ E F G).symm.cont_diff
lemma cont_diff_on_fderiv_within_apply {m n : with_top  â„•} {s : set E}
  {f : E â†’ F} (hf : cont_diff_on ğ•œ n f s) (hs : unique_diff_on ğ•œ s) (hmn : m + 1 â‰¤ n) :
  cont_diff_on ğ•œ m (Î»p : E Ã— E, (fderiv_within ğ•œ f s p.1 : E â†’L[ğ•œ] F) p.2)
  (s Ã—Ë¢ (univ : set E)) :=
begin
  have A : cont_diff ğ•œ m (Î»p : (E â†’L[ğ•œ] F) Ã— E, p.1 p.2),
  { apply is_bounded_bilinear_map.cont_diff,
    exact is_bounded_bilinear_map_apply },
  have B : cont_diff_on ğ•œ m
    (Î» (p : E Ã— E), ((fderiv_within ğ•œ f s p.fst), p.snd)) (s Ã—Ë¢ univ),
  { apply cont_diff_on.prod _ _,
    { have I : cont_diff_on ğ•œ m (Î» (x : E), fderiv_within ğ•œ f s x) s :=
        hf.fderiv_within hs hmn,
      have J : cont_diff_on ğ•œ m (Î» (x : E Ã— E), x.1) (s Ã—Ë¢ univ) :=
        cont_diff_fst.cont_diff_on,
      exact cont_diff_on.comp I J (prod_subset_preimage_fst _ _) },
    { apply cont_diff.cont_diff_on _ ,
      apply is_bounded_linear_map.snd.cont_diff } },
  exact A.comp_cont_diff_on B
end
lemma cont_diff.cont_diff_fderiv_apply {f : E â†’ F}
  (hf : cont_diff ğ•œ n f) (hmn : m + 1 â‰¤ n) :
  cont_diff ğ•œ m (Î»p : E Ã— E, (fderiv ğ•œ f p.1 : E â†’L[ğ•œ] F) p.2) :=
begin
  rw â† cont_diff_on_univ at âŠ¢ hf,
  rw [â† fderiv_within_univ, â† univ_prod_univ],
  exact cont_diff_on_fderiv_within_apply hf unique_diff_on_univ hmn
end
section pi
variables {Î¹ Î¹' : Type*} [fintype Î¹] [fintype Î¹'] {F' : Î¹ â†’ Type*} [Î  i, normed_group (F' i)]
  [Î  i, normed_space ğ•œ (F' i)] {Ï† : Î  i, E â†’ F' i}
  {p' : Î  i, E â†’ formal_multilinear_series ğ•œ E (F' i)}
  {Î¦ : E â†’ Î  i, F' i} {P' : E â†’ formal_multilinear_series ğ•œ E (Î  i, F' i)}
lemma has_ftaylor_series_up_to_on_pi :
  has_ftaylor_series_up_to_on n (Î» x i, Ï† i x)
    (Î» x m, continuous_multilinear_map.pi (Î» i, p' i x m)) s â†”
    âˆ€ i, has_ftaylor_series_up_to_on n (Ï† i) (p' i) s :=
begin
  set pr := @continuous_linear_map.proj ğ•œ _ Î¹ F' _ _ _,
  letI : Î  (m : â„•) (i : Î¹), normed_space ğ•œ (E [Ã—m]â†’L[ğ•œ] (F' i)) := Î» m i, infer_instance,
  set L : Î  m : â„•, (Î  i, E [Ã—m]â†’L[ğ•œ] (F' i)) â‰ƒâ‚—áµ¢[ğ•œ] (E [Ã—m]â†’L[ğ•œ] (Î  i, F' i)) :=
    Î» m, continuous_multilinear_map.piâ‚—áµ¢ _ _,
  refine âŸ¨Î» h i, _, Î» h, âŸ¨Î» x hx, _, _, _âŸ©âŸ©,
  { convert h.continuous_linear_map_comp (pr i),
    ext, refl },
  { ext1 i,
    exact (h i).zero_eq x hx },
  { intros m hm x hx,
    have := has_fderiv_within_at_pi.2 (Î» i, (h i).fderiv_within m hm x hx),
    convert (L m).has_fderiv_at.comp_has_fderiv_within_at x this },
  { intros m hm,
    have := continuous_on_pi.2 (Î» i, (h i).cont m hm),
    convert (L m).continuous.comp_continuous_on this }
end
@[simp] lemma has_ftaylor_series_up_to_on_pi' :
  has_ftaylor_series_up_to_on n Î¦ P' s â†”
    âˆ€ i, has_ftaylor_series_up_to_on n (Î» x, Î¦ x i)
      (Î» x m, (@continuous_linear_map.proj ğ•œ _ Î¹ F' _ _ _ i).comp_continuous_multilinear_map
        (P' x m)) s :=
by { convert has_ftaylor_series_up_to_on_pi, ext, refl }
lemma cont_diff_within_at_pi :
  cont_diff_within_at ğ•œ n Î¦ s x â†”
    âˆ€ i, cont_diff_within_at ğ•œ n (Î» x, Î¦ x i) s x :=
begin
  set pr := @continuous_linear_map.proj ğ•œ _ Î¹ F' _ _ _,
  refine âŸ¨Î» h i, h.continuous_linear_map_comp (pr i), Î» h m hm, _âŸ©,
  choose u hux p hp using Î» i, h i m hm,
  exact âŸ¨â‹‚ i, u i, filter.Inter_mem.2 hux, _,
    has_ftaylor_series_up_to_on_pi.2 (Î» i, (hp i).mono $ Inter_subset _ _)âŸ©,
end
lemma cont_diff_on_pi :
  cont_diff_on ğ•œ n Î¦ s â†” âˆ€ i, cont_diff_on ğ•œ n (Î» x, Î¦ x i) s :=
âŸ¨Î» h i x hx, cont_diff_within_at_pi.1 (h x hx) _,
  Î» h x hx, cont_diff_within_at_pi.2 (Î» i, h i x hx)âŸ©
lemma cont_diff_at_pi :
  cont_diff_at ğ•œ n Î¦ x â†” âˆ€ i, cont_diff_at ğ•œ n (Î» x, Î¦ x i) x :=
cont_diff_within_at_pi
lemma cont_diff_pi :
  cont_diff ğ•œ n Î¦ â†” âˆ€ i, cont_diff ğ•œ n (Î» x, Î¦ x i) :=
by simp only [â† cont_diff_on_univ, cont_diff_on_pi]
variables (ğ•œ E)
lemma cont_diff_apply (i : Î¹) : cont_diff ğ•œ n (Î» (f : Î¹ â†’ E), f i) :=
cont_diff_pi.mp cont_diff_id i
lemma cont_diff_apply_apply (i : Î¹) (j : Î¹') : cont_diff ğ•œ n (Î» (f : Î¹ â†’ Î¹' â†’ E), f i j) :=
cont_diff_pi.mp (cont_diff_apply ğ•œ (Î¹' â†’ E) i) j
variables {ğ•œ E}
end pi
lemma cont_diff_add : cont_diff ğ•œ n (Î»p : F Ã— F, p.1 + p.2) :=
(is_bounded_linear_map.fst.add is_bounded_linear_map.snd).cont_diff
lemma cont_diff_within_at.add {s : set E} {f g : E â†’ F}
  (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) :
  cont_diff_within_at ğ•œ n (Î»x, f x + g x) s x :=
cont_diff_add.cont_diff_within_at.comp x (hf.prod hg) subset_preimage_univ
lemma cont_diff_at.add {f g : E â†’ F} (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) :
  cont_diff_at ğ•œ n (Î»x, f x + g x) x :=
by rw [â† cont_diff_within_at_univ] at *; exact hf.add hg
lemma cont_diff.add {f g : E â†’ F} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) :
  cont_diff ğ•œ n (Î»x, f x + g x) :=
cont_diff_add.comp (hf.prod hg)
lemma cont_diff_on.add {s : set E} {f g : E â†’ F}
  (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) :
  cont_diff_on ğ•œ n (Î»x, f x + g x) s :=
Î» x hx, (hf x hx).add (hg x hx)
lemma cont_diff_neg : cont_diff ğ•œ n (Î»p : F, -p) :=
is_bounded_linear_map.id.neg.cont_diff
lemma cont_diff_within_at.neg {s : set E} {f : E â†’ F}
  (hf : cont_diff_within_at ğ•œ n f s x) : cont_diff_within_at ğ•œ n (Î»x, -f x) s x :=
cont_diff_neg.cont_diff_within_at.comp x hf subset_preimage_univ
lemma cont_diff_at.neg {f : E â†’ F}
  (hf : cont_diff_at ğ•œ n f x) : cont_diff_at ğ•œ n (Î»x, -f x) x :=
by rw â† cont_diff_within_at_univ at *; exact hf.neg
lemma cont_diff.neg {f : E â†’ F} (hf : cont_diff ğ•œ n f) : cont_diff ğ•œ n (Î»x, -f x) :=
cont_diff_neg.comp hf
lemma cont_diff_on.neg {s : set E} {f : E â†’ F}
  (hf : cont_diff_on ğ•œ n f s) : cont_diff_on ğ•œ n (Î»x, -f x) s :=
Î» x hx, (hf x hx).neg
lemma cont_diff_within_at.sub {s : set E} {f g : E â†’ F}
  (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) :
  cont_diff_within_at ğ•œ n (Î»x, f x - g x) s x :=
by simpa only [sub_eq_add_neg] using hf.add hg.neg
lemma cont_diff_at.sub {f g : E â†’ F}
  (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) :
  cont_diff_at ğ•œ n (Î»x, f x - g x) x :=
by simpa only [sub_eq_add_neg] using hf.add hg.neg
lemma cont_diff_on.sub {s : set E} {f g : E â†’ F}
  (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) :
  cont_diff_on ğ•œ n (Î»x, f x - g x) s :=
by simpa only [sub_eq_add_neg] using hf.add hg.neg
lemma cont_diff.sub {f g : E â†’ F}
  (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) : cont_diff ğ•œ n (Î»x, f x - g x) :=
by simpa only [sub_eq_add_neg] using hf.add hg.neg
lemma cont_diff_within_at.sum
  {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {s : finset Î¹} {t : set E} {x : E}
  (h : âˆ€ i âˆˆ s, cont_diff_within_at ğ•œ n (Î» x, f i x) t x) :
  cont_diff_within_at ğ•œ n (Î» x, (âˆ‘ i in s, f i x)) t x :=
begin
  classical,
  induction s using finset.induction_on with i s is IH,
  { simp [cont_diff_within_at_const] },
  { simp only [is, finset.sum_insert, not_false_iff],
    exact (h _ (finset.mem_insert_self i s)).add (IH (Î» j hj, h _ (finset.mem_insert_of_mem hj))) }
end
lemma cont_diff_at.sum
  {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {s : finset Î¹} {x : E}
  (h : âˆ€ i âˆˆ s, cont_diff_at ğ•œ n (Î» x, f i x) x) :
  cont_diff_at ğ•œ n (Î» x, (âˆ‘ i in s, f i x)) x :=
by rw [â† cont_diff_within_at_univ] at *; exact cont_diff_within_at.sum h
lemma cont_diff_on.sum
  {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {s : finset Î¹} {t : set E}
  (h : âˆ€ i âˆˆ s, cont_diff_on ğ•œ n (Î» x, f i x) t) :
  cont_diff_on ğ•œ n (Î» x, (âˆ‘ i in s, f i x)) t :=
Î» x hx, cont_diff_within_at.sum (Î» i hi, h i hi x hx)
lemma cont_diff.sum
  {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {s : finset Î¹}
  (h : âˆ€ i âˆˆ s, cont_diff ğ•œ n (Î» x, f i x)) :
  cont_diff ğ•œ n (Î» x, (âˆ‘ i in s, f i x)) :=
by simp [â† cont_diff_on_univ] at *; exact cont_diff_on.sum h
lemma cont_diff_mul : cont_diff ğ•œ n (Î» p : ğ•œ Ã— ğ•œ, p.1 * p.2) :=
is_bounded_bilinear_map_mul.cont_diff
lemma cont_diff_within_at.mul {s : set E} {f g : E â†’ ğ•œ}
  (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) :
  cont_diff_within_at ğ•œ n (Î» x, f x * g x) s x :=
cont_diff_mul.cont_diff_within_at.comp x (hf.prod hg) subset_preimage_univ
lemma cont_diff_at.mul {f g : E â†’ ğ•œ}
  (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) :
  cont_diff_at ğ•œ n (Î» x, f x * g x) x :=
by rw [â† cont_diff_within_at_univ] at *; exact hf.mul hg
lemma cont_diff_on.mul {s : set E} {f g : E â†’ ğ•œ}
  (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) :
  cont_diff_on ğ•œ n (Î» x, f x * g x) s :=
Î» x hx, (hf x hx).mul (hg x hx)
lemma cont_diff.mul {f g : E â†’ ğ•œ} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) :
  cont_diff ğ•œ n (Î» x, f x * g x) :=
cont_diff_mul.comp (hf.prod hg)
lemma cont_diff_within_at.div_const {f : E â†’ ğ•œ} {n} {c : ğ•œ}
  (hf : cont_diff_within_at ğ•œ n f s x) :
  cont_diff_within_at ğ•œ n (Î» x, f x / c) s x :=
by simpa only [div_eq_mul_inv] using hf.mul cont_diff_within_at_const
lemma cont_diff_at.div_const {f : E â†’ ğ•œ} {n} {c : ğ•œ} (hf : cont_diff_at ğ•œ n f x) :
  cont_diff_at ğ•œ n (Î» x, f x / c) x :=
by simpa only [div_eq_mul_inv] using hf.mul cont_diff_at_const
lemma cont_diff_on.div_const {f : E â†’ ğ•œ} {n} {c : ğ•œ} (hf : cont_diff_on ğ•œ n f s) :
  cont_diff_on ğ•œ n (Î» x, f x / c) s :=
by simpa only [div_eq_mul_inv] using hf.mul cont_diff_on_const
lemma cont_diff.div_const {f : E â†’ ğ•œ} {n} {c : ğ•œ} (hf : cont_diff ğ•œ n f) :
  cont_diff ğ•œ n (Î» x, f x / c) :=
by simpa only [div_eq_mul_inv] using hf.mul cont_diff_const
lemma cont_diff.pow {f : E â†’ ğ•œ}
  (hf : cont_diff ğ•œ n f) :
  âˆ€ m : â„•, cont_diff ğ•œ n (Î» x, (f x) ^ m)
| 0       := by simpa using cont_diff_const
| (m + 1) := by simpa [pow_succ] using hf.mul (cont_diff.pow m)
lemma cont_diff_at.pow {f : E â†’ ğ•œ} (hf : cont_diff_at ğ•œ n f x)
  (m : â„•) : cont_diff_at ğ•œ n (Î» y, f y ^ m) x :=
(cont_diff_id.pow m).cont_diff_at.comp x hf
lemma cont_diff_within_at.pow {f : E â†’ ğ•œ}
  (hf : cont_diff_within_at ğ•œ n f s x) (m : â„•) :
  cont_diff_within_at ğ•œ n (Î» y, f y ^ m) s x :=
(cont_diff_id.pow m).cont_diff_at.comp_cont_diff_within_at x hf
lemma cont_diff_on.pow {f : E â†’ ğ•œ}
  (hf : cont_diff_on ğ•œ n f s) (m : â„•) :
  cont_diff_on ğ•œ n (Î» y, f y ^ m) s :=
Î» y hy, (hf y hy).pow m
lemma cont_diff_smul : cont_diff ğ•œ n (Î» p : ğ•œ Ã— F, p.1 â€¢ p.2) :=
is_bounded_bilinear_map_smul.cont_diff
lemma cont_diff_within_at.smul {s : set E} {f : E â†’ ğ•œ} {g : E â†’ F}
  (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g s x) :
  cont_diff_within_at ğ•œ n (Î» x, f x â€¢ g x) s x :=
cont_diff_smul.cont_diff_within_at.comp x (hf.prod hg) subset_preimage_univ
lemma cont_diff_at.smul {f : E â†’ ğ•œ} {g : E â†’ F}
  (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g x) :
  cont_diff_at ğ•œ n (Î» x, f x â€¢ g x) x :=
by rw [â† cont_diff_within_at_univ] at *; exact hf.smul hg
lemma cont_diff.smul {f : E â†’ ğ•œ} {g : E â†’ F} (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) :
  cont_diff ğ•œ n (Î» x, f x â€¢ g x) :=
cont_diff_smul.comp (hf.prod hg)
lemma cont_diff_on.smul {s : set E} {f : E â†’ ğ•œ} {g : E â†’ F}
  (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g s) :
  cont_diff_on ğ•œ n (Î» x, f x â€¢ g x) s :=
Î» x hx, (hf x hx).smul (hg x hx)
section prod_map
variables {E' : Type*} [normed_group E'] [normed_space ğ•œ E']
variables {F' : Type*} [normed_group F'] [normed_space ğ•œ F']
lemma cont_diff_within_at.prod_map'
  {s : set E} {t : set E'} {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'}
  (hf : cont_diff_within_at ğ•œ n f s p.1) (hg : cont_diff_within_at ğ•œ n g t p.2) :
  cont_diff_within_at ğ•œ n (prod.map f g) (s Ã—Ë¢ t) p :=
(hf.comp p cont_diff_within_at_fst (prod_subset_preimage_fst _ _)).prod
  (hg.comp p cont_diff_within_at_snd (prod_subset_preimage_snd _ _))
lemma cont_diff_within_at.prod_map
  {s : set E} {t : set E'} {f : E â†’ F} {g : E' â†’ F'} {x : E} {y : E'}
  (hf : cont_diff_within_at ğ•œ n f s x) (hg : cont_diff_within_at ğ•œ n g t y) :
  cont_diff_within_at ğ•œ n (prod.map f g) (s Ã—Ë¢ t) (x, y) :=
cont_diff_within_at.prod_map' hf hg
lemma cont_diff_on.prod_map {E' : Type*} [normed_group E'] [normed_space ğ•œ E']
  {F' : Type*} [normed_group F'] [normed_space ğ•œ F']
  {s : set E} {t : set E'} {f : E â†’ F} {g : E' â†’ F'}
  (hf : cont_diff_on ğ•œ n f s) (hg : cont_diff_on ğ•œ n g t) :
  cont_diff_on ğ•œ n (prod.map f g) (s Ã—Ë¢ t) :=
(hf.comp cont_diff_on_fst (prod_subset_preimage_fst _ _)).prod
  (hg.comp (cont_diff_on_snd) (prod_subset_preimage_snd _ _))
lemma cont_diff_at.prod_map {f : E â†’ F} {g : E' â†’ F'} {x : E} {y : E'}
  (hf : cont_diff_at ğ•œ n f x) (hg : cont_diff_at ğ•œ n g y) :
  cont_diff_at ğ•œ n (prod.map f g) (x, y) :=
begin
  rw cont_diff_at at *,
  convert hf.prod_map hg,
  simp only [univ_prod_univ]
end
lemma cont_diff_at.prod_map' {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'}
  (hf : cont_diff_at ğ•œ n f p.1) (hg : cont_diff_at ğ•œ n g p.2) :
  cont_diff_at ğ•œ n (prod.map f g) p :=
begin
  rcases p,
  exact cont_diff_at.prod_map hf hg
end
lemma cont_diff.prod_map {f : E â†’ F} {g : E' â†’ F'}
  (hf : cont_diff ğ•œ n f) (hg : cont_diff ğ•œ n g) :
  cont_diff ğ•œ n (prod.map f g) :=
begin
  rw cont_diff_iff_cont_diff_at at *,
  exact Î» âŸ¨x, yâŸ©, (hf x).prod_map (hg y)
end
lemma cont_diff_prod_mk_left (fâ‚€ : F) : cont_diff ğ•œ n (Î» e : E, (e, fâ‚€)) :=
cont_diff_id.prod cont_diff_const
lemma cont_diff_prod_mk_right (eâ‚€ : E) : cont_diff ğ•œ n (Î» f : F, (eâ‚€, f)) :=
cont_diff_const.prod cont_diff_id
end prod_map
lemma cont_diff.clm_comp {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F}
  (hg : cont_diff ğ•œ n g) (hf : cont_diff ğ•œ n f) :
  cont_diff ğ•œ n (Î» x, (g x).comp (f x)) :=
is_bounded_bilinear_map_comp.cont_diff.compâ‚‚ hg hf
lemma cont_diff_on.clm_comp {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F}
  {s : set X} (hg : cont_diff_on ğ•œ n g s) (hf : cont_diff_on ğ•œ n f s) :
  cont_diff_on ğ•œ n (Î» x, (g x).comp (f x)) s :=
is_bounded_bilinear_map_comp.cont_diff.comp_cont_diff_onâ‚‚ hg hf
section algebra_inverse
variables (ğ•œ) {R : Type*} [normed_ring R] [normed_algebra ğ•œ R]
open normed_ring continuous_linear_map ring
lemma cont_diff_at_ring_inverse [complete_space R] (x : RË£) :
  cont_diff_at ğ•œ n ring.inverse (x : R) :=
begin
  induction n using with_top.nat_induction with n IH Itop,
  { intros m hm,
    refine âŸ¨{y : R | is_unit y}, _, _âŸ©,
    { simp [nhds_within_univ],
      exact x.nhds },
    { use (ftaylor_series_within ğ•œ inverse univ),
      rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff],
      split,
      { rintros _ âŸ¨x', rflâŸ©,
        exact (inverse_continuous_at x').continuous_within_at },
      { simp [ftaylor_series_within] } } },
  { apply cont_diff_at_succ_iff_has_fderiv_at.mpr,
    refine âŸ¨Î» (x : R), - lmul_left_right ğ•œ R (inverse x) (inverse x), _, _âŸ©,
    { refine âŸ¨{y : R | is_unit y}, x.nhds, _âŸ©,
      rintros _ âŸ¨y, rflâŸ©,
      rw [inverse_unit],
      exact has_fderiv_at_ring_inverse y },
    { convert (lmul_left_right_is_bounded_bilinear ğ•œ R).cont_diff.neg.comp_cont_diff_at
        (x : R) (IH.prod IH) } },
  { exact cont_diff_at_top.mpr Itop }
end
variables (ğ•œ) {ğ•œ' : Type*} [normed_field ğ•œ'] [normed_algebra ğ•œ ğ•œ'] [complete_space ğ•œ']
lemma cont_diff_at_inv {x : ğ•œ'} (hx : x â‰  0) {n} :
  cont_diff_at ğ•œ n has_inv.inv x :=
by simpa only [ring.inverse_eq_inv'] using cont_diff_at_ring_inverse ğ•œ (units.mk0 x hx)
lemma cont_diff_on_inv {n} : cont_diff_on ğ•œ n (has_inv.inv : ğ•œ' â†’ ğ•œ') {0}á¶œ :=
Î» x hx, (cont_diff_at_inv ğ•œ hx).cont_diff_within_at
variable {ğ•œ}
section map_inverse
open continuous_linear_map
lemma cont_diff_at_map_inverse [complete_space E] (e : E â‰ƒL[ğ•œ] F) :
  cont_diff_at ğ•œ n inverse (e : E â†’L[ğ•œ] F) :=
begin
  nontriviality E,
theorem local_homeomorph.cont_diff_at_symm [complete_space E]
  (f : local_homeomorph E F) {fâ‚€' : E â‰ƒL[ğ•œ] F} {a : F} (ha : a âˆˆ f.target)
  (hfâ‚€' : has_fderiv_at f (fâ‚€' : E â†’L[ğ•œ] F) (f.symm a)) (hf : cont_diff_at ğ•œ n f (f.symm a)) :
  cont_diff_at ğ•œ n f.symm a :=
begin
theorem homeomorph.cont_diff_symm [complete_space E] (f : E â‰ƒâ‚œ F) {fâ‚€' : E â†’ E â‰ƒL[ğ•œ] F}
  (hfâ‚€' : âˆ€ a, has_fderiv_at f (fâ‚€' a : E â†’L[ğ•œ] F) a) (hf : cont_diff ğ•œ n (f : E â†’ F)) :
  cont_diff ğ•œ n (f.symm : F â†’ E) :=
cont_diff_iff_cont_diff_at.2 $ Î» x,
  f.to_local_homeomorph.cont_diff_at_symm (mem_univ x) (hfâ‚€' _) hf.cont_diff_at
theorem local_homeomorph.cont_diff_at_symm_deriv [complete_space ğ•œ]
  (f : local_homeomorph ğ•œ ğ•œ) {fâ‚€' a : ğ•œ} (hâ‚€ : fâ‚€' â‰  0) (ha : a âˆˆ f.target)
  (hfâ‚€' : has_deriv_at f fâ‚€' (f.symm a)) (hf : cont_diff_at ğ•œ n f (f.symm a)) :
  cont_diff_at ğ•œ n f.symm a :=
f.cont_diff_at_symm ha (hfâ‚€'.has_fderiv_at_equiv hâ‚€) hf
theorem homeomorph.cont_diff_symm_deriv [complete_space ğ•œ] (f : ğ•œ â‰ƒâ‚œ ğ•œ) {f' : ğ•œ â†’ ğ•œ}
  (hâ‚€ : âˆ€ x, f' x â‰  0) (hf' : âˆ€ x, has_deriv_at f (f' x) x) (hf : cont_diff ğ•œ n (f : ğ•œ â†’ ğ•œ)) :
  cont_diff ğ•œ n (f.symm : ğ•œ â†’ ğ•œ) :=
cont_diff_iff_cont_diff_at.2 $ Î» x,
  f.to_local_homeomorph.cont_diff_at_symm_deriv (hâ‚€ _) (mem_univ x) (hf' _) hf.cont_diff_at
end function_inverse
section finite_dimensional
open function finite_dimensional
variables [complete_space ğ•œ]
lemma cont_diff_on_clm_apply {n : with_top â„•} {f : E â†’ F â†’L[ğ•œ] G}
  {s : set E} [finite_dimensional ğ•œ F] :
  cont_diff_on ğ•œ n f s â†” âˆ€ y, cont_diff_on ğ•œ n (Î» x, f x y) s :=
begin
  refine âŸ¨Î» h y, (continuous_linear_map.apply ğ•œ G y).cont_diff.comp_cont_diff_on h, Î» h, _âŸ©,
  let d := finrank ğ•œ F,
  have hd : d = finrank ğ•œ (fin d â†’ ğ•œ) := (finrank_fin_fun ğ•œ).symm,
  let eâ‚ := continuous_linear_equiv.of_finrank_eq hd,
  let eâ‚‚ := (eâ‚.arrow_congr (1 : G â‰ƒL[ğ•œ] G)).trans (continuous_linear_equiv.pi_ring (fin d)),
  rw [â† comp.left_id f, â† eâ‚‚.symm_comp_self],
  exact eâ‚‚.symm.cont_diff.comp_cont_diff_on (cont_diff_on_pi.mpr (Î» i, h _))
end
lemma cont_diff_clm_apply {n : with_top â„•} {f : E â†’ F â†’L[ğ•œ] G} [finite_dimensional ğ•œ F] :
  cont_diff ğ•œ n f â†” âˆ€ y, cont_diff ğ•œ n (Î» x, f x y) :=
by simp_rw [â† cont_diff_on_univ, cont_diff_on_clm_apply]
lemma cont_diff_succ_iff_fderiv_apply [finite_dimensional ğ•œ E] {n : â„•} {f : E â†’ F} :
  cont_diff ğ•œ ((n + 1) : â„•) f â†”
  differentiable ğ•œ f âˆ§ âˆ€ y, cont_diff ğ•œ n (Î» x, fderiv ğ•œ f x y) :=
by rw [cont_diff_succ_iff_fderiv, cont_diff_clm_apply]
lemma cont_diff_on_succ_of_fderiv_apply [finite_dimensional ğ•œ E] {n : â„•} {f : E â†’ F}
  {s : set E} (hf : differentiable_on ğ•œ f s)
  (h : âˆ€ y, cont_diff_on ğ•œ n (Î» x, fderiv_within ğ•œ f s x y) s) :
  cont_diff_on ğ•œ ((n + 1) : â„•) f s :=
cont_diff_on_succ_of_fderiv_within hf $ cont_diff_on_clm_apply.mpr h
lemma cont_diff_on_succ_iff_fderiv_apply [finite_dimensional ğ•œ E] {n : â„•} {f : E â†’ F}
  {s : set E} (hs : unique_diff_on ğ•œ s) : cont_diff_on ğ•œ ((n + 1) : â„•) f s â†”
  differentiable_on ğ•œ f s âˆ§ âˆ€ y, cont_diff_on ğ•œ n (Î» x, fderiv_within ğ•œ f s x y) s :=
by rw [cont_diff_on_succ_iff_fderiv_within hs, cont_diff_on_clm_apply]
end finite_dimensional
section real
variables
{ğ•‚ : Type*} [is_R_or_C ğ•‚]
{E' : Type*} [normed_group E'] [normed_space ğ•‚ E']
{F' : Type*} [normed_group F'] [normed_space ğ•‚ F']
lemma has_ftaylor_series_up_to_on.has_strict_fderiv_at
  {s : set E'} {f : E' â†’ F'} {x : E'} {p : E' â†’ formal_multilinear_series ğ•‚ E' F'}
  (hf : has_ftaylor_series_up_to_on n f p s) (hn : 1 â‰¤ n) (hs : s âˆˆ ğ“ x) :
  has_strict_fderiv_at f ((continuous_multilinear_curry_fin1 ğ•‚ E' F') (p x 1)) x :=
has_strict_fderiv_at_of_has_fderiv_at_of_continuous_at (hf.eventually_has_fderiv_at hn hs) $
  (continuous_multilinear_curry_fin1 ğ•‚ E' F').continuous_at.comp $
    (hf.cont 1 hn).continuous_at hs
lemma cont_diff_at.has_strict_fderiv_at'
  {f : E' â†’ F'} {f' : E' â†’L[ğ•‚] F'} {x : E'}
  (hf : cont_diff_at ğ•‚ n f x) (hf' : has_fderiv_at f f' x) (hn : 1 â‰¤ n) :
  has_strict_fderiv_at f f' x :=
begin
  rcases hf 1 hn with âŸ¨u, H, p, hpâŸ©,
  simp only [nhds_within_univ, mem_univ, insert_eq_of_mem] at H,
  have := hp.has_strict_fderiv_at le_rfl H,
  rwa hf'.unique this.has_fderiv_at
end
lemma cont_diff_at.has_strict_deriv_at' {f : ğ•‚ â†’ F'} {f' : F'} {x : ğ•‚}
  (hf : cont_diff_at ğ•‚ n f x) (hf' : has_deriv_at f f' x) (hn : 1 â‰¤ n) :
  has_strict_deriv_at f f' x :=
hf.has_strict_fderiv_at' hf' hn
lemma cont_diff_at.has_strict_fderiv_at {f : E' â†’ F'} {x : E'}
  (hf : cont_diff_at ğ•‚ n f x) (hn : 1 â‰¤ n) :
  has_strict_fderiv_at f (fderiv ğ•‚ f x) x :=
hf.has_strict_fderiv_at' (hf.differentiable_at hn).has_fderiv_at hn
lemma cont_diff_at.has_strict_deriv_at {f : ğ•‚ â†’ F'} {x : ğ•‚}
  (hf : cont_diff_at ğ•‚ n f x) (hn : 1 â‰¤ n) :
  has_strict_deriv_at f (deriv f x) x :=
(hf.has_strict_fderiv_at hn).has_strict_deriv_at
lemma cont_diff.has_strict_fderiv_at
  {f : E' â†’ F'} {x : E'} (hf : cont_diff ğ•‚ n f) (hn : 1 â‰¤ n) :
  has_strict_fderiv_at f (fderiv ğ•‚ f x) x :=
hf.cont_diff_at.has_strict_fderiv_at hn
lemma cont_diff.has_strict_deriv_at
  {f : ğ•‚ â†’ F'} {x : ğ•‚} (hf : cont_diff ğ•‚ n f) (hn : 1 â‰¤ n) :
  has_strict_deriv_at f (deriv f x) x :=
hf.cont_diff_at.has_strict_deriv_at hn
lemma has_ftaylor_series_up_to_on.exists_lipschitz_on_with_of_nnnorm_lt {E F : Type*}
  [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {f : E â†’ F}
  {p : E â†’ formal_multilinear_series â„ E F} {s : set E} {x : E}
  (hf : has_ftaylor_series_up_to_on 1 f p (insert x s)) (hs : convex â„ s) (K : â„â‰¥0)
  (hK : âˆ¥p x 1âˆ¥â‚Š < K) :
  âˆƒ t âˆˆ ğ“[s] x, lipschitz_on_with K f t :=
begin
  set f' := Î» y, continuous_multilinear_curry_fin1 â„ E F (p y 1),
  have hder : âˆ€ y âˆˆ s, has_fderiv_within_at f (f' y) s y,
    from Î» y hy, (hf.has_fderiv_within_at le_rfl (subset_insert x s hy)).mono (subset_insert x s),
  have hcont : continuous_within_at f' s x,
    from (continuous_multilinear_curry_fin1 â„ E F).continuous_at.comp_continuous_within_at
      ((hf.cont _ le_rfl _ (mem_insert _ _)).mono (subset_insert x s)),
  replace hK : âˆ¥f' xâˆ¥â‚Š < K, by simpa only [linear_isometry_equiv.nnnorm_map],
  exact hs.exists_nhds_within_lipschitz_on_with_of_has_fderiv_within_at_of_nnnorm_lt
    (eventually_nhds_within_iff.2 $ eventually_of_forall hder) hcont K hK
end
lemma has_ftaylor_series_up_to_on.exists_lipschitz_on_with {E F : Type*}
  [normed_group E] [normed_space â„ E] [normed_group F] [normed_space â„ F] {f : E â†’ F}
  {p : E â†’ formal_multilinear_series â„ E F} {s : set E} {x : E}
  (hf : has_ftaylor_series_up_to_on 1 f p (insert x s)) (hs : convex â„ s) :
  âˆƒ K (t âˆˆ ğ“[s] x), lipschitz_on_with K f t :=
(exists_gt _).imp $ hf.exists_lipschitz_on_with_of_nnnorm_lt hs
lemma cont_diff_within_at.exists_lipschitz_on_with {E F : Type*} [normed_group E]
  [normed_space â„ E] [normed_group F] [normed_space â„ F] {f : E â†’ F} {s : set E}
  {x : E} (hf : cont_diff_within_at â„ 1 f s x) (hs : convex â„ s) :
  âˆƒ (K : â„â‰¥0) (t âˆˆ ğ“[s] x), lipschitz_on_with K f t :=
begin
  rcases hf 1 le_rfl with âŸ¨t, hst, p, hpâŸ©,
  rcases metric.mem_nhds_within_iff.mp hst with âŸ¨Îµ, Îµ0, hÎµâŸ©,
  replace hp : has_ftaylor_series_up_to_on 1 f p (metric.ball x Îµ âˆ© insert x s) := hp.mono hÎµ,
  clear hst hÎµ t,
  rw [â† insert_eq_of_mem (metric.mem_ball_self Îµ0), â† insert_inter_distrib] at hp,
  rcases hp.exists_lipschitz_on_with ((convex_ball _ _).inter hs) with âŸ¨K, t, hst, hftâŸ©,
  rw [inter_comm, â† nhds_within_restrict' _ (metric.ball_mem_nhds _ Îµ0)] at hst,
  exact âŸ¨K, t, hst, hftâŸ©
end
lemma cont_diff_at.exists_lipschitz_on_with_of_nnnorm_lt {f : E' â†’ F'} {x : E'}
  (hf : cont_diff_at ğ•‚ 1 f x) (K : â„â‰¥0) (hK : âˆ¥fderiv ğ•‚ f xâˆ¥â‚Š < K) :
  âˆƒ t âˆˆ ğ“ x, lipschitz_on_with K f t :=
(hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with_of_nnnorm_lt K hK
lemma cont_diff_at.exists_lipschitz_on_with {f : E' â†’ F'} {x : E'}
  (hf : cont_diff_at ğ•‚ 1 f x) :
  âˆƒ K (t âˆˆ ğ“ x), lipschitz_on_with K f t :=
(hf.has_strict_fderiv_at le_rfl).exists_lipschitz_on_with
end real
section deriv
variables {fâ‚‚ : ğ•œ â†’ F} {sâ‚‚ : set ğ•œ}
open continuous_linear_map (smul_right)
theorem cont_diff_on_succ_iff_deriv_within {n : â„•} (hs : unique_diff_on ğ•œ sâ‚‚) :
  cont_diff_on ğ•œ ((n + 1) : â„•) fâ‚‚ sâ‚‚ â†”
  differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ n (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=
begin
  rw cont_diff_on_succ_iff_fderiv_within hs,
  congr' 2,
  apply le_antisymm,
  { assume h,
    have : deriv_within fâ‚‚ sâ‚‚ = (Î» u : ğ•œ â†’L[ğ•œ] F, u 1) âˆ˜ (fderiv_within ğ•œ fâ‚‚ sâ‚‚),
      by { ext x, refl },
    simp only [this],
    apply cont_diff.comp_cont_diff_on _ h,
    exact (is_bounded_bilinear_map_apply.is_bounded_linear_map_left _).cont_diff },
  { assume h,
    have : fderiv_within ğ•œ fâ‚‚ sâ‚‚ = smul_right (1 : ğ•œ â†’L[ğ•œ] ğ•œ) âˆ˜ deriv_within fâ‚‚ sâ‚‚,
      by { ext x, simp [deriv_within] },
    simp only [this],
    apply cont_diff.comp_cont_diff_on _ h,
    have : is_bounded_bilinear_map ğ•œ (Î» _ : (ğ•œ â†’L[ğ•œ] ğ•œ) Ã— F, _) :=
      is_bounded_bilinear_map_smul_right,
    exact (this.is_bounded_linear_map_right _).cont_diff }
end
theorem cont_diff_on_succ_iff_deriv_of_open {n : â„•} (hs : is_open sâ‚‚) :
  cont_diff_on ğ•œ ((n + 1) : â„•) fâ‚‚ sâ‚‚ â†”
  differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ n (deriv fâ‚‚) sâ‚‚ :=
begin
  rw cont_diff_on_succ_iff_deriv_within hs.unique_diff_on,
  congrm _ âˆ§ _,
  apply cont_diff_on_congr,
  assume x hx,
  exact deriv_within_of_open hs hx
end
theorem cont_diff_on_top_iff_deriv_within (hs : unique_diff_on ğ•œ sâ‚‚) :
  cont_diff_on ğ•œ âˆ fâ‚‚ sâ‚‚ â†”
  differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ âˆ (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=
begin
  split,
  { assume h,
    refine âŸ¨h.differentiable_on le_top, _âŸ©,
    apply cont_diff_on_top.2 (Î» n, ((cont_diff_on_succ_iff_deriv_within hs).1 _).2),
    exact h.of_le le_top },
  { assume h,
    refine cont_diff_on_top.2 (Î» n, _),
    have A : (n : with_top â„•) â‰¤ âˆ := le_top,
    apply ((cont_diff_on_succ_iff_deriv_within hs).2 âŸ¨h.1, h.2.of_le AâŸ©).of_le,
    exact with_top.coe_le_coe.2 (nat.le_succ n) }
end
theorem cont_diff_on_top_iff_deriv_of_open (hs : is_open sâ‚‚) :
  cont_diff_on ğ•œ âˆ fâ‚‚ sâ‚‚ â†”
  differentiable_on ğ•œ fâ‚‚ sâ‚‚ âˆ§ cont_diff_on ğ•œ âˆ (deriv fâ‚‚) sâ‚‚ :=
begin
  rw cont_diff_on_top_iff_deriv_within hs.unique_diff_on,
  congrm _ âˆ§ _,
  apply cont_diff_on_congr,
  assume x hx,
  exact deriv_within_of_open hs hx
end
lemma cont_diff_on.deriv_within
  (hf : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : unique_diff_on ğ•œ sâ‚‚) (hmn : m + 1 â‰¤ n) :
  cont_diff_on ğ•œ m (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=
begin
  cases m,
  { change âˆ + 1 â‰¤ n at hmn,
    have : n = âˆ, by simpa using hmn,
    rw this at hf,
    exact ((cont_diff_on_top_iff_deriv_within hs).1 hf).2 },
  { change (m.succ : with_top â„•) â‰¤ n at hmn,
    exact ((cont_diff_on_succ_iff_deriv_within hs).1 (hf.of_le hmn)).2 }
end
lemma cont_diff_on.deriv_of_open
  (hf : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : is_open sâ‚‚) (hmn : m + 1 â‰¤ n) :
  cont_diff_on ğ•œ m (deriv fâ‚‚) sâ‚‚ :=
(hf.deriv_within hs.unique_diff_on hmn).congr (Î» x hx, (deriv_within_of_open hs hx).symm)
lemma cont_diff_on.continuous_on_deriv_within
  (h : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : unique_diff_on ğ•œ sâ‚‚) (hn : 1 â‰¤ n) :
  continuous_on (deriv_within fâ‚‚ sâ‚‚) sâ‚‚ :=
((cont_diff_on_succ_iff_deriv_within hs).1 (h.of_le hn)).2.continuous_on
lemma cont_diff_on.continuous_on_deriv_of_open
  (h : cont_diff_on ğ•œ n fâ‚‚ sâ‚‚) (hs : is_open sâ‚‚) (hn : 1 â‰¤ n) :
  continuous_on (deriv fâ‚‚) sâ‚‚ :=
((cont_diff_on_succ_iff_deriv_of_open hs).1 (h.of_le hn)).2.continuous_on
theorem cont_diff_succ_iff_deriv {n : â„•} :
  cont_diff ğ•œ ((n + 1) : â„•) fâ‚‚ â†”
    differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ n (deriv fâ‚‚) :=
by simp only [â† cont_diff_on_univ, cont_diff_on_succ_iff_deriv_of_open, is_open_univ,
  differentiable_on_univ]
theorem cont_diff_one_iff_deriv :
  cont_diff ğ•œ 1 fâ‚‚ â†” differentiable ğ•œ fâ‚‚ âˆ§ continuous (deriv fâ‚‚) :=
cont_diff_succ_iff_deriv.trans $ iff.rfl.and cont_diff_zero
theorem cont_diff_top_iff_deriv :
  cont_diff ğ•œ âˆ fâ‚‚ â†”
  differentiable ğ•œ fâ‚‚ âˆ§ cont_diff ğ•œ âˆ (deriv fâ‚‚) :=
begin
  simp [cont_diff_on_univ.symm, differentiable_on_univ.symm, deriv_within_univ.symm,
        - deriv_within_univ],
  rw cont_diff_on_top_iff_deriv_within unique_diff_on_univ,
end
lemma cont_diff.continuous_deriv (h : cont_diff ğ•œ n fâ‚‚) (hn : 1 â‰¤ n) :
  continuous (deriv fâ‚‚) :=
(cont_diff_succ_iff_deriv.mp (h.of_le hn)).2.continuous
end deriv
section restrict_scalars
variables (ğ•œ) {ğ•œ' : Type*} [nondiscrete_normed_field ğ•œ'] [normed_algebra ğ•œ ğ•œ']
variables [normed_space ğ•œ' E] [is_scalar_tower ğ•œ ğ•œ' E]
variables [normed_space ğ•œ' F] [is_scalar_tower ğ•œ ğ•œ' F]
variables {p' : E â†’ formal_multilinear_series ğ•œ' E F}
lemma has_ftaylor_series_up_to_on.restrict_scalars
  (h : has_ftaylor_series_up_to_on n f p' s) :
  has_ftaylor_series_up_to_on n f (Î» x, (p' x).restrict_scalars ğ•œ) s :=
{ zero_eq := Î» x hx, h.zero_eq x hx,
  fderiv_within :=
    begin
      intros m hm x hx,
      convert ((continuous_multilinear_map.restrict_scalars_linear ğ•œ).has_fderiv_at)
        .comp_has_fderiv_within_at _ ((h.fderiv_within m hm x hx).restrict_scalars ğ•œ),
    end,
  cont := Î» m hm, continuous_multilinear_map.continuous_restrict_scalars.comp_continuous_on
    (h.cont m hm) }
lemma cont_diff_within_at.restrict_scalars (h : cont_diff_within_at ğ•œ' n f s x) :
  cont_diff_within_at ğ•œ n f s x :=
begin
  intros m hm,
  rcases h m hm with âŸ¨u, u_mem, p', hp'âŸ©,
  exact âŸ¨u, u_mem, _, hp'.restrict_scalars _âŸ©
end
lemma cont_diff_on.restrict_scalars (h : cont_diff_on ğ•œ' n f s) :
  cont_diff_on ğ•œ n f s :=
Î» x hx, (h x hx).restrict_scalars _
lemma cont_diff_at.restrict_scalars (h : cont_diff_at ğ•œ' n f x) :
  cont_diff_at ğ•œ n f x :=
cont_diff_within_at_univ.1 $ h.cont_diff_within_at.restrict_scalars _
lemma cont_diff.restrict_scalars (h : cont_diff ğ•œ' n f) :
  cont_diff ğ•œ n f :=
cont_diff_iff_cont_diff_at.2 $ Î» x, h.cont_diff_at.restrict_scalars _
end restrict_scalars
