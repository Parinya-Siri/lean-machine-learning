import category_theory.sites.sieves
import category_theory.limits.shapes.pullbacks
import category_theory.limits.shapes.multiequalizer
import category_theory.category.preorder
import order.copy
universes w v u
namespace category_theory
open category_theory category
variables (C : Type u) [category.{v} C]
structure grothendieck_topology :=
(sieves : Œ† (X : C), set (sieve X))
(top_mem' : ‚àÄ X, ‚ä§ ‚àà sieves X)
(pullback_stable' : ‚àÄ ‚¶ÉX Y : C‚¶Ñ ‚¶ÉS : sieve X‚¶Ñ (f : Y ‚ü∂ X), S ‚àà sieves X ‚Üí S.pullback f ‚àà sieves Y)
(transitive' : ‚àÄ ‚¶ÉX‚¶Ñ ‚¶ÉS : sieve X‚¶Ñ (hS : S ‚àà sieves X) (R : sieve X),
              (‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí R.pullback f ‚àà sieves Y) ‚Üí R ‚àà sieves X)
namespace grothendieck_topology
instance : has_coe_to_fun (grothendieck_topology C) (Œª _, Œ† X : C, set (sieve X)) := ‚ü®sieves‚ü©
variables {C} {X Y : C} {S R : sieve X}
variables (J : grothendieck_topology C)
@[ext]
lemma ext {J‚ÇÅ J‚ÇÇ : grothendieck_topology C} (h : (J‚ÇÅ : Œ† (X : C), set (sieve X)) = J‚ÇÇ) : J‚ÇÅ = J‚ÇÇ :=
by { cases J‚ÇÅ, cases J‚ÇÇ, congr, apply h }
@[simp] lemma mem_sieves_iff_coe : S ‚àà J.sieves X ‚Üî S ‚àà J X := iff.rfl
lemma superset_covering (Hss : S ‚â§ R) (sjx : S ‚àà J X) : R ‚àà J X :=
begin
  apply J.transitive sjx R (Œª Y f hf, _),
  apply covering_of_eq_top,
  rw [‚Üê top_le_iff, ‚Üê S.pullback_eq_top_of_mem hf],
  apply sieve.pullback_monotone _ Hss,
end
lemma intersection_covering (rj : R ‚àà J X) (sj : S ‚àà J X) : R ‚äì S ‚àà J X :=
begin
  apply J.transitive rj _ (Œª Y f Hf, _),
  rw [sieve.pullback_inter, R.pullback_eq_top_of_mem Hf],
  simp [sj],
end
@[simp]
lemma intersection_covering_iff : R ‚äì S ‚àà J X ‚Üî R ‚àà J X ‚àß S ‚àà J X :=
‚ü®Œª h, ‚ü®J.superset_covering inf_le_left h, J.superset_covering inf_le_right h‚ü©,
 Œª t, intersection_covering _ t.1 t.2‚ü©
lemma bind_covering {S : sieve X} {R : Œ† ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí sieve Y} (hS : S ‚àà J X)
  (hR : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (H : S f), R H ‚àà J Y) :
sieve.bind S R ‚àà J X :=
J.transitive hS _ (Œª Y f hf, superset_covering J (sieve.le_pullback_bind S R f hf) (hR hf))
def covers (S : sieve X) (f : Y ‚ü∂ X) : Prop := S.pullback f ‚àà J Y
lemma covers_iff (S : sieve X) (f : Y ‚ü∂ X) : J.covers S f ‚Üî S.pullback f ‚àà J Y :=
iff.rfl
lemma covering_iff_covers_id (S : sieve X) : S ‚àà J X ‚Üî J.covers S (ùüô X) :=
by simp [covers_iff]
lemma arrow_max (f : Y ‚ü∂ X) (S : sieve X) (hf : S f) : J.covers S f :=
begin
  rw [covers, (sieve.pullback_eq_top_iff_mem f).1 hf],
  apply J.top_mem,
end
lemma arrow_stable (f : Y ‚ü∂ X) (S : sieve X) (h : J.covers S f) {Z : C} (g : Z ‚ü∂ Y) :
  J.covers S (g ‚â´ f) :=
begin
  rw covers_iff at h ‚ä¢,
  simp [h, sieve.pullback_comp],
end
lemma arrow_trans (f : Y ‚ü∂ X) (S R : sieve X) (h : J.covers S f) :
  (‚àÄ {Z : C} (g : Z ‚ü∂ X), S g ‚Üí J.covers R g) ‚Üí J.covers R f :=
begin
  intro k,
  apply J.transitive h,
  intros Z g hg,
  rw ‚Üê sieve.pullback_comp,
  apply k (g ‚â´ f) hg,
end
lemma arrow_intersect (f : Y ‚ü∂ X) (S R : sieve X) (hS : J.covers S f) (hR : J.covers R f) :
  J.covers (S ‚äì R) f :=
by simpa [covers_iff] using and.intro hS hR
variable (C)
def trivial : grothendieck_topology C :=
{ sieves := Œª X, {‚ä§},
  top_mem' := Œª X, rfl,
  pullback_stable' := Œª X Y S f hf,
  begin
    rw set.mem_singleton_iff at ‚ä¢ hf,
    simp [hf],
  end,
  transitive' := Œª X S hS R hR,
  begin
    rw [set.mem_singleton_iff, ‚Üê sieve.id_mem_iff_eq_top] at hS,
    simpa using hR hS,
  end }
def discrete : grothendieck_topology C :=
{ sieves := Œª X, set.univ,
  top_mem' := by simp,
  pullback_stable' := Œª X Y f, by simp,
  transitive' := by simp }
variable {C}
lemma trivial_covering : S ‚àà trivial C X ‚Üî S = ‚ä§ := set.mem_singleton_iff
instance : has_le (grothendieck_topology C) :=
{ le := Œª J‚ÇÅ J‚ÇÇ, (J‚ÇÅ : Œ† (X : C), set (sieve X)) ‚â§ (J‚ÇÇ : Œ† (X : C), set (sieve X)) }
lemma le_def {J‚ÇÅ J‚ÇÇ : grothendieck_topology C} :
  J‚ÇÅ ‚â§ J‚ÇÇ ‚Üî (J‚ÇÅ : Œ† (X : C), set (sieve X)) ‚â§ J‚ÇÇ := iff.rfl
instance : partial_order (grothendieck_topology C) :=
{ le_refl := Œª J‚ÇÅ, le_def.mpr le_rfl,
  le_trans := Œª J‚ÇÅ J‚ÇÇ J‚ÇÉ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ, le_def.mpr (le_trans h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ),
  le_antisymm := Œª J‚ÇÅ J‚ÇÇ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ, grothendieck_topology.ext (le_antisymm h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ),
  ..grothendieck_topology.has_le }
instance : has_Inf (grothendieck_topology C) :=
{ Inf := Œª T,
  { sieves := Inf (sieves '' T),
    top_mem' :=
    begin
      rintro X S ‚ü®‚ü®_, J, hJ, rfl‚ü©, rfl‚ü©,
      simp,
    end,
    pullback_stable' :=
    begin
      rintro X Y S hS f _ ‚ü®‚ü®_, J, hJ, rfl‚ü©, rfl‚ü©,
      apply J.pullback_stable _ (f _ ‚ü®‚ü®_, _, hJ, rfl‚ü©, rfl‚ü©),
    end,
    transitive' :=
    begin
      rintro X S hS R h _ ‚ü®‚ü®_, J, hJ, rfl‚ü©, rfl‚ü©,
      apply J.transitive (hS _ ‚ü®‚ü®_, _, hJ, rfl‚ü©, rfl‚ü©) _ (Œª Y f hf, h hf _ ‚ü®‚ü®_, _, hJ, rfl‚ü©, rfl‚ü©),
    end } }
lemma is_glb_Inf (s : set (grothendieck_topology C)) : is_glb s (Inf s) :=
begin
  refine @is_glb.of_image _ _ _ _ sieves _ _ _ _,
  { intros, refl },
  { exact is_glb_Inf _ },
end
instance : complete_lattice (grothendieck_topology C) :=
complete_lattice.copy
(complete_lattice_of_Inf _ is_glb_Inf)
_ rfl
(discrete C)
(begin
  apply le_antisymm,
  { exact @complete_lattice.le_top _ (complete_lattice_of_Inf _ is_glb_Inf) (discrete C) },
  { intros X S hS,
    apply set.mem_univ },
end)
(trivial C)
(begin
  apply le_antisymm,
  { intros X S hS,
    rw trivial_covering at hS,
    apply covering_of_eq_top _ hS },
  { refine @complete_lattice.bot_le _ (complete_lattice_of_Inf _ is_glb_Inf) (trivial C) },
end)
_ rfl
_ rfl
_ rfl
Inf rfl
instance : inhabited (grothendieck_topology C) := ‚ü®‚ä§‚ü©
@[simp] lemma trivial_eq_bot : trivial C = ‚ä• := rfl
@[simp] lemma discrete_eq_top : discrete C = ‚ä§ := rfl
@[simp] lemma bot_covering : S ‚àà (‚ä• : grothendieck_topology C) X ‚Üî S = ‚ä§ := trivial_covering
@[simp] lemma top_covering : S ‚àà (‚ä§ : grothendieck_topology C) X := ‚ü®‚ü©
lemma bot_covers (S : sieve X) (f : Y ‚ü∂ X) :
  (‚ä• : grothendieck_topology C).covers S f ‚Üî S f :=
by rw [covers_iff, bot_covering, ‚Üê sieve.pullback_eq_top_iff_mem]
@[simp] lemma top_covers (S : sieve X) (f : Y ‚ü∂ X) : (‚ä§ : grothendieck_topology C).covers S f :=
by simp [covers_iff]
def dense : grothendieck_topology C :=
{ sieves := Œª X S, ‚àÄ {Y : C} (f : Y ‚ü∂ X), ‚àÉ Z (g : Z ‚ü∂ Y), S (g ‚â´ f),
  top_mem' := Œª X Y f, ‚ü®Y, ùüô Y, ‚ü®‚ü©‚ü©,
  pullback_stable' :=
  begin
    intros X Y S h H Z f,
    rcases H (f ‚â´ h) with ‚ü®W, g, H'‚ü©,
    exact ‚ü®W, g, by simpa‚ü©,
  end,
  transitive' :=
  begin
    intros X S H‚ÇÅ R H‚ÇÇ Y f,
    rcases H‚ÇÅ f with ‚ü®Z, g, H‚ÇÉ‚ü©,
    rcases H‚ÇÇ H‚ÇÉ (ùüô Z) with ‚ü®W, h, H‚ÇÑ‚ü©,
    exact ‚ü®W, (h ‚â´ g), by simpa using H‚ÇÑ‚ü©,
  end }
lemma dense_covering : S ‚àà dense X ‚Üî ‚àÄ {Y} (f : Y ‚ü∂ X), ‚àÉ Z (g : Z ‚ü∂ Y), S (g ‚â´ f) :=
iff.rfl
def right_ore_condition (C : Type u) [category.{v} C] : Prop :=
‚àÄ {X Y Z : C} (yx : Y ‚ü∂ X) (zx : Z ‚ü∂ X), ‚àÉ W (wy : W ‚ü∂ Y) (wz : W ‚ü∂ Z), wy ‚â´ yx = wz ‚â´ zx
lemma right_ore_of_pullbacks [limits.has_pullbacks C] : right_ore_condition C :=
Œª X Y Z yx zx, ‚ü®_, _, _, limits.pullback.condition‚ü©
def atomic (hro : right_ore_condition C) : grothendieck_topology C :=
{ sieves := Œª X S, ‚àÉ Y (f : Y ‚ü∂ X), S f,
  top_mem' := Œª X, ‚ü®_, ùüô _, ‚ü®‚ü©‚ü©,
  pullback_stable' :=
  begin
    rintros X Y S h ‚ü®Z, f, hf‚ü©,
    rcases hro h f with ‚ü®W, g, k, comm‚ü©,
    refine ‚ü®_, g, _‚ü©,
    simp [comm, hf],
  end,
  transitive' :=
  begin
    rintros X S ‚ü®Y, f, hf‚ü© R h,
    rcases h hf with ‚ü®Z, g, hg‚ü©,
    exact ‚ü®_, _, hg‚ü©,
  end }
@[derive preorder]
def cover (X : C) := { S : sieve X // S ‚àà J X }
namespace cover
variables {J}
instance : has_coe (J.cover X) (sieve X) := ‚ü®Œª S, S.1‚ü©
instance : has_coe_to_fun (J.cover X) (Œª S, Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), Prop) :=
‚ü®Œª S Y f, (S : sieve X) f‚ü©
@[simp]
lemma coe_fun_coe (S : J.cover X) (f : Y ‚ü∂ X) : (S : sieve X) f = S f := rfl
lemma condition (S : J.cover X) : (S : sieve X) ‚àà J X := S.2
@[ext]
lemma ext (S T : J.cover X) (h : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), S f ‚Üî T f) : S = T :=
subtype.ext $ sieve.ext h
instance : order_top (J.cover X) :=
{ top := ‚ü®‚ä§, J.top_mem _‚ü©,
  le_top := Œª S Y f h, by tauto,
  ..(infer_instance : preorder _) }
instance : semilattice_inf (J.cover X) :=
{ inf := Œª S T, ‚ü®S ‚äì T, J.intersection_covering S.condition T.condition‚ü©,
  le_antisymm := Œª S T h1 h2, ext _ _ $ Œª Y f, ‚ü®h1 _, h2 _‚ü©,
  inf_le_left := Œª S T Y f hf, hf.1,
  inf_le_right := Œª S T Y f hf, hf.2,
  le_inf := Œª S T W h1 h2 Y f h, ‚ü®h1 _ h, h2 _ h‚ü©,
  ..(infer_instance : preorder _) }
instance : inhabited (J.cover X) := ‚ü®‚ä§‚ü©
@[nolint has_inhabited_instance, ext]
structure arrow (S : J.cover X) :=
(Y : C)
(f : Y ‚ü∂ X)
(hf : S f)
@[nolint has_inhabited_instance, ext]
structure relation (S : J.cover X) :=
(Y‚ÇÅ Y‚ÇÇ Z : C)
(g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ)
(g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ)
(f‚ÇÅ : Y‚ÇÅ ‚ü∂ X)
(f‚ÇÇ : Y‚ÇÇ ‚ü∂ X)
(h‚ÇÅ : S f‚ÇÅ)
(h‚ÇÇ : S f‚ÇÇ)
(w : g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ)
@[simps]
def arrow.map {S T : J.cover X} (I : S.arrow) (f : S ‚ü∂ T) : T.arrow :=
‚ü®I.Y, I.f, f.le _ I.hf‚ü©
@[simps]
def relation.map {S T : J.cover X} (I : S.relation) (f : S ‚ü∂ T) : T.relation :=
‚ü®_, _, _, I.g‚ÇÅ, I.g‚ÇÇ, I.f‚ÇÅ, I.f‚ÇÇ, f.le _ I.h‚ÇÅ, f.le _ I.h‚ÇÇ, I.w‚ü©
@[simps]
def relation.fst {S : J.cover X} (I : S.relation) : S.arrow :=
‚ü®I.Y‚ÇÅ, I.f‚ÇÅ, I.h‚ÇÅ‚ü©
@[simps]
def relation.snd {S : J.cover X} (I : S.relation) : S.arrow :=
‚ü®I.Y‚ÇÇ, I.f‚ÇÇ, I.h‚ÇÇ‚ü©
@[simp]
lemma relation.map_fst {S T : J.cover X} (I : S.relation) (f : S ‚ü∂ T) :
   I.fst.map f = (I.map f).fst := rfl
@[simp]
lemma relation.map_snd {S T : J.cover X} (I : S.relation) (f : S ‚ü∂ T) :
  I.snd.map f = (I.map f).snd := rfl
def pullback (S : J.cover X) (f : Y ‚ü∂ X) : J.cover Y :=
‚ü®sieve.pullback f S, J.pullback_stable _ S.condition‚ü©
@[simps]
def arrow.base {f : Y ‚ü∂ X} {S : J.cover X} (I : (S.pullback f).arrow) : S.arrow :=
‚ü®I.Y, I.f ‚â´ f, I.hf‚ü©
@[simps]
def relation.base {f : Y ‚ü∂ X} {S : J.cover X} (I : (S.pullback f).relation) : S.relation :=
‚ü®_, _, _, I.g‚ÇÅ, I.g‚ÇÇ, I.f‚ÇÅ ‚â´ f, I.f‚ÇÇ‚â´ f, I.h‚ÇÅ, I.h‚ÇÇ, by simp [reassoc_of I.w]‚ü©
@[simp]
lemma relation.base_fst {f : Y ‚ü∂ X} {S : J.cover X} (I : (S.pullback f).relation) :
 I.fst.base = I.base.fst := rfl
@[simp]
lemma relation.base_snd {f : Y ‚ü∂ X} {S : J.cover X} (I : (S.pullback f).relation) :
 I.snd.base = I.base.snd := rfl
@[simp]
lemma coe_pullback {Z : C} (f : Y ‚ü∂ X) (g : Z ‚ü∂ Y) (S : J.cover X) :
  (S.pullback f) g ‚Üî S (g ‚â´ f) := iff.rfl
def pullback_id (S : J.cover X) : S.pullback (ùüô X) ‚âÖ S :=
eq_to_iso $ cover.ext _ _ $ Œª Y f, by simp
def pullback_comp {X Y Z : C} (S : J.cover X) (f : Z ‚ü∂ Y) (g : Y ‚ü∂ X) :
  S.pullback (f ‚â´ g) ‚âÖ (S.pullback g).pullback f :=
eq_to_iso $ cover.ext _ _ $ Œª Y f, by simp
def bind {X : C} (S : J.cover X) (T : Œ† (I : S.arrow), J.cover I.Y) : J.cover X :=
‚ü®sieve.bind S (Œª Y f hf, T ‚ü®Y, f, hf‚ü©), J.bind_covering S.condition (Œª _ _ _, (T _).condition)‚ü©
def bind_to_base {X : C} (S : J.cover X) (T : Œ† (I : S.arrow), J.cover I.Y) : S.bind T ‚ü∂ S :=
hom_of_le $ by { rintro Y f ‚ü®Z,e1,e2,h1,h2,h3‚ü©, rw ‚Üê h3, apply sieve.downward_closed, exact h1 }
noncomputable def arrow.middle {X : C} {S : J.cover X} {T : Œ† (I : S.arrow), J.cover I.Y}
  (I : (S.bind T).arrow) : C :=
I.hf.some
noncomputable def arrow.to_middle_hom {X : C} {S : J.cover X} {T : Œ† (I : S.arrow), J.cover I.Y}
  (I : (S.bind T).arrow) : I.Y ‚ü∂ I.middle :=
I.hf.some_spec.some
noncomputable def arrow.from_middle_hom {X : C} {S : J.cover X} {T : Œ† (I : S.arrow), J.cover I.Y}
  (I : (S.bind T).arrow) : I.middle ‚ü∂ X :=
I.hf.some_spec.some_spec.some
lemma arrow.from_middle_condition {X : C} {S : J.cover X} {T : Œ† (I : S.arrow), J.cover I.Y}
  (I : (S.bind T).arrow) : S I.from_middle_hom :=
I.hf.some_spec.some_spec.some_spec.some
noncomputable
def arrow.from_middle {X : C} {S : J.cover X} {T : Œ† (I : S.arrow), J.cover I.Y}
  (I : (S.bind T).arrow) : S.arrow := ‚ü®_, I.from_middle_hom, I.from_middle_condition‚ü©
lemma arrow.to_middle_condition {X : C} {S : J.cover X} {T : Œ† (I : S.arrow), J.cover I.Y}
  (I : (S.bind T).arrow) : (T I.from_middle) I.to_middle_hom :=
I.hf.some_spec.some_spec.some_spec.some_spec.1
noncomputable
def arrow.to_middle {X : C} {S : J.cover X} {T : Œ† (I : S.arrow), J.cover I.Y}
  (I : (S.bind T).arrow) : (T I.from_middle).arrow := ‚ü®_, I.to_middle_hom, I.to_middle_condition‚ü©
lemma arrow.middle_spec {X : C} {S : J.cover X} {T : Œ† (I : S.arrow), J.cover I.Y}
  (I : (S.bind T).arrow) : I.to_middle_hom ‚â´ I.from_middle_hom = I.f :=
I.hf.some_spec.some_spec.some_spec.some_spec.2
def index {D : Type w} [category.{max v u} D] (S : J.cover X) (P : C·µí·µñ ‚•§ D) :
  limits.multicospan_index D :=
{ L := S.arrow,
  R := S.relation,
  fst_to := Œª I, I.fst,
  snd_to := Œª I, I.snd,
  left := Œª I, P.obj (opposite.op I.Y),
  right := Œª I, P.obj (opposite.op I.Z),
  fst := Œª I, P.map I.g‚ÇÅ.op,
  snd := Œª I, P.map I.g‚ÇÇ.op }
abbreviation multifork {D : Type w} [category.{max v u} D] (S : J.cover X) (P : C·µí·µñ ‚•§ D) :
  limits.multifork (S.index P) :=
limits.multifork.of_Œπ _ (P.obj (opposite.op X)) (Œª I, P.map I.f.op) begin
  intros I,
  dsimp [index],
  simp only [‚Üê P.map_comp, ‚Üê op_comp, I.w]
end
noncomputable
abbreviation to_multiequalizer {D : Type w} [category.{max v u} D] (S : J.cover X) (P : C·µí·µñ ‚•§ D)
  [limits.has_multiequalizer (S.index P)] :
P.obj (opposite.op X) ‚ü∂ limits.multiequalizer (S.index P) :=
limits.multiequalizer.lift _ _ (Œª I, P.map I.f.op) begin
  intros I,
  dsimp only [index, relation.fst, relation.snd],
  simp only [‚Üê P.map_comp, ‚Üê op_comp, I.w],
end
end cover
@[simps obj]
def pullback (f : Y ‚ü∂ X) : J.cover X ‚•§ J.cover Y :=
{ obj := Œª S, S.pullback f,
  map := Œª S T f, (sieve.pullback_monotone _ f.le).hom }
def pullback_id (X : C) : J.pullback (ùüô X) ‚âÖ ùü≠ _ :=
nat_iso.of_components (Œª S, S.pullback_id) $ by tidy
def pullback_comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  J.pullback (f ‚â´ g) ‚âÖ J.pullback g ‚ãô J.pullback f :=
nat_iso.of_components (Œª S, S.pullback_comp f g) $ by tidy
end grothendieck_topology
end category_theory
