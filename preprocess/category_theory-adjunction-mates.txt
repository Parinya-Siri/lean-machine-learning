import category_theory.adjunction.basic
import category_theory.conj
universes vâ‚ vâ‚‚ vâ‚ƒ vâ‚„ uâ‚ uâ‚‚ uâ‚ƒ uâ‚„
namespace category_theory
open category
variables {C : Type uâ‚} {D : Type uâ‚‚} [category.{vâ‚} C] [category.{vâ‚‚} D]
section square
variables {E : Type uâ‚ƒ} {F : Type uâ‚„} [category.{vâ‚ƒ} E] [category.{vâ‚„} F]
variables {G : C â¥¤ E} {H : D â¥¤ F} {Lâ‚ : C â¥¤ D} {Râ‚ : D â¥¤ C} {Lâ‚‚ : E â¥¤ F} {Râ‚‚ : F â¥¤ E}
variables (adjâ‚ : Lâ‚ âŠ£ Râ‚) (adjâ‚‚ : Lâ‚‚ âŠ£ Râ‚‚)
include adjâ‚ adjâ‚‚
def transfer_nat_trans : (G â‹™ Lâ‚‚ âŸ¶ Lâ‚ â‹™ H) â‰ƒ (Râ‚ â‹™ G âŸ¶ H â‹™ Râ‚‚) :=
{ to_fun := Î» h,
  { app := Î» X, adjâ‚‚.unit.app _ â‰« Râ‚‚.map (h.app _ â‰« H.map (adjâ‚.counit.app _)),
    naturality' := Î» X Y f,
    begin
      dsimp,
      rw [assoc, â† Râ‚‚.map_comp, assoc, â† H.map_comp, â† adjâ‚.counit_naturality, H.map_comp,
          â†functor.comp_map Lâ‚, â†h.naturality_assoc],
      simp,
    end },
  inv_fun := Î» h,
  { app := Î» X, Lâ‚‚.map (G.map (adjâ‚.unit.app _) â‰« h.app _) â‰« adjâ‚‚.counit.app _,
  naturality' := Î» X Y f,
  begin
    dsimp,
    rw [â† Lâ‚‚.map_comp_assoc, â† G.map_comp_assoc, â† adjâ‚.unit_naturality, G.map_comp_assoc,
        â† functor.comp_map, h.naturality],
    simp,
  end },
  left_inv := Î» h,
  begin
    ext X,
    dsimp,
    simp only [Lâ‚‚.map_comp, assoc, adjâ‚‚.counit_naturality, adjâ‚‚.left_triangle_components_assoc,
      â†functor.comp_map G Lâ‚‚, h.naturality_assoc, functor.comp_map Lâ‚, â†H.map_comp,
      adjâ‚.left_triangle_components],
    dsimp,
def transfer_nat_trans_self : (Lâ‚‚ âŸ¶ Lâ‚) â‰ƒ (Râ‚ âŸ¶ Râ‚‚) :=
calc (Lâ‚‚ âŸ¶ Lâ‚) â‰ƒ _         : (iso.hom_congr Lâ‚‚.left_unitor Lâ‚.right_unitor).symm
           ... â‰ƒ _         : transfer_nat_trans adjâ‚ adjâ‚‚
           ... â‰ƒ (Râ‚ âŸ¶ Râ‚‚) : Râ‚.right_unitor.hom_congr Râ‚‚.left_unitor
lemma transfer_nat_trans_self_counit (f : Lâ‚‚ âŸ¶ Lâ‚) (X) :
  Lâ‚‚.map ((transfer_nat_trans_self adjâ‚ adjâ‚‚ f).app _) â‰« adjâ‚‚.counit.app X =
    f.app _ â‰« adjâ‚.counit.app X :=
begin
  dsimp [transfer_nat_trans_self],
  rw [id_comp, comp_id],
  have := transfer_nat_trans_counit adjâ‚ adjâ‚‚ (Lâ‚‚.left_unitor.hom â‰« f â‰« Lâ‚.right_unitor.inv) X,
  dsimp at this,
  rw this,
  simp,
end
lemma unit_transfer_nat_trans_self (f : Lâ‚‚ âŸ¶ Lâ‚) (X) :
  adjâ‚.unit.app _ â‰« (transfer_nat_trans_self adjâ‚ adjâ‚‚ f).app _ =
    adjâ‚‚.unit.app X â‰« functor.map _ (f.app _) :=
begin
  dsimp [transfer_nat_trans_self],
  rw [id_comp, comp_id],
  have := unit_transfer_nat_trans adjâ‚ adjâ‚‚ (Lâ‚‚.left_unitor.hom â‰« f â‰« Lâ‚.right_unitor.inv) X,
  dsimp at this,
  rw this,
  simp
end
@[simp]
lemma transfer_nat_trans_self_id : transfer_nat_trans_self adjâ‚ adjâ‚ (ğŸ™ _) = ğŸ™ _ :=
by { ext, dsimp [transfer_nat_trans_self, transfer_nat_trans], simp }
instance transfer_nat_trans_self_iso (f : Lâ‚‚ âŸ¶ Lâ‚) [is_iso f] :
  is_iso (transfer_nat_trans_self adjâ‚ adjâ‚‚ f) :=
âŸ¨âŸ¨transfer_nat_trans_self adjâ‚‚ adjâ‚ (inv f),
  âŸ¨transfer_nat_trans_self_comm _ _ (by simp), transfer_nat_trans_self_comm _ _ (by simp)âŸ©âŸ©âŸ©
instance transfer_nat_trans_self_symm_iso (f : Râ‚ âŸ¶ Râ‚‚) [is_iso f] :
  is_iso ((transfer_nat_trans_self adjâ‚ adjâ‚‚).symm f) :=
âŸ¨âŸ¨(transfer_nat_trans_self adjâ‚‚ adjâ‚).symm (inv f),
  âŸ¨transfer_nat_trans_self_symm_comm _ _ (by simp),
   transfer_nat_trans_self_symm_comm _ _ (by simp)âŸ©âŸ©âŸ©
lemma transfer_nat_trans_self_of_iso (f : Lâ‚‚ âŸ¶ Lâ‚) [is_iso (transfer_nat_trans_self adjâ‚ adjâ‚‚ f)] :
  is_iso f :=
begin
  suffices :
    is_iso ((transfer_nat_trans_self adjâ‚ adjâ‚‚).symm (transfer_nat_trans_self adjâ‚ adjâ‚‚ f)),
  { simpa using this },
  apply_instance,
end
lemma transfer_nat_trans_self_symm_of_iso (f : Râ‚ âŸ¶ Râ‚‚)
  [is_iso ((transfer_nat_trans_self adjâ‚ adjâ‚‚).symm f)] :
  is_iso f :=
begin
  suffices :
    is_iso ((transfer_nat_trans_self adjâ‚ adjâ‚‚) ((transfer_nat_trans_self adjâ‚ adjâ‚‚).symm f)),
  { simpa using this },
  apply_instance,
end
end self
end category_theory
