import analysis.analytic.basic
import combinatorics.composition
noncomputable theory
variables {ğ•œ : Type*} {E F G H : Type*}
open filter list
open_locale topological_space big_operators classical nnreal ennreal
section topological
variables [comm_ring ğ•œ] [add_comm_group E] [add_comm_group F] [add_comm_group G]
variables [module ğ•œ E] [module ğ•œ F] [module ğ•œ G]
variables [topological_space E] [topological_space F] [topological_space G]
namespace formal_multilinear_series
variables [topological_add_group E] [has_continuous_const_smul ğ•œ E]
variables [topological_add_group F] [has_continuous_const_smul ğ•œ F]
variables [topological_add_group G] [has_continuous_const_smul ğ•œ G]
def apply_composition
  (p : formal_multilinear_series ğ•œ E F) {n : â„•} (c : composition n) :
  (fin n â†’ E) â†’ (fin (c.length) â†’ F) :=
Î» v i, p (c.blocks_fun i) (v âˆ˜ (c.embedding i))
lemma apply_composition_ones (p : formal_multilinear_series ğ•œ E F) (n : â„•) :
  p.apply_composition (composition.ones n) =
    Î» v i, p 1 (Î» _, v (fin.cast_le (composition.length_le _) i)) :=
begin
  funext v i,
  apply p.congr (composition.ones_blocks_fun _ _),
  intros j hjn hj1,
  obtain rfl : j = 0, { linarith },
  refine congr_arg v _,
  rw [fin.ext_iff, fin.coe_cast_le, composition.ones_embedding, fin.coe_mk],
end
lemma apply_composition_single (p : formal_multilinear_series ğ•œ E F) {n : â„•} (hn : 0 < n)
  (v : fin n â†’ E) : p.apply_composition (composition.single n hn) v = Î» j, p n v :=
begin
  ext j,
  refine p.congr (by simp) (Î» i hi1 hi2, _),
  dsimp,
  congr' 1,
  convert composition.single_embedding hn âŸ¨i, hi2âŸ©,
  cases j,
  have : j_val = 0 := le_bot_iff.1 (nat.lt_succ_iff.1 j_property),
  unfold_coes,
  congr; try { assumption <|> simp },
end
@[simp] lemma remove_zero_apply_composition
  (p : formal_multilinear_series ğ•œ E F) {n : â„•} (c : composition n) :
  p.remove_zero.apply_composition c = p.apply_composition c :=
begin
  ext v i,
  simp [apply_composition, zero_lt_one.trans_le (c.one_le_blocks_fun i), remove_zero_of_pos],
end
lemma apply_composition_update
  (p : formal_multilinear_series ğ•œ E F) {n : â„•} (c : composition n)
  (j : fin n) (v : fin n â†’ E) (z : E) :
  p.apply_composition c (function.update v j z) =
    function.update (p.apply_composition c v) (c.index j)
      (p (c.blocks_fun (c.index j))
        (function.update (v âˆ˜ (c.embedding (c.index j))) (c.inv_embedding j) z)) :=
begin
  ext k,
  by_cases h : k = c.index j,
  { rw h,
    let r : fin (c.blocks_fun (c.index j)) â†’ fin n := c.embedding (c.index j),
    simp only [function.update_same],
    change p (c.blocks_fun (c.index j)) ((function.update v j z) âˆ˜ r) = _,
    let j' := c.inv_embedding j,
    suffices B : (function.update v j z) âˆ˜ r = function.update (v âˆ˜ r) j' z,
      by rw B,
    suffices C : (function.update v (r j') z) âˆ˜ r = function.update (v âˆ˜ r) j' z,
      by { convert C, exact (c.embedding_comp_inv j).symm },
    exact function.update_comp_eq_of_injective _ (c.embedding _).injective _ _ },
  { simp only [h, function.update_eq_self, function.update_noteq, ne.def, not_false_iff],
    let r : fin (c.blocks_fun k) â†’ fin n := c.embedding k,
    change p (c.blocks_fun k) ((function.update v j z) âˆ˜ r) = p (c.blocks_fun k) (v âˆ˜ r),
    suffices B : (function.update v j z) âˆ˜ r = v âˆ˜ r, by rw B,
    apply function.update_comp_eq_of_not_mem_range,
    rwa c.mem_range_embedding_iff' }
end
@[simp] lemma comp_continuous_linear_map_apply_composition {n : â„•}
  (p : formal_multilinear_series ğ•œ F G) (f : E â†’L[ğ•œ] F) (c : composition n) (v : fin n â†’ E) :
  (p.comp_continuous_linear_map f).apply_composition c v = p.apply_composition c (f âˆ˜ v) :=
by simp [apply_composition]
end formal_multilinear_series
namespace continuous_multilinear_map
open formal_multilinear_series
variables [topological_add_group E] [has_continuous_const_smul ğ•œ E]
variables [topological_add_group F] [has_continuous_const_smul ğ•œ F]
def comp_along_composition {n : â„•}
  (p : formal_multilinear_series ğ•œ E F) (c : composition n)
  (f : continuous_multilinear_map ğ•œ (Î» (i : fin c.length), F) G) :
  continuous_multilinear_map ğ•œ (Î» i : fin n, E) G :=
{ to_fun    := Î» v, f (p.apply_composition c v),
  map_add'  := Î» v i x y, by simp only [apply_composition_update,
    continuous_multilinear_map.map_add],
  map_smul' := Î» v i c x, by simp only [apply_composition_update,
    continuous_multilinear_map.map_smul],
  cont := f.cont.comp $ continuous_pi $ Î» i, (coe_continuous _).comp $ continuous_pi $ Î» j,
    continuous_apply _, }
@[simp] lemma comp_along_composition_apply {n : â„•}
  (p : formal_multilinear_series ğ•œ E F) (c : composition n)
  (f : continuous_multilinear_map ğ•œ (Î» (i : fin c.length), F) G) (v : fin n â†’ E) :
  (f.comp_along_composition p c) v = f (p.apply_composition c v) := rfl
end continuous_multilinear_map
namespace formal_multilinear_series
variables [topological_add_group E] [has_continuous_const_smul ğ•œ E]
variables [topological_add_group F] [has_continuous_const_smul ğ•œ F]
variables [topological_add_group G] [has_continuous_const_smul ğ•œ G]
def comp_along_composition {n : â„•}
  (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)
  (c : composition n) : continuous_multilinear_map ğ•œ (Î» i : fin n, E) G :=
(q c.length).comp_along_composition p c
@[simp] lemma comp_along_composition_apply {n : â„•}
  (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)
  (c : composition n) (v : fin n â†’ E) :
  (q.comp_along_composition p c) v = q c.length (p.apply_composition c v) := rfl
protected def comp (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) :
  formal_multilinear_series ğ•œ E G :=
Î» n, âˆ‘ c : composition n, q.comp_along_composition p c
lemma comp_coeff_zero (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)
  (v : fin 0 â†’ E) (v' : fin 0 â†’ F) :
  (q.comp p) 0 v = q 0 v' :=
begin
  let c : composition 0 := composition.ones 0,
  dsimp [formal_multilinear_series.comp],
  have : {c} = (finset.univ : finset (composition 0)),
  { apply finset.eq_of_subset_of_card_le; simp [finset.card_univ, composition_card 0] },
  rw [â† this, finset.sum_singleton, comp_along_composition_apply],
  symmetry, congr'
end
@[simp] lemma comp_coeff_zero'
  (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (v : fin 0 â†’ E) :
  (q.comp p) 0 v = q 0 (Î» i, 0) :=
q.comp_coeff_zero p v _
lemma comp_coeff_zero'' (q : formal_multilinear_series ğ•œ E F)
  (p : formal_multilinear_series ğ•œ E E) :
  (q.comp p) 0 = q 0 :=
by { ext v, exact q.comp_coeff_zero p _ _ }
lemma comp_coeff_one (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)
  (v : fin 1 â†’ E) : (q.comp p) 1 v = q 1 (Î» i, p 1 v) :=
begin
  have : {composition.ones 1} = (finset.univ : finset (composition 1)) :=
    finset.eq_univ_of_card _ (by simp [composition_card]),
  simp only [formal_multilinear_series.comp, comp_along_composition_apply, â† this,
    finset.sum_singleton],
  refine q.congr (by simp) (Î» i hi1 hi2, _),
  simp only [apply_composition_ones],
  exact p.congr rfl (Î» j hj1 hj2, by congr)
end
lemma remove_zero_comp_of_pos (q : formal_multilinear_series ğ•œ F G)
  (p : formal_multilinear_series ğ•œ E F) {n : â„•} (hn : 0 < n) :
  q.remove_zero.comp p n = q.comp p n :=
begin
  ext v,
  simp only [formal_multilinear_series.comp, comp_along_composition,
    continuous_multilinear_map.comp_along_composition_apply, continuous_multilinear_map.sum_apply],
  apply finset.sum_congr rfl (Î» c hc, _),
  rw remove_zero_of_pos _ (c.length_pos_of_pos hn)
end
@[simp] lemma comp_remove_zero (q : formal_multilinear_series ğ•œ F G)
  (p : formal_multilinear_series ğ•œ E F) :
  q.comp p.remove_zero = q.comp p :=
by { ext n, simp [formal_multilinear_series.comp] }
end formal_multilinear_series
end topological
variables [nondiscrete_normed_field ğ•œ]
  [normed_group E] [normed_space ğ•œ E]
  [normed_group F] [normed_space ğ•œ F]
  [normed_group G] [normed_space ğ•œ G]
  [normed_group H] [normed_space ğ•œ H]
namespace formal_multilinear_series
lemma comp_along_composition_bound {n : â„•}
  (p : formal_multilinear_series ğ•œ E F) (c : composition n)
  (f : continuous_multilinear_map ğ•œ (Î» (i : fin c.length), F) G) (v : fin n â†’ E) :
  âˆ¥f.comp_along_composition p c vâˆ¥ â‰¤
    âˆ¥fâˆ¥ * (âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥) * (âˆ i : fin n, âˆ¥v iâˆ¥) :=
calc âˆ¥f.comp_along_composition p c vâˆ¥ = âˆ¥f (p.apply_composition c v)âˆ¥ : rfl
... â‰¤ âˆ¥fâˆ¥ * âˆ i, âˆ¥p.apply_composition c v iâˆ¥ : continuous_multilinear_map.le_op_norm _ _
... â‰¤ âˆ¥fâˆ¥ * âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥ *
        âˆ j : fin (c.blocks_fun i), âˆ¥(v âˆ˜ (c.embedding i)) jâˆ¥ :
  begin
    apply mul_le_mul_of_nonneg_left _ (norm_nonneg _),
    refine finset.prod_le_prod (Î» i hi, norm_nonneg _) (Î» i hi, _),
    apply continuous_multilinear_map.le_op_norm,
  end
... = âˆ¥fâˆ¥ * (âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥) *
        âˆ i (j : fin (c.blocks_fun i)), âˆ¥(v âˆ˜ (c.embedding i)) jâˆ¥ :
  by rw [finset.prod_mul_distrib, mul_assoc]
... = âˆ¥fâˆ¥ * (âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥) * (âˆ i : fin n, âˆ¥v iâˆ¥) :
  by { rw [â† c.blocks_fin_equiv.prod_comp, â† finset.univ_sigma_univ, finset.prod_sigma],
       congr }
lemma comp_along_composition_norm {n : â„•}
  (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)
  (c : composition n) :
  âˆ¥q.comp_along_composition p câˆ¥ â‰¤ âˆ¥q c.lengthâˆ¥ * âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥ :=
continuous_multilinear_map.op_norm_le_bound _
  (mul_nonneg (norm_nonneg _) (finset.prod_nonneg (Î» i hi, norm_nonneg _)))
    (comp_along_composition_bound _ _ _)
lemma comp_along_composition_nnnorm {n : â„•}
  (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)
  (c : composition n) :
  âˆ¥q.comp_along_composition p câˆ¥â‚Š â‰¤ âˆ¥q c.lengthâˆ¥â‚Š * âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥â‚Š :=
by { rw â† nnreal.coe_le_coe, push_cast, exact q.comp_along_composition_norm p c }
section
variables (ğ•œ E)
def id : formal_multilinear_series ğ•œ E E
| 0 := 0
| 1 := (continuous_multilinear_curry_fin1 ğ•œ E E).symm (continuous_linear_map.id ğ•œ E)
| _ := 0
@[simp] lemma id_apply_one (v : fin 1 â†’ E) : (formal_multilinear_series.id ğ•œ E) 1 v = v 0 := rfl
lemma id_apply_one' {n : â„•} (h : n = 1) (v : fin n â†’ E) :
  (id ğ•œ E) n v = v âŸ¨0, h.symm â–¸ zero_lt_oneâŸ© :=
begin
  subst n,
  apply id_apply_one
end
@[simp] lemma id_apply_ne_one {n : â„•} (h : n â‰  1) : (formal_multilinear_series.id ğ•œ E) n = 0 :=
by { cases n, { refl }, cases n, { contradiction }, refl }
end
@[simp] theorem comp_id (p : formal_multilinear_series ğ•œ E F) : p.comp (id ğ•œ E) = p :=
begin
  ext1 n,
  dsimp [formal_multilinear_series.comp],
  rw finset.sum_eq_single (composition.ones n),
  show comp_along_composition p (id ğ•œ E) (composition.ones n) = p n,
  { ext v,
    rw comp_along_composition_apply,
    apply p.congr (composition.ones_length n),
    intros,
    rw apply_composition_ones,
    refine congr_arg v _,
    rw [fin.ext_iff, fin.coe_cast_le, fin.coe_mk, fin.coe_mk], },
  show âˆ€ (b : composition n),
    b âˆˆ finset.univ â†’ b â‰  composition.ones n â†’ comp_along_composition p (id ğ•œ E) b = 0,
  { assume b _ hb,
    obtain âŸ¨k, hk, lt_kâŸ© : âˆƒ (k : â„•) (H : k âˆˆ composition.blocks b), 1 < k :=
      composition.ne_ones_iff.1 hb,
    obtain âŸ¨i, i_lt, hiâŸ© : âˆƒ (i : â„•) (h : i < b.blocks.length), b.blocks.nth_le i h = k :=
      nth_le_of_mem hk,
    let j : fin b.length := âŸ¨i, b.blocks_length â–¸ i_ltâŸ©,
    have A : 1 < b.blocks_fun j := by convert lt_k,
    ext v,
    rw [comp_along_composition_apply, continuous_multilinear_map.zero_apply],
    apply continuous_multilinear_map.map_coord_zero _ j,
    dsimp [apply_composition],
    rw id_apply_ne_one _ _ (ne_of_gt A),
    refl },
  { simp }
end
@[simp] theorem id_comp (p : formal_multilinear_series ğ•œ E F) (h : p 0 = 0) : (id ğ•œ F).comp p = p :=
begin
  ext1 n,
  by_cases hn : n = 0,
  { rw [hn, h],
    ext v,
    rw [comp_coeff_zero', id_apply_ne_one _ _ zero_ne_one],
    refl },
  { dsimp [formal_multilinear_series.comp],
    have n_pos : 0 < n := bot_lt_iff_ne_bot.mpr hn,
    rw finset.sum_eq_single (composition.single n n_pos),
    show comp_along_composition (id ğ•œ F) p (composition.single n n_pos) = p n,
    { ext v,
      rw [comp_along_composition_apply, id_apply_one' _ _ (composition.single_length n_pos)],
      dsimp [apply_composition],
      refine p.congr rfl (Î» i him hin, congr_arg v $ _),
      ext, simp },
    show âˆ€ (b : composition n),
      b âˆˆ finset.univ â†’ b â‰  composition.single n n_pos â†’ comp_along_composition (id ğ•œ F) p b = 0,
    { assume b _ hb,
      have A : b.length â‰  1, by simpa [composition.eq_single_iff_length] using hb,
      ext v,
      rw [comp_along_composition_apply, id_apply_ne_one _ _ A],
      refl },
    { simp } }
end
section
theorem comp_summable_nnreal
  (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F)
  (hq : 0 < q.radius) (hp : 0 < p.radius) :
  âˆƒ r > (0 : â„â‰¥0),
    summable (Î» i : Î£ n, composition n, âˆ¥q.comp_along_composition p i.2âˆ¥â‚Š * r ^ i.1) :=
begin
  rcases ennreal.lt_iff_exists_nnreal_btwn.1 (lt_min ennreal.zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©,
  rcases ennreal.lt_iff_exists_nnreal_btwn.1 (lt_min ennreal.zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©,
  simp only [lt_min_iff, ennreal.coe_lt_one_iff, ennreal.coe_pos] at hrp hrq rp_pos rq_pos,
  obtain âŸ¨Cq, hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, âˆ¥q nâˆ¥â‚Š * rq^n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2,
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, âˆ¥p nâˆ¥â‚Š * rp^n â‰¤ Cp,
  { rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©,
    exact âŸ¨max Cp 1, le_max_right _ _, Î» n, (hCp n).trans (le_max_left _ _)âŸ© },
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹,
  have r0_pos : 0 < r0 := nnreal.inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1)),
  set r : â„â‰¥0 := rp * rq * r0,
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos,
  have I : âˆ€ (i : Î£ (n : â„•), composition n),
    âˆ¥q.comp_along_composition p i.2âˆ¥â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1,
  { rintros âŸ¨n, câŸ©,
    have A,
    calc âˆ¥q c.lengthâˆ¥â‚Š * rq ^ n â‰¤ âˆ¥q c.lengthâˆ¥â‚Š* rq ^ c.length :
      mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
    ... â‰¤ Cq : hCq _,
    have B,
    calc ((âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥â‚Š) * rp ^ n)
        = âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥â‚Š * rp ^ c.blocks_fun i :
      by simp only [finset.prod_mul_distrib, finset.prod_pow_eq_pow_sum, c.sum_blocks_fun]
    ... â‰¤ âˆ i : fin c.length, Cp : finset.prod_le_prod' (Î» i _, hCp _)
    ... = Cp ^ c.length : by simp
    ... â‰¤ Cp ^ n : pow_le_pow hCp1 c.length_le,
    calc âˆ¥q.comp_along_composition p câˆ¥â‚Š * r ^ n
        â‰¤ (âˆ¥q c.lengthâˆ¥â‚Š * âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥â‚Š) * r ^ n :
          mul_le_mul' (q.comp_along_composition_nnnorm p c) le_rfl
    ... = (âˆ¥q c.lengthâˆ¥â‚Š * rq ^ n) * ((âˆ i, âˆ¥p (c.blocks_fun i)âˆ¥â‚Š) * rp ^ n) * r0 ^ n :
          by { simp only [r, mul_pow], ring }
    ... â‰¤ Cq * Cp ^ n * r0 ^ n : mul_le_mul' (mul_le_mul' A B) le_rfl
    ... = Cq / 4 ^ n :
      begin
        simp only [r0],
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne'],
        ring
      end },
  refine âŸ¨r, r_pos, nnreal.summable_of_le I _âŸ©,
  simp_rw div_eq_mul_inv,
  refine summable.mul_left _ _,
  have : âˆ€ n : â„•, has_sum (Î» c : composition n, (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n),
  { intro n,
    convert has_sum_fintype (Î» c : composition n, (4 ^ n : â„â‰¥0)â»Â¹),
    simp [finset.card_univ, composition_card, div_eq_mul_inv] },
  refine nnreal.summable_sigma.2 âŸ¨Î» n, (this n).summable, (nnreal.summable_nat_add_iff 1).1 _âŸ©,
  convert (nnreal.summable_geometric (nnreal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4),
  ext1 n,
  rw [(this _).tsum_eq, add_tsub_cancel_right],
  field_simp [â† mul_assoc, pow_succ', mul_pow, show (4 : â„â‰¥0) = 2 * 2, from (two_mul 2).symm,
    mul_right_comm]
end
end
theorem le_comp_radius_of_summable
  (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (r : â„â‰¥0)
  (hr : summable (Î» i : (Î£ n, composition n), âˆ¥q.comp_along_composition p i.2âˆ¥â‚Š * r ^ i.1)) :
  (r : â„â‰¥0âˆ) â‰¤ (q.comp p).radius :=
begin
  refine le_radius_of_bound_nnreal _
    (âˆ‘' i : (Î£ n, composition n), âˆ¥comp_along_composition q p i.sndâˆ¥â‚Š * r ^ i.fst) (Î» n, _),
  calc âˆ¥formal_multilinear_series.comp q p nâˆ¥â‚Š * r ^ n â‰¤
  âˆ‘' (c : composition n), âˆ¥comp_along_composition q p câˆ¥â‚Š * r ^ n :
    begin
      rw [tsum_fintype, â† finset.sum_mul],
      exact mul_le_mul' (nnnorm_sum_le _ _) le_rfl
    end
  ... â‰¤ âˆ‘' (i : Î£ (n : â„•), composition n), âˆ¥comp_along_composition q p i.sndâˆ¥â‚Š * r ^ i.fst :
    nnreal.tsum_comp_le_tsum_of_inj hr sigma_mk_injective
end
def comp_partial_sum_source (m M N : â„•) : finset (Î£ n, (fin n) â†’ â„•) :=
finset.sigma (finset.Ico m M) (Î» (n : â„•), fintype.pi_finset (Î» (i : fin n), finset.Ico 1 N) : _)
@[simp] lemma mem_comp_partial_sum_source_iff (m M N : â„•) (i : Î£ n, (fin n) â†’ â„•) :
  i âˆˆ comp_partial_sum_source m M N â†”
    (m â‰¤ i.1 âˆ§ i.1 < M) âˆ§ âˆ€ (a : fin i.1), 1 â‰¤ i.2 a âˆ§ i.2 a < N :=
by simp only [comp_partial_sum_source, finset.mem_Ico, fintype.mem_pi_finset, finset.mem_sigma,
  iff_self]
def comp_change_of_variables (m M N : â„•) (i : Î£ n, (fin n) â†’ â„•)
  (hi : i âˆˆ comp_partial_sum_source m M N) : (Î£ n, composition n) :=
begin
  rcases i with âŸ¨n, fâŸ©,
  rw mem_comp_partial_sum_source_iff at hi,
  refine âŸ¨âˆ‘ j, f j, of_fn (Î» a, f a), Î» i hi', _, by simp [sum_of_fn]âŸ©,
  obtain âŸ¨j, rflâŸ© : âˆƒ (j : fin n), f j = i, by rwa [mem_of_fn, set.mem_range] at hi',
  exact (hi.2 j).1
end
@[simp] lemma comp_change_of_variables_length
  (m M N : â„•) {i : Î£ n, (fin n) â†’ â„•} (hi : i âˆˆ comp_partial_sum_source m M N) :
  composition.length (comp_change_of_variables m M N i hi).2 = i.1 :=
begin
  rcases i with âŸ¨k, blocks_funâŸ©,
  dsimp [comp_change_of_variables],
  simp only [composition.length, map_of_fn, length_of_fn]
end
lemma comp_change_of_variables_blocks_fun
  (m M N : â„•) {i : Î£ n, (fin n) â†’ â„•} (hi : i âˆˆ comp_partial_sum_source m M N) (j : fin i.1) :
  (comp_change_of_variables m M N i hi).2.blocks_fun
    âŸ¨j, (comp_change_of_variables_length m M N hi).symm â–¸ j.2âŸ© = i.2 j :=
begin
  rcases i with âŸ¨n, fâŸ©,
  dsimp [composition.blocks_fun, composition.blocks, comp_change_of_variables],
  simp only [map_of_fn, nth_le_of_fn', function.comp_app],
  apply congr_arg,
  exact fin.eta _ _
end
def comp_partial_sum_target_set (m M N : â„•) : set (Î£ n, composition n) :=
{i | (m â‰¤ i.2.length) âˆ§ (i.2.length < M) âˆ§ (âˆ€ (j : fin i.2.length), i.2.blocks_fun j < N)}
lemma comp_partial_sum_target_subset_image_comp_partial_sum_source
  (m M N : â„•) (i : Î£ n, composition n) (hi : i âˆˆ comp_partial_sum_target_set m M N) :
  âˆƒ j (hj : j âˆˆ comp_partial_sum_source m M N), i = comp_change_of_variables m M N j hj :=
begin
  rcases i with âŸ¨n, câŸ©,
  refine âŸ¨âŸ¨c.length, c.blocks_funâŸ©, _, _âŸ©,
  { simp only [comp_partial_sum_target_set, set.mem_set_of_eq] at hi,
    simp only [mem_comp_partial_sum_source_iff, hi.left, hi.right, true_and, and_true],
    exact Î» a, c.one_le_blocks' _ },
  { dsimp [comp_change_of_variables],
    rw composition.sigma_eq_iff_blocks_eq,
    simp only [composition.blocks_fun, composition.blocks, subtype.coe_eta, nth_le_map'],
    conv_lhs { rw â† of_fn_nth_le c.blocks } }
end
def comp_partial_sum_target (m M N : â„•) : finset (Î£ n, composition n) :=
set.finite.to_finset $ ((finset.finite_to_set _).dependent_image _).subset $
  comp_partial_sum_target_subset_image_comp_partial_sum_source m M N
@[simp] lemma mem_comp_partial_sum_target_iff {m M N : â„•} {a : Î£ n, composition n} :
  a âˆˆ comp_partial_sum_target m M N â†”
    m â‰¤ a.2.length âˆ§ a.2.length < M âˆ§ (âˆ€ (j : fin a.2.length), a.2.blocks_fun j < N) :=
by simp [comp_partial_sum_target, comp_partial_sum_target_set]
lemma comp_change_of_variables_sum {Î± : Type*} [add_comm_monoid Î±] (m M N : â„•)
  (f : (Î£ (n : â„•), fin n â†’ â„•) â†’ Î±) (g : (Î£ n, composition n) â†’ Î±)
  (h : âˆ€ e (he : e âˆˆ comp_partial_sum_source m M N),
    f e = g (comp_change_of_variables m M N e he)) :
  âˆ‘ e in comp_partial_sum_source m M N, f e = âˆ‘ e in comp_partial_sum_target m M N, g e :=
begin
  apply finset.sum_bij (comp_change_of_variables m M N),
lemma comp_partial_sum_target_tendsto_at_top :
  tendsto (Î» N, comp_partial_sum_target 0 N N) at_top at_top :=
begin
  apply monotone.tendsto_at_top_finset,
  { assume m n hmn a ha,
    have : âˆ€ i, i < m â†’ i < n := Î» i hi, lt_of_lt_of_le hi hmn,
    tidy },
  { rintros âŸ¨n, câŸ©,
    simp only [mem_comp_partial_sum_target_iff],
    obtain âŸ¨n, hnâŸ© : bdd_above â†‘(finset.univ.image (Î» (i : fin c.length), c.blocks_fun i)) :=
      finset.bdd_above _,
    refine âŸ¨max n c.length + 1, bot_le, lt_of_le_of_lt (le_max_right n c.length) (lt_add_one _),
      Î» j, lt_of_le_of_lt (le_trans _ (le_max_left _ _)) (lt_add_one _)âŸ©,
    apply hn,
    simp only [finset.mem_image_of_mem, finset.mem_coe, finset.mem_univ] }
end
lemma comp_partial_sum
  (q : formal_multilinear_series ğ•œ F G) (p : formal_multilinear_series ğ•œ E F) (N : â„•) (z : E) :
  q.partial_sum N (âˆ‘ i in finset.Ico 1 N, p i (Î» j, z)) =
    âˆ‘ i in comp_partial_sum_target 0 N N, q.comp_along_composition p i.2 (Î» j, z) :=
begin
theorem has_fpower_series_at.comp {g : F â†’ G} {f : E â†’ F}
  {q : formal_multilinear_series ğ•œ F G} {p : formal_multilinear_series ğ•œ E F} {x : E}
  (hg : has_fpower_series_at g q (f x)) (hf : has_fpower_series_at f p x) :
  has_fpower_series_at (g âˆ˜ f) (q.comp p) x :=
begin
  rcases hg with âŸ¨rg, HgâŸ©,
  rcases hf with âŸ¨rf, HfâŸ©,
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©,
  have : continuous_at f x := Hf.analytic_at.continuous_at,
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ (Î´ : â„â‰¥0âˆ) (H : 0 < Î´),
    âˆ€ {z : E}, z âˆˆ emetric.ball x Î´ â†’ f z âˆˆ emetric.ball (f x) rg,
  { have : emetric.ball (f x) rg âˆˆ ğ“ (f x) := emetric.ball_mem_nhds _ Hg.r_pos,
    rcases emetric.mem_nhds_iff.1 (Hf.analytic_at.continuous_at this) with âŸ¨Î´, Î´pos, HÎ´âŸ©,
    exact âŸ¨Î´, Î´pos, Î» z hz, HÎ´ hzâŸ© },
  let rf' := min rf Î´,
  have min_pos : 0 < min rf' r,
    by simp only [r_pos, Hf.r_pos, Î´pos, lt_min_iff, ennreal.coe_pos, and_self],
  refine âŸ¨min rf' r, _âŸ©,
  refine âŸ¨le_trans (min_le_right rf' r)
    (formal_multilinear_series.le_comp_radius_of_summable q p r hr), min_pos, Î» y hy, _âŸ©,
theorem analytic_at.comp {g : F â†’ G} {f : E â†’ F} {x : E}
  (hg : analytic_at ğ•œ g (f x)) (hf : analytic_at ğ•œ f x) : analytic_at ğ•œ (g âˆ˜ f) x :=
let âŸ¨q, hqâŸ© := hg, âŸ¨p, hpâŸ© := hf in (hq.comp hp).analytic_at
namespace composition
variable {n : â„•}
lemma sigma_composition_eq_iff (i j : Î£ (a : composition n), composition a.length) :
  i = j â†” i.1.blocks = j.1.blocks âˆ§ i.2.blocks = j.2.blocks :=
begin
  refine âŸ¨by rintro rfl; exact âŸ¨rfl, rflâŸ©, _âŸ©,
  rcases i with âŸ¨a, bâŸ©,
  rcases j with âŸ¨a', b'âŸ©,
  rintros âŸ¨h, h'âŸ©,
  have H : a = a', by { ext1, exact h },
  induction H, congr, ext1, exact h'
end
lemma sigma_pi_composition_eq_iff
  (u v : Î£ (c : composition n), Î  (i : fin c.length), composition (c.blocks_fun i)) :
  u = v â†” of_fn (Î» i, (u.2 i).blocks) = of_fn (Î» i, (v.2 i).blocks) :=
begin
  refine âŸ¨Î» H, by rw H, Î» H, _âŸ©,
  rcases u with âŸ¨a, bâŸ©,
  rcases v with âŸ¨a', b'âŸ©,
  dsimp at H,
  have h : a = a',
  { ext1,
    have : map list.sum (of_fn (Î» (i : fin (composition.length a)), (b i).blocks)) =
      map list.sum (of_fn (Î» (i : fin (composition.length a')), (b' i).blocks)), by rw H,
    simp only [map_of_fn] at this,
    change of_fn (Î» (i : fin (composition.length a)), (b i).blocks.sum) =
      of_fn (Î» (i : fin (composition.length a')), (b' i).blocks.sum) at this,
    simpa [composition.blocks_sum, composition.of_fn_blocks_fun] using this },
  induction h,
  simp only [true_and, eq_self_iff_true, heq_iff_eq],
  ext i : 2,
  have : nth_le (of_fn (Î» (i : fin (composition.length a)), (b i).blocks)) i (by simp [i.is_lt]) =
         nth_le (of_fn (Î» (i : fin (composition.length a)), (b' i).blocks)) i (by simp [i.is_lt]) :=
    nth_le_of_eq H _,
  rwa [nth_le_of_fn, nth_le_of_fn] at this
end
def gather (a : composition n) (b : composition a.length) : composition n :=
{ blocks := (a.blocks.split_wrt_composition b).map sum,
  blocks_pos :=
  begin
    rw forall_mem_map_iff,
    intros j hj,
    suffices H : âˆ€ i âˆˆ j, 1 â‰¤ i, from
      calc 0 < j.length : length_pos_of_mem_split_wrt_composition hj
        ... â‰¤ j.sum    : length_le_sum_of_one_le _ H,
    intros i hi,
    apply a.one_le_blocks,
    rw â† a.blocks.join_split_wrt_composition b,
    exact mem_join_of_mem hj hi,
  end,
  blocks_sum := by { rw [â† sum_join, join_split_wrt_composition, a.blocks_sum] } }
lemma length_gather (a : composition n) (b : composition a.length) :
  length (a.gather b) = b.length :=
show (map list.sum (a.blocks.split_wrt_composition b)).length = b.blocks.length,
by rw [length_map, length_split_wrt_composition]
def sigma_composition_aux (a : composition n) (b : composition a.length)
  (i : fin (a.gather b).length) :
  composition ((a.gather b).blocks_fun i) :=
{ blocks := nth_le (a.blocks.split_wrt_composition b) i
    (by { rw [length_split_wrt_composition, â† length_gather], exact i.2 }),
  blocks_pos := assume i hi, a.blocks_pos
    (by { rw â† a.blocks.join_split_wrt_composition b,
          exact mem_join_of_mem (nth_le_mem _ _ _) hi }),
  blocks_sum := by simp only [composition.blocks_fun, nth_le_map', composition.gather] }
lemma length_sigma_composition_aux (a : composition n) (b : composition a.length)
  (i : fin b.length) :
  composition.length (composition.sigma_composition_aux a b âŸ¨i, (length_gather a b).symm â–¸ i.2âŸ©) =
    composition.blocks_fun b i :=
show list.length (nth_le (split_wrt_composition a.blocks b) i _) = blocks_fun b i,
by { rw [nth_le_map_rev list.length, nth_le_of_eq (map_length_split_wrt_composition _ _)], refl }
lemma blocks_fun_sigma_composition_aux (a : composition n) (b : composition a.length)
  (i : fin b.length) (j : fin (blocks_fun b i)) :
  blocks_fun (sigma_composition_aux a b âŸ¨i, (length_gather a b).symm â–¸ i.2âŸ©)
      âŸ¨j, (length_sigma_composition_aux a b i).symm â–¸ j.2âŸ© = blocks_fun a (embedding b i j) :=
show nth_le (nth_le _ _ _) _ _ = nth_le a.blocks _ _,
by { rw [nth_le_of_eq (nth_le_split_wrt_composition _ _ _), nth_le_drop', nth_le_take'], refl }
lemma size_up_to_size_up_to_add (a : composition n) (b : composition a.length)
  {i j : â„•} (hi : i < b.length) (hj : j < blocks_fun b âŸ¨i, hiâŸ©) :
  size_up_to a (size_up_to b i + j) = size_up_to (a.gather b) i +
    (size_up_to (sigma_composition_aux a b âŸ¨i, (length_gather a b).symm â–¸ hiâŸ©) j) :=
begin
  induction j with j IHj,
  { show sum (take ((b.blocks.take i).sum) a.blocks) =
      sum (take i (map sum (split_wrt_composition a.blocks b))),
    induction i with i IH,
    { refl },
    { have A : i < b.length := nat.lt_of_succ_lt hi,
      have B : i < list.length (map list.sum (split_wrt_composition a.blocks b)), by simp [A],
      have C : 0 < blocks_fun b âŸ¨i, AâŸ© := composition.blocks_pos' _ _ _,
      rw [sum_take_succ _ _ B, â† IH A C],
      have : take (sum (take i b.blocks)) a.blocks =
        take (sum (take i b.blocks)) (take (sum (take (i+1) b.blocks)) a.blocks),
      { rw [take_take, min_eq_left],
        apply monotone_sum_take _ (nat.le_succ _) },
      rw [this, nth_le_map', nth_le_split_wrt_composition,
        â† take_append_drop (sum (take i b.blocks))
          ((take (sum (take (nat.succ i) b.blocks)) a.blocks)), sum_append],
      congr,
      rw [take_append_drop] } },
  { have A : j < blocks_fun b âŸ¨i, hiâŸ© := lt_trans (lt_add_one j) hj,
    have B : j < length (sigma_composition_aux a b âŸ¨i, (length_gather a b).symm â–¸ hiâŸ©),
      by { convert A, rw [â† length_sigma_composition_aux], refl },
    have C : size_up_to b i + j < size_up_to b (i + 1),
    { simp only [size_up_to_succ b hi, add_lt_add_iff_left],
      exact A },
    have D : size_up_to b i + j < length a := lt_of_lt_of_le C (b.size_up_to_le _),
    have : size_up_to b i + nat.succ j = (size_up_to b i + j).succ := rfl,
    rw [this, size_up_to_succ _ D, IHj A, size_up_to_succ _ B],
    simp only [sigma_composition_aux, add_assoc, add_left_inj, fin.coe_mk],
    rw [nth_le_of_eq (nth_le_split_wrt_composition _ _ _), nth_le_drop', nth_le_take _ _ C] }
end
def sigma_equiv_sigma_pi (n : â„•) :
  (Î£ (a : composition n), composition a.length) â‰ƒ
  (Î£ (c : composition n), Î  (i : fin c.length), composition (c.blocks_fun i)) :=
{ to_fun := Î» i, âŸ¨i.1.gather i.2, i.1.sigma_composition_aux i.2âŸ©,
  inv_fun := Î» i, âŸ¨
    { blocks := (of_fn (Î» j, (i.2 j).blocks)).join,
      blocks_pos :=
      begin
        simp only [and_imp, list.mem_join, exists_imp_distrib, forall_mem_of_fn_iff],
        exact Î» i j hj, composition.blocks_pos _ hj
      end,
      blocks_sum := by simp [sum_of_fn, composition.blocks_sum, composition.sum_blocks_fun] },
    { blocks := of_fn (Î» j, (i.2 j).length),
      blocks_pos := forall_mem_of_fn_iff.2
        (Î» j, composition.length_pos_of_pos _ (composition.blocks_pos' _ _ _)),
      blocks_sum := by { dsimp only [composition.length], simp [sum_of_fn] } }âŸ©,
  left_inv :=
  begin
  let f : (Î£ (a : composition n), composition a.length) â†’ H :=
    Î» c, r c.2.length (apply_composition q c.2 (apply_composition p c.1 v)),
  let g : (Î£ (c : composition n), Î  (i : fin c.length), composition (c.blocks_fun i)) â†’ H :=
    Î» c, r c.1.length (Î» (i : fin c.1.length),
      q (c.2 i).length (apply_composition p (c.2 i) (v âˆ˜ c.1.embedding i))),
  suffices : âˆ‘ c, f c = âˆ‘ c, g c,
    by simpa only [formal_multilinear_series.comp, continuous_multilinear_map.sum_apply,
      comp_along_composition_apply, continuous_multilinear_map.map_sum, finset.sum_sigma',
      apply_composition],
  rw â† (sigma_equiv_sigma_pi n).sum_comp,
  apply finset.sum_congr rfl,
  rintros âŸ¨a, bâŸ© _,
  dsimp [f, g, sigma_equiv_sigma_pi],
