import category_theory.limits.is_limit
import category_theory.category.ulift
noncomputable theory
open category_theory category_theory.category category_theory.functor opposite
namespace category_theory.limits
@[nolint has_inhabited_instance]
structure limit_cone (F : J â¥¤ C) :=
(cone : cone F)
(is_limit : is_limit cone)
class has_limit (F : J â¥¤ C) : Prop :=
mk' :: (exists_limit : nonempty (limit_cone F))
lemma has_limit.mk {F : J â¥¤ C} (d : limit_cone F) : has_limit F :=
âŸ¨nonempty.intro dâŸ©
def get_limit_cone (F : J â¥¤ C) [has_limit F] : limit_cone F :=
classical.choice $ has_limit.exists_limit
variables (J C)
class has_limits_of_shape : Prop :=
(has_limit : Î  F : J â¥¤ C, has_limit F . tactic.apply_instance)
class has_limits_of_size (C : Type u) [category.{v} C] : Prop :=
(has_limits_of_shape :
  Î  (J : Type uâ‚) [ğ’¥ : category.{vâ‚} J], has_limits_of_shape J C . tactic.apply_instance)
abbreviation has_limits (C : Type u) [category.{v} C] : Prop := has_limits_of_size.{v v} C
lemma has_limits.has_limits_of_shape {C : Type u} [category.{v} C] [has_limits C]
  (J : Type v) [category.{v} J] :
  has_limits_of_shape J C := has_limits_of_size.has_limits_of_shape J
variables {J C}
def limit.cone (F : J â¥¤ C) [has_limit F] : cone F := (get_limit_cone F).cone
def limit (F : J â¥¤ C) [has_limit F] := (limit.cone F).X
def limit.Ï€ (F : J â¥¤ C) [has_limit F] (j : J) : limit F âŸ¶ F.obj j :=
(limit.cone F).Ï€.app j
@[simp] lemma limit.cone_X {F : J â¥¤ C} [has_limit F] :
  (limit.cone F).X = limit F := rfl
@[simp] lemma limit.cone_Ï€ {F : J â¥¤ C} [has_limit F] :
  (limit.cone F).Ï€.app = limit.Ï€ _ := rfl
@[simp, reassoc] lemma limit.w (F : J â¥¤ C) [has_limit F] {j j' : J} (f : j âŸ¶ j') :
  limit.Ï€ F j â‰« F.map f = limit.Ï€ F j' := (limit.cone F).w f
def limit.is_limit (F : J â¥¤ C) [has_limit F] : is_limit (limit.cone F) :=
(get_limit_cone F).is_limit
def limit.lift (F : J â¥¤ C) [has_limit F] (c : cone F) : c.X âŸ¶ limit F :=
(limit.is_limit F).lift c
@[simp] lemma limit.is_limit_lift {F : J â¥¤ C} [has_limit F] (c : cone F) :
  (limit.is_limit F).lift c = limit.lift F c := rfl
@[simp, reassoc] lemma limit.lift_Ï€ {F : J â¥¤ C} [has_limit F] (c : cone F) (j : J) :
  limit.lift F c â‰« limit.Ï€ F j = c.Ï€.app j :=
is_limit.fac _ c j
def lim_map {F G : J â¥¤ C} [has_limit F] [has_limit G] (Î± : F âŸ¶ G) : limit F âŸ¶ limit G :=
is_limit.map _ (limit.is_limit G) Î±
@[simp, reassoc] lemma lim_map_Ï€ {F G : J â¥¤ C} [has_limit F] [has_limit G] (Î± : F âŸ¶ G) (j : J) :
  lim_map Î± â‰« limit.Ï€ G j = limit.Ï€ F j â‰« Î±.app j :=
limit.lift_Ï€ _ j
def limit.cone_morphism {F : J â¥¤ C} [has_limit F] (c : cone F) :
  c âŸ¶ limit.cone F :=
(limit.is_limit F).lift_cone_morphism c
@[simp] lemma limit.cone_morphism_hom {F : J â¥¤ C} [has_limit F] (c : cone F) :
  (limit.cone_morphism c).hom = limit.lift F c := rfl
lemma limit.cone_morphism_Ï€ {F : J â¥¤ C} [has_limit F] (c : cone F) (j : J) :
  (limit.cone_morphism c).hom â‰« limit.Ï€ F j = c.Ï€.app j :=
by simp
@[simp, reassoc] lemma limit.cone_point_unique_up_to_iso_hom_comp {F : J â¥¤ C} [has_limit F]
  {c : cone F} (hc : is_limit c) (j : J) :
  (is_limit.cone_point_unique_up_to_iso hc (limit.is_limit _)).hom â‰« limit.Ï€ F j = c.Ï€.app j :=
is_limit.cone_point_unique_up_to_iso_hom_comp _ _ _
@[simp, reassoc] lemma limit.cone_point_unique_up_to_iso_inv_comp {F : J â¥¤ C} [has_limit F]
  {c : cone F} (hc : is_limit c) (j : J) :
  (is_limit.cone_point_unique_up_to_iso (limit.is_limit _) hc).inv â‰« limit.Ï€ F j = c.Ï€.app j :=
is_limit.cone_point_unique_up_to_iso_inv_comp _ _ _
lemma limit.exists_unique {F : J â¥¤ C} [has_limit F] (t : cone F) :
  âˆƒ! (l : t.X âŸ¶ limit F), âˆ€ j, l â‰« limit.Ï€ F j = t.Ï€.app j :=
(limit.is_limit F).exists_unique _
def limit.iso_limit_cone {F : J â¥¤ C} [has_limit F] (t : limit_cone F) :
  limit F â‰… t.cone.X :=
is_limit.cone_point_unique_up_to_iso (limit.is_limit F) t.is_limit
@[simp, reassoc] lemma limit.iso_limit_cone_hom_Ï€
  {F : J â¥¤ C} [has_limit F] (t : limit_cone F) (j : J) :
  (limit.iso_limit_cone t).hom â‰« t.cone.Ï€.app j = limit.Ï€ F j :=
by { dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso], tidy, }
@[simp, reassoc] lemma limit.iso_limit_cone_inv_Ï€
  {F : J â¥¤ C} [has_limit F] (t : limit_cone F) (j : J) :
  (limit.iso_limit_cone t).inv â‰« limit.Ï€ F j = t.cone.Ï€.app j :=
by { dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso], tidy, }
@[ext] lemma limit.hom_ext {F : J â¥¤ C} [has_limit F] {X : C} {f f' : X âŸ¶ limit F}
  (w : âˆ€ j, f â‰« limit.Ï€ F j = f' â‰« limit.Ï€ F j) : f = f' :=
(limit.is_limit F).hom_ext w
@[simp] lemma limit.lift_map {F G : J â¥¤ C} [has_limit F] [has_limit G] (c : cone F) (Î± : F âŸ¶ G) :
  limit.lift F c â‰« lim_map Î± = limit.lift G ((cones.postcompose Î±).obj c) :=
by { ext, rw [assoc, lim_map_Ï€, limit.lift_Ï€_assoc, limit.lift_Ï€], refl }
@[simp] lemma limit.lift_cone {F : J â¥¤ C} [has_limit F] :
  limit.lift F (limit.cone F) = ğŸ™ (limit F) :=
(limit.is_limit _).lift_self
def limit.hom_iso (F : J â¥¤ C) [has_limit F] (W : C) :
  ulift.{uâ‚} (W âŸ¶ limit F : Type v) â‰… (F.cones.obj (op W)) :=
(limit.is_limit F).hom_iso W
@[simp] lemma limit.hom_iso_hom (F : J â¥¤ C) [has_limit F] {W : C} (f : ulift (W âŸ¶ limit F)) :
  (limit.hom_iso F W).hom f = (const J).map f.down â‰« (limit.cone F).Ï€ :=
(limit.is_limit F).hom_iso_hom f
def limit.hom_iso' (F : J â¥¤ C) [has_limit F] (W : C) :
  ulift.{uâ‚} ((W âŸ¶ limit F) : Type v) â‰…
    { p : Î  j, W âŸ¶ F.obj j // âˆ€ {j j' : J} (f : j âŸ¶ j'), p j â‰« F.map f = p j' } :=
(limit.is_limit F).hom_iso' W
lemma limit.lift_extend {F : J â¥¤ C} [has_limit F] (c : cone F) {X : C} (f : X âŸ¶ c.X) :
  limit.lift F (c.extend f) = f â‰« limit.lift F c :=
by obviously
lemma has_limit_of_iso {F G : J â¥¤ C} [has_limit F] (Î± : F â‰… G) : has_limit G :=
has_limit.mk
{ cone := (cones.postcompose Î±.hom).obj (limit.cone F),
  is_limit :=
  { lift := Î» s, limit.lift F ((cones.postcompose Î±.inv).obj s),
    fac' := Î» s j,
    begin
      rw [cones.postcompose_obj_Ï€, nat_trans.comp_app, limit.cone_Ï€, â†category.assoc, limit.lift_Ï€],
      simp
    end,
    uniq' := Î» s m w,
    begin
      apply limit.hom_ext, intro j,
      rw [limit.lift_Ï€, cones.postcompose_obj_Ï€, nat_trans.comp_app, â†nat_iso.app_inv,
        iso.eq_comp_inv],
      simpa using w j
    end } }
def has_limit.iso_of_nat_iso {F G : J â¥¤ C} [has_limit F] [has_limit G] (w : F â‰… G) :
  limit F â‰… limit G :=
is_limit.cone_points_iso_of_nat_iso (limit.is_limit F) (limit.is_limit G) w
@[simp, reassoc]
lemma has_limit.iso_of_nat_iso_hom_Ï€ {F G : J â¥¤ C} [has_limit F] [has_limit G]
  (w : F â‰… G) (j : J) :
  (has_limit.iso_of_nat_iso w).hom â‰« limit.Ï€ G j = limit.Ï€ F j â‰« w.hom.app j :=
is_limit.cone_points_iso_of_nat_iso_hom_comp _ _ _ _
@[simp, reassoc]
lemma has_limit.iso_of_nat_iso_inv_Ï€ {F G : J â¥¤ C} [has_limit F] [has_limit G]
  (w : F â‰… G) (j : J) :
  (has_limit.iso_of_nat_iso w).inv â‰« limit.Ï€ F j = limit.Ï€ G j â‰« w.inv.app j :=
is_limit.cone_points_iso_of_nat_iso_inv_comp _ _ _ _
@[simp, reassoc]
lemma has_limit.lift_iso_of_nat_iso_hom {F G : J â¥¤ C} [has_limit F] [has_limit G] (t : cone F)
  (w : F â‰… G) :
  limit.lift F t â‰« (has_limit.iso_of_nat_iso w).hom =
    limit.lift G ((cones.postcompose w.hom).obj _) :=
is_limit.lift_comp_cone_points_iso_of_nat_iso_hom _ _ _
@[simp, reassoc]
lemma has_limit.lift_iso_of_nat_iso_inv {F G : J â¥¤ C} [has_limit F] [has_limit G] (t : cone G)
  (w : F â‰… G) :
  limit.lift G t â‰« (has_limit.iso_of_nat_iso w).inv =
    limit.lift F ((cones.postcompose w.inv).obj _) :=
is_limit.lift_comp_cone_points_iso_of_nat_iso_inv _ _ _
def has_limit.iso_of_equivalence {F : J â¥¤ C} [has_limit F] {G : K â¥¤ C} [has_limit G]
   (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) : limit F â‰… limit G :=
is_limit.cone_points_iso_of_equivalence (limit.is_limit F) (limit.is_limit G) e w
@[simp]
lemma has_limit.iso_of_equivalence_hom_Ï€ {F : J â¥¤ C} [has_limit F] {G : K â¥¤ C} [has_limit G]
   (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) (k : K) :
  (has_limit.iso_of_equivalence e w).hom â‰« limit.Ï€ G k =
    limit.Ï€ F (e.inverse.obj k) â‰« w.inv.app (e.inverse.obj k) â‰« G.map (e.counit.app k) :=
begin
  simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom],
  dsimp,
  simp,
end
@[simp]
lemma has_limit.iso_of_equivalence_inv_Ï€ {F : J â¥¤ C} [has_limit F] {G : K â¥¤ C} [has_limit G]
   (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) (j : J) :
  (has_limit.iso_of_equivalence e w).inv â‰« limit.Ï€ F j =
    limit.Ï€ G (e.functor.obj j) â‰« w.hom.app j :=
begin
  simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom],
  dsimp,
  simp,
end
section pre
variables (F) [has_limit F] (E : K â¥¤ J) [has_limit (E â‹™ F)]
def limit.pre : limit F âŸ¶ limit (E â‹™ F) :=
limit.lift (E â‹™ F) ((limit.cone F).whisker E)
@[simp, reassoc] lemma limit.pre_Ï€ (k : K) :
  limit.pre F E â‰« limit.Ï€ (E â‹™ F) k = limit.Ï€ F (E.obj k) :=
by { erw is_limit.fac, refl }
@[simp] lemma limit.lift_pre (c : cone F) :
  limit.lift F c â‰« limit.pre F E = limit.lift (E â‹™ F) (c.whisker E) :=
by ext; simp
variables {L : Type uâ‚ƒ} [category.{vâ‚ƒ} L]
variables (D : L â¥¤ K) [has_limit (D â‹™ E â‹™ F)]
@[simp] lemma limit.pre_pre : limit.pre F E â‰« limit.pre (E â‹™ F) D = limit.pre F (D â‹™ E) :=
by ext j; erw [assoc, limit.pre_Ï€, limit.pre_Ï€, limit.pre_Ï€]; refl
variables {E F}
lemma limit.pre_eq (s : limit_cone (E â‹™ F)) (t : limit_cone F) :
  limit.pre F E =
    (limit.iso_limit_cone t).hom â‰« s.is_limit.lift ((t.cone).whisker E) â‰«
      (limit.iso_limit_cone s).inv :=
by tidy
end pre
section post
variables {D : Type u'} [category.{v'} D]
variables (F) [has_limit F] (G : C â¥¤ D) [has_limit (F â‹™ G)]
def limit.post : G.obj (limit F) âŸ¶ limit (F â‹™ G) :=
limit.lift (F â‹™ G) (G.map_cone (limit.cone F))
@[simp, reassoc] lemma limit.post_Ï€ (j : J) :
  limit.post F G â‰« limit.Ï€ (F â‹™ G) j = G.map (limit.Ï€ F j) :=
by { erw is_limit.fac, refl }
@[simp] lemma limit.lift_post (c : cone F) :
  G.map (limit.lift F c) â‰« limit.post F G = limit.lift (F â‹™ G) (G.map_cone c) :=
by { ext, rw [assoc, limit.post_Ï€, â†G.map_comp, limit.lift_Ï€, limit.lift_Ï€], refl }
@[simp] lemma limit.post_post
  {E : Type u''} [category.{v''} E] (H : D â¥¤ E) [has_limit ((F â‹™ G) â‹™ H)] :
  H.map (limit.post F G) â‰« limit.post (F â‹™ G) H = limit.post F (G â‹™ H) :=
by ext; erw [assoc, limit.post_Ï€, â†H.map_comp, limit.post_Ï€, limit.post_Ï€]; refl
end post
lemma limit.pre_post {D : Type u'} [category.{v'} D]
  (E : K â¥¤ J) (F : J â¥¤ C) (G : C â¥¤ D)
  [has_limit F] [has_limit (E â‹™ F)] [has_limit (F â‹™ G)] [has_limit ((E â‹™ F) â‹™ G)] :
  G.map (limit.pre F E) â‰« limit.post (E â‹™ F) G = limit.post F G â‰« limit.pre (F â‹™ G) E :=
by ext; erw [assoc, limit.post_Ï€, â†G.map_comp, limit.pre_Ï€, assoc, limit.pre_Ï€, limit.post_Ï€]; refl
open category_theory.equivalence
instance has_limit_equivalence_comp (e : K â‰Œ J) [has_limit F] : has_limit (e.functor â‹™ F) :=
has_limit.mk { cone := cone.whisker e.functor (limit.cone F),
  is_limit := is_limit.whisker_equivalence (limit.is_limit F) e, }
lemma has_limit_of_equivalence_comp (e : K â‰Œ J) [has_limit (e.functor â‹™ F)] : has_limit F :=
begin
  haveI : has_limit (e.inverse â‹™ e.functor â‹™ F) := limits.has_limit_equivalence_comp e.symm,
  apply has_limit_of_iso (e.inv_fun_id_assoc F),
end
@[simps obj]
def lim : (J â¥¤ C) â¥¤ C :=
{ obj := Î» F, limit F,
  map := Î» F G Î±, lim_map Î±,
  map_id' := Î» F, by { ext, erw [lim_map_Ï€, category.id_comp, category.comp_id] },
  map_comp' := Î» F G H Î± Î²,
    by ext; erw [assoc, is_limit.fac, is_limit.fac, â†assoc, is_limit.fac, assoc]; refl }
end
variables {F} {G : J â¥¤ C} (Î± : F âŸ¶ G)
  H.map (lim_map Î±) â‰« limit.post G H = limit.post F H â‰« lim_map (whisker_right Î± H) :=
begin
  ext,
  simp only [whisker_right_app, lim_map_Ï€, assoc, limit.post_Ï€_assoc, limit.post_Ï€, â† H.map_comp],
end
def lim_yoneda : lim â‹™ yoneda â‹™ (whiskering_right _ _ _).obj ulift_functor.{uâ‚}
  â‰… category_theory.cones J C :=
nat_iso.of_components (Î» F, nat_iso.of_components (Î» W, limit.hom_iso F (unop W)) (by tidy))
  (by tidy)
end lim_functor
lemma has_limits_of_shape_of_equivalence {J' : Type uâ‚‚} [category.{vâ‚‚} J']
  (e : J â‰Œ J') [has_limits_of_shape J C] : has_limits_of_shape J' C :=
by { constructor, intro F, apply has_limit_of_equivalence_comp e, apply_instance }
variable (C)
lemma has_limits_of_size_shrink [has_limits_of_size.{(max vâ‚ vâ‚‚) (max uâ‚ uâ‚‚)} C] :
  has_limits_of_size.{vâ‚ uâ‚} C :=
âŸ¨Î» J hJ, by exactI has_limits_of_shape_of_equivalence
  (ulift_hom_ulift_category.equiv.{vâ‚‚ uâ‚‚} J).symmâŸ©
@[priority 100]
instance has_smallest_limits_of_has_limits [has_limits C] :
  has_limits_of_size.{0 0} C := has_limits_of_size_shrink.{0 0} C
end limit
section colimit
@[nolint has_inhabited_instance]
structure colimit_cocone (F : J â¥¤ C) :=
(cocone : cocone F)
(is_colimit : is_colimit cocone)
class has_colimit (F : J â¥¤ C) : Prop :=
mk' :: (exists_colimit : nonempty (colimit_cocone F))
lemma has_colimit.mk {F : J â¥¤ C} (d : colimit_cocone F) : has_colimit F :=
âŸ¨nonempty.intro dâŸ©
def get_colimit_cocone (F : J â¥¤ C) [has_colimit F] : colimit_cocone F :=
classical.choice $ has_colimit.exists_colimit
variables (J C)
class has_colimits_of_shape : Prop :=
(has_colimit : Î  F : J â¥¤ C, has_colimit F . tactic.apply_instance)
class has_colimits_of_size (C : Type u) [category.{v} C] : Prop :=
(has_colimits_of_shape :
  Î  (J : Type uâ‚) [ğ’¥ : category.{vâ‚} J], has_colimits_of_shape J C . tactic.apply_instance)
abbreviation has_colimits (C : Type u) [category.{v} C] : Prop := has_colimits_of_size.{v v} C
lemma has_colimits.has_colimits_of_shape {C : Type u} [category.{v} C] [has_colimits C]
  (J : Type v) [category.{v} J] :
  has_colimits_of_shape J C := has_colimits_of_size.has_colimits_of_shape J
variables {J C}
def colimit.cocone (F : J â¥¤ C) [has_colimit F] : cocone F := (get_colimit_cocone F).cocone
def colimit (F : J â¥¤ C) [has_colimit F] := (colimit.cocone F).X
def colimit.Î¹ (F : J â¥¤ C) [has_colimit F] (j : J) : F.obj j âŸ¶ colimit F :=
(colimit.cocone F).Î¹.app j
@[simp] lemma colimit.cocone_Î¹ {F : J â¥¤ C} [has_colimit F] (j : J) :
  (colimit.cocone F).Î¹.app j = colimit.Î¹ _ j := rfl
@[simp] lemma colimit.cocone_X {F : J â¥¤ C} [has_colimit F] :
  (colimit.cocone F).X = colimit F := rfl
@[simp, reassoc] lemma colimit.w (F : J â¥¤ C) [has_colimit F] {j j' : J} (f : j âŸ¶ j') :
  F.map f â‰« colimit.Î¹ F j' = colimit.Î¹ F j := (colimit.cocone F).w f
def colimit.is_colimit (F : J â¥¤ C) [has_colimit F] : is_colimit (colimit.cocone F) :=
(get_colimit_cocone F).is_colimit
def colimit.desc (F : J â¥¤ C) [has_colimit F] (c : cocone F) : colimit F âŸ¶ c.X :=
(colimit.is_colimit F).desc c
@[simp] lemma colimit.is_colimit_desc {F : J â¥¤ C} [has_colimit F] (c : cocone F) :
  (colimit.is_colimit F).desc c = colimit.desc F c := rfl
@[simp, reassoc] lemma colimit.Î¹_desc {F : J â¥¤ C} [has_colimit F] (c : cocone F) (j : J) :
  colimit.Î¹ F j â‰« colimit.desc F c = c.Î¹.app j :=
is_colimit.fac _ c j
def colim_map {F G : J â¥¤ C} [has_colimit F] [has_colimit G] (Î± : F âŸ¶ G) : colimit F âŸ¶ colimit G :=
is_colimit.map (colimit.is_colimit F) _ Î±
@[simp, reassoc]
lemma Î¹_colim_map {F G : J â¥¤ C} [has_colimit F] [has_colimit G] (Î± : F âŸ¶ G) (j : J) :
  colimit.Î¹ F j â‰« colim_map Î± = Î±.app j â‰« colimit.Î¹ G j :=
colimit.Î¹_desc _ j
def colimit.cocone_morphism {F : J â¥¤ C} [has_colimit F] (c : cocone F) :
  (colimit.cocone F) âŸ¶ c :=
(colimit.is_colimit F).desc_cocone_morphism c
@[simp] lemma colimit.cocone_morphism_hom {F : J â¥¤ C} [has_colimit F] (c : cocone F) :
  (colimit.cocone_morphism c).hom = colimit.desc F c := rfl
lemma colimit.Î¹_cocone_morphism {F : J â¥¤ C} [has_colimit F] (c : cocone F) (j : J) :
  colimit.Î¹ F j â‰« (colimit.cocone_morphism c).hom = c.Î¹.app j :=
by simp
@[simp, reassoc] lemma colimit.comp_cocone_point_unique_up_to_iso_hom {F : J â¥¤ C} [has_colimit F]
  {c : cocone F} (hc : is_colimit c) (j : J) :
  colimit.Î¹ F j â‰« (is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit _) hc).hom =
    c.Î¹.app j :=
is_colimit.comp_cocone_point_unique_up_to_iso_hom _ _ _
@[simp, reassoc] lemma colimit.comp_cocone_point_unique_up_to_iso_inv {F : J â¥¤ C} [has_colimit F]
  {c : cocone F} (hc : is_colimit c) (j : J) :
  colimit.Î¹ F j â‰« (is_colimit.cocone_point_unique_up_to_iso hc (colimit.is_colimit _)).inv =
    c.Î¹.app j :=
is_colimit.comp_cocone_point_unique_up_to_iso_inv _ _ _
lemma colimit.exists_unique {F : J â¥¤ C} [has_colimit F] (t : cocone F) :
  âˆƒ! (d : colimit F âŸ¶ t.X), âˆ€ j, colimit.Î¹ F j â‰« d = t.Î¹.app j :=
(colimit.is_colimit F).exists_unique _
def colimit.iso_colimit_cocone {F : J â¥¤ C} [has_colimit F] (t : colimit_cocone F) :
  colimit F â‰… t.cocone.X :=
is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit F) t.is_colimit
@[simp, reassoc] lemma colimit.iso_colimit_cocone_Î¹_hom
  {F : J â¥¤ C} [has_colimit F] (t : colimit_cocone F) (j : J) :
  colimit.Î¹ F j â‰« (colimit.iso_colimit_cocone t).hom = t.cocone.Î¹.app j :=
by { dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso], tidy, }
@[simp, reassoc] lemma colimit.iso_colimit_cocone_Î¹_inv
  {F : J â¥¤ C} [has_colimit F] (t : colimit_cocone F) (j : J) :
  t.cocone.Î¹.app j â‰« (colimit.iso_colimit_cocone t).inv = colimit.Î¹ F j :=
by { dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso], tidy, }
@[ext] lemma colimit.hom_ext {F : J â¥¤ C} [has_colimit F] {X : C} {f f' : colimit F âŸ¶ X}
  (w : âˆ€ j, colimit.Î¹ F j â‰« f = colimit.Î¹ F j â‰« f') : f = f' :=
(colimit.is_colimit F).hom_ext w
@[simp] lemma colimit.desc_cocone {F : J â¥¤ C} [has_colimit F] :
  colimit.desc F (colimit.cocone F) = ğŸ™ (colimit F) :=
(colimit.is_colimit _).desc_self
def colimit.hom_iso (F : J â¥¤ C) [has_colimit F] (W : C) :
  ulift.{uâ‚} (colimit F âŸ¶ W : Type v) â‰… (F.cocones.obj W) :=
(colimit.is_colimit F).hom_iso W
@[simp] lemma colimit.hom_iso_hom (F : J â¥¤ C) [has_colimit F] {W : C} (f : ulift (colimit F âŸ¶ W)) :
  (colimit.hom_iso F W).hom f = (colimit.cocone F).Î¹ â‰« (const J).map f.down :=
(colimit.is_colimit F).hom_iso_hom f
def colimit.hom_iso' (F : J â¥¤ C) [has_colimit F] (W : C) :
  ulift.{uâ‚} ((colimit F âŸ¶ W) : Type v) â‰…
    { p : Î  j, F.obj j âŸ¶ W // âˆ€ {j j'} (f : j âŸ¶ j'), F.map f â‰« p j' = p j } :=
(colimit.is_colimit F).hom_iso' W
lemma colimit.desc_extend (F : J â¥¤ C) [has_colimit F] (c : cocone F) {X : C} (f : c.X âŸ¶ X) :
  colimit.desc F (c.extend f) = colimit.desc F c â‰« f :=
begin
  ext1, rw [â†category.assoc], simp
end
lemma has_colimit.of_cocones_iso {K : Type uâ‚} [category.{vâ‚‚} K] (F : J â¥¤ C)
  (G : K â¥¤ C) (h : F.cocones â‰… G.cocones)
    [has_colimit F] : has_colimit G :=
has_colimit.mk âŸ¨_, is_colimit.of_nat_iso (is_colimit.nat_iso (colimit.is_colimit F) â‰ªâ‰« h)âŸ©
def has_colimit.iso_of_nat_iso {F G : J â¥¤ C} [has_colimit F] [has_colimit G] (w : F â‰… G) :
  colimit F â‰… colimit G :=
is_colimit.cocone_points_iso_of_nat_iso (colimit.is_colimit F) (colimit.is_colimit G) w
@[simp, reassoc]
lemma has_colimit.iso_of_nat_iso_Î¹_hom {F G : J â¥¤ C} [has_colimit F] [has_colimit G]
  (w : F â‰… G) (j : J) :
  colimit.Î¹ F j â‰« (has_colimit.iso_of_nat_iso w).hom = w.hom.app j â‰« colimit.Î¹ G j :=
is_colimit.comp_cocone_points_iso_of_nat_iso_hom _ _ _ _
@[simp, reassoc]
lemma has_colimit.iso_of_nat_iso_Î¹_inv {F G : J â¥¤ C} [has_colimit F] [has_colimit G]
  (w : F â‰… G) (j : J) :
  colimit.Î¹ G j â‰« (has_colimit.iso_of_nat_iso w).inv = w.inv.app j â‰« colimit.Î¹ F j :=
is_colimit.comp_cocone_points_iso_of_nat_iso_inv _ _ _ _
@[simp, reassoc]
lemma has_colimit.iso_of_nat_iso_hom_desc {F G : J â¥¤ C} [has_colimit F] [has_colimit G]
  (t : cocone G) (w : F â‰… G) :
  (has_colimit.iso_of_nat_iso w).hom â‰« colimit.desc G t =
    colimit.desc F ((cocones.precompose w.hom).obj _) :=
is_colimit.cocone_points_iso_of_nat_iso_hom_desc _ _ _
@[simp, reassoc]
lemma has_colimit.iso_of_nat_iso_inv_desc {F G : J â¥¤ C} [has_colimit F] [has_colimit G]
  (t : cocone F) (w : F â‰… G) :
  (has_colimit.iso_of_nat_iso w).inv â‰« colimit.desc F t =
    colimit.desc G ((cocones.precompose w.inv).obj _) :=
is_colimit.cocone_points_iso_of_nat_iso_inv_desc _ _ _
def has_colimit.iso_of_equivalence {F : J â¥¤ C} [has_colimit F] {G : K â¥¤ C} [has_colimit G]
   (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) : colimit F â‰… colimit G :=
is_colimit.cocone_points_iso_of_equivalence (colimit.is_colimit F) (colimit.is_colimit G) e w
@[simp]
lemma has_colimit.iso_of_equivalence_hom_Ï€ {F : J â¥¤ C} [has_colimit F] {G : K â¥¤ C} [has_colimit G]
   (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) (j : J) :
  colimit.Î¹ F j â‰« (has_colimit.iso_of_equivalence e w).hom =
     F.map (e.unit.app j) â‰« w.inv.app _ â‰« colimit.Î¹ G _ :=
begin
  simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv],
  dsimp,
  simp,
end
@[simp]
lemma has_colimit.iso_of_equivalence_inv_Ï€ {F : J â¥¤ C} [has_colimit F] {G : K â¥¤ C} [has_colimit G]
   (e : J â‰Œ K) (w : e.functor â‹™ G â‰… F) (k : K) :
  colimit.Î¹ G k â‰« (has_colimit.iso_of_equivalence e w).inv =
     G.map (e.counit_inv.app k) â‰« w.hom.app (e.inverse.obj k) â‰« colimit.Î¹ F (e.inverse.obj k) :=
begin
  simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv],
  dsimp,
  simp,
end
section pre
variables (F) [has_colimit F] (E : K â¥¤ J) [has_colimit (E â‹™ F)]
def colimit.pre : colimit (E â‹™ F) âŸ¶ colimit F :=
colimit.desc (E â‹™ F) ((colimit.cocone F).whisker E)
@[simp, reassoc] lemma colimit.Î¹_pre (k : K) :
  colimit.Î¹ (E â‹™ F) k â‰« colimit.pre F E = colimit.Î¹ F (E.obj k) :=
by { erw is_colimit.fac, refl, }
@[simp, reassoc] lemma colimit.pre_desc (c : cocone F) :
  colimit.pre F E â‰« colimit.desc F c = colimit.desc (E â‹™ F) (c.whisker E) :=
by ext; rw [â†assoc, colimit.Î¹_pre]; simp
variables {L : Type uâ‚ƒ} [category.{vâ‚ƒ} L]
variables (D : L â¥¤ K) [has_colimit (D â‹™ E â‹™ F)]
@[simp] lemma colimit.pre_pre : colimit.pre (E â‹™ F) D â‰« colimit.pre F E = colimit.pre F (D â‹™ E) :=
begin
  ext j,
  rw [â†assoc, colimit.Î¹_pre, colimit.Î¹_pre],
  letI : has_colimit ((D â‹™ E) â‹™ F) := show has_colimit (D â‹™ E â‹™ F), by apply_instance,
  exact (colimit.Î¹_pre F (D â‹™ E) j).symm
end
variables {E F}
lemma colimit.pre_eq (s : colimit_cocone (E â‹™ F)) (t : colimit_cocone F) :
  colimit.pre F E =
    (colimit.iso_colimit_cocone s).hom â‰« s.is_colimit.desc ((t.cocone).whisker E) â‰«
      (colimit.iso_colimit_cocone t).inv :=
by tidy
end pre
section post
variables {D : Type u'} [category.{v'} D]
variables (F) [has_colimit F] (G : C â¥¤ D) [has_colimit (F â‹™ G)]
def colimit.post : colimit (F â‹™ G) âŸ¶ G.obj (colimit F) :=
colimit.desc (F â‹™ G) (G.map_cocone (colimit.cocone F))
@[simp, reassoc] lemma colimit.Î¹_post (j : J) :
  colimit.Î¹ (F â‹™ G) j â‰« colimit.post F G  = G.map (colimit.Î¹ F j) :=
by { erw is_colimit.fac, refl, }
@[simp] lemma colimit.post_desc (c : cocone F) :
  colimit.post F G â‰« G.map (colimit.desc F c) = colimit.desc (F â‹™ G) (G.map_cocone c) :=
by { ext, rw [â†assoc, colimit.Î¹_post, â†G.map_comp, colimit.Î¹_desc, colimit.Î¹_desc], refl }
@[simp] lemma colimit.post_post
  {E : Type u''} [category.{v''} E] (H : D â¥¤ E) [has_colimit ((F â‹™ G) â‹™ H)] :
  colimit.post (F â‹™ G) H â‰« H.map (colimit.post F G) = colimit.post F (G â‹™ H) :=
begin
  ext,
  rw [â†assoc, colimit.Î¹_post, â†H.map_comp, colimit.Î¹_post],
  exact (colimit.Î¹_post F (G â‹™ H) j).symm
end
end post
lemma colimit.pre_post {D : Type u'} [category.{v'} D]
  (E : K â¥¤ J) (F : J â¥¤ C) (G : C â¥¤ D)
  [has_colimit F] [has_colimit (E â‹™ F)] [has_colimit (F â‹™ G)] [H : has_colimit ((E â‹™ F) â‹™ G)] :
  colimit.post (E â‹™ F) G â‰« G.map (colimit.pre F E) =
    (@@colimit.pre _ _ _ (F â‹™ G) _ E H â‰« colimit.post F G : _) :=
begin
  ext,
  rw [â†assoc, colimit.Î¹_post, â†G.map_comp, colimit.Î¹_pre, â†assoc],
  letI : has_colimit (E â‹™ F â‹™ G) := show has_colimit ((E â‹™ F) â‹™ G), by apply_instance,
  erw [colimit.Î¹_pre (F â‹™ G) E j, colimit.Î¹_post]
end
open category_theory.equivalence
instance has_colimit_equivalence_comp (e : K â‰Œ J) [has_colimit F] : has_colimit (e.functor â‹™ F) :=
has_colimit.mk { cocone := cocone.whisker e.functor (colimit.cocone F),
  is_colimit := is_colimit.whisker_equivalence (colimit.is_colimit F) e, }
lemma has_colimit_of_equivalence_comp (e : K â‰Œ J) [has_colimit (e.functor â‹™ F)] : has_colimit F :=
begin
  haveI : has_colimit (e.inverse â‹™ e.functor â‹™ F) := limits.has_colimit_equivalence_comp e.symm,
  apply has_colimit_of_iso (e.inv_fun_id_assoc F).symm,
end
section colim_functor
variables [has_colimits_of_shape J C]
section
local attribute [simp] colim_map
@[simps obj]
def colim : (J â¥¤ C) â¥¤ C :=
{ obj := Î» F, colimit F,
  map := Î» F G Î±, colim_map Î±,
  map_id' := Î» F, by { ext, erw [Î¹_colim_map, id_comp, comp_id] },
  map_comp' := Î» F G H Î± Î²,
    by { ext, erw [â†assoc, is_colimit.fac, is_colimit.fac, assoc, is_colimit.fac, â†assoc], refl } }
end
variables {F} {G : J â¥¤ C} (Î± : F âŸ¶ G)
@[simp, reassoc] lemma colimit.Î¹_map (j : J) :
  colimit.Î¹ F j â‰« colim.map Î± = Î±.app j â‰« colimit.Î¹ G j :=
by apply is_colimit.fac
@[simp] lemma colimit.map_desc (c : cocone G) :
  colim.map Î± â‰« colimit.desc G c = colimit.desc F ((cocones.precompose Î±).obj c) :=
by ext; rw [â†assoc, colimit.Î¹_map, assoc, colimit.Î¹_desc, colimit.Î¹_desc]; refl
lemma colimit.pre_map [has_colimits_of_shape K C] (E : K â¥¤ J) :
  colimit.pre F E â‰« colim.map Î± = colim.map (whisker_left E Î±) â‰« colimit.pre G E :=
by ext; rw [â†assoc, colimit.Î¹_pre, colimit.Î¹_map, â†assoc, colimit.Î¹_map, assoc, colimit.Î¹_pre]; refl
lemma colimit.pre_map' [has_colimits_of_shape K C]
  (F : J â¥¤ C) {Eâ‚ Eâ‚‚ : K â¥¤ J} (Î± : Eâ‚ âŸ¶ Eâ‚‚) :
  colimit.pre F Eâ‚ = colim.map (whisker_right Î± F) â‰« colimit.pre F Eâ‚‚ :=
by ext1; simp [â† category.assoc]
lemma colimit.pre_id (F : J â¥¤ C) :
colimit.pre F (ğŸ­ _) = colim.map (functor.left_unitor F).hom := by tidy
lemma colimit.map_post {D : Type u'} [category.{v'} D] [has_colimits_of_shape J D] (H : C â¥¤ D) :
  colimit.post F H â‰« H.map (colim.map Î±) = colim.map (whisker_right Î± H) â‰« colimit.post G H:=
begin
  ext,
  rw [â†assoc, colimit.Î¹_post, â†H.map_comp, colimit.Î¹_map, H.map_comp],
  rw [â†assoc, colimit.Î¹_map, assoc, colimit.Î¹_post],
  refl
end
def colim_coyoneda : colim.op â‹™ coyoneda â‹™ (whiskering_right _ _ _).obj ulift_functor.{uâ‚} â‰…
  category_theory.cocones J C :=
nat_iso.of_components (Î» F, nat_iso.of_components (colimit.hom_iso (unop F)) (by tidy))
  (by tidy)
end colim_functor
lemma has_colimits_of_shape_of_equivalence {J' : Type uâ‚‚} [category.{vâ‚‚} J']
  (e : J â‰Œ J') [has_colimits_of_shape J C] : has_colimits_of_shape J' C :=
by { constructor, intro F, apply has_colimit_of_equivalence_comp e, apply_instance }
variable (C)
lemma has_colimits_of_size_shrink [has_colimits_of_size.{(max vâ‚ vâ‚‚) (max uâ‚ uâ‚‚)} C] :
  has_colimits_of_size.{vâ‚ uâ‚} C :=
âŸ¨Î» J hJ, by exactI has_colimits_of_shape_of_equivalence
  (ulift_hom_ulift_category.equiv.{vâ‚‚ uâ‚‚} J).symmâŸ©
@[priority 100]
instance has_smallest_colimits_of_has_colimits [has_colimits C] :
  has_colimits_of_size.{0 0} C := has_colimits_of_size_shrink.{0 0} C
end colimit
section opposite
def is_limit.op {t : cone F} (P : is_limit t) : is_colimit t.op :=
{ desc := Î» s, (P.lift s.unop).op,
  fac' := Î» s j, congr_arg quiver.hom.op (P.fac s.unop (unop j)),
  uniq' := Î» s m w,
  begin
    rw â† P.uniq s.unop m.unop,
    { refl, },
    { dsimp, intro j, rw â† w, refl, }
  end }
def is_colimit.op {t : cocone F} (P : is_colimit t) : is_limit t.op :=
{ lift := Î» s, (P.desc s.unop).op,
  fac' := Î» s j, congr_arg quiver.hom.op (P.fac s.unop (unop j)),
  uniq' := Î» s m w,
  begin
    rw â† P.uniq s.unop m.unop,
    { refl, },
    { dsimp, intro j, rw â† w, refl, }
  end }
def is_limit.unop {t : cone F.op} (P : is_limit t) : is_colimit t.unop :=
{ desc := Î» s, (P.lift s.op).unop,
  fac' := Î» s j, congr_arg quiver.hom.unop (P.fac s.op (op j)),
  uniq' := Î» s m w,
  begin
    rw â† P.uniq s.op m.op,
    { refl, },
    { dsimp, intro j, rw â† w, refl, }
  end }
def is_colimit.unop {t : cocone F.op} (P : is_colimit t) : is_limit t.unop :=
{ lift := Î» s, (P.desc s.op).unop,
  fac' := Î» s j, congr_arg quiver.hom.unop (P.fac s.op (op j)),
  uniq' := Î» s m w,
  begin
    rw â† P.uniq s.op m.op,
    { refl, },
    { dsimp, intro j, rw â† w, refl, }
  end }
def is_limit_equiv_is_colimit_op {t : cone F} : is_limit t â‰ƒ is_colimit t.op :=
equiv_of_subsingleton_of_subsingleton
  is_limit.op (Î» P, P.unop.of_iso_limit (cones.ext (iso.refl _) (by tidy)))
def is_colimit_equiv_is_limit_op {t : cocone F} : is_colimit t â‰ƒ is_limit t.op :=
equiv_of_subsingleton_of_subsingleton
  is_colimit.op (Î» P, P.unop.of_iso_colimit (cocones.ext (iso.refl _) (by tidy)))
end opposite
end category_theory.limits
