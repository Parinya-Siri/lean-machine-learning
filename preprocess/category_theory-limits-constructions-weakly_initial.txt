import category_theory.limits.shapes.wide_equalizers
import category_theory.limits.shapes.products
import category_theory.limits.shapes.terminal
universes v u
namespace category_theory
open limits
variables {C : Type u} [category.{v} C]
lemma has_weakly_initial_of_weakly_initial_set_and_has_products [has_products.{v} C]
  {Î¹ : Type v} {B : Î¹ â†’ C} (hB : âˆ€ (A : C), âˆƒ i, nonempty (B i âŸ¶ A)) :
  âˆƒ (T : C), âˆ€ X, nonempty (T âŸ¶ X) :=
âŸ¨âˆ B, Î» X, âŸ¨pi.Ï€ _ _ â‰« (hB X).some_spec.someâŸ©âŸ©
lemma has_initial_of_weakly_initial_and_has_wide_equalizers [has_wide_equalizers.{v} C]
  {T : C} (hT : âˆ€ X, nonempty (T âŸ¶ X)) :
  has_initial C :=
begin
  let endos := T âŸ¶ T,
  let i := wide_equalizer.Î¹ (id : endos â†’ endos),
  haveI : nonempty endos := âŸ¨ğŸ™ _âŸ©,
  have : âˆ€ (X : C), unique (wide_equalizer (id : endos â†’ endos) âŸ¶ X),
  { intro X,
    refine âŸ¨âŸ¨i â‰« classical.choice (hT X)âŸ©, Î» a, _âŸ©,
    let E := equalizer a (i â‰« classical.choice (hT _)),
    let e : E âŸ¶ wide_equalizer id := equalizer.Î¹ _ _,
    let h : T âŸ¶ E := classical.choice (hT E),
    have : ((i â‰« h) â‰« e) â‰« i = i â‰« ğŸ™ _,
    { rw [category.assoc, category.assoc],
      apply wide_equalizer.condition (id : endos â†’ endos) (h â‰« e â‰« i) },
    rw [category.comp_id, cancel_mono_id i] at this,
    haveI : split_epi e := âŸ¨i â‰« h, thisâŸ©,
    rw â†cancel_epi e,
    apply equalizer.condition },
  exactI has_initial_of_unique (wide_equalizer (id : endos â†’ endos)),
end
end category_theory
