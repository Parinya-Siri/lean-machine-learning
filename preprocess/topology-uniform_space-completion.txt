import topology.uniform_space.abstract_completion
noncomputable theory
open filter set
universes u v w x
open_locale uniformity classical topological_space filter
def Cauchy (Œ± : Type u) [uniform_space Œ±] : Type u := { f : filter Œ± // cauchy f }
namespace Cauchy
section
parameters {Œ± : Type u} [uniform_space Œ±]
variables {Œ≤ : Type v} {Œ≥ : Type w}
variables [uniform_space Œ≤] [uniform_space Œ≥]
def gen (s : set (Œ± √ó Œ±)) : set (Cauchy Œ± √ó Cauchy Œ±) :=
{p | s ‚àà p.1.val √ó·∂† p.2.val }
lemma monotone_gen : monotone gen :=
monotone_set_of $ assume p, @monotone_mem (Œ±√óŒ±) (p.1.val √ó·∂† p.2.val)
private lemma symm_gen : map prod.swap ((ùì§ Œ±).lift' gen) ‚â§ (ùì§ Œ±).lift' gen :=
calc map prod.swap ((ùì§ Œ±).lift' gen) =
  (ùì§ Œ±).lift' (Œªs:set (Œ±√óŒ±), {p | s ‚àà p.2.val √ó·∂† p.1.val }) :
  begin
    delta gen,
    simp [map_lift'_eq, monotone_set_of, monotone_mem,
          function.comp, image_swap_eq_preimage_swap, -subtype.val_eq_coe]
  end
  ... ‚â§ (ùì§ Œ±).lift' gen :
    uniformity_lift_le_swap
      (monotone_principal.comp (monotone_set_of $ assume p,
        @monotone_mem (Œ±√óŒ±) (p.2.val √ó·∂†  p.1.val)))
      begin
        have h := Œª(p:Cauchy Œ±√óCauchy Œ±), @filter.prod_comm _ _ (p.2.val) (p.1.val),
        simp [function.comp, h, -subtype.val_eq_coe, mem_map'],
        exact le_rfl,
      end
private lemma comp_rel_gen_gen_subset_gen_comp_rel {s t : set (Œ±√óŒ±)} : comp_rel (gen s) (gen t) ‚äÜ
  (gen (comp_rel s t) : set (Cauchy Œ± √ó Cauchy Œ±)) :=
assume ‚ü®f, g‚ü© ‚ü®h, h‚ÇÅ, h‚ÇÇ‚ü©,
let ‚ü®t‚ÇÅ, (ht‚ÇÅ : t‚ÇÅ ‚àà f.val), t‚ÇÇ, (ht‚ÇÇ : t‚ÇÇ ‚àà h.val), (h‚ÇÅ : t‚ÇÅ √óÀ¢ t‚ÇÇ ‚äÜ s)‚ü© :=
  mem_prod_iff.mp h‚ÇÅ in
let ‚ü®t‚ÇÉ, (ht‚ÇÉ : t‚ÇÉ ‚àà h.val), t‚ÇÑ, (ht‚ÇÑ : t‚ÇÑ ‚àà g.val), (h‚ÇÇ : t‚ÇÉ √óÀ¢ t‚ÇÑ ‚äÜ t)‚ü© :=
  mem_prod_iff.mp h‚ÇÇ in
have t‚ÇÇ ‚à© t‚ÇÉ ‚àà h.val,
  from inter_mem ht‚ÇÇ ht‚ÇÉ,
let ‚ü®x, xt‚ÇÇ, xt‚ÇÉ‚ü© :=
  h.property.left.nonempty_of_mem this in
(f.val √ó·∂† g.val).sets_of_superset
  (prod_mem_prod ht‚ÇÅ ht‚ÇÑ)
  (assume ‚ü®a, b‚ü© ‚ü®(ha : a ‚àà t‚ÇÅ), (hb : b ‚àà t‚ÇÑ)‚ü©,
    ‚ü®x,
      h‚ÇÅ (show (a, x) ‚àà t‚ÇÅ √óÀ¢ t‚ÇÇ, from ‚ü®ha, xt‚ÇÇ‚ü©),
      h‚ÇÇ (show (x, b) ‚àà t‚ÇÉ √óÀ¢ t‚ÇÑ, from ‚ü®xt‚ÇÉ, hb‚ü©)‚ü©)
private lemma comp_gen :
  ((ùì§ Œ±).lift' gen).lift' (Œªs, comp_rel s s) ‚â§ (ùì§ Œ±).lift' gen :=
calc ((ùì§ Œ±).lift' gen).lift' (Œªs, comp_rel s s) =
    (ùì§ Œ±).lift' (Œªs, comp_rel (gen s) (gen s)) :
  begin
    rw [lift'_lift'_assoc],
    exact monotone_gen,
    exact (monotone_comp_rel monotone_id monotone_id)
  end
  ... ‚â§ (ùì§ Œ±).lift' (Œªs, gen $ comp_rel s s) :
    lift'_mono' $ assume s hs, comp_rel_gen_gen_subset_gen_comp_rel
  ... = ((ùì§ Œ±).lift' $ Œªs:set(Œ±√óŒ±), comp_rel s s).lift' gen :
  begin
    rw [lift'_lift'_assoc],
    exact (monotone_comp_rel monotone_id monotone_id),
    exact monotone_gen
  end
  ... ‚â§ (ùì§ Œ±).lift' gen : lift'_mono comp_le_uniformity le_rfl
instance : uniform_space (Cauchy Œ±) :=
uniform_space.of_core
{ uniformity  := (ùì§ Œ±).lift' gen,
  refl        := principal_le_lift' $ assume s hs ‚ü®a, b‚ü© (a_eq_b : a = b),
    a_eq_b ‚ñ∏ a.property.right hs,
  symm        := symm_gen,
  comp        := comp_gen }
theorem mem_uniformity {s : set (Cauchy Œ± √ó Cauchy Œ±)} :
  s ‚àà ùì§ (Cauchy Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, gen t ‚äÜ s :=
mem_lift'_sets monotone_gen
theorem mem_uniformity' {s : set (Cauchy Œ± √ó Cauchy Œ±)} :
  s ‚àà ùì§ (Cauchy Œ±) ‚Üî ‚àÉ t ‚àà ùì§ Œ±, ‚àÄ f g : Cauchy Œ±, t ‚àà f.1 √ó·∂† g.1 ‚Üí (f, g) ‚àà s :=
mem_uniformity.trans $ bex_congr $ Œª t h, prod.forall
def pure_cauchy (a : Œ±) : Cauchy Œ± :=
‚ü®pure a, cauchy_pure‚ü©
lemma uniform_inducing_pure_cauchy : uniform_inducing (pure_cauchy : Œ± ‚Üí Cauchy Œ±) :=
‚ü®have (preimage (Œª (x : Œ± √ó Œ±), (pure_cauchy (x.fst), pure_cauchy (x.snd))) ‚àò gen) = id,
      from funext $ assume s, set.ext $ assume ‚ü®a‚ÇÅ, a‚ÇÇ‚ü©,
        by simp [preimage, gen, pure_cauchy, prod_principal_principal],
    calc comap (Œª (x : Œ± √ó Œ±), (pure_cauchy (x.fst), pure_cauchy (x.snd))) ((ùì§ Œ±).lift' gen)
          = (ùì§ Œ±).lift'
              (preimage (Œª (x : Œ± √ó Œ±), (pure_cauchy (x.fst), pure_cauchy (x.snd))) ‚àò gen) :
        comap_lift'_eq
      ... = ùì§ Œ± : by simp [this]‚ü©
lemma uniform_embedding_pure_cauchy : uniform_embedding (pure_cauchy : Œ± ‚Üí Cauchy Œ±) :=
{ inj := assume a‚ÇÅ a‚ÇÇ h, pure_injective $ subtype.ext_iff_val.1 h,
  ..uniform_inducing_pure_cauchy }
lemma dense_range_pure_cauchy : dense_range pure_cauchy :=
assume f,
have h_ex : ‚àÄ s ‚àà ùì§ (Cauchy Œ±), ‚àÉy:Œ±, (f, pure_cauchy y) ‚àà s, from
  assume s hs,
  let ‚ü®t'', ht''‚ÇÅ, (ht''‚ÇÇ : gen t'' ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs in
  let ‚ü®t', ht'‚ÇÅ, ht'‚ÇÇ‚ü© := comp_mem_uniformity_sets ht''‚ÇÅ in
  have t' ‚àà f.val √ó·∂† f.val,
    from f.property.right ht'‚ÇÅ,
  let ‚ü®t, ht, (h : t √óÀ¢ t ‚äÜ t')‚ü© := mem_prod_same_iff.mp this in
  let ‚ü®x, (hx : x ‚àà t)‚ü© := f.property.left.nonempty_of_mem ht in
  have t'' ‚àà f.val √ó·∂† pure x,
    from mem_prod_iff.mpr ‚ü®t, ht, {y:Œ± | (x, y) ‚àà t'},
      h $ mk_mem_prod hx hx,
      assume ‚ü®a, b‚ü© ‚ü®(h‚ÇÅ : a ‚àà t), (h‚ÇÇ : (x, b) ‚àà t')‚ü©,
        ht'‚ÇÇ $ prod_mk_mem_comp_rel (@h (a, x) ‚ü®h‚ÇÅ, hx‚ü©) h‚ÇÇ‚ü©,
  ‚ü®x, ht''‚ÇÇ $ by dsimp [gen]; exact this‚ü©,
begin
  simp only [closure_eq_cluster_pts, cluster_pt, nhds_eq_uniformity, lift'_inf_principal_eq,
    set.inter_comm _ (range pure_cauchy), mem_set_of_eq],
  exact (lift'_ne_bot_iff $ monotone_const.inter monotone_preimage).mpr
    (assume s hs,
      let ‚ü®y, hy‚ü© := h_ex s hs in
      have pure_cauchy y ‚àà range pure_cauchy ‚à© {y : Cauchy Œ± | (f, y) ‚àà s},
        from ‚ü®mem_range_self y, hy‚ü©,
      ‚ü®_, this‚ü©)
end
lemma dense_inducing_pure_cauchy : dense_inducing pure_cauchy :=
uniform_inducing_pure_cauchy.dense_inducing dense_range_pure_cauchy
lemma dense_embedding_pure_cauchy : dense_embedding pure_cauchy :=
uniform_embedding_pure_cauchy.dense_embedding dense_range_pure_cauchy
lemma nonempty_Cauchy_iff : nonempty (Cauchy Œ±) ‚Üî nonempty Œ± :=
begin
  split ; rintro ‚ü®c‚ü©,
  { have := eq_univ_iff_forall.1 dense_embedding_pure_cauchy.to_dense_inducing.closure_range c,
    obtain ‚ü®_, ‚ü®_, a, _‚ü©‚ü© := mem_closure_iff.1 this _ is_open_univ trivial,
    exact ‚ü®a‚ü© },
  { exact ‚ü®pure_cauchy c‚ü© }
end
section
set_option eqn_compiler.zeta true
instance : complete_space (Cauchy Œ±) :=
complete_space_extension
  uniform_inducing_pure_cauchy
  dense_range_pure_cauchy $
  assume f hf,
  let f' : Cauchy Œ± := ‚ü®f, hf‚ü© in
  have map pure_cauchy f ‚â§ (ùì§ $ Cauchy Œ±).lift' (preimage (prod.mk f')),
    from le_lift' $ assume s hs,
    let ‚ü®t, ht‚ÇÅ, (ht‚ÇÇ : gen t ‚äÜ s)‚ü© := (mem_lift'_sets monotone_gen).mp hs in
    let ‚ü®t', ht', (h : t' √óÀ¢ t' ‚äÜ t)‚ü© := mem_prod_same_iff.mp (hf.right ht‚ÇÅ) in
    have t' ‚äÜ { y : Œ± | (f', pure_cauchy y) ‚àà gen t },
      from assume x hx, (f √ó·∂† pure x).sets_of_superset (prod_mem_prod ht' hx) h,
    f.sets_of_superset ht' $ subset.trans this (preimage_mono ht‚ÇÇ),
  ‚ü®f', by simp [nhds_eq_uniformity]; assumption‚ü©
end
instance [inhabited Œ±] : inhabited (Cauchy Œ±) :=
‚ü®pure_cauchy default‚ü©
instance [h : nonempty Œ±] : nonempty (Cauchy Œ±) :=
h.rec_on $ assume a, nonempty.intro $ Cauchy.pure_cauchy a
section extend
def extend (f : Œ± ‚Üí Œ≤) : (Cauchy Œ± ‚Üí Œ≤) :=
if uniform_continuous f then
  dense_inducing_pure_cauchy.extend f
else
  Œª x, f (classical.inhabited_of_nonempty $ nonempty_Cauchy_iff.1 ‚ü®x‚ü©).default
section separated_space
variables [separated_space Œ≤]
lemma extend_pure_cauchy {f : Œ± ‚Üí Œ≤} (hf : uniform_continuous f) (a : Œ±) :
  extend f (pure_cauchy a) = f a :=
begin
  rw [extend, if_pos hf],
  exact uniformly_extend_of_ind uniform_inducing_pure_cauchy dense_range_pure_cauchy hf _
end
end separated_space
variables [_root_.complete_space Œ≤]
lemma uniform_continuous_extend {f : Œ± ‚Üí Œ≤} : uniform_continuous (extend f) :=
begin
  by_cases hf : uniform_continuous f,
  { rw [extend, if_pos hf],
    exact uniform_continuous_uniformly_extend uniform_inducing_pure_cauchy
      dense_range_pure_cauchy hf },
  { rw [extend, if_neg hf],
    exact uniform_continuous_of_const (assume a b, by congr) }
end
end extend
end
theorem Cauchy_eq {Œ± : Type*} [inhabited Œ±] [uniform_space Œ±] [complete_space Œ±]
  [separated_space Œ±] {f g : Cauchy Œ±} :
  Lim f.1 = Lim g.1 ‚Üî (f, g) ‚àà separation_rel (Cauchy Œ±) :=
begin
  split,
  { intros e s hs,
    rcases Cauchy.mem_uniformity'.1 hs with ‚ü®t, tu, ts‚ü©,
    apply ts,
    rcases comp_mem_uniformity_sets tu with ‚ü®d, du, dt‚ü©,
    refine mem_prod_iff.2
      ‚ü®_, f.2.le_nhds_Lim (mem_nhds_right (Lim f.1) du),
       _, g.2.le_nhds_Lim (mem_nhds_left (Lim g.1) du), Œª x h, _‚ü©,
    cases x with a b, cases h with h‚ÇÅ h‚ÇÇ,
    rw ‚Üê e at h‚ÇÇ,
    exact dt ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© },
  { intros H,
    refine separated_def.1 (by apply_instance) _ _ (Œª t tu, _),
    rcases mem_uniformity_is_closed tu with ‚ü®d, du, dc, dt‚ü©,
    refine H {p | (Lim p.1.1, Lim p.2.1) ‚àà t}
      (Cauchy.mem_uniformity'.2 ‚ü®d, du, Œª f g h, _‚ü©),
    rcases mem_prod_iff.1 h with ‚ü®x, xf, y, yg, h‚ü©,
    have limc : ‚àÄ (f : Cauchy Œ±) (x ‚àà f.1), Lim f.1 ‚àà closure x,
    { intros f x xf,
      rw closure_eq_cluster_pts,
      exact f.2.1.mono
        (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf)) },
    have := dc.closure_subset_iff.2 h,
    rw closure_prod_eq at this,
    refine dt (this ‚ü®_, _‚ü©); dsimp; apply limc; assumption }
end
section
local attribute [instance] uniform_space.separation_setoid
lemma separated_pure_cauchy_injective {Œ± : Type*} [uniform_space Œ±] [s : separated_space Œ±] :
  function.injective (Œªa:Œ±, ‚ü¶pure_cauchy a‚üß) | a b h :=
separated_def.1 s _ _ $ assume s hs,
let ‚ü®t, ht, hts‚ü© :=
  by rw [‚Üê (@uniform_embedding_pure_cauchy Œ± _).comap_uniformity, filter.mem_comap] at hs;
    exact hs in
have (pure_cauchy a, pure_cauchy b) ‚àà t, from quotient.exact h t ht,
@hts (a, b) this
end
end Cauchy
local attribute [instance] uniform_space.separation_setoid
open Cauchy set
namespace uniform_space
variables (Œ± : Type*) [uniform_space Œ±]
variables {Œ≤ : Type*} [uniform_space Œ≤]
variables {Œ≥ : Type*} [uniform_space Œ≥]
instance complete_space_separation [h : complete_space Œ±] :
  complete_space (quotient (separation_setoid Œ±)) :=
‚ü®assume f, assume hf : cauchy f,
  have cauchy (f.comap (Œªx, ‚ü¶x‚üß)), from
    hf.comap' comap_quotient_le_uniformity $ hf.left.comap_of_surj (surjective_quotient_mk _),
  let ‚ü®x, (hx : f.comap (Œªx, ‚ü¶x‚üß) ‚â§ ùìù x)‚ü© := complete_space.complete this in
  ‚ü®‚ü¶x‚üß, (comap_le_comap_iff $ by simp).1
    (hx.trans $ map_le_iff_le_comap.1 continuous_quotient_mk.continuous_at)‚ü©‚ü©
def completion := quotient (separation_setoid $ Cauchy Œ±)
namespace completion
instance [inhabited Œ±] : inhabited (completion Œ±) :=
quotient.inhabited (separation_setoid (Cauchy Œ±))
@[priority 50]
instance : uniform_space (completion Œ±) := separation_setoid.uniform_space
instance : complete_space (completion Œ±) := uniform_space.complete_space_separation (Cauchy Œ±)
instance : separated_space (completion Œ±) := uniform_space.separated_separation
instance : regular_space (completion Œ±) := separated_regular
protected def extension (f : Œ± ‚Üí Œ≤) : completion Œ± ‚Üí Œ≤ :=
cpkg.extend f
section complete_space
variables [complete_space Œ≤]
lemma uniform_continuous_extension : uniform_continuous (completion.extension f) :=
cpkg.uniform_continuous_extend
lemma continuous_extension : continuous (completion.extension f) :=
cpkg.continuous_extend
end complete_space
@[simp] lemma extension_coe [separated_space Œ≤] (hf : uniform_continuous f) (a : Œ±) :
  (completion.extension f) a = f a :=
cpkg.extend_coe hf a
variables [separated_space Œ≤] [complete_space Œ≤]
lemma extension_unique (hf : uniform_continuous f) {g : completion Œ± ‚Üí Œ≤}
  (hg : uniform_continuous g) (h : ‚àÄ a : Œ±, f a = g (a : completion Œ±)) :
  completion.extension f = g :=
cpkg.extend_unique hf hg h
@[simp] lemma extension_comp_coe {f : completion Œ± ‚Üí Œ≤} (hf : uniform_continuous f) :
  completion.extension (f ‚àò coe) = f :=
cpkg.extend_comp_coe hf
end extension
section map
variables {f : Œ± ‚Üí Œ≤}
protected def map (f : Œ± ‚Üí Œ≤) : completion Œ± ‚Üí completion Œ≤ :=
cpkg.map cpkg f
lemma uniform_continuous_map : uniform_continuous (completion.map f) :=
cpkg.uniform_continuous_map cpkg f
lemma continuous_map : continuous (completion.map f) :=
cpkg.continuous_map cpkg f
@[simp] lemma map_coe (hf : uniform_continuous f) (a : Œ±) : (completion.map f) a = f a :=
cpkg.map_coe cpkg hf a
lemma map_unique {f : Œ± ‚Üí Œ≤} {g : completion Œ± ‚Üí completion Œ≤}
  (hg : uniform_continuous g) (h : ‚àÄa:Œ±, ‚Üë(f a) = g a) : completion.map f = g :=
cpkg.map_unique cpkg hg h
@[simp] lemma map_id : completion.map (@id Œ±) = id :=
cpkg.map_id
lemma extension_map [complete_space Œ≥] [separated_space Œ≥] {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤}
  (hf : uniform_continuous f) (hg : uniform_continuous g) :
  completion.extension f ‚àò completion.map g = completion.extension (f ‚àò g) :=
completion.ext (continuous_extension.comp continuous_map) continuous_extension $
  by intro a; simp only [hg, hf, hf.comp hg, (‚àò), map_coe, extension_coe]
lemma map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : uniform_continuous g) (hf : uniform_continuous f) :
  completion.map g ‚àò completion.map f = completion.map (g ‚àò f) :=
extension_map ((uniform_continuous_coe _).comp hg) hf
end map
section separation_quotient_completion
def completion_separation_quotient_equiv (Œ± : Type u) [uniform_space Œ±] :
  completion (separation_quotient Œ±) ‚âÉ completion Œ± :=
begin
  refine ‚ü®completion.extension (separation_quotient.lift (coe : Œ± ‚Üí completion Œ±)),
    completion.map quotient.mk, _, _‚ü©,
  { assume a,
    refine induction_on a (is_closed_eq (continuous_map.comp continuous_extension) continuous_id) _,
    rintros ‚ü®a‚ü©,
    show completion.map quotient.mk
      (completion.extension (separation_quotient.lift coe) ‚Üë‚ü¶a‚üß) = ‚Üë‚ü¶a‚üß,
    rw [extension_coe (separation_quotient.uniform_continuous_lift _),
      separation_quotient.lift_mk (uniform_continuous_coe Œ±),
      completion.map_coe uniform_continuous_quotient_mk] ; apply_instance },
  { assume a,
    refine completion.induction_on a
      (is_closed_eq (continuous_extension.comp continuous_map) continuous_id) (Œª a, _),
    rw [map_coe uniform_continuous_quotient_mk,
      extension_coe (separation_quotient.uniform_continuous_lift _),
      separation_quotient.lift_mk (uniform_continuous_coe Œ±) _] ; apply_instance }
end
lemma uniform_continuous_completion_separation_quotient_equiv :
  uniform_continuous ‚áë(completion_separation_quotient_equiv Œ±) :=
uniform_continuous_extension
lemma uniform_continuous_completion_separation_quotient_equiv_symm :
  uniform_continuous ‚áë(completion_separation_quotient_equiv Œ±).symm :=
uniform_continuous_map
end separation_quotient_completion
section extension‚ÇÇ
variables (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)
open function
protected def extension‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : completion Œ± ‚Üí completion Œ≤ ‚Üí Œ≥ :=
cpkg.extend‚ÇÇ cpkg f
section separated_space
variables [separated_space Œ≥] {f}
@[simp] lemma extension‚ÇÇ_coe_coe (hf : uniform_continuous‚ÇÇ f) (a : Œ±) (b : Œ≤) :
  completion.extension‚ÇÇ f a b = f a b :=
cpkg.extension‚ÇÇ_coe_coe cpkg hf a b
end separated_space
variables [complete_space Œ≥] (f)
lemma uniform_continuous_extension‚ÇÇ : uniform_continuous‚ÇÇ (completion.extension‚ÇÇ f) :=
cpkg.uniform_continuous_extension‚ÇÇ cpkg f
end extension‚ÇÇ
section map‚ÇÇ
open function
protected def map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : completion Œ± ‚Üí completion Œ≤ ‚Üí completion Œ≥ :=
cpkg.map‚ÇÇ cpkg cpkg f
lemma uniform_continuous_map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : uniform_continuous‚ÇÇ (completion.map‚ÇÇ f) :=
cpkg.uniform_continuous_map‚ÇÇ cpkg cpkg f
lemma continuous_map‚ÇÇ {Œ¥} [topological_space Œ¥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥}
  {a : Œ¥ ‚Üí completion Œ±} {b : Œ¥ ‚Üí completion Œ≤} (ha : continuous a) (hb : continuous b) :
  continuous (Œªd:Œ¥, completion.map‚ÇÇ f (a d) (b d)) :=
cpkg.continuous_map‚ÇÇ cpkg cpkg ha hb
lemma map‚ÇÇ_coe_coe (a : Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hf : uniform_continuous‚ÇÇ f) :
  completion.map‚ÇÇ f (a : completion Œ±) (b : completion Œ≤) = f a b :=
cpkg.map‚ÇÇ_coe_coe cpkg cpkg a b f hf
end map‚ÇÇ
end completion
end uniform_space
