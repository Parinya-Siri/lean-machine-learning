import category_theory.sites.pretopology
import category_theory.limits.shapes.types
import category_theory.full_subcategory
universes w v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ
namespace category_theory
open opposite category_theory category limits sieve
namespace presieve
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C]
variables {P Q U : C·µí·µñ ‚•§ Type w}
variables {X Y : C} {S : sieve X} {R : presieve X}
variables (J J‚ÇÇ : grothendieck_topology C)
def family_of_elements (P : C·µí·µñ ‚•§ Type w) (R : presieve X) :=
Œ† ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X), R f ‚Üí P.obj (op Y)
instance : inhabited (family_of_elements P (‚ä• : presieve X)) := ‚ü®Œª Y f, false.elim‚ü©
def family_of_elements.restrict {R‚ÇÅ R‚ÇÇ : presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ) :
  family_of_elements P R‚ÇÇ ‚Üí family_of_elements P R‚ÇÅ :=
Œª x Y f hf, x f (h _ hf)
def family_of_elements.compatible (x : family_of_elements P R) : Prop :=
‚àÄ ‚¶ÉY‚ÇÅ Y‚ÇÇ Z‚¶Ñ (g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ) (g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ) ‚¶Éf‚ÇÅ : Y‚ÇÅ ‚ü∂ X‚¶Ñ ‚¶Éf‚ÇÇ : Y‚ÇÇ ‚ü∂ X‚¶Ñ
  (h‚ÇÅ : R f‚ÇÅ) (h‚ÇÇ : R f‚ÇÇ), g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ ‚Üí P.map g‚ÇÅ.op (x f‚ÇÅ h‚ÇÅ) = P.map g‚ÇÇ.op (x f‚ÇÇ h‚ÇÇ)
def family_of_elements.pullback_compatible (x : family_of_elements P R) [has_pullbacks C] : Prop :=
‚àÄ ‚¶ÉY‚ÇÅ Y‚ÇÇ‚¶Ñ ‚¶Éf‚ÇÅ : Y‚ÇÅ ‚ü∂ X‚¶Ñ ‚¶Éf‚ÇÇ : Y‚ÇÇ ‚ü∂ X‚¶Ñ (h‚ÇÅ : R f‚ÇÅ) (h‚ÇÇ : R f‚ÇÇ),
  P.map (pullback.fst : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ _).op (x f‚ÇÅ h‚ÇÅ) = P.map pullback.snd.op (x f‚ÇÇ h‚ÇÇ)
lemma pullback_compatible_iff (x : family_of_elements P R) [has_pullbacks C] :
  x.compatible ‚Üî x.pullback_compatible :=
begin
  split,
  { intros t Y‚ÇÅ Y‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ,
    apply t,
    apply pullback.condition },
  { intros t Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm,
    rw [‚Üêpullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hf‚ÇÅ hf‚ÇÇ,
        ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, pullback.lift_snd] }
end
lemma family_of_elements.compatible.restrict {R‚ÇÅ R‚ÇÇ : presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ)
  {x : family_of_elements P R‚ÇÇ} : x.compatible ‚Üí (x.restrict h).compatible :=
Œª q Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm, q g‚ÇÅ g‚ÇÇ (h _ h‚ÇÅ) (h _ h‚ÇÇ) comm
noncomputable def family_of_elements.sieve_extend (x : family_of_elements P R) :
  family_of_elements P (generate R) :=
Œª Z f hf, P.map hf.some_spec.some.op (x _ hf.some_spec.some_spec.some_spec.1)
lemma family_of_elements.compatible.sieve_extend {x : family_of_elements P R} (hx : x.compatible) :
  x.sieve_extend.compatible :=
begin
  intros _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ comm,
  iterate 2 { erw ‚Üê functor_to_types.map_comp_apply, rw ‚Üê op_comp }, apply hx,
  simp [comm, h‚ÇÅ.some_spec.some_spec.some_spec.2, h‚ÇÇ.some_spec.some_spec.some_spec.2],
end
lemma extend_agrees {x : family_of_elements P R} (t : x.compatible) {f : Y ‚ü∂ X} (hf : R f) :
  x.sieve_extend f (le_generate R Y hf) = x f hf :=
begin
  have h := (le_generate R Y hf).some_spec,
  unfold family_of_elements.sieve_extend,
  rw t h.some (ùüô _) _ hf _,
  { simp }, { rw id_comp, exact h.some_spec.some_spec.2 },
end
@[simp]
lemma restrict_extend {x : family_of_elements P R} (t : x.compatible) :
  x.sieve_extend.restrict (le_generate R) = x :=
begin
  ext Y f hf,
  exact extend_agrees t hf,
end
def family_of_elements.sieve_compatible (x : family_of_elements P S) : Prop :=
‚àÄ ‚¶ÉY Z‚¶Ñ (f : Y ‚ü∂ X) (g : Z ‚ü∂ Y) (hf), x (g ‚â´ f) (S.downward_closed hf g) = P.map g.op (x f hf)
lemma compatible_iff_sieve_compatible (x : family_of_elements P S) :
  x.compatible ‚Üî x.sieve_compatible :=
begin
  split,
  { intros h Y Z f g hf,
    simpa using h (ùüô _) g (S.downward_closed hf g) hf (id_comp _) },
  { intros h Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ k,
    simp_rw [‚Üê h f‚ÇÅ g‚ÇÅ h‚ÇÅ, k, h f‚ÇÇ g‚ÇÇ h‚ÇÇ] }
end
lemma family_of_elements.compatible.to_sieve_compatible {x : family_of_elements P S}
  (t : x.compatible) : x.sieve_compatible :=
(compatible_iff_sieve_compatible x).1 t
@[simp]
lemma extend_restrict {x : family_of_elements P (generate R)} (t : x.compatible) :
  (x.restrict (le_generate R)).sieve_extend = x :=
begin
  rw compatible_iff_sieve_compatible at t,
  ext _ _ h, apply (t _ _ _).symm.trans, congr,
  exact h.some_spec.some_spec.some_spec.2,
end
lemma restrict_inj {x‚ÇÅ x‚ÇÇ : family_of_elements P (generate R)}
  (t‚ÇÅ : x‚ÇÅ.compatible) (t‚ÇÇ : x‚ÇÇ.compatible) :
  x‚ÇÅ.restrict (le_generate R) = x‚ÇÇ.restrict (le_generate R) ‚Üí x‚ÇÅ = x‚ÇÇ :=
Œª h, by { rw [‚Üêextend_restrict t‚ÇÅ, ‚Üêextend_restrict t‚ÇÇ], congr, exact h }
@[simps] noncomputable def compatible_equiv_generate_sieve_compatible :
  {x : family_of_elements P R // x.compatible} ‚âÉ
  {x : family_of_elements P (generate R) // x.compatible} :=
{ to_fun := Œª x, ‚ü®x.1.sieve_extend, x.2.sieve_extend‚ü©,
  inv_fun := Œª x, ‚ü®x.1.restrict (le_generate R), x.2.restrict _‚ü©,
  left_inv := Œª x, subtype.ext (restrict_extend x.2),
  right_inv := Œª x, subtype.ext (extend_restrict x.2) }
lemma family_of_elements.comp_of_compatible (S : sieve X) {x : family_of_elements P S}
  (t : x.compatible) {f : Y ‚ü∂ X} (hf : S f) {Z} (g : Z ‚ü∂ Y) :
  x (g ‚â´ f) (S.downward_closed hf g) = P.map g.op (x f hf) :=
by simpa using t (ùüô _) g (S.downward_closed hf g) hf (id_comp _)
section functor_pullback
variables {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] (F : D ‚•§ C) {Z : D}
variables {T : presieve (F.obj Z)} {x : family_of_elements P T}
def family_of_elements.functor_pullback (x : family_of_elements P T) :
  family_of_elements (F.op ‚ãô P) (T.functor_pullback F) := Œª Y f hf, x (F.map f) hf
lemma family_of_elements.compatible.functor_pullback (h : x.compatible) :
  (x.functor_pullback F).compatible :=
begin
  intros Z‚ÇÅ Z‚ÇÇ W g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ eq,
  exact h (F.map g‚ÇÅ) (F.map g‚ÇÇ) h‚ÇÅ h‚ÇÇ (by simp only [‚Üê F.map_comp, eq])
end
end functor_pullback
noncomputable
def family_of_elements.functor_pushforward {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] (F : D ‚•§ C) {X : D}
  {T : presieve X} (x : family_of_elements (F.op ‚ãô P) T) :
    family_of_elements P (T.functor_pushforward F) := Œª Y f h,
by { obtain ‚ü®Z, g, h, h‚ÇÅ, _‚ü© := get_functor_pushforward_structure h, exact P.map h.op (x g h‚ÇÅ) }
section pullback
def family_of_elements.pullback (f : Y ‚ü∂ X)  (x : family_of_elements P S) :
  family_of_elements P (S.pullback f) := Œª _ g hg, x (g ‚â´ f) hg
lemma family_of_elements.compatible.pullback (f : Y ‚ü∂ X) {x : family_of_elements P S}
  (h : x.compatible) : (x.pullback f).compatible :=
begin
  simp only [compatible_iff_sieve_compatible] at h ‚ä¢,
  intros W Z f‚ÇÅ f‚ÇÇ hf,
  unfold family_of_elements.pullback,
  rw ‚Üê (h (f‚ÇÅ ‚â´ f) f‚ÇÇ hf),
  simp only [assoc],
end
end pullback
def family_of_elements.comp_presheaf_map (f : P ‚ü∂ Q) (x : family_of_elements P R) :
  family_of_elements Q R := Œª Y g hg, f.app (op Y) (x g hg)
@[simp]
lemma family_of_elements.comp_presheaf_map_id (x : family_of_elements P R) :
  x.comp_presheaf_map (ùüô P) = x := rfl
@[simp]
lemma family_of_elements.comp_prersheaf_map_comp (x : family_of_elements P R)
  (f : P ‚ü∂ Q) (g : Q ‚ü∂ U) :
  (x.comp_presheaf_map f).comp_presheaf_map g = x.comp_presheaf_map (f ‚â´ g) := rfl
lemma family_of_elements.compatible.comp_presheaf_map (f : P ‚ü∂ Q) {x : family_of_elements P R}
  (h : x.compatible) : (x.comp_presheaf_map f).compatible :=
begin
  intros Z‚ÇÅ Z‚ÇÇ W g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ eq,
  unfold family_of_elements.comp_presheaf_map,
  rwa [‚Üê functor_to_types.naturality, ‚Üê functor_to_types.naturality, h],
end
def family_of_elements.is_amalgamation (x : family_of_elements P R)
  (t : P.obj (op X)) : Prop :=
‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (h : R f), P.map f.op t = x f h
lemma family_of_elements.is_amalgamation.comp_presheaf_map
  {x : family_of_elements P R} {t} (f : P ‚ü∂ Q) (h : x.is_amalgamation t) :
  (x.comp_presheaf_map f).is_amalgamation (f.app (op X) t) :=
begin
  intros Y g hg,
  dsimp [family_of_elements.comp_presheaf_map],
  change (f.app _ ‚â´ Q.map _) _ = _,
  simp [‚Üê f.naturality, h g hg],
end
lemma is_compatible_of_exists_amalgamation (x : family_of_elements P R)
  (h : ‚àÉ t, x.is_amalgamation t) : x.compatible :=
begin
  cases h with t ht,
  intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm,
  rw [‚Üêht _ h‚ÇÅ, ‚Üêht _ h‚ÇÇ, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, comm],
  simp,
end
lemma is_amalgamation_restrict {R‚ÇÅ R‚ÇÇ : presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ)
  (x : family_of_elements P R‚ÇÇ) (t : P.obj (op X)) (ht : x.is_amalgamation t) :
  (x.restrict h).is_amalgamation t :=
Œª Y f hf, ht f (h Y hf)
lemma is_amalgamation_sieve_extend {R : presieve X}
  (x : family_of_elements P R) (t : P.obj (op X)) (ht : x.is_amalgamation t) :
  x.sieve_extend.is_amalgamation t :=
begin
  intros Y f hf,
  dsimp [family_of_elements.sieve_extend],
  rw [‚Üêht _, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, hf.some_spec.some_spec.some_spec.2],
end
def is_separated_for (P : C·µí·µñ ‚•§ Type w) (R : presieve X) : Prop :=
‚àÄ (x : family_of_elements P R) (t‚ÇÅ t‚ÇÇ),
  x.is_amalgamation t‚ÇÅ ‚Üí x.is_amalgamation t‚ÇÇ ‚Üí t‚ÇÅ = t‚ÇÇ
lemma is_separated_for.ext {R : presieve X} (hR : is_separated_for P R)
  {t‚ÇÅ t‚ÇÇ : P.obj (op X)} (h : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : R f), P.map f.op t‚ÇÅ = P.map f.op t‚ÇÇ) :
t‚ÇÅ = t‚ÇÇ :=
hR (Œª Y f hf, P.map f.op t‚ÇÇ) t‚ÇÅ t‚ÇÇ (Œª Y f hf, h hf) (Œª Y f hf, rfl)
lemma is_separated_for_iff_generate :
  is_separated_for P R ‚Üî is_separated_for P (generate R) :=
begin
  split,
  { intros h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ,
    apply h (x.restrict (le_generate R)) t‚ÇÅ t‚ÇÇ _ _,
    { exact is_amalgamation_restrict _ x t‚ÇÅ ht‚ÇÅ },
    { exact is_amalgamation_restrict _ x t‚ÇÇ ht‚ÇÇ } },
  { intros h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ,
    apply h (x.sieve_extend),
    { exact is_amalgamation_sieve_extend x t‚ÇÅ ht‚ÇÅ },
    { exact is_amalgamation_sieve_extend x t‚ÇÇ ht‚ÇÇ } }
end
lemma is_separated_for_top (P : C·µí·µñ ‚•§ Type w) : is_separated_for P (‚ä§ : presieve X) :=
Œª x t‚ÇÅ t‚ÇÇ h‚ÇÅ h‚ÇÇ,
begin
  have q‚ÇÅ := h‚ÇÅ (ùüô X) (by simp),
  have q‚ÇÇ := h‚ÇÇ (ùüô X) (by simp),
  simp only [op_id, functor_to_types.map_id_apply] at q‚ÇÅ q‚ÇÇ,
  rw [q‚ÇÅ, q‚ÇÇ],
end
def is_sheaf_for (P : C·µí·µñ ‚•§ Type w) (R : presieve X) : Prop :=
‚àÄ (x : family_of_elements P R), x.compatible ‚Üí ‚àÉ! t, x.is_amalgamation t
def yoneda_sheaf_condition (P : C·µí·µñ ‚•§ Type v‚ÇÅ) (S : sieve X) : Prop :=
‚àÄ (f : S.functor ‚ü∂ P), ‚àÉ! g, S.functor_inclusion ‚â´ g = f
def nat_trans_equiv_compatible_family {P : C·µí·µñ ‚•§ Type v‚ÇÅ} :
  (S.functor ‚ü∂ P) ‚âÉ {x : family_of_elements P S // x.compatible} :=
{ to_fun := Œª Œ±,
  begin
    refine ‚ü®Œª Y f hf, _, _‚ü©,
    { apply Œ±.app (op Y) ‚ü®_, hf‚ü© },
    { rw compatible_iff_sieve_compatible,
      intros Y Z f g hf,
      dsimp,
      rw ‚Üê functor_to_types.naturality _ _ Œ± g.op,
      refl }
  end,
  inv_fun := Œª t,
  { app := Œª Y f, t.1 _ f.2,
    naturality' := Œª Y Z g,
    begin
      ext ‚ü®f, hf‚ü©,
      apply t.2.to_sieve_compatible _,
    end },
  left_inv := Œª Œ±,
  begin
    ext X ‚ü®_, _‚ü©,
    refl
  end,
  right_inv :=
  begin
    rintro ‚ü®x, hx‚ü©,
    refl,
  end }
lemma extension_iff_amalgamation {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (x : S.functor ‚ü∂ P) (g : yoneda.obj X ‚ü∂ P) :
  S.functor_inclusion ‚â´ g = x ‚Üî
  (nat_trans_equiv_compatible_family x).1.is_amalgamation (yoneda_equiv g) :=
begin
  change _ ‚Üî ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (h : S f), P.map f.op (yoneda_equiv g) = x.app (op Y) ‚ü®f, h‚ü©,
  split,
  { rintro rfl Y f hf,
    rw yoneda_equiv_naturality,
    dsimp,
lemma is_sheaf_for_iff_yoneda_sheaf_condition {P : C·µí·µñ ‚•§ Type v‚ÇÅ} :
  is_sheaf_for P S ‚Üî yoneda_sheaf_condition P S :=
begin
  rw [is_sheaf_for, yoneda_sheaf_condition],
  simp_rw [extension_iff_amalgamation],
  rw equiv.forall_congr_left' nat_trans_equiv_compatible_family,
  rw subtype.forall,
  apply ball_congr,
  intros x hx,
  rw equiv.exists_unique_congr_left _,
  simp,
end
noncomputable def is_sheaf_for.extend {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : is_sheaf_for P S)
  (f : S.functor ‚ü∂ P) : yoneda.obj X ‚ü∂ P :=
(is_sheaf_for_iff_yoneda_sheaf_condition.1 h f).exists.some
@[simp, reassoc]
lemma is_sheaf_for.functor_inclusion_comp_extend {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : is_sheaf_for P S)
  (f : S.functor ‚ü∂ P) : S.functor_inclusion ‚â´ h.extend f = f :=
(is_sheaf_for_iff_yoneda_sheaf_condition.1 h f).exists.some_spec
lemma is_sheaf_for.unique_extend {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : is_sheaf_for P S) {f : S.functor ‚ü∂ P}
  (t : yoneda.obj X ‚ü∂ P) (ht : S.functor_inclusion ‚â´ t = f) :
  t = h.extend f :=
((is_sheaf_for_iff_yoneda_sheaf_condition.1 h f).unique ht (h.functor_inclusion_comp_extend f))
lemma is_sheaf_for.hom_ext {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : is_sheaf_for P S) (t‚ÇÅ t‚ÇÇ : yoneda.obj X ‚ü∂ P)
  (ht : S.functor_inclusion ‚â´ t‚ÇÅ = S.functor_inclusion ‚â´ t‚ÇÇ) :
  t‚ÇÅ = t‚ÇÇ :=
(h.unique_extend t‚ÇÅ ht).trans (h.unique_extend t‚ÇÇ rfl).symm
lemma is_separated_for_and_exists_is_amalgamation_iff_sheaf_for :
  is_separated_for P R ‚àß (‚àÄ (x : family_of_elements P R), x.compatible ‚Üí ‚àÉ t, x.is_amalgamation t) ‚Üî
  is_sheaf_for P R :=
begin
  rw [is_separated_for, ‚Üêforall_and_distrib],
  apply forall_congr,
  intro x,
  split,
  { intros z hx, exact exists_unique_of_exists_of_unique (z.2 hx) z.1 },
  { intros h,
    refine ‚ü®_, (exists_of_exists_unique ‚àò h)‚ü©,
    intros t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ,
    apply (h _).unique ht‚ÇÅ ht‚ÇÇ,
    exact is_compatible_of_exists_amalgamation x ‚ü®_, ht‚ÇÇ‚ü© }
end
lemma is_separated_for.is_sheaf_for (t : is_separated_for P R) :
  (‚àÄ (x : family_of_elements P R), x.compatible ‚Üí ‚àÉ t, x.is_amalgamation t) ‚Üí
  is_sheaf_for P R :=
begin
  rw ‚Üê is_separated_for_and_exists_is_amalgamation_iff_sheaf_for,
  exact and.intro t,
end
lemma is_sheaf_for.is_separated_for : is_sheaf_for P R ‚Üí is_separated_for P R :=
Œª q, (is_separated_for_and_exists_is_amalgamation_iff_sheaf_for.2 q).1
noncomputable def is_sheaf_for.amalgamate
  (t : is_sheaf_for P R) (x : family_of_elements P R) (hx : x.compatible) :
  P.obj (op X) :=
(t x hx).exists.some
lemma is_sheaf_for.is_amalgamation
  (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : x.compatible) :
  x.is_amalgamation (t.amalgamate x hx) :=
(t x hx).exists.some_spec
@[simp]
lemma is_sheaf_for.valid_glue
  (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : x.compatible) (f : Y ‚ü∂ X) (Hf : R f) :
  P.map f.op (t.amalgamate x hx) = x f Hf :=
t.is_amalgamation hx f Hf
lemma is_sheaf_for_iff_generate (R : presieve X) :
  is_sheaf_for P R ‚Üî is_sheaf_for P (generate R) :=
begin
  rw ‚Üê is_separated_for_and_exists_is_amalgamation_iff_sheaf_for,
  rw ‚Üê is_separated_for_and_exists_is_amalgamation_iff_sheaf_for,
  rw ‚Üê is_separated_for_iff_generate,
  apply and_congr (iff.refl _),
  split,
  { intros q x hx,
    apply exists_imp_exists _ (q _ (hx.restrict (le_generate R))),
    intros t ht,
    simpa [hx] using is_amalgamation_sieve_extend _ _ ht },
  { intros q x hx,
    apply exists_imp_exists _ (q _ hx.sieve_extend),
    intros t ht,
    simpa [hx] using is_amalgamation_restrict (le_generate R) _ _ ht },
end
lemma is_sheaf_for_singleton_iso (P : C·µí·µñ ‚•§ Type w) :
  is_sheaf_for P (presieve.singleton (ùüô X)) :=
begin
  intros x hx,
  refine ‚ü®x _ (presieve.singleton_self _), _, _‚ü©,
  { rintro _ _ ‚ü®rfl, rfl‚ü©,
    simp },
  { intros t ht,
    simpa using ht _ (presieve.singleton_self _) }
end
lemma is_sheaf_for_top_sieve (P : C·µí·µñ ‚•§ Type w) :
  is_sheaf_for P ((‚ä§ : sieve X) : presieve X) :=
begin
  rw ‚Üê generate_of_singleton_split_epi (ùüô X),
  rw ‚Üê is_sheaf_for_iff_generate,
  apply is_sheaf_for_singleton_iso,
end
lemma is_sheaf_for_iso {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') : is_sheaf_for P R ‚Üí is_sheaf_for P' R :=
begin
  intros h x hx,
  let x' := x.comp_presheaf_map i.inv,
  have : x'.compatible := family_of_elements.compatible.comp_presheaf_map i.inv hx,
  obtain ‚ü®t, ht1, ht2‚ü© := h x' this,
  use i.hom.app _ t,
  fsplit,
  { convert family_of_elements.is_amalgamation.comp_presheaf_map i.hom ht1,
    dsimp [x'],
    simp },
  { intros y hy,
    rw (show y = (i.inv.app (op X) ‚â´ i.hom.app (op X)) y, by simp),
    simp [ ht2 (i.inv.app _ y) (family_of_elements.is_amalgamation.comp_presheaf_map i.inv hy)] }
end
lemma is_sheaf_for_subsieve_aux (P : C·µí·µñ ‚•§ Type w) {S : sieve X} {R : presieve X}
  (h : (S : presieve X) ‚â§ R)
  (hS : is_sheaf_for P S)
  (trans : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, R f ‚Üí is_separated_for P (S.pullback f)) :
  is_sheaf_for P R :=
begin
  rw ‚Üê is_separated_for_and_exists_is_amalgamation_iff_sheaf_for,
  split,
  { intros x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ,
    exact hS.is_separated_for _ _ _ (is_amalgamation_restrict h x t‚ÇÅ ht‚ÇÅ)
                                    (is_amalgamation_restrict h x t‚ÇÇ ht‚ÇÇ) },
  { intros x hx,
    use hS.amalgamate _ (hx.restrict h),
    intros W j hj,
    apply (trans hj).ext,
    intros Y f hf,
    rw [‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp,
        hS.valid_glue (hx.restrict h) _ hf, family_of_elements.restrict,
        ‚Üêhx (ùüô _) f _ _ (id_comp _)],
    simp },
end
lemma is_sheaf_for_subsieve (P : C·µí·µñ ‚•§ Type w) {S : sieve X} {R : presieve X}
  (h : (S : presieve X) ‚â§ R)
  (trans : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), is_sheaf_for P (S.pullback f)) :
  is_sheaf_for P R :=
is_sheaf_for_subsieve_aux P h (by simpa using trans (ùüô _)) (Œª Y f hf, (trans f).is_separated_for)
def is_separated (P : C·µí·µñ ‚•§ Type w) : Prop :=
‚àÄ {X} (S : sieve X), S ‚àà J X ‚Üí is_separated_for P S
def is_sheaf (P : C·µí·µñ ‚•§ Type w) : Prop :=
‚àÄ ‚¶ÉX‚¶Ñ (S : sieve X), S ‚àà J X ‚Üí is_sheaf_for P S
lemma is_sheaf.is_sheaf_for {P : C·µí·µñ ‚•§ Type w} (hp : is_sheaf J P)
  (R : presieve X) (hr : generate R ‚àà J X) : is_sheaf_for P R :=
(is_sheaf_for_iff_generate R).2 $ hp _ hr
lemma is_sheaf_of_le (P : C·µí·µñ ‚•§ Type w) {J‚ÇÅ J‚ÇÇ : grothendieck_topology C} :
  J‚ÇÅ ‚â§ J‚ÇÇ ‚Üí is_sheaf J‚ÇÇ P ‚Üí is_sheaf J‚ÇÅ P :=
Œª h t X S hS, t S (h _ hS)
lemma is_separated_of_is_sheaf (P : C·µí·µñ ‚•§ Type w) (h : is_sheaf J P) : is_separated J P :=
Œª X S hS, (h S hS).is_separated_for
lemma is_sheaf_iso {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') (h : is_sheaf J P) : is_sheaf J P' :=
Œª X S hS, is_sheaf_for_iso i (h S hS)
lemma is_sheaf_of_yoneda {P : C·µí·µñ ‚•§ Type v‚ÇÅ}
  (h : ‚àÄ {X} (S : sieve X), S ‚àà J X ‚Üí yoneda_sheaf_condition P S) : is_sheaf J P :=
Œª X S hS, is_sheaf_for_iff_yoneda_sheaf_condition.2 (h _ hS)
lemma is_sheaf_pretopology [has_pullbacks C] (K : pretopology C) :
  is_sheaf (K.to_grothendieck C) P ‚Üî (‚àÄ {X : C} (R : presieve X), R ‚àà K X ‚Üí is_sheaf_for P R) :=
begin
  split,
  { intros PJ X R hR,
    rw is_sheaf_for_iff_generate,
    apply PJ (sieve.generate R) ‚ü®_, hR, le_generate R‚ü© },
  { rintro PK X S ‚ü®R, hR, RS‚ü©,
    have gRS : ‚áë(generate R) ‚â§ S,
    { apply gi_generate.gc.monotone_u,
      rwa sets_iff_generate },
    apply is_sheaf_for_subsieve P gRS _,
    intros Y f,
    rw [‚Üê pullback_arrows_comm, ‚Üê is_sheaf_for_iff_generate],
    exact PK (pullback_arrows f R) (K.pullbacks f R hR) }
end
lemma is_sheaf_bot : is_sheaf (‚ä• : grothendieck_topology C) P :=
Œª X, by simp [is_sheaf_for_top_sieve]
end presieve
namespace equalizer
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ))
  {X : C} (R : presieve X) (S : sieve X)
noncomputable theory
def first_obj : Type (max v‚ÇÅ u‚ÇÅ) :=
‚àè (Œª (f : Œ£ Y, {f : Y ‚ü∂ X // R f}), P.obj (op f.1))
@[simps]
def first_obj_eq_family : first_obj P R ‚âÖ R.family_of_elements P :=
{ hom := Œª t Y f hf, pi.œÄ (Œª (f : Œ£ Y, {f : Y ‚ü∂ X // R f}), P.obj (op f.1)) ‚ü®_, _, hf‚ü© t,
  inv := pi.lift (Œª f x, x _ f.2.2),
  hom_inv_id' :=
  begin
    ext ‚ü®Y, f, hf‚ü© p,
    simpa,
  end,
  inv_hom_id' :=
  begin
    ext x Y f hf,
    apply limits.types.limit.lift_œÄ_apply',
  end }
instance : inhabited (first_obj P (‚ä• : presieve X)) :=
((first_obj_eq_family P _).to_equiv).inhabited
def fork_map : P.obj (op X) ‚ü∂ first_obj P R :=
pi.lift (Œª f, P.map f.2.1.op)
namespace sieve
def second_obj : Type (max v‚ÇÅ u‚ÇÅ) :=
‚àè (Œª (f : Œ£ Y Z (g : Z ‚ü∂ Y), {f' : Y ‚ü∂ X // S f'}), P.obj (op f.2.1))
def first_map : first_obj P S ‚ü∂ second_obj P S :=
pi.lift (Œª fg, pi.œÄ _ (‚ü®_, _, S.downward_closed fg.2.2.2.2 fg.2.2.1‚ü© : Œ£ Y, {f : Y ‚ü∂ X // S f}))
instance : inhabited (second_obj P (‚ä• : sieve X)) := ‚ü®first_map _ _ default‚ü©
def second_map : first_obj P S ‚ü∂ second_obj P S :=
pi.lift (Œª fg, pi.œÄ _ ‚ü®_, fg.2.2.2‚ü© ‚â´ P.map fg.2.2.1.op)
lemma w : fork_map P S ‚â´ first_map P S = fork_map P S ‚â´ second_map P S :=
begin
  apply limit.hom_ext,
  rintro ‚ü®Y, Z, g, f, hf‚ü©,
  simp [first_map, second_map, fork_map],
end
lemma compatible_iff (x : first_obj P S) :
  ((first_obj_eq_family P S).hom x).compatible ‚Üî first_map P S x = second_map P S x :=
begin
  rw presieve.compatible_iff_sieve_compatible,
  split,
  { intro t,
    ext ‚ü®Y, Z, g, f, hf‚ü©,
    simpa [first_map, second_map] using t _ g hf },
  { intros t Y Z f g hf,
    rw types.limit_ext_iff' at t,
    simpa [first_map, second_map] using t ‚ü®‚ü®Y, Z, g, f, hf‚ü©‚ü© }
end
lemma equalizer_sheaf_condition :
  presieve.is_sheaf_for P S ‚Üî nonempty (is_limit (fork.of_Œπ _ (w P S))) :=
begin
  rw [types.type_equalizer_iff_unique,
      ‚Üê equiv.forall_congr_left (first_obj_eq_family P S).to_equiv.symm],
  simp_rw ‚Üê compatible_iff,
  simp only [inv_hom_id_apply, iso.to_equiv_symm_fun],
  apply ball_congr,
  intros x tx,
  apply exists_unique_congr,
  intro t,
  rw ‚Üê iso.to_equiv_symm_fun,
  rw equiv.eq_symm_apply,
  split,
  { intros q,
    ext Y f hf,
    simpa [first_obj_eq_family, fork_map] using q _ _ },
  { intros q Y f hf,
    rw ‚Üê q,
    simp [first_obj_eq_family, fork_map] }
end
end sieve
namespace presieve
variables [has_pullbacks C]
def second_obj : Type (max v‚ÇÅ u‚ÇÅ) :=
‚àè (Œª (fg : (Œ£ Y, {f : Y ‚ü∂ X // R f}) √ó (Œ£ Z, {g : Z ‚ü∂ X // R g})),
  P.obj (op (pullback fg.1.2.1 fg.2.2.1)))
def first_map : first_obj P R ‚ü∂ second_obj P R :=
pi.lift (Œª fg, pi.œÄ _ _ ‚â´ P.map pullback.fst.op)
instance : inhabited (second_obj P (‚ä• : presieve X)) := ‚ü®first_map _ _ default‚ü©
def second_map : first_obj P R ‚ü∂ second_obj P R :=
pi.lift (Œª fg, pi.œÄ _ _ ‚â´ P.map pullback.snd.op)
lemma w : fork_map P R ‚â´ first_map P R = fork_map P R ‚â´ second_map P R :=
begin
  apply limit.hom_ext,
  rintro ‚ü®‚ü®Y, f, hf‚ü©, ‚ü®Z, g, hg‚ü©‚ü©,
  simp only [first_map, second_map, fork_map],
  simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, assoc, fan.mk_œÄ_app, subtype.coe_mk,
             subtype.val_eq_coe],
  rw [‚Üê P.map_comp, ‚Üê op_comp, pullback.condition],
  simp,
end
lemma compatible_iff (x : first_obj P R) :
  ((first_obj_eq_family P R).hom x).compatible ‚Üî first_map P R x = second_map P R x :=
begin
  rw presieve.pullback_compatible_iff,
  split,
  { intro t,
    ext ‚ü®‚ü®Y, f, hf‚ü©, Z, g, hg‚ü©,
    simpa [first_map, second_map] using t hf hg },
  { intros t Y Z f g hf hg,
    rw types.limit_ext_iff' at t,
    simpa [first_map, second_map] using t ‚ü®‚ü®‚ü®Y, f, hf‚ü©, Z, g, hg‚ü©‚ü© }
end
lemma sheaf_condition :
  R.is_sheaf_for P ‚Üî nonempty (is_limit (fork.of_Œπ _ (w P R))) :=
begin
  rw types.type_equalizer_iff_unique,
  erw ‚Üê equiv.forall_congr_left (first_obj_eq_family P R).to_equiv.symm,
  simp_rw [‚Üê compatible_iff, ‚Üê iso.to_equiv_fun, equiv.apply_symm_apply],
  apply ball_congr,
  intros x hx,
  apply exists_unique_congr,
  intros t,
  rw equiv.eq_symm_apply,
  split,
  { intros q,
    ext Y f hf,
    simpa [fork_map] using q _ _ },
  { intros q Y f hf,
    rw ‚Üê q,
    simp [fork_map] }
end
end presieve
end equalizer
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C]
variables (J : grothendieck_topology C)
structure SheafOfTypes (J : grothendieck_topology C) : Type (max u‚ÇÅ v‚ÇÅ (w+1)) :=
(val : C·µí·µñ ‚•§ Type w)
(cond : presieve.is_sheaf J val)
namespace SheafOfTypes
variable {J}
@[ext]
structure hom (X Y : SheafOfTypes J) :=
(val : X.val ‚ü∂ Y.val)
@[simps]
instance : category (SheafOfTypes J) :=
{ hom := hom,
  id := Œª X, ‚ü®ùüô _‚ü©,
  comp := Œª X Y Z f g, ‚ü®f.val ‚â´ g.val‚ü©,
  id_comp' := Œª X Y f, hom.ext _ _ $ id_comp _,
  comp_id' := Œª X Y f, hom.ext _ _ $ comp_id _,
  assoc' := Œª X Y Z W f g h, hom.ext _ _ $ assoc _ _ _ }
@[simps]
def SheafOfTypes_to_presheaf : SheafOfTypes J ‚•§ (C·µí·µñ ‚•§ Type w) :=
{ obj := SheafOfTypes.val,
  map := Œª X Y f, f.val,
  map_id' := Œª X, rfl,
  map_comp' := Œª X Y Z f g, rfl }
instance : full (SheafOfTypes_to_presheaf J) := { preimage := Œª X Y f, ‚ü®f‚ü© }
instance : faithful (SheafOfTypes_to_presheaf J) := {}
@[simps]
def SheafOfTypes_bot_equiv : SheafOfTypes (‚ä• : grothendieck_topology C) ‚âå (C·µí·µñ ‚•§ Type w) :=
{ functor := SheafOfTypes_to_presheaf _,
  inverse :=
  { obj := Œª P, ‚ü®P, presieve.is_sheaf_bot‚ü©,
    map := Œª P‚ÇÅ P‚ÇÇ f, (SheafOfTypes_to_presheaf _).preimage f },
  unit_iso :=
  { hom := { app := Œª _, ‚ü®ùüô _‚ü© },
    inv := { app := Œª _, ‚ü®ùüô _‚ü© } },
  counit_iso := iso.refl _ }
instance : inhabited (SheafOfTypes (‚ä• : grothendieck_topology C)) :=
‚ü®SheafOfTypes_bot_equiv.inverse.obj ((functor.const _).obj punit)‚ü©
end category_theory
