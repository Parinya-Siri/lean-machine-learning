import category_theory.natural_isomorphism
import category_theory.eq_to_hom
namespace category_theory
universes wâ‚€ wâ‚ wâ‚‚ vâ‚ vâ‚‚ uâ‚ uâ‚‚
variables {I : Type wâ‚€} (C : I â†’ Type uâ‚) [Î  i, category.{vâ‚} (C i)]
instance pi : category.{max wâ‚€ vâ‚} (Î  i, C i) :=
{ hom := Î» X Y, Î  i, X i âŸ¶ Y i,
  id := Î» X i, ğŸ™ (X i),
  comp := Î» X Y Z f g i, f i â‰« g i }
abbreviation pi' {I : Type vâ‚} (C : I â†’ Type uâ‚) [Î  i, category.{vâ‚} (C i)] :
  category.{vâ‚} (Î  i, C i) :=
category_theory.pi C
attribute [instance] pi'
namespace pi
@[simp] lemma id_apply (X : Î  i, C i) (i) : (ğŸ™ X : Î  i, X i âŸ¶ X i) i = ğŸ™ (X i) := rfl
@[simp] lemma comp_apply {X Y Z : Î  i, C i} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (i) :
  (f â‰« g : Î  i, X i âŸ¶ Z i) i = f i â‰« g i := rfl
@[simps]
def eval (i : I) : (Î  i, C i) â¥¤ C i :=
{ obj := Î» f, f i,
  map := Î» f g Î±, Î± i, }
section
variables {J : Type wâ‚}
@[simps]
def comap (h : J â†’ I) : (Î  i, C i) â¥¤ (Î  j, C (h j)) :=
{ obj := Î» f i, f (h i),
  map := Î» f g Î± i, Î± (h i), }
variables (I)
@[simps]
def comap_id : comap C (id : I â†’ I) â‰… ğŸ­ (Î  i, C i) :=
{ hom := { app := Î» X, ğŸ™ X },
  inv := { app := Î» X, ğŸ™ X } }.
variables {I}
variables {K : Type wâ‚‚}
@[simps]
def comap_comp (f : K â†’ J) (g : J â†’ I) : comap C g â‹™ comap (C âˆ˜ g) f â‰… comap C (g âˆ˜ f) :=
{ hom := { app := Î» X b, ğŸ™ (X (g (f b))) },
  inv := { app := Î» X b, ğŸ™ (X (g (f b))) } }
@[simps]
def comap_eval_iso_eval (h : J â†’ I) (j : J) : comap C h â‹™ eval (C âˆ˜ h) j â‰… eval C (h j) :=
nat_iso.of_components (Î» f, iso.refl _) (by tidy)
end
section
variables {J : Type wâ‚€} {D : J â†’ Type uâ‚} [Î  j, category.{vâ‚} (D j)]
instance sum_elim_category : Î  (s : I âŠ• J), category.{vâ‚} (sum.elim C D s)
| (sum.inl i) := by { dsimp, apply_instance, }
| (sum.inr j) := by { dsimp, apply_instance, }
@[simps]
def sum : (Î  i, C i) â¥¤ (Î  j, D j) â¥¤ (Î  s : I âŠ• J, sum.elim C D s) :=
{ obj := Î» f,
  { obj := Î» g s, sum.rec f g s,
    map := Î» g g' Î± s, sum.rec (Î» i, ğŸ™ (f i)) Î± s },
  map := Î» f f' Î±,
  { app := Î» g s, sum.rec Î± (Î» j, ğŸ™ (g j)) s, }}
end
variables {C}
@[simps] def iso_app {X Y : Î  i, C i} (f : X â‰… Y) (i : I) : X i â‰… Y i :=
âŸ¨f.hom i, f.inv i, by { dsimp, rw [â† comp_apply, iso.hom_inv_id, id_apply] },
  by { dsimp, rw [â† comp_apply, iso.inv_hom_id, id_apply] }âŸ©
@[simp] lemma iso_app_refl (X : Î  i, C i) (i : I) : iso_app (iso.refl X) i = iso.refl (X i) := rfl
@[simp] lemma iso_app_symm {X Y : Î  i, C i} (f : X â‰… Y) (i : I) :
  iso_app f.symm i = (iso_app f i).symm := rfl
@[simp] lemma iso_app_trans {X Y Z : Î  i, C i} (f : X â‰… Y) (g : Y â‰… Z) (i : I) :
  iso_app (f â‰ªâ‰« g) i = iso_app f i â‰ªâ‰« iso_app g i := rfl
end pi
namespace functor
variables {C}
variables {D : I â†’ Type uâ‚} [âˆ€ i, category.{vâ‚} (D i)] {A : Type uâ‚} [category.{uâ‚} A]
@[simps]
def pi (F : Î  i, C i â¥¤ D i) : (Î  i, C i) â¥¤ (Î  i, D i) :=
{ obj := Î» f i, (F i).obj (f i),
  map := Î» f g Î± i, (F i).map (Î± i) }
@[simps]
def pi' (f : Î  i, A â¥¤ C i) : A â¥¤ Î  i, C i :=
{ obj := Î» a i, (f i).obj a,
  map := Î» aâ‚ aâ‚‚ h i, (f i).map h, }
section eq_to_hom
@[simp] lemma eq_to_hom_proj {x x' : Î  i, C i} (h : x = x') (i : I) :
  (eq_to_hom h : x âŸ¶ x') i = eq_to_hom (function.funext_iff.mp h i) := by { subst h, refl, }
end eq_to_hom
lemma pi_ext (f f' : A â¥¤ Î  i, C i) (h : âˆ€ i, f â‹™ (pi.eval C i) = f' â‹™ (pi.eval C i)) :
  f = f' :=
begin
  apply functor.ext, swap,
  { intro X, ext i, specialize h i,
    have := congr_obj h X, simpa, },
  { intros x y p, ext i, specialize h i,
    have := congr_hom h p, simpa, }
end
end functor
namespace nat_trans
variables {C}
variables {D : I â†’ Type uâ‚} [âˆ€ i, category.{vâ‚} (D i)]
variables {F G : Î  i, C i â¥¤ D i}
@[simps]
def pi (Î± : Î  i, F i âŸ¶ G i) : functor.pi F âŸ¶ functor.pi G :=
{ app := Î» f i, (Î± i).app (f i), }
end nat_trans
end category_theory
