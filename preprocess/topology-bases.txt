import topology.constructions
import topology.continuous_on
open set filter function
open_locale topological_space filter
noncomputable theory
namespace topological_space
universe u
variables {Œ± : Type u} [t : topological_space Œ±]
include t
structure is_topological_basis (s : set (set Œ±)) : Prop :=
(exists_subset_inter : ‚àÄt‚ÇÅ‚ààs, ‚àÄt‚ÇÇ‚ààs, ‚àÄ x ‚àà t‚ÇÅ ‚à© t‚ÇÇ, ‚àÉ t‚ÇÉ‚ààs, x ‚àà t‚ÇÉ ‚àß t‚ÇÉ ‚äÜ t‚ÇÅ ‚à© t‚ÇÇ)
(sUnion_eq : (‚ãÉ‚ÇÄ s) = univ)
(eq_generate_from : t = generate_from s)
lemma is_topological_basis_of_subbasis {s : set (set Œ±)} (hs : t = generate_from s) :
  is_topological_basis ((Œª f, ‚ãÇ‚ÇÄ f) '' {f : set (set Œ±) | f.finite ‚àß f ‚äÜ s ‚àß (‚ãÇ‚ÇÄ f).nonempty}) :=
begin
  refine ‚ü®_, _, _‚ü©,
  { rintro _ ‚ü®t‚ÇÅ, ‚ü®hft‚ÇÅ, ht‚ÇÅb, ht‚ÇÅ‚ü©, rfl‚ü© _ ‚ü®t‚ÇÇ, ‚ü®hft‚ÇÇ, ht‚ÇÇb, ht‚ÇÇ‚ü©, rfl‚ü© x h,
    have : ‚ãÇ‚ÇÄ (t‚ÇÅ ‚à™ t‚ÇÇ) = ‚ãÇ‚ÇÄ t‚ÇÅ ‚à© ‚ãÇ‚ÇÄ t‚ÇÇ := sInter_union t‚ÇÅ t‚ÇÇ,
    exact ‚ü®_, ‚ü®t‚ÇÅ ‚à™ t‚ÇÇ, ‚ü®hft‚ÇÅ.union hft‚ÇÇ, union_subset ht‚ÇÅb ht‚ÇÇb, this.symm ‚ñ∏ ‚ü®x, h‚ü©‚ü©, this‚ü©, h,
      subset.rfl‚ü© },
  { rw [sUnion_image, Union‚ÇÇ_eq_univ_iff],
    intro x, have : x ‚àà ‚ãÇ‚ÇÄ ‚àÖ, { rw sInter_empty, exact mem_univ x },
    exact ‚ü®‚àÖ, ‚ü®finite_empty, empty_subset _, x, this‚ü©, this‚ü© },
  { rw hs,
    apply le_antisymm; apply le_generate_from,
    { rintro _ ‚ü®t, ‚ü®hft, htb, ht‚ü©, rfl‚ü©,
      exact @is_open_sInter _ (generate_from s) _ hft (Œª s hs, generate_open.basic _ $ htb hs) },
    { intros t ht,
      rcases t.eq_empty_or_nonempty with rfl|hne, { apply @is_open_empty _ _ },
      rw ‚Üê sInter_singleton t at hne ‚ä¢,
      exact generate_open.basic _ ‚ü®{t}, ‚ü®finite_singleton t, singleton_subset_iff.2 ht, hne‚ü©,
        rfl‚ü© } }
end
lemma is_topological_basis_of_open_of_nhds {s : set (set Œ±)}
  (h_open : ‚àÄ u ‚àà s, is_open u)
  (h_nhds : ‚àÄ(a:Œ±) (u : set Œ±), a ‚àà u ‚Üí is_open u ‚Üí ‚àÉv ‚àà s, a ‚àà v ‚àß v ‚äÜ u) :
  is_topological_basis s :=
begin
  refine ‚ü®Œª t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ x hx, h_nhds _ _ hx (is_open.inter (h_open _ ht‚ÇÅ) (h_open _ ht‚ÇÇ)), _, _‚ü©,
  { refine sUnion_eq_univ_iff.2 (Œª a, _),
    rcases h_nhds a univ trivial is_open_univ with ‚ü®u, h‚ÇÅ, h‚ÇÇ, -‚ü©,
    exact ‚ü®u, h‚ÇÅ, h‚ÇÇ‚ü© },
  { refine (le_generate_from h_open).antisymm (Œª u hu, _),
    refine (@is_open_iff_nhds Œ± (generate_from s) u).mpr (Œª a ha, _),
    rcases h_nhds a u ha hu with ‚ü®v, hvs, hav, hvu‚ü©,
    rw nhds_generate_from,
    exact infi‚ÇÇ_le_of_le v ‚ü®hav, hvs‚ü© (le_principal_iff.2 hvu) }
end
lemma is_topological_basis.mem_nhds_iff {a : Œ±} {s : set Œ±} {b : set (set Œ±)}
  (hb : is_topological_basis b) : s ‚àà ùìù a ‚Üî ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s :=
begin
  change s ‚àà (ùìù a).sets ‚Üî ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s,
  rw [hb.eq_generate_from, nhds_generate_from, binfi_sets_eq],
  { simp [and_assoc, and.left_comm] },
  { exact assume s ‚ü®hs‚ÇÅ, hs‚ÇÇ‚ü© t ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü©,
      have a ‚àà s ‚à© t, from ‚ü®hs‚ÇÅ, ht‚ÇÅ‚ü©,
      let ‚ü®u, hu‚ÇÅ, hu‚ÇÇ, hu‚ÇÉ‚ü© := hb.1 _ hs‚ÇÇ _ ht‚ÇÇ _ this in
      ‚ü®u, ‚ü®hu‚ÇÇ, hu‚ÇÅ‚ü©, le_principal_iff.2 (subset.trans hu‚ÇÉ (inter_subset_left _ _)),
        le_principal_iff.2 (subset.trans hu‚ÇÉ (inter_subset_right _ _))‚ü© },
  { rcases eq_univ_iff_forall.1 hb.sUnion_eq a with ‚ü®i, h1, h2‚ü©,
    exact ‚ü®i, h2, h1‚ü© }
end
lemma is_topological_basis.is_open_iff {s : set Œ±} {b : set (set Œ±)} (hb : is_topological_basis b) :
  is_open s ‚Üî ‚àÄ a ‚àà s, ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s :=
by simp [is_open_iff_mem_nhds, hb.mem_nhds_iff]
lemma is_topological_basis.nhds_has_basis {b : set (set Œ±)} (hb : is_topological_basis b) {a : Œ±} :
  (ùìù a).has_basis (Œª t : set Œ±, t ‚àà b ‚àß a ‚àà t) (Œª t, t) :=
‚ü®Œª s, hb.mem_nhds_iff.trans $ by simp only [exists_prop, and_assoc]‚ü©
protected lemma is_topological_basis.is_open {s : set Œ±} {b : set (set Œ±)}
  (hb : is_topological_basis b) (hs : s ‚àà b) : is_open s :=
by { rw hb.eq_generate_from, exact generate_open.basic s hs }
protected lemma is_topological_basis.mem_nhds {a : Œ±} {s : set Œ±} {b : set (set Œ±)}
  (hb : is_topological_basis b) (hs : s ‚àà b) (ha : a ‚àà s) : s ‚àà ùìù a :=
(hb.is_open hs).mem_nhds ha
lemma is_topological_basis.exists_subset_of_mem_open {b : set (set Œ±)}
  (hb : is_topological_basis b) {a:Œ±} {u : set Œ±} (au : a ‚àà u)
  (ou : is_open u) : ‚àÉv ‚àà b, a ‚àà v ‚àß v ‚äÜ u :=
hb.mem_nhds_iff.1 $ is_open.mem_nhds ou au
lemma is_topological_basis.open_eq_sUnion' {B : set (set Œ±)}
  (hB : is_topological_basis B) {u : set Œ±} (ou : is_open u) :
  u = ‚ãÉ‚ÇÄ {s ‚àà B | s ‚äÜ u} :=
ext $ Œª a,
‚ü®Œª ha, let ‚ü®b, hb, ab, bu‚ü© := hB.exists_subset_of_mem_open ha ou in ‚ü®b, ‚ü®hb, bu‚ü©, ab‚ü©,
  Œª ‚ü®b, ‚ü®hb, bu‚ü©, ab‚ü©, bu ab‚ü©
lemma is_topological_basis.open_eq_sUnion {B : set (set Œ±)}
  (hB : is_topological_basis B) {u : set Œ±} (ou : is_open u) :
  ‚àÉ S ‚äÜ B, u = ‚ãÉ‚ÇÄ S :=
‚ü®{s ‚àà B | s ‚äÜ u}, Œª s h, h.1, hB.open_eq_sUnion' ou‚ü©
lemma is_topological_basis.open_eq_Union {B : set (set Œ±)}
  (hB : is_topological_basis B) {u : set Œ±} (ou : is_open u) :
  ‚àÉ (Œ≤ : Type u) (f : Œ≤ ‚Üí set Œ±), u = (‚ãÉ i, f i) ‚àß ‚àÄ i, f i ‚àà B :=
‚ü®‚Ü•{s ‚àà B | s ‚äÜ u}, coe, by { rw ‚Üê sUnion_eq_Union, apply hB.open_eq_sUnion' ou }, Œª s, and.left s.2‚ü©
lemma is_topological_basis.mem_closure_iff {b : set (set Œ±)} (hb : is_topological_basis b)
  {s : set Œ±} {a : Œ±} :
  a ‚àà closure s ‚Üî ‚àÄ o ‚àà b, a ‚àà o ‚Üí (o ‚à© s).nonempty :=
(mem_closure_iff_nhds_basis' hb.nhds_has_basis).trans $ by simp only [and_imp]
lemma is_topological_basis.dense_iff {b : set (set Œ±)} (hb : is_topological_basis b) {s : set Œ±} :
  dense s ‚Üî ‚àÄ o ‚àà b, set.nonempty o ‚Üí (o ‚à© s).nonempty :=
begin
  simp only [dense, hb.mem_closure_iff],
  exact ‚ü®Œª h o hb ‚ü®a, ha‚ü©, h a o hb ha, Œª h a o hb ha, h o hb ‚ü®a, ha‚ü©‚ü©
end
lemma is_topological_basis.is_open_map_iff {Œ≤} [topological_space Œ≤] {B : set (set Œ±)}
  (hB : is_topological_basis B) {f : Œ± ‚Üí Œ≤} :
  is_open_map f ‚Üî ‚àÄ s ‚àà B, is_open (f '' s) :=
begin
  refine ‚ü®Œª H o ho, H _ (hB.is_open ho), Œª hf o ho, _‚ü©,
  rw [hB.open_eq_sUnion' ho, sUnion_eq_Union, image_Union],
  exact is_open_Union (Œª s, hf s s.2.1)
end
lemma is_topological_basis.exists_nonempty_subset {B : set (set Œ±)}
  (hb : is_topological_basis B) {u : set Œ±} (hu : u.nonempty) (ou : is_open u) :
  ‚àÉ v ‚àà B, set.nonempty v ‚àß v ‚äÜ u :=
begin
  cases hu with x hx,
  rw [hb.open_eq_sUnion' ou, mem_sUnion] at hx,
  rcases hx with ‚ü®v, hv, hxv‚ü©,
  exact ‚ü®v, hv.1, ‚ü®x, hxv‚ü©, hv.2‚ü©
end
lemma is_topological_basis_opens : is_topological_basis { U : set Œ± | is_open U } :=
is_topological_basis_of_open_of_nhds (by tauto) (by tauto)
protected lemma is_topological_basis.prod {Œ≤} [topological_space Œ≤] {B‚ÇÅ : set (set Œ±)}
  {B‚ÇÇ : set (set Œ≤)} (h‚ÇÅ : is_topological_basis B‚ÇÅ) (h‚ÇÇ : is_topological_basis B‚ÇÇ) :
  is_topological_basis (image2 (√óÀ¢) B‚ÇÅ B‚ÇÇ) :=
begin
  refine is_topological_basis_of_open_of_nhds _ _,
  { rintro _ ‚ü®u‚ÇÅ, u‚ÇÇ, hu‚ÇÅ, hu‚ÇÇ, rfl‚ü©,
    exact (h‚ÇÅ.is_open hu‚ÇÅ).prod (h‚ÇÇ.is_open hu‚ÇÇ) },
  { rintro ‚ü®a, b‚ü© u hu uo,
    rcases (h‚ÇÅ.nhds_has_basis.prod_nhds h‚ÇÇ.nhds_has_basis).mem_iff.1 (is_open.mem_nhds uo hu)
      with ‚ü®‚ü®s, t‚ü©, ‚ü®‚ü®hs, ha‚ü©, ht, hb‚ü©, hu‚ü©,
    exact ‚ü®s √óÀ¢ t, mem_image2_of_mem hs ht, ‚ü®ha, hb‚ü©, hu‚ü© }
end
protected lemma is_topological_basis.inducing {Œ≤} [topological_space Œ≤]
  {f : Œ± ‚Üí Œ≤} {T : set (set Œ≤)} (hf : inducing f) (h : is_topological_basis T) :
  is_topological_basis (image (preimage f) T) :=
begin
  refine is_topological_basis_of_open_of_nhds _ _,
  { rintros _ ‚ü®V, hV, rfl‚ü©,
    rwa hf.is_open_iff,
    refine ‚ü®V, h.is_open hV, rfl‚ü© },
  { intros a U ha hU,
    rw hf.is_open_iff at hU,
    obtain ‚ü®V, hV, rfl‚ü© := hU,
    obtain ‚ü®S, hS, rfl‚ü© := h.open_eq_sUnion hV,
    obtain ‚ü®W, hW, ha‚ü© := ha,
    refine ‚ü®f ‚Åª¬π' W, ‚ü®_, hS hW, rfl‚ü©, ha, set.preimage_mono $ set.subset_sUnion_of_mem hW‚ü© }
end
lemma is_topological_basis_of_cover {Œπ} {U  : Œπ ‚Üí set Œ±} (Uo : ‚àÄ i, is_open (U i))
  (Uc : (‚ãÉ i, U i) = univ) {b : Œ† i, set (set (U i))} (hb : ‚àÄ i, is_topological_basis (b i)) :
  is_topological_basis (‚ãÉ i : Œπ, image (coe : U i ‚Üí Œ±) '' (b i)) :=
begin
  refine is_topological_basis_of_open_of_nhds (Œª u hu, _) _,
  { simp only [mem_Union, mem_image] at hu,
    rcases hu with ‚ü®i, s, sb, rfl‚ü©,
    exact (Uo i).is_open_map_subtype_coe _ ((hb i).is_open sb) },
  { intros a u ha uo,
    rcases Union_eq_univ_iff.1 Uc a with ‚ü®i, hi‚ü©,
    lift a to ‚Ü•(U i) using hi,
    rcases (hb i).exists_subset_of_mem_open (by exact ha) (uo.preimage continuous_subtype_coe)
      with ‚ü®v, hvb, hav, hvu‚ü©,
    exact ‚ü®coe '' v, mem_Union.2 ‚ü®i, mem_image_of_mem _ hvb‚ü©, mem_image_of_mem _ hav,
      image_subset_iff.2 hvu‚ü© }
end
protected lemma is_topological_basis.continuous {Œ≤ : Type*} [topological_space Œ≤]
  {B : set (set Œ≤)} (hB : is_topological_basis B) (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ s ‚àà B, is_open (f ‚Åª¬π' s)) :
  continuous f :=
begin rw hB.eq_generate_from, exact continuous_generated_from hf end
variables (Œ±)
class separable_space : Prop :=
(exists_countable_dense : ‚àÉs:set Œ±, s.countable ‚àß dense s)
lemma exists_countable_dense [separable_space Œ±] :
  ‚àÉ s : set Œ±, s.countable ‚àß dense s :=
separable_space.exists_countable_dense
lemma exists_dense_seq [separable_space Œ±] [nonempty Œ±] : ‚àÉ u : ‚Ñï ‚Üí Œ±, dense_range u :=
begin
  obtain ‚ü®s : set Œ±, hs, s_dense‚ü© := exists_countable_dense Œ±,
  cases countable_iff_exists_surjective.mp hs with u hu,
  exact ‚ü®u, s_dense.mono hu‚ü©,
end
def dense_seq [separable_space Œ±] [nonempty Œ±] : ‚Ñï ‚Üí Œ± := classical.some (exists_dense_seq Œ±)
@[simp] lemma dense_range_dense_seq [separable_space Œ±] [nonempty Œ±] :
  dense_range (dense_seq Œ±) := classical.some_spec (exists_dense_seq Œ±)
variable {Œ±}
@[priority 100]
instance encodable.to_separable_space [encodable Œ±] : separable_space Œ± :=
{ exists_countable_dense := ‚ü®set.univ, set.countable_encodable set.univ, dense_univ‚ü© }
lemma separable_space_of_dense_range {Œπ : Type*} [encodable Œπ] (u : Œπ ‚Üí Œ±) (hu : dense_range u) :
  separable_space Œ± :=
‚ü®‚ü®range u, countable_range u, hu‚ü©‚ü©
lemma _root_.set.pairwise_disjoint.countable_of_is_open [separable_space Œ±] {Œπ : Type*}
  {s : Œπ ‚Üí set Œ±} {a : set Œπ} (h : a.pairwise_disjoint s) (ha : ‚àÄ i ‚àà a, is_open (s i))
  (h'a : ‚àÄ i ‚àà a, (s i).nonempty) :
  a.countable :=
begin
  rcases exists_countable_dense Œ± with ‚ü®u, ‚ü®u_encodable‚ü©, u_dense‚ü©,
  have : ‚àÄ i : a, ‚àÉ y, y ‚àà s i ‚à© u :=
    Œª i, dense_iff_inter_open.1 u_dense (s i) (ha i i.2) (h'a i i.2),
  choose f hfs hfu using this,
  lift f to a ‚Üí u using hfu,
  have f_inj : injective f,
  { refine injective_iff_pairwise_ne.mpr ((h.subtype _ _).mono $ Œª i j hij hfij, hij ‚ü®hfs i, _‚ü©),
    simp only [congr_arg coe hfij, hfs j] },
  exact ‚ü®@encodable.of_inj _ _ u_encodable f f_inj‚ü©
end
lemma _root_.set.pairwise_disjoint.countable_of_nonempty_interior [separable_space Œ±] {Œπ : Type*}
  {s : Œπ ‚Üí set Œ±} {a : set Œπ} (h : a.pairwise_disjoint s)
  (ha : ‚àÄ i ‚àà a, (interior (s i)).nonempty) :
  a.countable :=
(h.mono $ Œª i, interior_subset).countable_of_is_open (Œª i hi, is_open_interior) ha
def is_separable (s : set Œ±) :=
‚àÉ c : set Œ±, c.countable ‚àß s ‚äÜ closure c
lemma is_separable.mono {s u : set Œ±} (hs : is_separable s) (hu : u ‚äÜ s) :
  is_separable u :=
begin
  rcases hs with ‚ü®c, c_count, hs‚ü©,
  exact ‚ü®c, c_count, hu.trans hs‚ü©
end
lemma is_separable.union {s u : set Œ±} (hs : is_separable s) (hu : is_separable u) :
  is_separable (s ‚à™ u) :=
begin
  rcases hs with ‚ü®cs, cs_count, hcs‚ü©,
  rcases hu with ‚ü®cu, cu_count, hcu‚ü©,
  refine ‚ü®cs ‚à™ cu, cs_count.union cu_count, _‚ü©,
  exact union_subset (hcs.trans (closure_mono (subset_union_left _ _)))
    (hcu.trans (closure_mono (subset_union_right _ _)))
end
lemma is_separable.closure {s : set Œ±} (hs : is_separable s) : is_separable (closure s) :=
begin
  rcases hs with ‚ü®c, c_count, hs‚ü©,
  exact ‚ü®c, c_count, by simpa using closure_mono hs‚ü©,
end
lemma is_separable_Union {Œπ : Type*} [encodable Œπ] {s : Œπ ‚Üí set Œ±} (hs : ‚àÄ i, is_separable (s i)) :
  is_separable (‚ãÉ i, s i) :=
begin
  choose c hc h'c using hs,
  refine ‚ü®‚ãÉ i, c i, countable_Union hc, Union_subset_iff.2 (Œª i, _)‚ü©,
  exact (h'c i).trans (closure_mono (subset_Union _ i))
end
lemma _root_.set.countable.is_separable {s : set Œ±} (hs : s.countable) : is_separable s :=
‚ü®s, hs, subset_closure‚ü©
lemma _root_.set.finite.is_separable {s : set Œ±} (hs : s.finite) : is_separable s :=
hs.countable.is_separable
lemma is_separable_univ_iff :
  is_separable (univ : set Œ±) ‚Üî separable_space Œ± :=
begin
  split,
  { rintros ‚ü®c, c_count, hc‚ü©,
    refine ‚ü®‚ü®c, c_count, by rwa [dense_iff_closure_eq, ‚Üê univ_subset_iff]‚ü©‚ü© },
  { introsI h,
    rcases exists_countable_dense Œ± with ‚ü®c, c_count, hc‚ü©,
    exact ‚ü®c, c_count, by rwa [univ_subset_iff, ‚Üê dense_iff_closure_eq]‚ü© }
end
lemma is_separable_of_separable_space [h : separable_space Œ±] (s : set Œ±) : is_separable s :=
is_separable.mono (is_separable_univ_iff.2 h) (subset_univ _)
lemma is_separable.image {Œ≤ : Type*} [topological_space Œ≤]
  {s : set Œ±} (hs : is_separable s) {f : Œ± ‚Üí Œ≤} (hf : continuous f) :
  is_separable (f '' s) :=
begin
  rcases hs with ‚ü®c, c_count, hc‚ü©,
  refine ‚ü®f '' c, c_count.image _, _‚ü©,
  rw image_subset_iff,
  exact hc.trans (closure_subset_preimage_closure_image hf)
end
lemma is_separable_of_separable_space_subtype (s : set Œ±) [separable_space s] : is_separable s :=
begin
  have : is_separable ((coe : s ‚Üí Œ±) '' (univ : set s)) :=
    (is_separable_of_separable_space _).image continuous_subtype_coe,
  simpa only [image_univ, subtype.range_coe_subtype],
end
end topological_space
open topological_space
lemma is_topological_basis_pi {Œπ : Type*} {X : Œπ ‚Üí Type*}
  [‚àÄ i, topological_space (X i)] {T : Œ† i, set (set (X i))}
  (cond : ‚àÄ i, is_topological_basis (T i)) :
  is_topological_basis {S : set (Œ† i, X i) | ‚àÉ (U : Œ† i, set (X i)) (F : finset Œπ),
    (‚àÄ i, i ‚àà F ‚Üí (U i) ‚àà T i) ‚àß S = (F : set Œπ).pi U } :=
begin
  refine is_topological_basis_of_open_of_nhds _ _,
  { rintro _ ‚ü®U, F, h1, rfl‚ü©,
    apply is_open_set_pi F.finite_to_set,
    intros i hi,
    exact (cond i).is_open (h1 i hi) },
  { intros a U ha hU,
    obtain ‚ü®I, t, hta, htU‚ü© :
      ‚àÉ (I : finset Œπ) (t : Œ† (i : Œπ), set (X i)), (‚àÄ i, t i ‚àà ùìù (a i)) ‚àß set.pi ‚ÜëI t ‚äÜ U,
    { rw [‚Üê filter.mem_pi', ‚Üê nhds_pi], exact hU.mem_nhds ha },
    have : ‚àÄ i, ‚àÉ V ‚àà T i, a i ‚àà V ‚àß V ‚äÜ t i := Œª i, (cond i).mem_nhds_iff.1 (hta i),
    choose V hVT haV hVt,
    exact ‚ü®_, ‚ü®V, I, Œª i hi, hVT i, rfl‚ü©, Œª i hi, haV i, (pi_mono $ Œª i hi, hVt i).trans htU‚ü© },
end
lemma is_topological_basis_infi {Œ≤ : Type*} {Œπ : Type*} {X : Œπ ‚Üí Type*}
  [t : ‚àÄ i, topological_space (X i)] {T : Œ† i, set (set (X i))}
  (cond : ‚àÄ i, is_topological_basis (T i)) (f : Œ† i, Œ≤ ‚Üí X i) :
  @is_topological_basis Œ≤ (‚®Ö i, induced (f i) (t i))
  { S | ‚àÉ (U : Œ† i, set (X i)) (F : finset Œπ),
    (‚àÄ i, i ‚àà F ‚Üí U i ‚àà T i) ‚àß S = ‚ãÇ i (hi : i ‚àà F), (f i) ‚Åª¬π' (U i) } :=
begin
  convert (is_topological_basis_pi cond).inducing (inducing_infi_to_pi _),
  ext V,
  split,
  { rintros ‚ü®U, F, h1, h2‚ü©,
    have : (F : set Œπ).pi U = (‚ãÇ (i : Œπ) (hi : i ‚àà F),
        (Œª (z : Œ† j, X j), z i) ‚Åª¬π' (U i)), by { ext, simp },
    refine ‚ü®(F : set Œπ).pi U, ‚ü®U, F, h1, rfl‚ü©, _‚ü©,
    rw [this, h2, set.preimage_Inter],
    congr' 1,
    ext1,
    rw set.preimage_Inter,
    refl },
  { rintros ‚ü®U, ‚ü®U, F, h1, rfl‚ü©, h‚ü©,
    refine ‚ü®U, F, h1, _‚ü©,
    have : (F : set Œπ).pi U = (‚ãÇ (i : Œπ) (hi : i ‚àà F),
        (Œª (z : Œ† j, X j), z i) ‚Åª¬π' (U i)), by { ext, simp },
    rw [‚Üê h, this, set.preimage_Inter],
    congr' 1,
    ext1,
    rw set.preimage_Inter,
    refl }
end
lemma is_topological_basis_singletons (Œ± : Type*) [topological_space Œ±] [discrete_topology Œ±] :
  is_topological_basis {s | ‚àÉ (x : Œ±), (s : set Œ±) = {x}} :=
is_topological_basis_of_open_of_nhds (Œª u hu, is_open_discrete _) $
  Œª x u hx u_open, ‚ü®{x}, ‚ü®x, rfl‚ü©, mem_singleton x, singleton_subset_iff.2 hx‚ü©
protected lemma dense_range.separable_space {Œ± Œ≤ : Type*} [topological_space Œ±] [separable_space Œ±]
  [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (h : dense_range f) (h' : continuous f) :
  separable_space Œ≤ :=
let ‚ü®s, s_cnt, s_dense‚ü© := exists_countable_dense Œ± in
‚ü®‚ü®f '' s, countable.image s_cnt f, h.dense_image h' s_dense‚ü©‚ü©
lemma dense.exists_countable_dense_subset {Œ± : Type*} [topological_space Œ±]
  {s : set Œ±} [separable_space s] (hs : dense s) :
  ‚àÉ t ‚äÜ s, t.countable ‚àß dense t :=
let ‚ü®t, htc, htd‚ü© := exists_countable_dense s
in ‚ü®coe '' t, image_subset_iff.2 $ Œª x _, mem_preimage.2 $ subtype.coe_prop _, htc.image coe,
  hs.dense_range_coe.dense_image continuous_subtype_val htd‚ü©
lemma dense.exists_countable_dense_subset_bot_top {Œ± : Type*} [topological_space Œ±]
  [partial_order Œ±] {s : set Œ±} [separable_space s] (hs : dense s) :
  ‚àÉ t ‚äÜ s, t.countable ‚àß dense t ‚àß (‚àÄ x, is_bot x ‚Üí x ‚àà s ‚Üí x ‚àà t) ‚àß
    (‚àÄ x, is_top x ‚Üí x ‚àà s ‚Üí x ‚àà t) :=
begin
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©,
  refine ‚ü®(t ‚à™ ({x | is_bot x} ‚à™ {x | is_top x})) ‚à© s, _, _, _, _, _‚ü©,
  exacts [inter_subset_right _ _,
    (htc.union ((countable_is_bot Œ±).union (countable_is_top Œ±))).mono (inter_subset_left _ _),
    htd.mono (subset_inter (subset_union_left _ _) hts),
    Œª x hx hxs, ‚ü®or.inr $ or.inl hx, hxs‚ü©, Œª x hx hxs, ‚ü®or.inr $ or.inr hx, hxs‚ü©]
end
instance separable_space_univ {Œ± : Type*} [topological_space Œ±] [separable_space Œ±] :
  separable_space (univ : set Œ±) :=
(equiv.set.univ Œ±).symm.surjective.dense_range.separable_space
  (continuous_subtype_mk _ continuous_id)
lemma exists_countable_dense_bot_top (Œ± : Type*) [topological_space Œ±] [separable_space Œ±]
  [partial_order Œ±] :
  ‚àÉ s : set Œ±, s.countable ‚àß dense s ‚àß (‚àÄ x, is_bot x ‚Üí x ‚àà s) ‚àß (‚àÄ x, is_top x ‚Üí x ‚àà s) :=
by simpa using dense_univ.exists_countable_dense_subset_bot_top
namespace topological_space
universe u
variables (Œ± : Type u) [t : topological_space Œ±]
include t
class first_countable_topology : Prop :=
(nhds_generated_countable : ‚àÄa:Œ±, (ùìù a).is_countably_generated)
attribute [instance] first_countable_topology.nhds_generated_countable
namespace first_countable_topology
variable {Œ±}
lemma tendsto_subseq [first_countable_topology Œ±] {u : ‚Ñï ‚Üí Œ±} {x : Œ±}
  (hx : map_cluster_pt x at_top u) :
  ‚àÉ (œà : ‚Ñï ‚Üí ‚Ñï), (strict_mono œà) ‚àß (tendsto (u ‚àò œà) at_top (ùìù x)) :=
subseq_tendsto_of_ne_bot hx
end first_countable_topology
variables {Œ±}
instance is_countably_generated_nhds_within (x : Œ±) [is_countably_generated (ùìù x)] (s : set Œ±) :
  is_countably_generated (ùìù[s] x) :=
inf.is_countably_generated _ _
variable (Œ±)
class second_countable_topology : Prop :=
(is_open_generated_countable [] :
  ‚àÉ b : set (set Œ±), b.countable ‚àß t = topological_space.generate_from b)
variable {Œ±}
protected lemma is_topological_basis.second_countable_topology
  {b : set (set Œ±)} (hb : is_topological_basis b) (hc : b.countable) :
  second_countable_topology Œ± :=
‚ü®‚ü®b, hc, hb.eq_generate_from‚ü©‚ü©
variable (Œ±)
lemma exists_countable_basis [second_countable_topology Œ±] :
  ‚àÉb:set (set Œ±), b.countable ‚àß ‚àÖ ‚àâ b ‚àß is_topological_basis b :=
let ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := second_countable_topology.is_open_generated_countable Œ± in
let b' := (Œªs, ‚ãÇ‚ÇÄ s) '' {s:set (set Œ±) | s.finite ‚àß s ‚äÜ b ‚àß (‚ãÇ‚ÇÄ s).nonempty} in
‚ü®b',
  ((countable_set_of_finite_subset hb‚ÇÅ).mono
    (by { simp only [‚Üê and_assoc], apply inter_subset_left })).image _,
  assume ‚ü®s, ‚ü®_, _, hn‚ü©, hp‚ü©, absurd hn (not_nonempty_iff_eq_empty.2 hp),
  is_topological_basis_of_subbasis hb‚ÇÇ‚ü©
def countable_basis [second_countable_topology Œ±] : set (set Œ±) :=
(exists_countable_basis Œ±).some
lemma countable_countable_basis [second_countable_topology Œ±] : (countable_basis Œ±).countable :=
(exists_countable_basis Œ±).some_spec.1
instance encodable_countable_basis [second_countable_topology Œ±] :
  encodable (countable_basis Œ±) :=
(countable_countable_basis Œ±).to_encodable
lemma empty_nmem_countable_basis [second_countable_topology Œ±] : ‚àÖ ‚àâ countable_basis Œ± :=
(exists_countable_basis Œ±).some_spec.2.1
lemma is_basis_countable_basis [second_countable_topology Œ±] :
  is_topological_basis (countable_basis Œ±) :=
(exists_countable_basis Œ±).some_spec.2.2
lemma eq_generate_from_countable_basis [second_countable_topology Œ±] :
  ‚Äπtopological_space Œ±‚Ä∫ = generate_from (countable_basis Œ±) :=
(is_basis_countable_basis Œ±).eq_generate_from
variable {Œ±}
lemma is_open_of_mem_countable_basis [second_countable_topology Œ±] {s : set Œ±}
  (hs : s ‚àà countable_basis Œ±) : is_open s :=
(is_basis_countable_basis Œ±).is_open hs
lemma nonempty_of_mem_countable_basis [second_countable_topology Œ±] {s : set Œ±}
  (hs : s ‚àà countable_basis Œ±) : s.nonempty :=
ne_empty_iff_nonempty.1 $ ne_of_mem_of_not_mem hs $ empty_nmem_countable_basis Œ±
variable (Œ±)
lemma second_countable_topology_induced (Œ≤)
  [t : topological_space Œ≤] [second_countable_topology Œ≤] (f : Œ± ‚Üí Œ≤) :
  @second_countable_topology Œ± (t.induced f) :=
begin
  rcases second_countable_topology.is_open_generated_countable Œ≤ with ‚ü®b, hb, eq‚ü©,
  refine { is_open_generated_countable := ‚ü®preimage f '' b, hb.image _, _‚ü© },
  rw [eq, induced_generate_from_eq]
end
instance subtype.second_countable_topology (s : set Œ±) [second_countable_topology Œ±] :
  second_countable_topology s :=
second_countable_topology_induced s Œ± coe
instance {Œ≤ : Type*} [topological_space Œ≤]
  [second_countable_topology Œ±] [second_countable_topology Œ≤] : second_countable_topology (Œ± √ó Œ≤) :=
((is_basis_countable_basis Œ±).prod (is_basis_countable_basis Œ≤)).second_countable_topology $
  (countable_countable_basis Œ±).image2 (countable_countable_basis Œ≤) _
instance second_countable_topology_encodable {Œπ : Type*} {œÄ : Œπ ‚Üí Type*}
  [encodable Œπ] [t : ‚àÄa, topological_space (œÄ a)] [‚àÄa, second_countable_topology (œÄ a)] :
  second_countable_topology (‚àÄa, œÄ a) :=
begin
  have : t = (Œªa, generate_from (countable_basis (œÄ a))),
    from funext (assume a, (is_basis_countable_basis (œÄ a)).eq_generate_from),
  rw [this, pi_generate_from_eq],
  constructor, refine ‚ü®_, _, rfl‚ü©,
  have : set.countable {T : set (Œ† i, œÄ i) | ‚àÉ (I : finset Œπ) (s : Œ† i : I, set (œÄ i)),
    (‚àÄ i, s i ‚àà countable_basis (œÄ i)) ‚àß T = {f | ‚àÄ i : I, f i ‚àà s i}},
  { simp only [set_of_exists, ‚Üê exists_prop],
    refine countable_Union (Œª I, countable.bUnion _ (Œª _ _, countable_singleton _)),
    change set.countable {s : Œ† i : I, set (œÄ i) | ‚àÄ i, s i ‚àà countable_basis (œÄ i)},
    exact countable_pi (Œª i, countable_countable_basis _) },
  convert this using 1, ext1 T, split,
  { rintro ‚ü®s, I, hs, rfl‚ü©,
    refine ‚ü®I, Œª i, s i, Œª i, hs i i.2, _‚ü©,
    simp only [set.pi, set_coe.forall'], refl },
  { rintro ‚ü®I, s, hs, rfl‚ü©,
    rcases @subtype.surjective_restrict Œπ (Œª i, set (œÄ i)) _ (Œª i, i ‚àà I) s with ‚ü®s, rfl‚ü©,
    exact ‚ü®s, I, Œª i hi, hs ‚ü®i, hi‚ü©, set.ext $ Œª f, subtype.forall‚ü© }
end
instance second_countable_topology_fintype {Œπ : Type*} {œÄ : Œπ ‚Üí Type*}
  [fintype Œπ] [t : ‚àÄa, topological_space (œÄ a)] [‚àÄa, second_countable_topology (œÄ a)] :
  second_countable_topology (‚àÄa, œÄ a) :=
by { letI := fintype.to_encodable Œπ, exact topological_space.second_countable_topology_encodable }
lemma second_countable_topology_of_countable_cover {Œπ} [encodable Œπ] {U : Œπ ‚Üí set Œ±}
  [‚àÄ i, second_countable_topology (U i)] (Uo : ‚àÄ i, is_open (U i))  (hc : (‚ãÉ i, U i) = univ) :
  second_countable_topology Œ± :=
begin
  have : is_topological_basis (‚ãÉ i, image (coe : U i ‚Üí Œ±) '' (countable_basis (U i))),
    from is_topological_basis_of_cover Uo hc (Œª i, is_basis_countable_basis (U i)),
  exact this.second_countable_topology
    (countable_Union $ Œª i, (countable_countable_basis _).image _)
end
lemma is_open_Union_countable [second_countable_topology Œ±]
  {Œπ} (s : Œπ ‚Üí set Œ±) (H : ‚àÄ i, is_open (s i)) :
  ‚àÉ T : set Œπ, T.countable ‚àß (‚ãÉ i ‚àà T, s i) = ‚ãÉ i, s i :=
begin
  let B := {b ‚àà countable_basis Œ± | ‚àÉ i, b ‚äÜ s i},
  choose f hf using Œª b : B, b.2.2,
  haveI : encodable B := ((countable_countable_basis Œ±).mono (sep_subset _ _)).to_encodable,
  refine ‚ü®_, countable_range f, (Union‚ÇÇ_subset_Union _ _).antisymm (sUnion_subset _)‚ü©,
  rintro _ ‚ü®i, rfl‚ü© x xs,
  rcases (is_basis_countable_basis Œ±).exists_subset_of_mem_open xs (H _) with ‚ü®b, hb, xb, bs‚ü©,
  exact ‚ü®_, ‚ü®_, rfl‚ü©, _, ‚ü®‚ü®‚ü®_, hb, _, bs‚ü©, rfl‚ü©, rfl‚ü©, hf _ (by exact xb)‚ü©
end
lemma is_open_sUnion_countable [second_countable_topology Œ±]
  (S : set (set Œ±)) (H : ‚àÄ s ‚àà S, is_open s) :
  ‚àÉ T : set (set Œ±), T.countable ‚àß T ‚äÜ S ‚àß ‚ãÉ‚ÇÄ T = ‚ãÉ‚ÇÄ S :=
let ‚ü®T, cT, hT‚ü© := is_open_Union_countable (Œª s:S, s.1) (Œª s, H s.1 s.2) in
‚ü®subtype.val '' T, cT.image _,
  image_subset_iff.2 $ Œª ‚ü®x, xs‚ü© xt, xs,
  by rwa [sUnion_image, sUnion_eq_Union]‚ü©
lemma countable_cover_nhds [second_countable_topology Œ±] {f : Œ± ‚Üí set Œ±}
  (hf : ‚àÄ x, f x ‚àà ùìù x) : ‚àÉ s : set Œ±, s.countable ‚àß (‚ãÉ x ‚àà s, f x) = univ :=
begin
  rcases is_open_Union_countable (Œª x, interior (f x)) (Œª x, is_open_interior) with ‚ü®s, hsc, hsU‚ü©,
  suffices : (‚ãÉ x ‚àà s, interior (f x)) = univ,
    from ‚ü®s, hsc, flip eq_univ_of_subset this $ Union‚ÇÇ_mono $ Œª _ _, interior_subset‚ü©,
  simp only [hsU, eq_univ_iff_forall, mem_Union],
  exact Œª x, ‚ü®x, mem_interior_iff_mem_nhds.2 (hf x)‚ü©
end
lemma countable_cover_nhds_within [second_countable_topology Œ±] {f : Œ± ‚Üí set Œ±} {s : set Œ±}
  (hf : ‚àÄ x ‚àà s, f x ‚àà ùìù[s] x) : ‚àÉ t ‚äÜ s, t.countable ‚àß s ‚äÜ (‚ãÉ x ‚àà t, f x) :=
begin
  have : ‚àÄ x : s, coe ‚Åª¬π' (f x) ‚àà ùìù x, from Œª x, preimage_coe_mem_nhds_subtype.2 (hf x x.2),
  rcases countable_cover_nhds this with ‚ü®t, htc, htU‚ü©,
  refine ‚ü®coe '' t, subtype.coe_image_subset _ _, htc.image _, Œª x hx, _‚ü©,
  simp only [bUnion_image, eq_univ_iff_forall, ‚Üê preimage_Union, mem_preimage] at htU ‚ä¢,
  exact htU ‚ü®x, hx‚ü©
end
section sigma
variables {Œπ : Type*} {E : Œπ ‚Üí Type*} [‚àÄ i, topological_space (E i)]
omit t
lemma is_topological_basis.sigma
  {s : Œ† (i : Œπ), set (set (E i))} (hs : ‚àÄ i, is_topological_basis (s i)) :
  is_topological_basis (‚ãÉ (i : Œπ), (Œª u, ((sigma.mk i) '' u : set (Œ£ i, E i))) '' (s i)) :=
begin
  apply is_topological_basis_of_open_of_nhds,
  { assume u hu,
    obtain ‚ü®i, t, ts, rfl‚ü© : ‚àÉ (i : Œπ) (t : set (E i)), t ‚àà s i ‚àß sigma.mk i '' t = u,
      by simpa only [mem_Union, mem_image] using hu,
    exact is_open_map_sigma_mk _ ((hs i).is_open ts) },
  { rintros ‚ü®i, x‚ü© u hxu u_open,
    have hx : x ‚àà sigma.mk i ‚Åª¬π' u := hxu,
    obtain ‚ü®v, vs, xv, hv‚ü© : ‚àÉ (v : set (E i)) (H : v ‚àà s i), x ‚àà v ‚àß v ‚äÜ sigma.mk i ‚Åª¬π' u :=
      (hs i).exists_subset_of_mem_open hx (is_open_sigma_iff.1 u_open i),
    exact ‚ü®(sigma.mk i) '' v, mem_Union.2 ‚ü®i, mem_image_of_mem _ vs‚ü©, mem_image_of_mem _ xv,
      image_subset_iff.2 hv‚ü© }
end
instance [encodable Œπ] [‚àÄ i, second_countable_topology (E i)] :
  second_countable_topology (Œ£ i, E i) :=
begin
  let b := (‚ãÉ (i : Œπ), (Œª u, ((sigma.mk i) '' u : set (Œ£ i, E i))) '' (countable_basis (E i))),
  have A : is_topological_basis b := is_topological_basis.sigma (Œª i, is_basis_countable_basis  _),
  have B : b.countable := countable_Union (Œª i, countable.image (countable_countable_basis _) _),
  exact A.second_countable_topology B,
end
end sigma
section sum
omit t
variables {Œ≤ : Type*} [topological_space Œ±] [topological_space Œ≤]
lemma is_topological_basis.sum
  {s : set (set Œ±)} (hs : is_topological_basis s) {t : set (set Œ≤)} (ht : is_topological_basis t) :
  is_topological_basis (((Œª u, sum.inl '' u) '' s) ‚à™ ((Œª u, sum.inr '' u) '' t)) :=
begin
  apply is_topological_basis_of_open_of_nhds,
  { assume u hu,
    cases hu,
    { rcases hu with ‚ü®w, hw, rfl‚ü©,
      exact open_embedding_inl.is_open_map w (hs.is_open hw) },
    { rcases hu with ‚ü®w, hw, rfl‚ü©,
      exact open_embedding_inr.is_open_map w (ht.is_open hw) } },
  { rintros x u hxu u_open,
    cases x,
    { have h'x : x ‚àà sum.inl ‚Åª¬π' u := hxu,
      obtain ‚ü®v, vs, xv, vu‚ü© : ‚àÉ (v : set Œ±) (H : v ‚àà s), x ‚àà v ‚àß v ‚äÜ sum.inl ‚Åª¬π' u :=
        hs.exists_subset_of_mem_open h'x (is_open_sum_iff.1 u_open).1,
      exact ‚ü®sum.inl '' v, mem_union_left _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv,
        image_subset_iff.2 vu‚ü© },
    { have h'x : x ‚àà sum.inr ‚Åª¬π' u := hxu,
      obtain ‚ü®v, vs, xv, vu‚ü© : ‚àÉ (v : set Œ≤) (H : v ‚àà t), x ‚àà v ‚àß v ‚äÜ sum.inr ‚Åª¬π' u :=
        ht.exists_subset_of_mem_open h'x (is_open_sum_iff.1 u_open).2,
      exact ‚ü®sum.inr '' v, mem_union_right _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv,
        image_subset_iff.2 vu‚ü© } }
end
instance [second_countable_topology Œ±] [second_countable_topology Œ≤] :
  second_countable_topology (Œ± ‚äï Œ≤) :=
begin
  let b := (Œª u, sum.inl '' u) '' (countable_basis Œ±) ‚à™ (Œª u, sum.inr '' u) '' (countable_basis Œ≤),
  have A : is_topological_basis b := (is_basis_countable_basis Œ±).sum (is_basis_countable_basis Œ≤),
  have B : b.countable := (countable.image (countable_countable_basis _) _).union
    (countable.image (countable_countable_basis _) _),
  exact A.second_countable_topology B,
end
end sum
end topological_space
open topological_space
variables {Œ± Œ≤ : Type*} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤}
protected lemma inducing.second_countable_topology [second_countable_topology Œ≤]
  (hf : inducing f) : second_countable_topology Œ± :=
by { rw hf.1, exact second_countable_topology_induced Œ± Œ≤ f }
protected lemma embedding.second_countable_topology [second_countable_topology Œ≤]
  (hf : embedding f) : second_countable_topology Œ± :=
hf.1.second_countable_topology
