import category_theory.monoidal.natural_transformation
universes vâ‚ vâ‚‚ uâ‚ uâ‚‚
noncomputable theory
open category_theory
open category_theory.category
open category_theory.monoidal_category
namespace category_theory.monoidal
variables {C : Type uâ‚} [category.{vâ‚} C] [monoidal_category.{vâ‚} C]
variables {D : Type uâ‚‚} [category.{vâ‚‚} D]
@[derive category, nolint unused_arguments]
def transported (e : C â‰Œ D) := D
instance (e : C â‰Œ D) : monoidal_category (transported e) := transport e
instance (e : C â‰Œ D) : inhabited (transported e) := âŸ¨ğŸ™_ _âŸ©
section
local attribute [simp] transport_tensor_unit
section
local attribute [simp] transport_tensor_hom transport_associator
  transport_left_unitor transport_right_unitor
@[simps]
def lax_to_transported (e : C â‰Œ D) : lax_monoidal_functor C (transported e) :=
{ to_functor := e.functor,
  Îµ := ğŸ™ (e.functor.obj (ğŸ™_ C)),
  Î¼ := Î» X Y, e.functor.map (e.unit_inv.app X âŠ— e.unit_inv.app Y),
  Î¼_natural' := Î» X Y X' Y' f g,
  begin
    dsimp,
    simp only [equivalence.inv_fun_map, functor.map_comp, tensor_comp, category.assoc],
    simp only [â†e.functor.map_comp],
    congr' 1,
    rw [â†tensor_comp, iso.hom_inv_id_app, iso.hom_inv_id_app, â†tensor_comp],
    dsimp,
    rw [comp_id, comp_id],
  end,
  associativity' := Î» X Y Z,
  begin
    dsimp,
    simp only [comp_tensor_id, assoc, equivalence.inv_fun_map, functor.map_comp, id_tensor_comp,
      e.inverse.map_id],
    simp only [â†e.functor.map_comp],
    congr' 2,
    slice_lhs 3 3 { rw [â†tensor_id_comp_id_tensor], },
    slice_lhs 2 3 { rw [â†comp_tensor_id, iso.hom_inv_id_app], dsimp, rw [tensor_id] },
    simp only [id_comp],
    slice_rhs 2 3 { rw [â†id_tensor_comp, iso.hom_inv_id_app], dsimp, rw [tensor_id] },
    simp only [id_comp],
    conv_rhs { rw [â†id_tensor_comp_tensor_id _ (e.unit_inv.app X)], },
    dsimp only [functor.comp_obj],
    slice_rhs 3 4 { rw [â†id_tensor_comp, iso.hom_inv_id_app], dsimp, rw [tensor_id] },
    simp only [associator_conjugation, â†tensor_id, â†tensor_comp, iso.inv_hom_id,
      iso.inv_hom_id_assoc, category.assoc, category.id_comp, category.comp_id],
  end,
  left_unitality' := Î» X,
  begin
    dsimp,
    simp only [tensor_id, assoc, id_comp, functor.map_comp, e.inverse.map_id],
    rw equivalence.counit_app_functor,
    simp only [â†e.functor.map_comp],
    congr' 1,
    simp only [â†left_unitor_naturality, id_comp, â†tensor_comp_assoc, comp_id],
  end,
  right_unitality' := Î» X,
  begin
    dsimp,
    simp only [tensor_id, assoc, id_comp, functor.map_comp, e.inverse.map_id],
    rw equivalence.counit_app_functor,
    simp only [â†e.functor.map_comp],
    congr' 1,
    simp only [â†right_unitor_naturality, id_comp, â†tensor_comp_assoc, comp_id],
  end, }.
end
@[simps]
def to_transported (e : C â‰Œ D) : monoidal_functor C (transported e) :=
{ to_lax_monoidal_functor := lax_to_transported e,
  Îµ_is_iso := by { dsimp, apply_instance, },
  Î¼_is_iso := Î» X Y, by { dsimp, apply_instance, }, }
end
instance (e : C â‰Œ D) : is_equivalence (to_transported e).to_functor :=
by { dsimp, apply_instance, }
@[simps]
def from_transported (e : C â‰Œ D) : monoidal_functor (transported e) C :=
monoidal_inverse (to_transported e)
@[simps]
def transported_monoidal_unit_iso (e : C â‰Œ D) :
  lax_monoidal_functor.id C â‰…
    lax_to_transported e âŠ—â‹™ (from_transported e).to_lax_monoidal_functor :=
as_iso (monoidal_unit (to_transported e))
@[simps]
def transported_monoidal_counit_iso (e : C â‰Œ D) :
  (from_transported e).to_lax_monoidal_functor âŠ—â‹™ lax_to_transported e â‰…
    lax_monoidal_functor.id (transported e) :=
as_iso (monoidal_counit (to_transported e))
end category_theory.monoidal
