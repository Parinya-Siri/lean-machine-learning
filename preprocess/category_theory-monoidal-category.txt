import category_theory.products.basic
open category_theory
universes v u
open category_theory
open category_theory.category
open category_theory.iso
namespace category_theory
class monoidal_category (C : Type u) [ğ’ : category.{v} C] :=
@[simps]
def tensor_iso {C : Type u} {X Y X' Y' : C} [category.{v} C] [monoidal_category.{v} C]
  (f : X â‰… Y) (g : X' â‰… Y') :
    X âŠ— X' â‰… Y âŠ— Y' :=
{ hom := f.hom âŠ— g.hom,
  inv := f.inv âŠ— g.inv,
  hom_inv_id' := by rw [â†tensor_comp, iso.hom_inv_id, iso.hom_inv_id, â†tensor_id],
  inv_hom_id' := by rw [â†tensor_comp, iso.inv_hom_id, iso.inv_hom_id, â†tensor_id] }
infixr ` âŠ— `:70 := tensor_iso
namespace monoidal_category
section
variables {C : Type u} [category.{v} C] [monoidal_category.{v} C]
instance tensor_is_iso {W X Y Z : C} (f : W âŸ¶ X) [is_iso f] (g : Y âŸ¶ Z) [is_iso g] :
  is_iso (f âŠ— g) :=
is_iso.of_iso (as_iso f âŠ— as_iso g)
@[simp] lemma inv_tensor {W X Y Z : C} (f : W âŸ¶ X) [is_iso f] (g : Y âŸ¶ Z) [is_iso g] :
  inv (f âŠ— g) = inv f âŠ— inv g :=
by { ext, simp [â†tensor_comp], }
variables {U V W X Y Z : C}
lemma tensor_dite {P : Prop} [decidable P]
  {W X Y Z : C} (f : W âŸ¶ X) (g : P â†’ (Y âŸ¶ Z)) (g' : Â¬P â†’ (Y âŸ¶ Z)) :
  f âŠ— (if h : P then g h else g' h) = if h : P then f âŠ— g h else f âŠ— g' h :=
by { split_ifs; refl }
lemma dite_tensor {P : Prop} [decidable P]
  {W X Y Z : C} (f : W âŸ¶ X) (g : P â†’ (Y âŸ¶ Z)) (g' : Â¬P â†’ (Y âŸ¶ Z)) :
  (if h : P then g h else g' h) âŠ— f  = if h : P then g h âŠ— f else g' h âŠ— f :=
by { split_ifs; refl }
@[reassoc, simp] lemma comp_tensor_id (f : W âŸ¶ X) (g : X âŸ¶ Y) :
  (f â‰« g) âŠ— (ğŸ™ Z) = (f âŠ— (ğŸ™ Z)) â‰« (g âŠ— (ğŸ™ Z)) :=
by { rw â†tensor_comp, simp }
@[reassoc, simp] lemma id_tensor_comp (f : W âŸ¶ X) (g : X âŸ¶ Y) :
  (ğŸ™ Z) âŠ— (f â‰« g) = (ğŸ™ Z âŠ— f) â‰« (ğŸ™ Z âŠ— g) :=
by { rw â†tensor_comp, simp }
@[simp, reassoc] lemma id_tensor_comp_tensor_id (f : W âŸ¶ X) (g : Y âŸ¶ Z) :
  ((ğŸ™ Y) âŠ— f) â‰« (g âŠ— (ğŸ™ X)) = g âŠ— f :=
by { rw [â†tensor_comp], simp }
@[simp, reassoc] lemma tensor_id_comp_id_tensor (f : W âŸ¶ X) (g : Y âŸ¶ Z) :
  (g âŠ— (ğŸ™ W)) â‰« ((ğŸ™ Z) âŠ— f) = g âŠ— f :=
by { rw [â†tensor_comp], simp }
@[simp]
lemma right_unitor_conjugation {X Y : C} (f : X âŸ¶ Y) :
  (f âŠ— (ğŸ™ (ğŸ™_ C))) = (Ï_ X).hom â‰« f â‰« (Ï_ Y).inv :=
by rw [â†right_unitor_naturality_assoc, iso.hom_inv_id, category.comp_id]
@[simp]
lemma left_unitor_conjugation {X Y : C} (f : X âŸ¶ Y) :
  ((ğŸ™ (ğŸ™_ C)) âŠ— f) = (Î»_ X).hom â‰« f â‰« (Î»_ Y).inv :=
by rw [â†left_unitor_naturality_assoc, iso.hom_inv_id, category.comp_id]
@[reassoc]
lemma left_unitor_inv_naturality {X X' : C} (f : X âŸ¶ X') :
  f â‰« (Î»_ X').inv = (Î»_ X).inv â‰« (ğŸ™ _ âŠ— f) :=
by simp
@[reassoc]
lemma right_unitor_inv_naturality {X X' : C} (f : X âŸ¶ X') :
  f â‰« (Ï_ X').inv = (Ï_ X).inv â‰« (f âŠ— ğŸ™ _) :=
by simp
lemma tensor_left_iff
  {X Y : C} (f g : X âŸ¶ Y) :
  ((ğŸ™ (ğŸ™_ C)) âŠ— f = (ğŸ™ (ğŸ™_ C)) âŠ— g) â†” (f = g) :=
by simp
lemma tensor_right_iff
  {X Y : C} (f g : X âŸ¶ Y) :
  (f âŠ— (ğŸ™ (ğŸ™_ C)) = g âŠ— (ğŸ™ (ğŸ™_ C))) â†” (f = g) :=
by simp
section
@[reassoc]
lemma pentagon_inv (W X Y Z : C) :
  ((ğŸ™ W) âŠ— (Î±_ X Y Z).inv) â‰« (Î±_ W (X âŠ— Y) Z).inv â‰« ((Î±_ W X Y).inv âŠ— (ğŸ™ Z))
    = (Î±_ W X (Y âŠ— Z)).inv â‰« (Î±_ (W âŠ— X) Y Z).inv :=
category_theory.eq_of_inv_eq_inv (by simp [pentagon])
@[reassoc, simp]
lemma right_unitor_tensor (X Y : C) :
  (Ï_ (X âŠ— Y)).hom = (Î±_ X Y (ğŸ™_ C)).hom â‰« ((ğŸ™ X) âŠ— (Ï_ Y).hom) :=
by
  rw [â†tensor_right_iff, comp_tensor_id, â†cancel_mono (Î±_ X Y (ğŸ™_ C)).hom, assoc,
      associator_naturality, â†triangle_assoc, â†triangle, id_tensor_comp, pentagon_assoc,
      â†associator_naturality, tensor_id]
@[reassoc, simp]
lemma right_unitor_tensor_inv (X Y : C) :
  ((Ï_ (X âŠ— Y)).inv) = ((ğŸ™ X) âŠ— (Ï_ Y).inv) â‰« (Î±_ X Y (ğŸ™_ C)).inv :=
eq_of_inv_eq_inv (by simp)
@[simp, reassoc] lemma triangle_assoc_comp_right (X Y : C) :
  (Î±_ X (ğŸ™_ C) Y).inv â‰« ((Ï_ X).hom âŠ— ğŸ™ Y) = ((ğŸ™ X) âŠ— (Î»_ Y).hom) :=
by rw [â†triangle, iso.inv_hom_id_assoc]
@[simp, reassoc] lemma triangle_assoc_comp_left_inv (X Y : C) :
  ((ğŸ™ X) âŠ— (Î»_ Y).inv) â‰« (Î±_ X (ğŸ™_ C) Y).inv = ((Ï_ X).inv âŠ— ğŸ™ Y) :=
begin
  apply (cancel_mono ((Ï_ X).hom âŠ— ğŸ™ Y)).1,
  simp only [triangle_assoc_comp_right, assoc],
  rw [â†id_tensor_comp, iso.inv_hom_id, â†comp_tensor_id, iso.inv_hom_id]
end
end
@[reassoc]
lemma associator_inv_naturality {X Y Z X' Y' Z' : C} (f : X âŸ¶ X') (g : Y âŸ¶ Y') (h : Z âŸ¶ Z') :
  (f âŠ— (g âŠ— h)) â‰« (Î±_ X' Y' Z').inv = (Î±_ X Y Z).inv â‰« ((f âŠ— g) âŠ— h) :=
by { rw [comp_inv_eq, assoc, associator_naturality], simp }
@[reassoc, simp]
lemma associator_conjugation {X X' Y Y' Z Z' : C} (f : X âŸ¶ X') (g : Y âŸ¶ Y') (h : Z âŸ¶ Z') :
  (f âŠ— g) âŠ— h = (Î±_ X Y Z).hom â‰« (f âŠ— (g âŠ— h)) â‰« (Î±_ X' Y' Z').inv :=
by rw [associator_inv_naturality, hom_inv_id_assoc]
@[reassoc]
lemma associator_inv_conjugation {X X' Y Y' Z Z' : C} (f : X âŸ¶ X') (g : Y âŸ¶ Y') (h : Z âŸ¶ Z') :
  f âŠ— g âŠ— h = (Î±_ X Y Z).inv â‰« ((f âŠ— g) âŠ— h) â‰« (Î±_ X' Y' Z').hom :=
by rw [associator_naturality, inv_hom_id_assoc]
@[simps] def tensor : (C Ã— C) â¥¤ C :=
{ obj := Î» X, X.1 âŠ— X.2,
  map := Î» {X Y : C Ã— C} (f : X âŸ¶ Y), f.1 âŠ— f.2 }
def left_assoc_tensor : (C Ã— C Ã— C) â¥¤ C :=
{ obj := Î» X, (X.1 âŠ— X.2.1) âŠ— X.2.2,
  map := Î» {X Y : C Ã— C Ã— C} (f : X âŸ¶ Y), (f.1 âŠ— f.2.1) âŠ— f.2.2 }
@[simp] lemma left_assoc_tensor_obj (X) :
  (left_assoc_tensor C).obj X = (X.1 âŠ— X.2.1) âŠ— X.2.2 := rfl
@[simp] lemma left_assoc_tensor_map {X Y} (f : X âŸ¶ Y) :
  (left_assoc_tensor C).map f = (f.1 âŠ— f.2.1) âŠ— f.2.2 := rfl
def right_assoc_tensor : (C Ã— C Ã— C) â¥¤ C :=
{ obj := Î» X, X.1 âŠ— (X.2.1 âŠ— X.2.2),
  map := Î» {X Y : C Ã— C Ã— C} (f : X âŸ¶ Y), f.1 âŠ— (f.2.1 âŠ— f.2.2) }
@[simp] lemma right_assoc_tensor_obj (X) :
  (right_assoc_tensor C).obj X = X.1 âŠ— (X.2.1 âŠ— X.2.2) := rfl
@[simp] lemma right_assoc_tensor_map {X Y} (f : X âŸ¶ Y) :
  (right_assoc_tensor C).map f = f.1 âŠ— (f.2.1 âŠ— f.2.2) := rfl
def tensor_unit_left : C â¥¤ C :=
{ obj := Î» X, ğŸ™_ C âŠ— X,
  map := Î» {X Y : C} (f : X âŸ¶ Y), (ğŸ™ (ğŸ™_ C)) âŠ— f }
def tensor_unit_right : C â¥¤ C :=
{ obj := Î» X, X âŠ— ğŸ™_ C,
  map := Î» {X Y : C} (f : X âŸ¶ Y), f âŠ— (ğŸ™ (ğŸ™_ C)) }
@[simps]
def associator_nat_iso :
  left_assoc_tensor C â‰… right_assoc_tensor C :=
nat_iso.of_components
  (by { intros, apply monoidal_category.associator })
  (by { intros, apply monoidal_category.associator_naturality })
@[simps]
def left_unitor_nat_iso :
  tensor_unit_left C â‰… ğŸ­ C :=
nat_iso.of_components
  (by { intros, apply monoidal_category.left_unitor })
  (by { intros, apply monoidal_category.left_unitor_naturality })
@[simps]
def right_unitor_nat_iso :
  tensor_unit_right C â‰… ğŸ­ C :=
nat_iso.of_components
  (by { intros, apply monoidal_category.right_unitor })
  (by { intros, apply monoidal_category.right_unitor_naturality })
section
variables {C}
@[simps]
def tensor_left (X : C) : C â¥¤ C :=
{ obj := Î» Y, X âŠ— Y,
  map := Î» Y Y' f, (ğŸ™ X) âŠ— f, }
def tensor_left_tensor (X Y : C) : tensor_left (X âŠ— Y) â‰… tensor_left Y â‹™ tensor_left X :=
nat_iso.of_components
  (associator _ _)
  (Î» Z Z' f, by { dsimp, rw[â†tensor_id], apply associator_naturality })
@[simp] lemma tensor_left_tensor_hom_app (X Y Z : C) :
  (tensor_left_tensor X Y).hom.app Z = (associator X Y Z).hom :=
rfl
@[simp] lemma tensor_left_tensor_inv_app (X Y Z : C) :
  (tensor_left_tensor X Y).inv.app Z = (associator X Y Z).inv :=
by { simp [tensor_left_tensor], }
@[simps]
def tensor_right (X : C) : C â¥¤ C :=
{ obj := Î» Y, Y âŠ— X,
  map := Î» Y Y' f, f âŠ— (ğŸ™ X), }
variables (C)
@[simps]
def tensoring_left : C â¥¤ C â¥¤ C :=
{ obj := tensor_left,
  map := Î» X Y f,
  { app := Î» Z, f âŠ— (ğŸ™ Z) } }
instance : faithful (tensoring_left C) :=
{ map_injective' := Î» X Y f g h,
  begin
    injections with h,
    replace h := congr_fun h (ğŸ™_ C),
    simpa using h,
  end }
@[simps]
def tensoring_right : C â¥¤ C â¥¤ C :=
{ obj := tensor_right,
  map := Î» X Y f,
  { app := Î» Z, (ğŸ™ Z) âŠ— f } }
instance : faithful (tensoring_right C) :=
{ map_injective' := Î» X Y f g h,
  begin
    injections with h,
    replace h := congr_fun h (ğŸ™_ C),
    simpa using h,
  end }
variables {C}
def tensor_right_tensor (X Y : C) : tensor_right (X âŠ— Y) â‰… tensor_right X â‹™ tensor_right Y :=
nat_iso.of_components
  (Î» Z, (associator Z X Y).symm)
  (Î» Z Z' f, by { dsimp, rw[â†tensor_id], apply associator_inv_naturality })
@[simp] lemma tensor_right_tensor_hom_app (X Y Z : C) :
  (tensor_right_tensor X Y).hom.app Z = (associator Z X Y).inv :=
rfl
@[simp] lemma tensor_right_tensor_inv_app (X Y Z : C) :
  (tensor_right_tensor X Y).inv.app Z = (associator Z X Y).hom :=
by simp [tensor_right_tensor]
end
end
section
universes vâ‚ vâ‚‚ uâ‚ uâ‚‚
variables (Câ‚ : Type uâ‚) [category.{vâ‚} Câ‚] [monoidal_category.{vâ‚} Câ‚]
variables (Câ‚‚ : Type uâ‚‚) [category.{vâ‚‚} Câ‚‚] [monoidal_category.{vâ‚‚} Câ‚‚]
local attribute [simp]
associator_naturality left_unitor_naturality right_unitor_naturality pentagon
@[simps tensor_obj tensor_hom tensor_unit associator]
instance prod_monoidal : monoidal_category (Câ‚ Ã— Câ‚‚) :=
{ tensor_obj := Î» X Y, (X.1 âŠ— Y.1, X.2 âŠ— Y.2),
  tensor_hom := Î» _ _ _ _ f g, (f.1 âŠ— g.1, f.2 âŠ— g.2),
  tensor_unit := (ğŸ™_ Câ‚, ğŸ™_ Câ‚‚),
  associator := Î» X Y Z, (Î±_ X.1 Y.1 Z.1).prod (Î±_ X.2 Y.2 Z.2),
  left_unitor := Î» âŸ¨Xâ‚, Xâ‚‚âŸ©, (Î»_ Xâ‚).prod (Î»_ Xâ‚‚),
  right_unitor := Î» âŸ¨Xâ‚, Xâ‚‚âŸ©, (Ï_ Xâ‚).prod (Ï_ Xâ‚‚) }
@[simp] lemma prod_monoidal_left_unitor_hom_fst (X : Câ‚ Ã— Câ‚‚) :
  ((Î»_ X).hom : (ğŸ™_ _) âŠ— X âŸ¶ X).1 = (Î»_ X.1).hom := by { cases X, refl }
@[simp] lemma prod_monoidal_left_unitor_hom_snd (X : Câ‚ Ã— Câ‚‚) :
  ((Î»_ X).hom : (ğŸ™_ _) âŠ— X âŸ¶ X).2 = (Î»_ X.2).hom := by { cases X, refl }
@[simp] lemma prod_monoidal_left_unitor_inv_fst (X : Câ‚ Ã— Câ‚‚) :
  ((Î»_ X).inv : X âŸ¶ (ğŸ™_ _) âŠ— X).1 = (Î»_ X.1).inv := by { cases X, refl }
@[simp] lemma prod_monoidal_left_unitor_inv_snd (X : Câ‚ Ã— Câ‚‚) :
  ((Î»_ X).inv : X âŸ¶ (ğŸ™_ _) âŠ— X).2 = (Î»_ X.2).inv := by { cases X, refl }
@[simp] lemma prod_monoidal_right_unitor_hom_fst (X : Câ‚ Ã— Câ‚‚) :
  ((Ï_ X).hom : X âŠ— (ğŸ™_ _) âŸ¶ X).1 = (Ï_ X.1).hom := by { cases X, refl }
@[simp] lemma prod_monoidal_right_unitor_hom_snd (X : Câ‚ Ã— Câ‚‚) :
  ((Ï_ X).hom : X âŠ— (ğŸ™_ _) âŸ¶ X).2 = (Ï_ X.2).hom := by { cases X, refl }
@[simp] lemma prod_monoidal_right_unitor_inv_fst (X : Câ‚ Ã— Câ‚‚) :
  ((Ï_ X).inv : X âŸ¶ X âŠ— (ğŸ™_ _)).1 = (Ï_ X.1).inv := by { cases X, refl }
@[simp] lemma prod_monoidal_right_unitor_inv_snd (X : Câ‚ Ã— Câ‚‚) :
  ((Ï_ X).inv : X âŸ¶ X âŠ— (ğŸ™_ _)).2 = (Ï_ X.2).inv := by { cases X, refl }
end
end monoidal_category
end category_theory
