import analysis.calculus.cont_diff
import tactic.ring_exp
import analysis.normed_space.banach
import topology.local_homeomorph
open function set filter metric
open_locale topological_space classical nnreal
noncomputable theory
variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
variables {E : Type*} [normed_group E] [normed_space ğ•œ E]
variables {F : Type*} [normed_group F] [normed_space ğ•œ F]
variables {G : Type*} [normed_group G] [normed_space ğ•œ G]
variables {G' : Type*} [normed_group G'] [normed_space ğ•œ G']
variables {Îµ : â„}
open asymptotics filter metric set
open continuous_linear_map (id)
def approximates_linear_on (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (s : set E) (c : â„â‰¥0) : Prop :=
âˆ€ (x âˆˆ s) (y âˆˆ s), âˆ¥f x - f y - f' (x - y)âˆ¥ â‰¤ c * âˆ¥x - yâˆ¥
@[simp] lemma approximates_linear_on_empty (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (c : â„â‰¥0) :
  approximates_linear_on f f' âˆ… c :=
by simp [approximates_linear_on]
namespace approximates_linear_on
variables [cs : complete_space E] {f : E â†’ F}
section
variables {f' : E â†’L[ğ•œ] F} {s t : set E} {c c' : â„â‰¥0}
theorem mono_num (hc : c â‰¤ c') (hf : approximates_linear_on f f' s c) :
  approximates_linear_on f f' s c' :=
Î» x hx y hy, le_trans (hf x hx y hy) (mul_le_mul_of_nonneg_right hc $ norm_nonneg _)
theorem mono_set (hst : s âŠ† t) (hf : approximates_linear_on f f' t c) :
  approximates_linear_on f f' s c :=
Î» x hx y hy, hf x (hst hx) y (hst hy)
lemma approximates_linear_on_iff_lipschitz_on_with
  {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {s : set E} {c : â„â‰¥0} :
  approximates_linear_on f f' s c â†” lipschitz_on_with c (f - f') s :=
begin
  have : âˆ€ x y, f x - f y - f' (x - y) = (f - f') x - (f - f') y,
  { assume x y, simp only [map_sub, pi.sub_apply], abel },
  simp only [this, lipschitz_on_with_iff_norm_sub_le, approximates_linear_on],
end
alias approximates_linear_on_iff_lipschitz_on_with â†”
  lipschitz_on_with _root_.lipschitz_on_with.approximates_linear_on
lemma lipschitz_sub (hf : approximates_linear_on f f' s c) :
  lipschitz_with c (Î» x : s, f x - f' x) :=
begin
  refine lipschitz_with.of_dist_le_mul (Î» x y, _),
  rw [dist_eq_norm, subtype.dist_eq, dist_eq_norm],
  convert hf x x.2 y y.2 using 2,
  rw [f'.map_sub], abel
end
protected lemma lipschitz (hf : approximates_linear_on f f' s c) :
  lipschitz_with (âˆ¥f'âˆ¥â‚Š + c) (s.restrict f) :=
by simpa only [restrict_apply, add_sub_cancel'_right]
  using (f'.lipschitz.restrict s).add hf.lipschitz_sub
protected lemma continuous (hf : approximates_linear_on f f' s c) :
  continuous (s.restrict f) :=
hf.lipschitz.continuous
protected lemma continuous_on (hf : approximates_linear_on f f' s c) :
  continuous_on f s :=
continuous_on_iff_continuous_restrict.2 hf.continuous
end
section locally_onto
include cs
variables {s : set E} {c : â„â‰¥0} {f' : E â†’L[ğ•œ] F}
theorem surj_on_closed_ball_of_nonlinear_right_inverse
  (hf : approximates_linear_on f f' s c)  (f'symm : f'.nonlinear_right_inverse)
  {Îµ : â„} {b : E} (Îµ0 : 0 â‰¤ Îµ) (hÎµ : closed_ball b Îµ âŠ† s) :
  surj_on f (closed_ball b Îµ) (closed_ball (f b) (((f'symm.nnnorm : â„)â»Â¹ - c) * Îµ)) :=
begin
  assume y hy,
  cases le_or_lt (f'symm.nnnorm : â„) â»Â¹ c with hc hc,
  { refine âŸ¨b, by simp [Îµ0], _âŸ©,
    have : dist y (f b) â‰¤ 0 :=
      (mem_closed_ball.1 hy).trans (mul_nonpos_of_nonpos_of_nonneg (by linarith) Îµ0),
    simp only [dist_le_zero] at this,
    rw this },
  have If' : (0 : â„) < f'symm.nnnorm,
    by { rw [â† inv_pos], exact (nnreal.coe_nonneg _).trans_lt hc },
  have Icf' : (c : â„) * f'symm.nnnorm < 1, by rwa [inv_eq_one_div, lt_div_iff If'] at hc,
  have Jf' : (f'symm.nnnorm : â„) â‰  0 := ne_of_gt If',
  have Jcf' : (1 : â„) - c * f'symm.nnnorm â‰  0, by { apply ne_of_gt, linarith },
  set g := Î» x, x + f'symm (y - f x) with hg,
  set u := Î» (n : â„•), g ^[n] b with hu,
  have usucc : âˆ€ n, u (n + 1) = g (u n), by simp [hu, â† iterate_succ_apply' g _ b],
  have D : âˆ€ (n : â„•), dist (f (u n)) y â‰¤ (c * f'symm.nnnorm)^n * dist (f b) y
    âˆ§ dist (u n) b â‰¤ f'symm.nnnorm * (1 - (c * f'symm.nnnorm)^n) / (1 - c * f'symm.nnnorm)
      * dist (f b) y,
  { assume n,
    induction n with n IH, { simp [hu, le_refl] },
    rw usucc,
    have Ign : dist (g (u n)) b â‰¤
      f'symm.nnnorm * (1 - (c * f'symm.nnnorm)^n.succ) / (1 - c * f'symm.nnnorm) * dist (f b) y :=
    calc
      dist (g (u n)) b â‰¤ dist (g (u n)) (u n) + dist (u n) b : dist_triangle _ _ _
      ... â‰¤ f'symm.nnnorm * dist (f (u n)) y + dist (u n) b : add_le_add (A _) le_rfl
      ... â‰¤ f'symm.nnnorm * ((c * f'symm.nnnorm)^n * dist (f b) y) +
        f'symm.nnnorm * (1 - (c * f'symm.nnnorm)^n) / (1 - c * f'symm.nnnorm) * dist (f b) y :
          add_le_add (mul_le_mul_of_nonneg_left IH.1 (nnreal.coe_nonneg _)) IH.2
      ... = f'symm.nnnorm * (1 - (c * f'symm.nnnorm)^n.succ) / (1 - c * f'symm.nnnorm)
        * dist (f b) y : by { field_simp [Jcf'], ring_exp },
    refine âŸ¨_, IgnâŸ©,
    calc dist (f (g (u n))) y â‰¤ c * f'symm.nnnorm * dist (f (u n)) y :
      B _ (C n _ IH.2) (C n.succ _ Ign)
    ... â‰¤ (c * f'symm.nnnorm) * ((c * f'symm.nnnorm)^n * dist (f b) y) :
      mul_le_mul_of_nonneg_left IH.1 (mul_nonneg (nnreal.coe_nonneg _) (nnreal.coe_nonneg _))
    ... = (c * f'symm.nnnorm) ^ n.succ * dist (f b) y : by ring_exp },
variables {f' : E â‰ƒL[ğ•œ] F} {s : set E} {c : â„â‰¥0}
local notation `N` := âˆ¥(f'.symm : F â†’L[ğ•œ] E)âˆ¥â‚Š
protected lemma antilipschitz (hf : approximates_linear_on f (f' : E â†’L[ğ•œ] F) s c)
  (hc : subsingleton E âˆ¨ c < Nâ»Â¹) :
  antilipschitz_with (Nâ»Â¹ - c)â»Â¹ (s.restrict f) :=
begin
  cases hc with hE hc,
  { haveI : subsingleton s := âŸ¨Î» x y, subtype.eq $ @subsingleton.elim _ hE _ _âŸ©,
    exact antilipschitz_with.of_subsingleton },
  convert (f'.antilipschitz.restrict s).add_lipschitz_with hf.lipschitz_sub hc,
  simp [restrict]
end
protected lemma injective (hf : approximates_linear_on f (f' : E â†’L[ğ•œ] F) s c)
  (hc : subsingleton E âˆ¨ c < Nâ»Â¹) :
  injective (s.restrict f) :=
(hf.antilipschitz hc).injective
protected lemma inj_on (hf : approximates_linear_on f (f' : E â†’L[ğ•œ] F) s c)
  (hc : subsingleton E âˆ¨ c < Nâ»Â¹) :
  inj_on f s :=
inj_on_iff_injective.2 $ hf.injective hc
protected lemma surjective [complete_space E]
  (hf : approximates_linear_on f (f' : E â†’L[ğ•œ] F) univ c) (hc : subsingleton E âˆ¨ c < Nâ»Â¹) :
  surjective f :=
begin
  cases hc with hE hc,
  { haveI : subsingleton F := (equiv.subsingleton_congr f'.to_linear_equiv.to_equiv).1 hE,
    exact surjective_to_subsingleton _ },
  { apply forall_of_forall_mem_closed_ball (Î» (y : F), âˆƒ a, f a = y) (f 0) _,
    have hc' : (0 : â„) < Nâ»Â¹ - c, by { rw sub_pos, exact hc },
    let p : â„ â†’ Prop := Î» R, closed_ball (f 0) R âŠ† set.range f,
    have hp : âˆ€á¶  (r:â„) in at_top, p ((Nâ»Â¹ - c) * r),
    { have hr : âˆ€á¶  (r:â„) in at_top, 0 â‰¤ r := eventually_ge_at_top 0,
      refine hr.mono (Î» r hr, subset.trans _ (image_subset_range f (closed_ball 0 r))),
      refine hf.surj_on_closed_ball_of_nonlinear_right_inverse f'.to_nonlinear_right_inverse hr _,
      exact subset_univ _ },
    refine ((tendsto_id.const_mul_at_top hc').frequently hp.frequently).mono _,
    exact Î» R h y hy, h hy },
end
def to_local_equiv (hf : approximates_linear_on f (f' : E â†’L[ğ•œ] F) s c)
  (hc : subsingleton E âˆ¨ c < Nâ»Â¹) : local_equiv E F :=
(hf.inj_on hc).to_local_equiv _ _
lemma inverse_continuous_on (hf : approximates_linear_on f (f' : E â†’L[ğ•œ] F) s c)
  (hc : subsingleton E âˆ¨ c < Nâ»Â¹) :
  continuous_on (hf.to_local_equiv hc).symm (f '' s) :=
begin
  apply continuous_on_iff_continuous_restrict.2,
  refine ((hf.antilipschitz hc).to_right_inv_on' _ (hf.to_local_equiv hc).right_inv').continuous,
  exact (Î» x hx, (hf.to_local_equiv hc).map_target hx)
end
lemma to_inv (hf : approximates_linear_on f (f' : E â†’L[ğ•œ] F) s c)
  (hc : subsingleton E âˆ¨ c < Nâ»Â¹) :
  approximates_linear_on (hf.to_local_equiv hc).symm (f'.symm : F â†’L[ğ•œ] E) (f '' s)
    (N * (Nâ»Â¹ - c)â»Â¹ * c) :=
begin
  assume x hx y hy,
  set A := hf.to_local_equiv hc with hA,
  have Af : âˆ€ z, A z = f z := Î» z, rfl,
  rcases (mem_image _ _ _).1 hx with âŸ¨x', x's, rflâŸ©,
  rcases (mem_image _ _ _).1 hy with âŸ¨y', y's, rflâŸ©,
  rw [â† Af x', â† Af y', A.left_inv x's, A.left_inv y's],
  calc âˆ¥x' - y' - (f'.symm) (A x' - A y')âˆ¥
      â‰¤ N * âˆ¥f' (x' - y' - (f'.symm) (A x' - A y'))âˆ¥ :
    (f' : E â†’L[ğ•œ] F).bound_of_antilipschitz f'.antilipschitz _
  ... = N * âˆ¥A y' - A x' - f' (y' - x')âˆ¥ :
    begin
      congr' 2,
      simp only [continuous_linear_equiv.apply_symm_apply, continuous_linear_equiv.map_sub],
      abel,
    end
  ... â‰¤ N * (c * âˆ¥y' - x'âˆ¥) :
    mul_le_mul_of_nonneg_left (hf _ y's _ x's) (nnreal.coe_nonneg _)
  ... â‰¤ N * (c * (((Nâ»Â¹ - c)â»Â¹ : â„â‰¥0) * âˆ¥A y' - A x'âˆ¥)) :
    begin
      apply_rules [mul_le_mul_of_nonneg_left, nnreal.coe_nonneg],
      rw [â† dist_eq_norm, â† dist_eq_norm],
      exact (hf.antilipschitz hc).le_mul_dist âŸ¨y', y'sâŸ© âŸ¨x', x'sâŸ©,
    end
  ... = (N * (Nâ»Â¹ - c)â»Â¹ * c : â„â‰¥0) * âˆ¥A x' - A y'âˆ¥ :
    by { simp only [norm_sub_rev, nonneg.coe_mul], ring }
end
include cs
section
variables (f s)
def to_local_homeomorph (hf : approximates_linear_on f (f' : E â†’L[ğ•œ] F) s c)
  (hc : subsingleton E âˆ¨ c < Nâ»Â¹) (hs : is_open s) : local_homeomorph E F :=
{ to_local_equiv := hf.to_local_equiv hc,
  open_source := hs,
  open_target := hf.open_image f'.to_nonlinear_right_inverse hs
    (by rwa f'.to_linear_equiv.to_equiv.subsingleton_congr at hc),
  continuous_to_fun := hf.continuous_on,
  continuous_inv_fun := hf.inverse_continuous_on hc }
def to_homeomorph (hf : approximates_linear_on f (f' : E â†’L[ğ•œ] F) univ c)
  (hc : subsingleton E âˆ¨ c < Nâ»Â¹) :
  E â‰ƒâ‚œ F :=
begin
  refine (hf.to_local_homeomorph _ _ hc is_open_univ).to_homeomorph_of_source_eq_univ_target_eq_univ
    rfl _,
  change f '' univ = univ,
  rw [image_univ, range_iff_surjective],
  exact hf.surjective hc,
end
omit cs
lemma exists_homeomorph_extension {E : Type*} [normed_group E] [normed_space â„ E]
  {F : Type*} [normed_group F] [normed_space â„ F] [finite_dimensional â„ F]
  {s : set E} {f : E â†’ F} {f' : E â‰ƒL[â„] F} {c : â„â‰¥0}
  (hf : approximates_linear_on f (f' : E â†’L[â„] F) s c)
  (hc : subsingleton E âˆ¨ lipschitz_extension_constant F * c < (âˆ¥(f'.symm : F â†’L[â„] E)âˆ¥â‚Š)â»Â¹) :
  âˆƒ g : E â‰ƒâ‚œ F, eq_on f g s :=
begin
namespace has_strict_fderiv_at
lemma approximates_deriv_on_nhds {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E}
  (hf : has_strict_fderiv_at f f' a) {c : â„â‰¥0} (hc : subsingleton E âˆ¨ 0 < c) :
  âˆƒ s âˆˆ ğ“ a, approximates_linear_on f f' s c :=
begin
  cases hc with hE hc,
  { refine âŸ¨univ, is_open.mem_nhds is_open_univ trivial, Î» x hx y hy, _âŸ©,
    simp [@subsingleton.elim E hE x y] },
  have := hf.def hc,
  rw [nhds_prod_eq, filter.eventually, mem_prod_same_iff] at this,
  rcases this with âŸ¨s, has, hsâŸ©,
  exact âŸ¨s, has, Î» x hx y hy, hs (mk_mem_prod hx hy)âŸ©
end
lemma map_nhds_eq_of_surj [complete_space E] [complete_space F]
  {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E}
  (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) (h : f'.range = âŠ¤) :
  map f (ğ“ a) = ğ“ (f a) :=
begin
  let f'symm := f'.nonlinear_right_inverse_of_surjective h,
  set c : â„â‰¥0 := f'symm.nnnormâ»Â¹ / 2 with hc,
  have f'symm_pos : 0 < f'symm.nnnorm := f'.nonlinear_right_inverse_of_surjective_nnnorm_pos h,
  have cpos : 0 < c, by simp [hc, nnreal.half_pos, nnreal.inv_pos, f'symm_pos],
  obtain âŸ¨s, s_nhds, hsâŸ© : âˆƒ s âˆˆ ğ“ a, approximates_linear_on f f' s c :=
    hf.approximates_deriv_on_nhds (or.inr cpos),
  apply hs.map_nhds_eq f'symm s_nhds (or.inr (nnreal.half_lt_self _)),
  simp [ne_of_gt f'symm_pos],
end
variables [cs : complete_space E] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {a : E}
lemma approximates_deriv_on_open_nhds (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  âˆƒ (s : set E) (hs : a âˆˆ s âˆ§ is_open s),
    approximates_linear_on f (f' : E â†’L[ğ•œ] F) s (âˆ¥(f'.symm : F â†’L[ğ•œ] E)âˆ¥â‚Šâ»Â¹ / 2) :=
begin
  refine ((nhds_basis_opens a).exists_iff _).1 _,
  exact (Î» s t, approximates_linear_on.mono_set),
  exact (hf.approximates_deriv_on_nhds $ f'.subsingleton_or_nnnorm_symm_pos.imp id $
    Î» hf', nnreal.half_pos $ nnreal.inv_pos.2 $ hf')
end
include cs
variable (f)
def to_local_homeomorph (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) : local_homeomorph E F :=
approximates_linear_on.to_local_homeomorph f
  (classical.some hf.approximates_deriv_on_open_nhds)
  (classical.some_spec hf.approximates_deriv_on_open_nhds).snd
  (f'.subsingleton_or_nnnorm_symm_pos.imp id $ Î» hf', nnreal.half_lt_self $ ne_of_gt $
    nnreal.inv_pos.2 $ hf')
  (classical.some_spec hf.approximates_deriv_on_open_nhds).fst.2
variable {f}
@[simp] lemma to_local_homeomorph_coe (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  (hf.to_local_homeomorph f : E â†’ F) = f := rfl
lemma mem_to_local_homeomorph_source (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  a âˆˆ (hf.to_local_homeomorph f).source :=
(classical.some_spec hf.approximates_deriv_on_open_nhds).fst.1
lemma image_mem_to_local_homeomorph_target (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  f a âˆˆ (hf.to_local_homeomorph f).target :=
(hf.to_local_homeomorph f).map_source hf.mem_to_local_homeomorph_source
lemma map_nhds_eq_of_equiv (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  map f (ğ“ a) = ğ“ (f a) :=
(hf.to_local_homeomorph f).map_nhds_eq hf.mem_to_local_homeomorph_source
variables (f f' a)
def local_inverse (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) : F â†’ E :=
(hf.to_local_homeomorph f).symm
variables {f f' a}
lemma local_inverse_def (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  hf.local_inverse f _ _ = (hf.to_local_homeomorph f).symm :=
rfl
lemma eventually_left_inverse (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  âˆ€á¶  x in ğ“ a, hf.local_inverse f f' a (f x) = x :=
(hf.to_local_homeomorph f).eventually_left_inverse hf.mem_to_local_homeomorph_source
@[simp] lemma local_inverse_apply_image (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  hf.local_inverse f f' a (f a) = a :=
hf.eventually_left_inverse.self_of_nhds
lemma eventually_right_inverse (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  âˆ€á¶  y in ğ“ (f a), f (hf.local_inverse f f' a y) = y :=
(hf.to_local_homeomorph f).eventually_right_inverse' hf.mem_to_local_homeomorph_source
lemma local_inverse_continuous_at (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  continuous_at (hf.local_inverse f f' a) (f a) :=
(hf.to_local_homeomorph f).continuous_at_symm hf.image_mem_to_local_homeomorph_target
lemma local_inverse_tendsto (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  tendsto (hf.local_inverse f f' a) (ğ“ $ f a) (ğ“ a) :=
(hf.to_local_homeomorph f).tendsto_symm hf.mem_to_local_homeomorph_source
lemma local_inverse_unique (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) {g : F â†’ E}
  (hg : âˆ€á¶  x in ğ“ a, g (f x) = x) :
  âˆ€á¶  y in ğ“ (f a), g y = local_inverse f f' a hf y :=
eventually_eq_of_left_inv_of_right_inv hg hf.eventually_right_inverse $
  (hf.to_local_homeomorph f).tendsto_symm hf.mem_to_local_homeomorph_source
theorem to_local_inverse (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
  has_strict_fderiv_at (hf.local_inverse f f' a) (f'.symm : F â†’L[ğ•œ] E) (f a) :=
(hf.to_local_homeomorph f).has_strict_fderiv_at_symm hf.image_mem_to_local_homeomorph_target $
  by simpa [â† local_inverse_def] using hf
theorem to_local_left_inverse (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) {g : F â†’ E}
  (hg : âˆ€á¶  x in ğ“ a, g (f x) = x) :
  has_strict_fderiv_at g (f'.symm : F â†’L[ğ•œ] E) (f a) :=
hf.to_local_inverse.congr_of_eventually_eq $ (hf.local_inverse_unique hg).mono $ Î» _, eq.symm
end has_strict_fderiv_at
lemma open_map_of_strict_fderiv_equiv [complete_space E] {f : E â†’ F} {f' : E â†’ E â‰ƒL[ğ•œ] F}
  (hf : âˆ€ x, has_strict_fderiv_at f (f' x : E â†’L[ğ•œ] F) x) :
  is_open_map f :=
is_open_map_iff_nhds_le.2 $ Î» x, (hf x).map_nhds_eq_of_equiv.ge
namespace has_strict_deriv_at
variables [cs : complete_space ğ•œ] {f : ğ•œ â†’ ğ•œ} {f' a : ğ•œ} (hf : has_strict_deriv_at f f' a)
  (hf' : f' â‰  0)
include cs
variables (f f' a)
@[reducible] def local_inverse : ğ•œ â†’ ğ•œ :=
(hf.has_strict_fderiv_at_equiv hf').local_inverse _ _ _
variables {f f' a}
lemma map_nhds_eq : map f (ğ“ a) = ğ“ (f a) :=
(hf.has_strict_fderiv_at_equiv hf').map_nhds_eq_of_equiv
theorem to_local_inverse : has_strict_deriv_at (hf.local_inverse f f' a hf') f'â»Â¹ (f a) :=
(hf.has_strict_fderiv_at_equiv hf').to_local_inverse
theorem to_local_left_inverse {g : ğ•œ â†’ ğ•œ} (hg : âˆ€á¶  x in ğ“ a, g (f x) = x) :
  has_strict_deriv_at g f'â»Â¹ (f a) :=
(hf.has_strict_fderiv_at_equiv hf').to_local_left_inverse hg
end has_strict_deriv_at
lemma open_map_of_strict_deriv [complete_space ğ•œ] {f f' : ğ•œ â†’ ğ•œ}
  (hf : âˆ€ x, has_strict_deriv_at f (f' x) x) (h0 : âˆ€ x, f' x â‰  0) :
  is_open_map f :=
is_open_map_iff_nhds_le.2 $ Î» x, ((hf x).map_nhds_eq (h0 x)).ge
namespace cont_diff_at
variables {ğ•‚ : Type*} [is_R_or_C ğ•‚]
variables {E' : Type*} [normed_group E'] [normed_space ğ•‚ E']
variables {F' : Type*} [normed_group F'] [normed_space ğ•‚ F']
variables [complete_space E'] (f : E' â†’ F') {f' : E' â‰ƒL[ğ•‚] F'} {a : E'}
def to_local_homeomorph
  {n : with_top â„•} (hf : cont_diff_at ğ•‚ n f a) (hf' : has_fderiv_at f (f' : E' â†’L[ğ•‚] F') a)
  (hn : 1 â‰¤ n) :
  local_homeomorph E' F' :=
(hf.has_strict_fderiv_at' hf' hn).to_local_homeomorph f
variable {f}
@[simp] lemma to_local_homeomorph_coe
  {n : with_top â„•} (hf : cont_diff_at ğ•‚ n f a) (hf' : has_fderiv_at f (f' : E' â†’L[ğ•‚] F') a)
  (hn : 1 â‰¤ n) :
  (hf.to_local_homeomorph f hf' hn : E' â†’ F') = f := rfl
lemma mem_to_local_homeomorph_source
  {n : with_top â„•} (hf : cont_diff_at ğ•‚ n f a) (hf' : has_fderiv_at f (f' : E' â†’L[ğ•‚] F') a)
  (hn : 1 â‰¤ n) :
  a âˆˆ (hf.to_local_homeomorph f hf' hn).source :=
(hf.has_strict_fderiv_at' hf' hn).mem_to_local_homeomorph_source
lemma image_mem_to_local_homeomorph_target
  {n : with_top â„•} (hf : cont_diff_at ğ•‚ n f a) (hf' : has_fderiv_at f (f' : E' â†’L[ğ•‚] F') a)
  (hn : 1 â‰¤ n) :
  f a âˆˆ (hf.to_local_homeomorph f hf' hn).target :=
(hf.has_strict_fderiv_at' hf' hn).image_mem_to_local_homeomorph_target
def local_inverse
  {n : with_top â„•} (hf : cont_diff_at ğ•‚ n f a) (hf' : has_fderiv_at f (f' : E' â†’L[ğ•‚] F') a)
  (hn : 1 â‰¤ n) :
  F' â†’ E' :=
(hf.has_strict_fderiv_at' hf' hn).local_inverse f f' a
lemma local_inverse_apply_image
  {n : with_top â„•} (hf : cont_diff_at ğ•‚ n f a) (hf' : has_fderiv_at f (f' : E' â†’L[ğ•‚] F') a)
  (hn : 1 â‰¤ n) :
  hf.local_inverse hf' hn (f a) = a :=
(hf.has_strict_fderiv_at' hf' hn).local_inverse_apply_image
lemma to_local_inverse
  {n : with_top â„•} (hf : cont_diff_at ğ•‚ n f a) (hf' : has_fderiv_at f (f' : E' â†’L[ğ•‚] F') a)
  (hn : 1 â‰¤ n) :
  cont_diff_at ğ•‚ n (hf.local_inverse hf' hn) (f a) :=
begin
  have := hf.local_inverse_apply_image hf' hn,
  apply (hf.to_local_homeomorph f hf' hn).cont_diff_at_symm
    (image_mem_to_local_homeomorph_target hf hf' hn),
  { convert hf' },
  { convert hf }
end
end cont_diff_at
