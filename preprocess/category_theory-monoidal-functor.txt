import category_theory.monoidal.category
import category_theory.adjunction.basic
import category_theory.products.basic
open category_theory
universes v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÇ u‚ÇÉ
open category_theory.category
open category_theory.functor
namespace category_theory
section
open monoidal_category
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] [monoidal_category.{v‚ÇÅ} C]
          (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D] [monoidal_category.{v‚ÇÇ} D]
structure monoidal_functor
extends lax_monoidal_functor.{v‚ÇÅ v‚ÇÇ} C D :=
(Œµ_is_iso            : is_iso Œµ . tactic.apply_instance)
(Œº_is_iso            : Œ† X Y : C, is_iso (Œº X Y) . tactic.apply_instance)
attribute [instance] monoidal_functor.Œµ_is_iso monoidal_functor.Œº_is_iso
variables {C D}
noncomputable
def monoidal_functor.Œµ_iso (F : monoidal_functor.{v‚ÇÅ v‚ÇÇ} C D) :
  tensor_unit D ‚âÖ F.obj (tensor_unit C) :=
as_iso F.Œµ
noncomputable
def monoidal_functor.Œº_iso (F : monoidal_functor.{v‚ÇÅ v‚ÇÇ} C D) (X Y : C) :
  (F.obj X) ‚äó (F.obj Y) ‚âÖ F.obj (X ‚äó Y) :=
as_iso (F.Œº X Y)
end
open monoidal_category
namespace lax_monoidal_functor
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] [monoidal_category.{v‚ÇÅ} C]
@[simps] def id : lax_monoidal_functor.{v‚ÇÅ v‚ÇÅ} C C :=
{ Œµ := ùüô _,
  Œº := Œª X Y, ùüô _,
  .. ùü≠ C }
instance : inhabited (lax_monoidal_functor C C) := ‚ü®id C‚ü©
end lax_monoidal_functor
namespace monoidal_functor
section
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] [monoidal_category.{v‚ÇÅ} C]
variables {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] [monoidal_category.{v‚ÇÇ} D]
variable (F : monoidal_functor.{v‚ÇÅ v‚ÇÇ} C D)
lemma map_tensor {X Y X' Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y') :
  F.map (f ‚äó g) = inv (F.Œº X X') ‚â´ ((F.map f) ‚äó (F.map g)) ‚â´ F.Œº Y Y' :=
by simp
lemma map_left_unitor (X : C) :
  F.map (Œª_ X).hom = inv (F.Œº (ùüô_ C) X) ‚â´ (inv F.Œµ ‚äó ùüô (F.obj X)) ‚â´ (Œª_ (F.obj X)).hom :=
begin
  simp only [lax_monoidal_functor.left_unitality],
  slice_rhs 2 3 { rw ‚Üêcomp_tensor_id, simp, },
  simp,
end
lemma map_right_unitor (X : C) :
  F.map (œÅ_ X).hom = inv (F.Œº X (ùüô_ C)) ‚â´ (ùüô (F.obj X) ‚äó inv F.Œµ) ‚â´ (œÅ_ (F.obj X)).hom :=
begin
  simp only [lax_monoidal_functor.right_unitality],
  slice_rhs 2 3 { rw ‚Üêid_tensor_comp, simp, },
  simp,
end
noncomputable
def Œº_nat_iso :
  (functor.prod F.to_functor F.to_functor) ‚ãô (tensor D) ‚âÖ (tensor C) ‚ãô F.to_functor :=
nat_iso.of_components
  (by { intros, apply F.Œº_iso })
  (by { intros, apply F.to_lax_monoidal_functor.Œº_natural })
@[simp] lemma Œº_iso_hom (X Y : C) : (F.Œº_iso X Y).hom = F.Œº X Y := rfl
@[simp, reassoc] lemma Œº_inv_hom_id (X Y : C) : (F.Œº_iso X Y).inv ‚â´ F.Œº X Y = ùüô _ :=
(F.Œº_iso X Y).inv_hom_id
@[simp] lemma Œº_hom_inv_id (X Y : C) : F.Œº X Y ‚â´ (F.Œº_iso X Y).inv = ùüô _ :=
(F.Œº_iso X Y).hom_inv_id
@[simp] lemma Œµ_iso_hom : F.Œµ_iso.hom = F.Œµ := rfl
@[simp, reassoc] lemma Œµ_inv_hom_id : F.Œµ_iso.inv ‚â´ F.Œµ = ùüô _ := F.Œµ_iso.inv_hom_id
@[simp] lemma Œµ_hom_inv_id : F.Œµ ‚â´ F.Œµ_iso.inv = ùüô _ := F.Œµ_iso.hom_inv_id
end
section
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] [monoidal_category.{v‚ÇÅ} C]
@[simps] def id : monoidal_functor.{v‚ÇÅ v‚ÇÅ} C C :=
{ Œµ := ùüô _,
  Œº := Œª X Y, ùüô _,
  .. ùü≠ C }
instance : inhabited (monoidal_functor C C) := ‚ü®id C‚ü©
end
end monoidal_functor
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] [monoidal_category.{v‚ÇÅ} C]
variables {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] [monoidal_category.{v‚ÇÇ} D]
variables {E : Type u‚ÇÉ} [category.{v‚ÇÉ} E] [monoidal_category.{v‚ÇÉ} E]
namespace lax_monoidal_functor
variables (F : lax_monoidal_functor.{v‚ÇÅ v‚ÇÇ} C D) (G : lax_monoidal_functor.{v‚ÇÇ v‚ÇÉ} D E)
@[simps] def comp : lax_monoidal_functor.{v‚ÇÅ v‚ÇÉ} C E :=
{ Œµ                := G.Œµ ‚â´ (G.map F.Œµ),
  Œº                := Œª X Y, G.Œº (F.obj X) (F.obj Y) ‚â´ G.map (F.Œº X Y),
  Œº_natural'       := Œª _ _ _ _ f g,
  begin
    simp only [functor.comp_map, assoc],
    rw [‚Üêcategory.assoc, lax_monoidal_functor.Œº_natural, category.assoc, ‚Üêmap_comp, ‚Üêmap_comp,
        ‚Üêlax_monoidal_functor.Œº_natural]
  end,
  associativity'   := Œª X Y Z,
  begin
    dsimp,
    rw id_tensor_comp,
    slice_rhs 3 4 { rw [‚Üê G.to_functor.map_id, G.Œº_natural], },
    slice_rhs 1 3 { rw ‚ÜêG.associativity, },
    rw comp_tensor_id,
    slice_lhs 2 3 { rw [‚Üê G.to_functor.map_id, G.Œº_natural], },
    rw [category.assoc, category.assoc, category.assoc, category.assoc, category.assoc,
        ‚ÜêG.to_functor.map_comp, ‚ÜêG.to_functor.map_comp, ‚ÜêG.to_functor.map_comp,
        ‚ÜêG.to_functor.map_comp, F.associativity],
  end,
  left_unitality'  := Œª X,
  begin
    dsimp,
    rw [G.left_unitality, comp_tensor_id, category.assoc, category.assoc],
    apply congr_arg,
    rw [F.left_unitality, map_comp, ‚Üênat_trans.id_app, ‚Üêcategory.assoc,
        ‚Üêlax_monoidal_functor.Œº_natural, nat_trans.id_app, map_id, ‚Üêcategory.assoc, map_comp],
  end,
  right_unitality' := Œª X,
  begin
    dsimp,
    rw [G.right_unitality, id_tensor_comp, category.assoc, category.assoc],
    apply congr_arg,
    rw [F.right_unitality, map_comp, ‚Üênat_trans.id_app, ‚Üêcategory.assoc,
        ‚Üêlax_monoidal_functor.Œº_natural, nat_trans.id_app, map_id, ‚Üêcategory.assoc, map_comp],
  end,
  .. (F.to_functor) ‚ãô (G.to_functor) }.
infixr ` ‚äó‚ãô `:80 := comp
end lax_monoidal_functor
namespace lax_monoidal_functor
universes v‚ÇÄ u‚ÇÄ
variables {B : Type u‚ÇÄ} [category.{v‚ÇÄ} B] [monoidal_category.{v‚ÇÄ} B]
variables (F : lax_monoidal_functor.{v‚ÇÄ v‚ÇÅ} B C) (G : lax_monoidal_functor.{v‚ÇÇ v‚ÇÉ} D E)
local attribute [simp] Œº_natural associativity left_unitality right_unitality
@[simps]
def prod : lax_monoidal_functor (B √ó D) (C √ó E) :=
{ Œµ := (Œµ F, Œµ G),
  Œº := Œª X Y, (Œº F X.1 Y.1, Œº G X.2 Y.2),
  .. (F.to_functor).prod (G.to_functor) }
end lax_monoidal_functor
namespace monoidal_functor
variable (C)
@[simps]
def diag : monoidal_functor C (C √ó C) :=
{ Œµ := ùüô _,
  Œº := Œª X Y, ùüô _,
  .. functor.diag C }
end monoidal_functor
namespace lax_monoidal_functor
variables (F : lax_monoidal_functor.{v‚ÇÅ v‚ÇÇ} C D) (G : lax_monoidal_functor.{v‚ÇÅ v‚ÇÉ} C E)
def prod' : lax_monoidal_functor C (D √ó E) :=
(monoidal_functor.diag C).to_lax_monoidal_functor ‚äó‚ãô (F.prod G)
@[simp] lemma prod'_to_functor :
  (F.prod' G).to_functor = (F.to_functor).prod' (G.to_functor) := rfl
@[simp] lemma prod'_Œµ : (F.prod' G).Œµ = (F.Œµ, G.Œµ) :=
by { dsimp [prod'], simp }
@[simp] lemma prod'_Œº (X Y : C) : (F.prod' G).Œº X Y = (F.Œº X Y, G.Œº X Y) :=
by { dsimp [prod'], simp }
end lax_monoidal_functor
namespace monoidal_functor
variables (F : monoidal_functor.{v‚ÇÅ v‚ÇÇ} C D) (G : monoidal_functor.{v‚ÇÇ v‚ÇÉ} D E)
@[simps]
def comp : monoidal_functor.{v‚ÇÅ v‚ÇÉ} C E :=
{ Œµ_is_iso := by { dsimp, apply_instance },
  Œº_is_iso := by { dsimp, apply_instance },
  .. (F.to_lax_monoidal_functor).comp (G.to_lax_monoidal_functor) }.
@[simps]
def prod : monoidal_functor (B √ó D) (C √ó E) :=
{ Œµ_is_iso := (is_iso_prod_iff C E).mpr ‚ü®Œµ_is_iso F, Œµ_is_iso G‚ü©,
  Œº_is_iso := Œª X Y, (is_iso_prod_iff C E).mpr ‚ü®Œº_is_iso F X.1 Y.1, Œº_is_iso G X.2 Y.2‚ü©,
  .. (F.to_lax_monoidal_functor).prod (G.to_lax_monoidal_functor) }
end monoidal_functor
namespace monoidal_functor
variables (F : monoidal_functor.{v‚ÇÅ v‚ÇÇ} C D) (G : monoidal_functor.{v‚ÇÅ v‚ÇÉ} C E)
def prod' : monoidal_functor C (D √ó E) := diag C ‚äó‚ãô (F.prod G)
@[simp] lemma prod'_to_lax_monoidal_functor :
    (F.prod' G).to_lax_monoidal_functor
  = (F.to_lax_monoidal_functor).prod' (G.to_lax_monoidal_functor) := rfl
end monoidal_functor
@[simps]
noncomputable
def monoidal_adjoint (F : monoidal_functor C D) {G : D ‚•§ C} (h : F.to_functor ‚ä£ G) :
  lax_monoidal_functor D C :=
{ to_functor := G,
  Œµ := h.hom_equiv _ _ (inv F.Œµ),
  Œº := Œª X Y,
    h.hom_equiv _ (X ‚äó Y) (inv (F.Œº (G.obj X) (G.obj Y)) ‚â´ (h.counit.app X ‚äó h.counit.app Y)),
  Œº_natural' := Œª X Y X' Y' f g,
  begin
    rw [‚Üêh.hom_equiv_naturality_left, ‚Üêh.hom_equiv_naturality_right, equiv.apply_eq_iff_eq, assoc,
      is_iso.eq_inv_comp, ‚ÜêF.to_lax_monoidal_functor.Œº_natural_assoc, is_iso.hom_inv_id_assoc,
      ‚Üêtensor_comp, adjunction.counit_naturality, adjunction.counit_naturality, tensor_comp],
  end,
  associativity' := Œª X Y Z,
  begin
    rw [‚Üêh.hom_equiv_naturality_right, ‚Üêh.hom_equiv_naturality_left, ‚Üêh.hom_equiv_naturality_left,
      ‚Üêh.hom_equiv_naturality_left, equiv.apply_eq_iff_eq,
      ‚Üê cancel_epi (F.to_lax_monoidal_functor.Œº (G.obj X ‚äó G.obj Y) (G.obj Z)),
      ‚Üê cancel_epi (F.to_lax_monoidal_functor.Œº (G.obj X) (G.obj Y) ‚äó ùüô (F.obj (G.obj Z))),
      F.to_lax_monoidal_functor.associativity_assoc (G.obj X) (G.obj Y) (G.obj Z),
      ‚ÜêF.to_lax_monoidal_functor.Œº_natural_assoc, assoc, is_iso.hom_inv_id_assoc,
      ‚ÜêF.to_lax_monoidal_functor.Œº_natural_assoc, is_iso.hom_inv_id_assoc, ‚Üêtensor_comp,
      ‚Üêtensor_comp, id_comp, functor.map_id, functor.map_id, id_comp, ‚Üêtensor_comp_assoc,
      ‚Üêtensor_comp_assoc, id_comp, id_comp, h.hom_equiv_unit, h.hom_equiv_unit, functor.map_comp,
      assoc, assoc, h.counit_naturality, h.left_triangle_components_assoc, is_iso.hom_inv_id_assoc,
      functor.map_comp, assoc, h.counit_naturality, h.left_triangle_components_assoc,
      is_iso.hom_inv_id_assoc],
    exact associator_naturality (h.counit.app X) (h.counit.app Y) (h.counit.app Z),
  end,
  left_unitality' := Œª X,
  begin
    rw [‚Üêh.hom_equiv_naturality_right, ‚Üêh.hom_equiv_naturality_left, ‚Üêequiv.symm_apply_eq,
      h.hom_equiv_counit, F.map_left_unitor, h.hom_equiv_unit, assoc, assoc, assoc, F.map_tensor,
      assoc, assoc, is_iso.hom_inv_id_assoc, ‚Üêtensor_comp_assoc, functor.map_id, id_comp,
      functor.map_comp, assoc, h.counit_naturality, h.left_triangle_components_assoc,
      ‚Üêleft_unitor_naturality, ‚Üêtensor_comp_assoc, id_comp, comp_id],
  end,
  right_unitality' := Œª X,
  begin
    rw [‚Üêh.hom_equiv_naturality_right, ‚Üêh.hom_equiv_naturality_left, ‚Üêequiv.symm_apply_eq,
      h.hom_equiv_counit, F.map_right_unitor, assoc, assoc, ‚Üêright_unitor_naturality,
      ‚Üêtensor_comp_assoc, comp_id, id_comp, h.hom_equiv_unit, F.map_tensor, assoc, assoc, assoc,
      is_iso.hom_inv_id_assoc, functor.map_comp, functor.map_id, ‚Üêtensor_comp_assoc, assoc,
      h.counit_naturality, h.left_triangle_components_assoc, id_comp],
  end }.
@[simps]
noncomputable
def monoidal_inverse (F : monoidal_functor C D) [is_equivalence F.to_functor] :
  monoidal_functor D C :=
{ to_lax_monoidal_functor := monoidal_adjoint F (as_equivalence _).to_adjunction,
  Œµ_is_iso := by { dsimp [equivalence.to_adjunction], apply_instance },
  Œº_is_iso := Œª X Y, by { dsimp [equivalence.to_adjunction], apply_instance } }
end category_theory
