import ring_theory.graded_algebra.homogeneous_ideal
open graded_ring direct_sum set_like finset
open_locale big_operators
variables {Î¹ Ïƒ A : Type*}
variables [comm_ring A]
variables [linear_ordered_cancel_add_comm_monoid Î¹]
variables [set_like Ïƒ A] [add_submonoid_class Ïƒ A] {ğ’œ : Î¹ â†’ Ïƒ} [graded_ring ğ’œ]
include A
lemma ideal.is_homogeneous.is_prime_of_homogeneous_mem_or_mem
  {I : ideal A} (hI : I.is_homogeneous ğ’œ) (I_ne_top : I â‰  âŠ¤)
  (homogeneous_mem_or_mem : âˆ€ {x y : A},
    is_homogeneous ğ’œ x â†’ is_homogeneous ğ’œ y â†’ (x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I)) :
  ideal.is_prime I :=
âŸ¨I_ne_top, begin
  intros x y hxy,
  by_contradiction rid,
  obtain âŸ¨ridâ‚, ridâ‚‚âŸ© := not_or_distrib.mp rid,
  classical,
  set setâ‚ := (decompose ğ’œ x).support.filter (Î» i, proj ğ’œ i x âˆ‰ I) with setâ‚_eq,
  set setâ‚‚ := (decompose ğ’œ y).support.filter (Î» i, proj ğ’œ i y âˆ‰ I) with setâ‚‚_eq,
  have nonempty :
    âˆ€ (x : A), (x âˆ‰ I) â†’ ((decompose ğ’œ x).support.filter (Î» i, proj ğ’œ i x âˆ‰ I)).nonempty,
  { intros x hx,
    rw filter_nonempty_iff,
    contrapose! hx,
    simp_rw proj_apply at hx,
    rw â† sum_support_decompose ğ’œ x,
    exact ideal.sum_mem _ hx, },
  set maxâ‚ := setâ‚.max' (nonempty x ridâ‚) with maxâ‚_eq,
  set maxâ‚‚ := setâ‚‚.max' (nonempty y ridâ‚‚) with maxâ‚‚_eq,
  have mem_maxâ‚ : maxâ‚ âˆˆ setâ‚ := max'_mem setâ‚ (nonempty x ridâ‚),
  have mem_maxâ‚‚ : maxâ‚‚ âˆˆ setâ‚‚ := max'_mem setâ‚‚ (nonempty y ridâ‚‚),
  replace hxy : proj ğ’œ (maxâ‚ + maxâ‚‚) (x * y) âˆˆ I := hI _ hxy,
  have mem_I : proj ğ’œ maxâ‚ x * proj ğ’œ maxâ‚‚ y âˆˆ I,
  { set antidiag :=
      ((decompose ğ’œ x).support.product (decompose ğ’œ y).support)
        .filter (Î» z : Î¹ Ã— Î¹, z.1 + z.2 = maxâ‚ + maxâ‚‚) with ha,
    have mem_antidiag : (maxâ‚, maxâ‚‚) âˆˆ antidiag,
    { simp only [add_sum_erase, mem_filter, mem_product],
      exact âŸ¨âŸ¨mem_of_mem_filter _ mem_maxâ‚, mem_of_mem_filter _ mem_maxâ‚‚âŸ©, rflâŸ© },
    have eq_add_sum :=
      calc  proj ğ’œ (maxâ‚ + maxâ‚‚) (x * y)
          = âˆ‘ ij in antidiag, proj ğ’œ ij.1 x * proj ğ’œ ij.2 y
          : by simp_rw [ha, proj_apply, direct_sum.decompose_mul,
                        direct_sum.coe_mul_apply ğ’œ]
      ... = proj ğ’œ maxâ‚ x * proj ğ’œ maxâ‚‚ y + âˆ‘ ij in antidiag.erase (maxâ‚, maxâ‚‚),
                                              proj ğ’œ ij.1 x * proj ğ’œ ij.2 y
          : (add_sum_erase _ _ mem_antidiag).symm,
    rw eq_sub_of_add_eq eq_add_sum.symm,
    refine ideal.sub_mem _ hxy (ideal.sum_mem _ (Î» z H, _)),
    rcases z with âŸ¨i, jâŸ©,
    simp only [mem_erase, prod.mk.inj_iff, ne.def, mem_filter, mem_product] at H,
    rcases H with âŸ¨Hâ‚, âŸ¨Hâ‚‚, Hâ‚ƒâŸ©, Hâ‚„âŸ©,
    have max_lt : maxâ‚ < i âˆ¨ maxâ‚‚ < j,
    { rcases lt_trichotomy maxâ‚ i with h | rfl | h,
      { exact or.inl h },
      { refine false.elim (Hâ‚ âŸ¨rfl, add_left_cancel Hâ‚„âŸ©), },
      { apply or.inr,
        have := add_lt_add_right h j,
        rw Hâ‚„ at this,
        exact lt_of_add_lt_add_left this, }, },
    cases max_lt,
def homogeneous_ideal.radical (I : homogeneous_ideal ğ’œ) : homogeneous_ideal ğ’œ :=
âŸ¨I.to_ideal.radical, I.is_homogeneous.radicalâŸ©
@[simp]
lemma homogeneous_ideal.coe_radical (I : homogeneous_ideal ğ’œ) :
  I.radical.to_ideal = I.to_ideal.radical := rfl
