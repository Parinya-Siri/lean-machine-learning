import measure_theory.covering.differentiation
import measure_theory.covering.vitali_family
import measure_theory.integral.lebesgue
import measure_theory.measure.regular
import set_theory.ordinal.arithmetic
import topology.metric_space.basic
noncomputable theory
universe u
open metric set filter fin measure_theory topological_space
open_locale topological_space classical big_operators ennreal measure_theory nnreal
structure besicovitch.satellite_config (Î± : Type*) [metric_space Î±] (N : â„•) (Ï„ : â„) :=
(c : fin N.succ â†’ Î±)
(r : fin N.succ â†’ â„)
(rpos : âˆ€ i, 0 < r i)
(h : âˆ€ i j, i â‰  j â†’ (r i â‰¤ dist (c i) (c j) âˆ§ r j â‰¤ Ï„ * r i) âˆ¨
                    (r j â‰¤ dist (c j) (c i) âˆ§ r i â‰¤ Ï„ * r j))
(hlast : âˆ€ i < last N, r i â‰¤ dist (c i) (c (last N)) âˆ§ r (last N) â‰¤ Ï„ * r i)
(inter : âˆ€ i < last N, dist (c i) (c (last N)) â‰¤ r i + r (last N))
class has_besicovitch_covering (Î± : Type*) [metric_space Î±] : Prop :=
(no_satellite_config [] : âˆƒ (N : â„•) (Ï„ : â„), 1 < Ï„ âˆ§ is_empty (besicovitch.satellite_config Î± N Ï„))
instance {Î± : Type*} {Ï„ : â„} [inhabited Î±] [metric_space Î±] :
  inhabited (besicovitch.satellite_config Î± 0 Ï„) :=
âŸ¨{ c := default,
  r := Î» i, 1,
  rpos := Î» i, zero_lt_one,
  h := Î» i j hij, (hij (subsingleton.elim i j)).elim,
  hlast := Î» i hi, by { rw subsingleton.elim i (last 0) at hi, exact (lt_irrefl _ hi).elim },
  inter := Î» i hi, by { rw subsingleton.elim i (last 0) at hi, exact (lt_irrefl _ hi).elim } }âŸ©
namespace besicovitch
namespace satellite_config
variables {Î± : Type*} [metric_space Î±] {N : â„•} {Ï„ : â„} (a : satellite_config Î± N Ï„)
lemma inter' (i : fin N.succ) : dist (a.c i) (a.c (last N)) â‰¤ a.r i + a.r (last N) :=
begin
  rcases lt_or_le i (last N) with H|H,
  { exact a.inter i H },
  { have I : i = last N := top_le_iff.1 H,
    have := (a.rpos (last N)).le,
    simp only [I, add_nonneg this this, dist_self] }
end
lemma hlast' (i : fin N.succ) (h : 1 â‰¤ Ï„) : a.r (last N) â‰¤ Ï„ * a.r i :=
begin
  rcases lt_or_le i (last N) with H|H,
  { exact (a.hlast i H).2 },
  { have : i = last N := top_le_iff.1 H,
    rw this,
    exact le_mul_of_one_le_left (a.rpos _).le h }
end
end satellite_config
structure ball_package (Î² : Type*) (Î± : Type*) :=
(c : Î² â†’ Î±)
(r : Î² â†’ â„)
(rpos : âˆ€ b, 0 < r b)
(r_bound : â„)
(r_le : âˆ€ b, r b â‰¤ r_bound)
def unit_ball_package (Î± : Type*) : ball_package Î± Î± :=
{ c := id,
  r := Î» _, 1,
  rpos := Î» _, zero_lt_one,
  r_bound := 1,
  r_le := Î» _, le_rfl }
instance (Î± : Type*) : inhabited (ball_package Î± Î±) :=
âŸ¨unit_ball_package Î±âŸ©
structure tau_package (Î² : Type*) (Î± : Type*) extends ball_package Î² Î± :=
(Ï„ : â„)
(one_lt_tau : 1 < Ï„)
instance (Î± : Type*) : inhabited (tau_package Î± Î±) :=
âŸ¨{ Ï„ := 2,
  one_lt_tau := one_lt_two,
  .. unit_ball_package Î± }âŸ©
variables {Î± : Type*} [metric_space Î±] {Î² : Type u}
namespace tau_package
variables [nonempty Î²] (p : tau_package Î² Î±)
include p
noncomputable def index : ordinal.{u} â†’ Î²
| i :=
def Union_up_to (i : ordinal.{u}) : set Î± :=
â‹ƒ (j : {j // j < i}), ball (p.c (p.index j)) (p.r (p.index j))
lemma monotone_Union_up_to : monotone p.Union_up_to :=
begin
  assume i j hij,
  simp only [Union_up_to],
  exact Union_mono' (Î» r, âŸ¨âŸ¨r, r.2.trans_le hijâŸ©, subset.rflâŸ©),
end
def R (i : ordinal.{u}) : â„ :=
supr (Î» b : {b : Î² // p.c b âˆ‰ p.Union_up_to i}, p.r b)
noncomputable def color : ordinal.{u} â†’ â„•
| i := let A : set â„• := â‹ƒ (j : {j // j < i})
          (hj : (closed_ball (p.c (p.index j)) (p.r (p.index j))
            âˆ© closed_ball (p.c (p.index i)) (p.r (p.index i))).nonempty), {color j} in
       Inf (univ \ A)
using_well_founded {dec_tac := `[exact j.2]}
def last_step : ordinal.{u} :=
Inf {i | Â¬ âˆƒ (b : Î²), p.c b âˆ‰ p.Union_up_to i âˆ§ p.R i â‰¤ p.Ï„ * p.r b}
lemma last_step_nonempty :
  {i | Â¬ âˆƒ (b : Î²), p.c b âˆ‰ p.Union_up_to i âˆ§ p.R i â‰¤ p.Ï„ * p.r b}.nonempty :=
begin
  by_contra,
  suffices H : function.injective p.index, from not_injective_of_ordinal p.index H,
  assume x y hxy,
  wlog x_le_y : x â‰¤ y := le_total x y using [x y, y x],
  rcases eq_or_lt_of_le x_le_y with rfl|H, { refl },
  simp only [nonempty_def, not_exists, exists_prop, not_and, not_lt, not_le, mem_set_of_eq,
    not_forall] at h,
  specialize h y,
  have A : p.c (p.index y) âˆ‰ p.Union_up_to y,
  { have : p.index y = classical.epsilon (Î» b : Î², p.c b âˆ‰ p.Union_up_to y âˆ§ p.R y â‰¤ p.Ï„ * p.r b),
      by { rw [tau_package.index], refl },
    rw this,
    exact (classical.epsilon_spec h).1 },
  simp only [Union_up_to, not_exists, exists_prop, mem_Union, mem_closed_ball, not_and, not_le,
              subtype.exists, subtype.coe_mk] at A,
  specialize A x H,
  simp [hxy] at A,
  exact (lt_irrefl _ ((p.rpos (p.index y)).trans_le A)).elim
end
lemma mem_Union_up_to_last_step (x : Î²) : p.c x âˆˆ p.Union_up_to p.last_step :=
begin
  have A : âˆ€ (z : Î²), p.c z âˆˆ p.Union_up_to p.last_step âˆ¨ p.Ï„ * p.r z < p.R p.last_step,
  { have : p.last_step âˆˆ {i | Â¬ âˆƒ (b : Î²), p.c b âˆ‰ p.Union_up_to i âˆ§ p.R i â‰¤ p.Ï„ * p.r b} :=
      Inf_mem p.last_step_nonempty,
    simpa only [not_exists, mem_set_of_eq, not_and_distrib, not_le, not_not_mem] },
  by_contra,
  rcases A x with H|H, { exact h H },
  have Rpos : 0 < p.R p.last_step,
  { apply lt_trans (mul_pos (_root_.zero_lt_one.trans p.one_lt_tau) (p.rpos _)) H },
  have B : p.Ï„â»Â¹ * p.R p.last_step < p.R p.last_step,
  { conv_rhs { rw â† one_mul (p.R p.last_step) },
    exact mul_lt_mul (inv_lt_one p.one_lt_tau) le_rfl Rpos zero_le_one },
  obtain âŸ¨y, hy1, hy2âŸ© : âˆƒ (y : Î²),
    p.c y âˆ‰ p.Union_up_to p.last_step âˆ§ (p.Ï„)â»Â¹ * p.R p.last_step < p.r y,
  { simpa only [exists_prop, mem_range, exists_exists_and_eq_and, subtype.exists, subtype.coe_mk]
      using exists_lt_of_lt_cSup _ B,
    rw [â† image_univ, nonempty_image_iff],
    exact âŸ¨âŸ¨_, hâŸ©, mem_univ _âŸ© },
  rcases A y with Hy|Hy,
  { exact hy1 Hy },
  { rw â† div_eq_inv_mul at hy2,
    have := (div_le_iff' (_root_.zero_lt_one.trans p.one_lt_tau)).1 hy2.le,
    exact lt_irrefl _ (Hy.trans_le this) }
end
lemma color_lt {i : ordinal.{u}} (hi : i < p.last_step)
  {N : â„•} (hN : is_empty (satellite_config Î± N p.Ï„)) :
  p.color i < N :=
begin
  induction i using ordinal.induction with i IH,
  let A : set â„• := â‹ƒ (j : {j // j < i})
         (hj : (closed_ball (p.c (p.index j)) (p.r (p.index j))
            âˆ© closed_ball (p.c (p.index i)) (p.r (p.index i))).nonempty), {p.color j},
  have color_i : p.color i = Inf (univ \ A), by rw [color],
  rw color_i,
  have N_mem : N âˆˆ univ \ A,
  { simp only [not_exists, true_and, exists_prop, mem_Union, mem_singleton_iff, mem_closed_ball,
      not_and, mem_univ, mem_diff, subtype.exists, subtype.coe_mk],
    assume j ji hj,
    exact (IH j ji (ji.trans hi)).ne' },
  suffices : Inf (univ \ A) â‰  N,
  { rcases (cInf_le (order_bot.bdd_below (univ \ A)) N_mem).lt_or_eq with H|H,
    { exact H },
    { exact (this H).elim } },
  assume Inf_eq_N,
  have : âˆ€ k, k < N â†’ âˆƒ j, j < i
    âˆ§ (closed_ball (p.c (p.index j)) (p.r (p.index j))
        âˆ© closed_ball (p.c (p.index i)) (p.r (p.index i))).nonempty
    âˆ§ k = p.color j,
  { assume k hk,
    rw â† Inf_eq_N at hk,
    have : k âˆˆ A,
      by simpa only [true_and, mem_univ, not_not, mem_diff] using nat.not_mem_of_lt_Inf hk,
    simp at this,
    simpa only [exists_prop, mem_Union, mem_singleton_iff, mem_closed_ball, subtype.exists,
      subtype.coe_mk] },
  choose! g hg using this,
theorem exist_disjoint_covering_families {N : â„•} {Ï„ : â„}
  (hÏ„ : 1 < Ï„) (hN : is_empty (satellite_config Î± N Ï„)) (q : ball_package Î² Î±) :
  âˆƒ s : fin N â†’ set Î²,
    (âˆ€ (i : fin N), (s i).pairwise_disjoint (Î» j, closed_ball (q.c j) (q.r j))) âˆ§
      (range q.c âŠ† â‹ƒ (i : fin N), â‹ƒ (j âˆˆ s i), ball (q.c j) (q.r j)) :=
begin
open_locale nnreal
variables [second_countable_topology Î±] [measurable_space Î±] [opens_measurable_space Î±]
lemma exist_finset_disjoint_balls_large_measure
  (Î¼ : measure Î±) [is_finite_measure Î¼] {N : â„•} {Ï„ : â„}
  (hÏ„ : 1 < Ï„) (hN : is_empty (satellite_config Î± N Ï„)) (s : set Î±)
  (r : Î± â†’ â„) (rpos : âˆ€ x âˆˆ s, 0 < r x) (rle : âˆ€ x âˆˆ s, r x â‰¤ 1) :
  âˆƒ (t : finset Î±), (â†‘t âŠ† s) âˆ§ Î¼ (s \ (â‹ƒ (x âˆˆ t), closed_ball x (r x))) â‰¤ N/(N+1) * Î¼ s
    âˆ§ (t : set Î±).pairwise_disjoint (Î» x, closed_ball x (r x)) :=
begin
  let a : ball_package s Î± :=
  { c := Î» x, x,
    r := Î» x, r x,
    rpos := Î» x, rpos x x.2,
    r_bound := 1,
    r_le := Î» x, rle x x.2 },
  rcases exist_disjoint_covering_families hÏ„ hN a with âŸ¨u, hu, hu'âŸ©,
  have u_count : âˆ€ i, (u i).countable,
  { assume i,
    refine (hu i).countable_of_nonempty_interior (Î» j hj, _),
    have : (ball (j : Î±) (r j)).nonempty := nonempty_ball.2 (a.rpos _),
    exact this.mono ball_subset_interior_closed_ball },
  let v : fin N â†’ set Î± := Î» i, â‹ƒ (x : s) (hx : x âˆˆ u i), closed_ball x (r x),
  have : âˆ€ i, measurable_set (v i) :=
    Î» i, measurable_set.bUnion (u_count i) (Î» b hb, measurable_set_closed_ball),
  have A : s = â‹ƒ (i : fin N), s âˆ© v i,
  { refine subset.antisymm _ (Union_subset (Î» i, inter_subset_left _ _)),
    assume x hx,
    obtain âŸ¨i, y, hxy, h'âŸ© : âˆƒ (i : fin N) (i_1 : â†¥s) (i : i_1 âˆˆ u i), x âˆˆ ball â†‘i_1 (r â†‘i_1),
    { have : x âˆˆ range a.c, by simpa only [subtype.range_coe_subtype, set_of_mem_eq],
      simpa only [mem_Union] using hu' this },
    refine mem_Union.2 âŸ¨i, âŸ¨hx, _âŸ©âŸ©,
    simp only [v, exists_prop, mem_Union, set_coe.exists, exists_and_distrib_right, subtype.coe_mk],
    exact âŸ¨y, âŸ¨y.2, by simpa only [subtype.coe_eta]âŸ©, ball_subset_closed_ball h'âŸ© },
  have S : âˆ‘ (i : fin N), Î¼ s / N â‰¤ âˆ‘ i, Î¼ (s âˆ© v i) := calc
    âˆ‘ (i : fin N), Î¼ s / N = Î¼ s : begin
      simp only [finset.card_fin, finset.sum_const, nsmul_eq_mul],
      rw ennreal.mul_div_cancel',
      { simp only [Npos, ne.def, nat.cast_eq_zero, not_false_iff] },
      { exact ennreal.coe_nat_ne_top }
    end
    ... â‰¤ âˆ‘ i, Î¼ (s âˆ© v i) : by { conv_lhs { rw A }, apply measure_Union_fintype_le },
theorem exists_disjoint_closed_ball_covering_ae_of_finite_measure_aux
  (Î¼ : measure Î±) [is_finite_measure Î¼]
  (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).nonempty) :
  âˆƒ (t : set (Î± Ã— â„)), t.countable
    âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.2 âˆˆ f p.1)
    âˆ§ Î¼ (s \ (â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), closed_ball p.1 p.2)) = 0
    âˆ§ t.pairwise_disjoint (Î» p, closed_ball p.1 p.2) :=
begin
  rcases has_besicovitch_covering.no_satellite_config Î± with âŸ¨N, Ï„, hÏ„, hNâŸ©,
  let P : finset (Î± Ã— â„) â†’ Prop := Î» t,
    (t : set (Î± Ã— â„)).pairwise_disjoint (Î» p, closed_ball p.1 p.2) âˆ§
    (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.2 âˆˆ f p.1),
  have : âˆ€ (t : finset (Î± Ã— â„)), P t â†’ âˆƒ (u : finset (Î± Ã— â„)), t âŠ† u âˆ§ P u âˆ§
    Î¼ (s \ (â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ u), closed_ball p.1 p.2)) â‰¤
      N/(N+1) * Î¼ (s \ (â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), closed_ball p.1 p.2)),
  { assume t ht,
    set B := â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), closed_ball p.1 p.2 with hB,
    have B_closed : is_closed B :=
      is_closed_bUnion (finset.finite_to_set _) (Î» i hi, is_closed_ball),
    set s' := s \ B with hs',
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, disjoint B (closed_ball x r),
    { assume x hx,
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1,
      rcases eq_empty_or_nonempty B with hB|hB,
      { have : (0 : â„) < 1 := zero_lt_one,
        rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©,
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ© },
      { let R := inf_dist x B,
        have : 0 < min R 1 :=
          lt_min ((B_closed.not_mem_iff_inf_dist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one,
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©,
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, _âŸ©,
        rw disjoint.comm,
        exact disjoint_closed_ball_of_lt_inf_dist (h'r.2.trans_le (min_le_left _ _)) } },
    choose! r hr using this,
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© : âˆƒ (v : finset Î±), â†‘v âŠ† s'
      âˆ§ Î¼ (s' \ â‹ƒ (x âˆˆ v), closed_ball x (r x)) â‰¤ N/(N+1) * Î¼ s'
      âˆ§ (v : set Î±).pairwise_disjoint (Î» (x : Î±), closed_ball x (r x)),
    { have rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := Î» x hx, (hr x hx).1.2,
      exact exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (Î» x hx, (rI x hx).1)
        (Î» x hx, (rI x hx).2.le) },
    refine âŸ¨t âˆª (finset.image (Î» x, (x, r x)) v), finset.subset_union_left _ _, âŸ¨_, _, _âŸ©, _âŸ©,
    { simp only [finset.coe_union, pairwise_disjoint_union, ht.1, true_and, finset.coe_image],
      split,
      { assume p hp q hq hpq,
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©,
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©,
        refine hv p'v q'v (Î» hp'q', _),
        rw [hp'q'] at hpq,
        exact hpq rfl },
      { assume p hp q hq hpq,
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©,
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2,
        rw [hB, â† finset.set_bUnion_coe],
        exact subset_bUnion_of_mem hp } },
    { assume p hp,
      rcases finset.mem_union.1 hp with h'p|h'p,
      { exact ht.2.1 p h'p },
      { rcases finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©,
        exact ((mem_diff _).1 (vs' (finset.mem_coe.2 p'v))).1 } },
    { assume p hp,
      rcases finset.mem_union.1 hp with h'p|h'p,
      { exact ht.2.2 p h'p },
      { rcases finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©,
        exact (hr p' (vs' p'v)).1.1 } },
    { convert hÎ¼v using 2,
      rw [finset.set_bUnion_union, â† diff_diff, finset.set_bUnion_finset_image] } },
  choose! F hF using this,
  let u := Î» n, F^[n] âˆ…,
  have u_succ : âˆ€ (n : â„•), u n.succ = F (u n) :=
    Î» n, by simp only [u, function.comp_app, function.iterate_succ'],
  have Pu : âˆ€ n, P (u n),
  { assume n,
    induction n with n IH,
    { simp only [u, P, prod.forall, id.def, function.iterate_zero],
      simp only [finset.not_mem_empty, forall_false_left, finset.coe_empty, forall_2_true_iff,
        and_self, pairwise_disjoint_empty] },
    { rw u_succ,
      exact (hF (u n) IH).2.1 } },
  refine âŸ¨â‹ƒ n, u n, countable_Union (Î» n, (u n).countable_to_set), _, _, _, _âŸ©,
  { assume p hp,
    rcases mem_Union.1 hp with âŸ¨n, hnâŸ©,
    exact (Pu n).2.1 p (finset.mem_coe.1 hn) },
  { assume p hp,
    rcases mem_Union.1 hp with âŸ¨n, hnâŸ©,
    exact (Pu n).2.2 p (finset.mem_coe.1 hn) },
  { have A : âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ â‹ƒ (n : â„•), (u n : set (Î± Ã— â„))),
                     closed_ball p.fst p.snd)
                â‰¤ Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ u n), closed_ball p.fst p.snd),
    { assume n,
      apply measure_mono,
      apply diff_subset_diff (subset.refl _),
      exact bUnion_subset_bUnion_left (subset_Union (Î» i, (u i : set (Î± Ã— â„))) n) },
    have B : âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ u n), closed_ball p.fst p.snd)
      â‰¤ (N/(N+1))^n * Î¼ s,
    { assume n,
      induction n with n IH,
      { simp only [le_refl, diff_empty, one_mul, Union_false, Union_empty, pow_zero] },
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ u n.succ), closed_ball p.fst p.snd)
            â‰¤ (N/(N+1)) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ u n), closed_ball p.fst p.snd) :
              by { rw u_succ, exact (hF (u n) (Pu n)).2.2 }
        ... â‰¤ (N/(N+1))^n.succ * Î¼ s :
          by { rw [pow_succ, mul_assoc], exact ennreal.mul_le_mul le_rfl IH } },
    have C : tendsto (Î» (n : â„•), ((N : â„â‰¥0âˆ)/(N+1))^n * Î¼ s) at_top (ğ“ (0 * Î¼ s)),
    { apply ennreal.tendsto.mul_const _ (or.inr (measure_lt_top Î¼ s).ne),
      apply ennreal.tendsto_pow_at_top_nhds_0_of_lt_1,
      rw [ennreal.div_lt_iff, one_mul],
      { conv_lhs {rw â† add_zero (N : â„â‰¥0âˆ) },
        exact ennreal.add_lt_add_left (ennreal.nat_ne_top N) ennreal.zero_lt_one },
      { simp only [true_or, add_eq_zero_iff, ne.def, not_false_iff, one_ne_zero, and_false] },
      { simp only [ennreal.nat_ne_top, ne.def, not_false_iff, or_true] } },
    rw zero_mul at C,
    apply le_bot_iff.1,
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C (Î» n, (A n).trans (B n)) },
  { refine (pairwise_disjoint_Union _).2 (Î» n, (Pu n).1),
    apply (monotone_nat_of_le_succ (Î» n, _)).directed_le,
    rw u_succ,
    exact (hF (u n) (Pu n)).1 }
end
theorem exists_disjoint_closed_ball_covering_ae_aux (Î¼ : measure Î±) [sigma_finite Î¼]
  (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).nonempty) :
  âˆƒ (t : set (Î± Ã— â„)), t.countable
    âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ (âˆ€ (p : Î± Ã— â„), p âˆˆ t â†’ p.2 âˆˆ f p.1)
    âˆ§ Î¼ (s \ (â‹ƒ (p : Î± Ã— â„) (hp : p âˆˆ t), closed_ball p.1 p.2)) = 0
    âˆ§ t.pairwise_disjoint (Î» p, closed_ball p.1 p.2) :=
begin
  unfreezingI { rcases exists_absolutely_continuous_is_finite_measure Î¼ with âŸ¨Î½, hÎ½, hÎ¼Î½âŸ© },
  rcases exists_disjoint_closed_ball_covering_ae_of_finite_measure_aux Î½ f s hf
    with âŸ¨t, t_count, ts, tr, tÎ½, tdisjâŸ©,
  exact âŸ¨t, t_count, ts, tr, hÎ¼Î½ tÎ½, tdisjâŸ©,
end
theorem exists_disjoint_closed_ball_covering_ae (Î¼ : measure Î±) [sigma_finite Î¼]
  (f : Î± â†’ set â„) (s : set Î±) (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).nonempty)
  (R : Î± â†’ â„) (hR : âˆ€ x âˆˆ s, 0 < R x):
  âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ x âˆˆ t, r x âˆˆ f x âˆ© Ioo 0 (R x))
    âˆ§ Î¼ (s \ (â‹ƒ (x âˆˆ t), closed_ball x (r x))) = 0
    âˆ§ t.pairwise_disjoint (Î» x, closed_ball x (r x)) :=
begin
  let g := Î» x, f x âˆ© Ioo 0 (R x),
  have hg : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (g x âˆ© Ioo 0 Î´).nonempty,
  { assume x hx Î´ Î´pos,
    rcases hf x hx (min Î´ (R x)) (lt_min Î´pos (hR x hx)) with âŸ¨r, hrâŸ©,
    exact âŸ¨r, âŸ¨âŸ¨hr.1, hr.2.1, hr.2.2.trans_le (min_le_right _ _)âŸ©,
      âŸ¨hr.2.1, hr.2.2.trans_le (min_le_left _ _)âŸ©âŸ©âŸ© },
  rcases exists_disjoint_closed_ball_covering_ae_aux Î¼ g s hg
    with âŸ¨v, v_count, vs, vg, Î¼v, v_disjâŸ©,
  let t := prod.fst '' v,
  have : âˆ€ x âˆˆ t, âˆƒ (r : â„), (x, r) âˆˆ v,
  { assume x hx,
    rcases (mem_image _ _ _).1 hx with âŸ¨âŸ¨p, qâŸ©, hp, rflâŸ©,
    exact âŸ¨q, hpâŸ© },
  choose! r hr using this,
  have im_t : (Î» x, (x, r x)) '' t = v,
  { have I : âˆ€ (p : Î± Ã— â„), p âˆˆ v â†’ 0 â‰¤ p.2 :=
      Î» p hp, (vg p hp).2.1.le,
    apply subset.antisymm,
    { simp only [image_subset_iff],
      rintros âŸ¨x, pâŸ© hxp,
      simp only [mem_preimage],
      exact hr _ (mem_image_of_mem _ hxp) },
    { rintros âŸ¨x, pâŸ© hxp,
      have hxrx : (x, r x) âˆˆ v := hr _ (mem_image_of_mem _ hxp),
      have : p = r x,
      { by_contra,
        have A : (x, p) â‰  (x, r x),
          by simpa only [true_and, prod.mk.inj_iff, eq_self_iff_true, ne.def] using h,
        have H := v_disj hxp hxrx A,
        contrapose H,
        rw not_disjoint_iff_nonempty_inter,
        refine âŸ¨x, by simp [I _ hxp, I _ hxrx]âŸ© },
      rw this,
      apply mem_image_of_mem,
      exact mem_image_of_mem _ hxp } },
  refine âŸ¨t, r, v_count.image _, _, _, _, _âŸ©,
  { assume x hx,
    rcases (mem_image _ _ _).1 hx with âŸ¨âŸ¨p, qâŸ©, hp, rflâŸ©,
    exact vs _ hp },
  { assume x hx,
    rcases (mem_image _ _ _).1 hx with âŸ¨âŸ¨p, qâŸ©, hp, rflâŸ©,
    exact vg _ (hr _ hx) },
  { have : (â‹ƒ (x : Î±) (H : x âˆˆ t), closed_ball x (r x)) =
      (â‹ƒ (p : Î± Ã— â„) (H : p âˆˆ (Î» x, (x, r x)) '' t), closed_ball p.1 p.2),
        by conv_rhs { rw bUnion_image },
    rw [this, im_t],
    exact Î¼v },
  { have A : inj_on (Î» x : Î±, (x, r x)) t,
      by simp only [inj_on, prod.mk.inj_iff, implies_true_iff, eq_self_iff_true] {contextual := tt},
    rwa [â† im_t, A.pairwise_disjoint_image] at v_disj }
end
theorem exists_closed_ball_covering_tsum_measure_le
  (Î¼ : measure Î±) [sigma_finite Î¼] [measure.outer_regular Î¼]
  {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) (f : Î± â†’ set â„) (s : set Î±)
  (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).nonempty) :
  âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable âˆ§ t âŠ† s âˆ§ (âˆ€ x âˆˆ t, r x âˆˆ f x)
    âˆ§ s âŠ† (â‹ƒ (x âˆˆ t), closed_ball x (r x))
    âˆ§ âˆ‘' (x : t), Î¼ (closed_ball x (r x)) â‰¤ Î¼ s + Îµ  :=
begin
  obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ U âŠ‡ s, is_open U âˆ§ Î¼ U â‰¤ Î¼ s + Îµ / 2 :=
    set.exists_is_open_le_add _ _ (by simpa only [or_false, ne.def, ennreal.div_zero_iff,
      ennreal.one_ne_top, ennreal.bit0_eq_top_iff] using hÎµ),
  have : âˆ€ x âˆˆ s, âˆƒ R > 0, ball x R âŠ† u :=
    Î» x hx, metric.mem_nhds_iff.1 (u_open.mem_nhds (su hx)),
  choose! R hR using this,
  obtain âŸ¨t0, r0, t0_count, t0s, hr0, Î¼t0, t0_disjâŸ© :
    âˆƒ (t0 : set Î±) (r0 : Î± â†’ â„), t0.countable âˆ§ t0 âŠ† s âˆ§ (âˆ€ x âˆˆ t0, r0 x âˆˆ f x âˆ© Ioo 0 (R x))
      âˆ§ Î¼ (s \ (â‹ƒ (x âˆˆ t0), closed_ball x (r0 x))) = 0
      âˆ§ t0.pairwise_disjoint (Î» x, closed_ball x (r0 x)) :=
        exists_disjoint_closed_ball_covering_ae Î¼ f s hf R (Î» x hx, (hR x hx).1),
protected def vitali_family (Î¼ : measure Î±) [sigma_finite Î¼] :
  vitali_family Î¼ :=
{ sets_at := Î» x, (Î» (r : â„), closed_ball x r) '' (Ioi (0 : â„)),
  measurable_set' := begin
    assume x y hy,
    obtain âŸ¨r, rpos, rflâŸ© : âˆƒ (r : â„), 0 < r âˆ§ closed_ball x r = y,
      by simpa only [mem_image, mem_Ioi] using hy,
    exact is_closed_ball.measurable_set
  end,
  nonempty_interior := begin
    assume x y hy,
    obtain âŸ¨r, rpos, rflâŸ© : âˆƒ (r : â„), 0 < r âˆ§ closed_ball x r = y,
      by simpa only [mem_image, mem_Ioi] using hy,
    simp only [nonempty.mono ball_subset_interior_closed_ball, rpos, nonempty_ball],
  end,
  nontrivial := Î» x Îµ Îµpos, âŸ¨closed_ball x Îµ, mem_image_of_mem _ Îµpos, subset.refl _âŸ©,
  covering := begin
    assume s f fsubset ffine,
    let g : Î± â†’ set â„ := Î» x, {r | 0 < r âˆ§ closed_ball x r âˆˆ f x},
    have A : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (g x âˆ© Ioo 0 Î´).nonempty,
    { assume x xs Î´ Î´pos,
      obtain âŸ¨t, tf, htâŸ© : âˆƒ (t : set Î±) (H : t âˆˆ f x), t âŠ† closed_ball x (Î´/2) :=
        ffine x xs (Î´/2) (half_pos Î´pos),
      obtain âŸ¨r, rpos, rflâŸ© : âˆƒ (r : â„), 0 < r âˆ§ closed_ball x r = t,
        by simpa using fsubset x xs tf,
      rcases le_total r (Î´/2) with H|H,
      { exact âŸ¨r, âŸ¨rpos, tfâŸ©, âŸ¨rpos, H.trans_lt (half_lt_self Î´pos)âŸ©âŸ© },
      { have : closed_ball x r = closed_ball x (Î´/2) :=
          subset.antisymm ht (closed_ball_subset_closed_ball H),
        rw this at tf,
        refine âŸ¨Î´/2, âŸ¨half_pos Î´pos, tfâŸ©, âŸ¨half_pos Î´pos, half_lt_self Î´posâŸ©âŸ© } },
    obtain âŸ¨t, r, t_count, ts, tg, Î¼t, tdisjâŸ© : âˆƒ (t : set Î±) (r : Î± â†’ â„), t.countable
      âˆ§ t âŠ† s âˆ§ (âˆ€ x âˆˆ t, r x âˆˆ g x âˆ© Ioo 0 1)
      âˆ§ Î¼ (s \ (â‹ƒ (x âˆˆ t), closed_ball x (r x))) = 0
      âˆ§ t.pairwise_disjoint (Î» x, closed_ball x (r x)) :=
        exists_disjoint_closed_ball_covering_ae Î¼ g s A (Î» _, 1) (Î» _ _, zero_lt_one),
    exact âŸ¨t, Î» x, closed_ball x (r x), ts, tdisj, Î» x xt, (tg x xt).1.2, Î¼tâŸ©,
  end }
lemma tendsto_filter_at (Î¼ : measure Î±) [sigma_finite Î¼] (x : Î±) :
  tendsto (Î» r, closed_ball x r) (ğ“[>] 0) ((besicovitch.vitali_family Î¼).filter_at x) :=
begin
  assume s hs,
  simp only [mem_map],
  obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ (Îµ : â„) (H : Îµ > 0), âˆ€ (a : set Î±),
    a âˆˆ (besicovitch.vitali_family Î¼).sets_at x â†’ a âŠ† closed_ball x Îµ â†’ a âˆˆ s :=
      (vitali_family.mem_filter_at_iff _).1 hs,
  have : Ioc (0 : â„) Îµ âˆˆ ğ“[>] (0 : â„) := Ioc_mem_nhds_within_Ioi âŸ¨le_rfl, ÎµposâŸ©,
  filter_upwards [this] with _ hr,
  apply hÎµ,
  { exact mem_image_of_mem _ hr.1 },
  { exact closed_ball_subset_closed_ball hr.2 }
end
variables [metric_space Î²] [measurable_space Î²] [borel_space Î²] [sigma_compact_space Î²]
  [has_besicovitch_covering Î²]
lemma ae_tendsto_rn_deriv
  (Ï Î¼ : measure Î²) [is_locally_finite_measure Î¼] [is_locally_finite_measure Ï] :
  âˆ€áµ x âˆ‚Î¼, tendsto (Î» r, Ï (closed_ball x r) / Î¼ (closed_ball x r))
    (ğ“[>] 0) (ğ“ (Ï.rn_deriv Î¼ x)) :=
begin
  haveI : second_countable_topology Î² := emetric.second_countable_of_sigma_compact Î²,
  filter_upwards [vitali_family.ae_tendsto_rn_deriv (besicovitch.vitali_family Î¼) Ï] with x hx,
  exact hx.comp (tendsto_filter_at Î¼ x)
end
lemma ae_tendsto_measure_inter_div_of_measurable_set
  (Î¼ : measure Î²) [is_locally_finite_measure Î¼] {s : set Î²} (hs : measurable_set s) :
  âˆ€áµ x âˆ‚Î¼, tendsto (Î» r, Î¼ (s âˆ© closed_ball x r) / Î¼ (closed_ball x r))
    (ğ“[>] 0) (ğ“ (s.indicator 1 x)) :=
begin
  haveI : second_countable_topology Î² := emetric.second_countable_of_sigma_compact Î²,
  filter_upwards [vitali_family.ae_tendsto_measure_inter_div_of_measurable_set
    (besicovitch.vitali_family Î¼) hs],
  assume x hx,
  exact hx.comp (tendsto_filter_at Î¼ x)
end
lemma ae_tendsto_measure_inter_div (Î¼ : measure Î²) [is_locally_finite_measure Î¼] (s : set Î²) :
  âˆ€áµ x âˆ‚(Î¼.restrict s), tendsto (Î» r, Î¼ (s âˆ© (closed_ball x r)) / Î¼ (closed_ball x r))
    (ğ“[>] 0) (ğ“ 1) :=
begin
  haveI : second_countable_topology Î² := emetric.second_countable_of_sigma_compact Î²,
  filter_upwards [vitali_family.ae_tendsto_measure_inter_div (besicovitch.vitali_family Î¼)]
    with x hx using hx.comp (tendsto_filter_at Î¼ x),
end
end besicovitch
