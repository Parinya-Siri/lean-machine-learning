import analysis.special_functions.pow
import logic.equiv.list
import measure_theory.constructions.borel_space
import measure_theory.measure.lebesgue
import topology.metric_space.holder
import topology.metric_space.metric_separated
open_locale nnreal ennreal topological_space big_operators
open emetric set function filter encodable finite_dimensional topological_space
noncomputable theory
variables {Œπ X Y : Type*} [emetric_space X] [emetric_space Y]
namespace measure_theory
namespace outer_measure
def is_metric (Œº : outer_measure X) : Prop :=
‚àÄ (s t : set X), is_metric_separated s t ‚Üí Œº (s ‚à™ t) = Œº s + Œº t
namespace is_metric
variables {Œº : outer_measure X}
lemma finset_Union_of_pairwise_separated (hm : is_metric Œº) {I : finset Œπ} {s : Œπ ‚Üí set X}
  (hI : ‚àÄ (i ‚àà I) (j ‚àà I), i ‚â† j ‚Üí is_metric_separated (s i) (s j)) :
  Œº (‚ãÉ i ‚àà I, s i) = ‚àë i in I, Œº (s i) :=
begin
  classical,
  induction I using finset.induction_on with i I hiI ihI hI, { simp },
  simp only [finset.mem_insert] at hI,
  rw [finset.set_bUnion_insert, hm, ihI, finset.sum_insert hiI],
  exacts [Œª i hi j hj hij, (hI i (or.inr hi) j (or.inr hj) hij),
    is_metric_separated.finset_Union_right
      (Œª j hj, hI i (or.inl rfl) j (or.inr hj) (ne_of_mem_of_not_mem hj hiI).symm)]
end
lemma borel_le_caratheodory (hm : is_metric Œº) :
  borel X ‚â§ Œº.caratheodory :=
begin
  rw [borel_eq_generate_from_is_closed],
  refine measurable_space.generate_from_le (Œª t ht, Œº.is_caratheodory_iff_le.2 $ Œª s, _),
  set S : ‚Ñï ‚Üí set X := Œª n, {x ‚àà s | (‚Üën)‚Åª¬π ‚â§ inf_edist x t},
  have n0 : ‚àÄ {n : ‚Ñï}, (n‚Åª¬π : ‚Ñù‚â•0‚àû) ‚â† 0, from Œª n, ennreal.inv_ne_zero.2 ennreal.coe_nat_ne_top,
  have Ssep : ‚àÄ n, is_metric_separated (S n) t,
    from Œª n, ‚ü®n‚Åª¬π, n0, Œª x hx y hy, hx.2.trans $ inf_edist_le_edist_of_mem hy‚ü©,
  have Ssep' : ‚àÄ n, is_metric_separated (S n) (s ‚à© t),
    from Œª n, (Ssep n).mono subset.rfl (inter_subset_right _ _),
  have S_sub : ‚àÄ n, S n ‚äÜ s \ t,
    from Œª n, subset_inter (inter_subset_left _ _) (Ssep n).subset_compl_right,
  have hSs : ‚àÄ n, Œº (s ‚à© t) + Œº (S n) ‚â§ Œº s, from Œª n,
  calc Œº (s ‚à© t) + Œº (S n) = Œº (s ‚à© t ‚à™ S n) :
    eq.symm $ hm _ _ $ (Ssep' n).symm
  ... ‚â§ Œº (s ‚à© t ‚à™ s \ t)  : by { mono*, exact le_rfl }
  ... = Œº s : by rw [inter_union_diff],
  have Union_S : (‚ãÉ n, S n) = s \ t,
  { refine subset.antisymm (Union_subset S_sub) _,
    rintro x ‚ü®hxs, hxt‚ü©,
    rw mem_iff_inf_edist_zero_of_closed ht at hxt,
    rcases ennreal.exists_inv_nat_lt hxt with ‚ü®n, hn‚ü©,
    exact mem_Union.2 ‚ü®n, hxs, hn.le‚ü© },
  by_cases htop : Œº (s \ t) = ‚àû,
  { rw [htop, ennreal.add_top, ‚Üê htop],
    exact Œº.mono (diff_subset _ _) },
  suffices : Œº (‚ãÉ n, S n) ‚â§ ‚®Ü n, Œº (S n),
  calc Œº (s ‚à© t) + Œº (s \ t) = Œº (s ‚à© t) + Œº (‚ãÉ n, S n) :
    by rw Union_S
  ... ‚â§ Œº (s ‚à© t) + ‚®Ü n, Œº (S n) :
    add_le_add le_rfl this
  ... = ‚®Ü n, Œº (s ‚à© t) + Œº (S n) : ennreal.add_supr
  ... ‚â§ Œº s : supr_le hSs,
  have : ‚àÄ n, S n ‚äÜ S (n + 1), from Œª n x hx,
    ‚ü®hx.1, le_trans (ennreal.inv_le_inv.2 $ ennreal.coe_nat_le_coe_nat.2 n.le_succ) hx.2‚ü©,
  refine (Œº.Union_nat_of_monotone_of_tsum_ne_top this _).le, clear this,
  rw [‚Üê tsum_even_add_odd ennreal.summable ennreal.summable, ennreal.add_ne_top],
  suffices : ‚àÄ a, (‚àë' (k : ‚Ñï), Œº (S (2 * k + 1 + a) \ S (2 * k + a))) ‚â† ‚àû,
    from ‚ü®by simpa using this 0, by simpa using this 1‚ü©,
  refine Œª r, ne_top_of_le_ne_top htop _,
  rw [‚Üê Union_S, ennreal.tsum_eq_supr_nat, supr_le_iff],
  intro n,
  rw [‚Üê hm.finset_Union_of_pairwise_separated],
  { exact Œº.mono (Union_subset $ Œª i, Union_subset $ Œª hi x hx, mem_Union.2 ‚ü®_, hx.1‚ü©) },
  suffices : ‚àÄ i  j, i < j ‚Üí is_metric_separated (S (2 * i + 1 + r)) (s \ S (2 * j + r)),
    from Œª i _ j _ hij, hij.lt_or_lt.elim
      (Œª h, (this i j h).mono (inter_subset_left _ _) (Œª x hx, ‚ü®hx.1.1, hx.2‚ü©))
      (Œª h, (this j i h).symm.mono  (Œª x hx, ‚ü®hx.1.1, hx.2‚ü©) (inter_subset_left _ _)),
  intros i j hj,
  have A : ((‚Üë(2 * j + r))‚Åª¬π : ‚Ñù‚â•0‚àû) < (‚Üë(2 * i + 1 + r))‚Åª¬π,
    by { rw [ennreal.inv_lt_inv, ennreal.coe_nat_lt_coe_nat], linarith },
  refine ‚ü®(‚Üë(2 * i + 1 + r))‚Åª¬π - (‚Üë(2 * j + r))‚Åª¬π, by simpa using A, Œª x hx y hy, _‚ü©,
  have : inf_edist y t < (‚Üë(2 * j + r))‚Åª¬π, from not_le.1 (Œª hle, hy.2 ‚ü®hy.1, hle‚ü©),
  rcases inf_edist_lt_iff.mp this with ‚ü®z, hzt, hyz‚ü©,
  have hxz : (‚Üë(2 * i + 1 + r))‚Åª¬π ‚â§ edist x z, from le_inf_edist.1 hx.2 _ hzt,
  apply ennreal.le_of_add_le_add_right hyz.ne_top,
  refine le_trans _ (edist_triangle _ _ _),
  refine (add_le_add le_rfl hyz.le).trans (eq.trans_le _ hxz),
  rw [tsub_add_cancel_of_le A.le]
end
lemma le_caratheodory [measurable_space X] [borel_space X] (hm : is_metric Œº) :
  ‚Äπmeasurable_space X‚Ä∫ ‚â§ Œº.caratheodory :=
by { rw @borel_space.measurable_eq X _ _, exact hm.borel_le_caratheodory }
end is_metric
def mk_metric'.pre (m : set X ‚Üí ‚Ñù‚â•0‚àû) (r : ‚Ñù‚â•0‚àû) :
  outer_measure X :=
bounded_by $ extend (Œª s (hs : diam s ‚â§ r), m s)
def mk_metric' (m : set X ‚Üí ‚Ñù‚â•0‚àû) :
  outer_measure X :=
‚®Ü r > 0, mk_metric'.pre m r
def mk_metric (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) : outer_measure X :=
mk_metric' (Œª s, m (diam s))
namespace mk_metric'
variables {m : set X ‚Üí ‚Ñù‚â•0‚àû} {r : ‚Ñù‚â•0‚àû} {Œº : outer_measure X} {s : set X}
lemma le_pre : Œº ‚â§ pre m r ‚Üî ‚àÄ s : set X, diam s ‚â§ r ‚Üí Œº s ‚â§ m s :=
by simp only [pre, le_bounded_by, extend, le_infi_iff]
lemma pre_le (hs : diam s ‚â§ r) : pre m r s ‚â§ m s :=
(bounded_by_le _).trans $ infi_le _ hs
lemma mono_pre (m : set X ‚Üí ‚Ñù‚â•0‚àû) {r r' : ‚Ñù‚â•0‚àû} (h : r ‚â§ r') :
  pre m r' ‚â§ pre m r :=
le_pre.2 $ Œª s hs, pre_le (hs.trans h)
lemma mono_pre_nat (m : set X ‚Üí ‚Ñù‚â•0‚àû) :
  monotone (Œª k : ‚Ñï, pre m k‚Åª¬π) :=
Œª k l h, le_pre.2 $ Œª s hs, pre_le (hs.trans $ by simpa)
lemma tendsto_pre (m : set X ‚Üí ‚Ñù‚â•0‚àû) (s : set X) :
  tendsto (Œª r, pre m r s) (ùìù[>] 0) (ùìù $ mk_metric' m s) :=
begin
  rw [‚Üê map_coe_Ioi_at_bot, tendsto_map'_iff],
  simp only [mk_metric', outer_measure.supr_apply, supr_subtype'],
  exact tendsto_at_bot_supr (Œª r r' hr, mono_pre _ hr _)
end
lemma tendsto_pre_nat (m : set X ‚Üí ‚Ñù‚â•0‚àû) (s : set X) :
  tendsto (Œª n : ‚Ñï, pre m n‚Åª¬π s) at_top (ùìù $ mk_metric' m s) :=
begin
  refine (tendsto_pre m s).comp (tendsto_inf.2 ‚ü®ennreal.tendsto_inv_nat_nhds_zero, _‚ü©),
  refine tendsto_principal.2 (eventually_of_forall $ Œª n, _),
  simp
end
lemma eq_supr_nat (m : set X ‚Üí ‚Ñù‚â•0‚àû) :
  mk_metric' m = ‚®Ü n : ‚Ñï, mk_metric'.pre m n‚Åª¬π :=
begin
  ext1 s,
  rw supr_apply,
  refine tendsto_nhds_unique (mk_metric'.tendsto_pre_nat m s)
    (tendsto_at_top_supr $ Œª k l hkl, mk_metric'.mono_pre_nat m hkl s)
end
lemma trim_pre [measurable_space X] [opens_measurable_space X]
  (m : set X ‚Üí ‚Ñù‚â•0‚àû) (hcl : ‚àÄ s, m (closure s) = m s) (r : ‚Ñù‚â•0‚àû) :
  (pre m r).trim = pre m r :=
begin
  refine le_antisymm (le_pre.2 $ Œª s hs, _) (le_trim _),
  rw trim_eq_infi,
  refine (infi_le_of_le (closure s) $ infi_le_of_le subset_closure $
    infi_le_of_le measurable_set_closure ((pre_le _).trans_eq (hcl _))),
  rwa diam_closure
end
end mk_metric'
lemma mk_metric'_is_metric (m : set X ‚Üí ‚Ñù‚â•0‚àû) :
  (mk_metric' m).is_metric :=
begin
  rintros s t ‚ü®r, r0, hr‚ü©,
  refine tendsto_nhds_unique_of_eventually_eq
    (mk_metric'.tendsto_pre _ _)
    ((mk_metric'.tendsto_pre _ _).add (mk_metric'.tendsto_pre _ _)) _,
  rw [‚Üê pos_iff_ne_zero] at r0,
  filter_upwards [Ioo_mem_nhds_within_Ioi ‚ü®le_rfl, r0‚ü©],
  rintro Œµ ‚ü®Œµ0, Œµr‚ü©,
  refine bounded_by_union_of_top_of_nonempty_inter _,
  rintro u ‚ü®x, hxs, hxu‚ü© ‚ü®y, hyt, hyu‚ü©,
  have : Œµ < diam u, from Œµr.trans_le ((hr x hxs y hyt).trans $ edist_le_diam_of_mem hxu hyu),
  exact infi_eq_top.2 (Œª h, (this.not_le h).elim)
end
lemma mk_metric_mono_smul {m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû} {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† ‚àû) (h0 : c ‚â† 0)
  (hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] c ‚Ä¢ m‚ÇÇ) :
  (mk_metric m‚ÇÅ : outer_measure X) ‚â§ c ‚Ä¢ mk_metric m‚ÇÇ :=
begin
  classical,
  rcases (mem_nhds_within_Ici_iff_exists_Ico_subset' ennreal.zero_lt_one).1 hle with ‚ü®r, hr0, hr‚ü©,
  refine Œª s, le_of_tendsto_of_tendsto (mk_metric'.tendsto_pre _ s)
    (ennreal.tendsto.const_mul (mk_metric'.tendsto_pre _ s) (or.inr hc))
    (mem_of_superset (Ioo_mem_nhds_within_Ioi ‚ü®le_rfl, hr0‚ü©) (Œª r' hr', _)),
  simp only [mem_set_of_eq, mk_metric'.pre, ring_hom.id_apply],
  rw [‚Üêsmul_eq_mul, ‚Üê smul_apply, smul_bounded_by hc],
  refine le_bounded_by.2 (Œª t, (bounded_by_le _).trans _) _,
  simp only [smul_eq_mul, pi.smul_apply, extend, infi_eq_if],
  split_ifs with ht ht,
  { apply hr,
    exact ‚ü®zero_le _, ht.trans_lt hr'.2‚ü© },
  { simp [h0] }
end
lemma mk_metric_mono {m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû} (hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] m‚ÇÇ) :
  (mk_metric m‚ÇÅ : outer_measure X) ‚â§ mk_metric m‚ÇÇ :=
by { convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp * }
lemma isometry_comap_mk_metric (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) {f : X ‚Üí Y} (hf : isometry f)
  (H : monotone m ‚à® surjective f) :
  comap f (mk_metric m) = mk_metric m :=
begin
  simp only [mk_metric, mk_metric', mk_metric'.pre, induced_outer_measure, comap_supr],
  refine surjective_id.supr_congr id (Œª Œµ, surjective_id.supr_congr id $ Œª hŒµ, _),
  rw comap_bounded_by _ (H.imp (Œª h_mono, _) id),
  { congr' with s : 1,
    apply extend_congr,
    { simp [hf.ediam_image] },
    { intros, simp [hf.injective.subsingleton_image_iff, hf.ediam_image] } },
  { assume s t hst,
    simp only [extend, le_infi_iff],
    assume ht,
    apply le_trans _ (h_mono (diam_mono hst)),
    simp only [(diam_mono hst).trans ht, le_refl, cinfi_pos] }
end
lemma isometry_map_mk_metric (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) {f : X ‚Üí Y} (hf : isometry f)
  (H : monotone m ‚à® surjective f) :
  map f (mk_metric m) = restrict (range f) (mk_metric m) :=
by rw [‚Üê isometry_comap_mk_metric _ hf H, map_comap]
lemma isometric_comap_mk_metric (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) (f : X ‚âÉ·µ¢ Y) :
  comap f (mk_metric m) = mk_metric m :=
isometry_comap_mk_metric _ f.isometry (or.inr f.surjective)
lemma isometric_map_mk_metric (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) (f : X ‚âÉ·µ¢ Y) :
  map f (mk_metric m) = mk_metric m :=
by rw [‚Üê isometric_comap_mk_metric _ f, map_comap_of_surjective f.surjective]
lemma trim_mk_metric [measurable_space X] [borel_space X] (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) :
  (mk_metric m : outer_measure X).trim = mk_metric m :=
begin
  simp only [mk_metric, mk_metric'.eq_supr_nat, trim_supr],
  congr' 1 with n : 1,
  refine mk_metric'.trim_pre _ (Œª s, _) _,
  simp
end
lemma le_mk_metric (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) (Œº : outer_measure X)
  (r : ‚Ñù‚â•0‚àû) (h0 : 0 < r) (hr : ‚àÄ s, diam s ‚â§ r ‚Üí Œº s ‚â§ m (diam s)) :
  Œº ‚â§ mk_metric m :=
le_supr‚ÇÇ_of_le r h0 $ mk_metric'.le_pre.2 $ Œª s hs, hr _ hs
end outer_measure
namespace measure
variables [measurable_space X] [borel_space X]
def mk_metric' (m : set X ‚Üí ‚Ñù‚â•0‚àû) : measure X :=
(outer_measure.mk_metric' m).to_measure (outer_measure.mk_metric'_is_metric _).le_caratheodory
def mk_metric (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) : measure X :=
(outer_measure.mk_metric m).to_measure (outer_measure.mk_metric'_is_metric _).le_caratheodory
@[simp] lemma mk_metric'_to_outer_measure (m : set X ‚Üí ‚Ñù‚â•0‚àû) :
  (mk_metric' m).to_outer_measure = (outer_measure.mk_metric' m).trim :=
rfl
@[simp] lemma mk_metric_to_outer_measure (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) :
  (mk_metric m : measure X).to_outer_measure = outer_measure.mk_metric m :=
outer_measure.trim_mk_metric m
end measure
lemma outer_measure.coe_mk_metric [measurable_space X] [borel_space X] (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) :
  ‚áë(outer_measure.mk_metric m : outer_measure X) = measure.mk_metric m :=
by rw [‚Üê measure.mk_metric_to_outer_measure, coe_to_outer_measure]
namespace measure
variables [measurable_space X] [borel_space X]
lemma mk_metric_mono_smul {m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû} {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† ‚àû) (h0 : c ‚â† 0)
  (hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] c ‚Ä¢ m‚ÇÇ) :
  (mk_metric m‚ÇÅ : measure X) ‚â§ c ‚Ä¢ mk_metric m‚ÇÇ :=
begin
  intros s hs,
  rw [‚Üê outer_measure.coe_mk_metric, coe_smul, ‚Üê outer_measure.coe_mk_metric],
  exact outer_measure.mk_metric_mono_smul hc h0 hle s
end
lemma mk_metric_mono {m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû} (hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] m‚ÇÇ) :
  (mk_metric m‚ÇÅ : measure X) ‚â§ mk_metric m‚ÇÇ :=
by { convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp * }
lemma mk_metric_apply (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) (s : set X) :
  mk_metric m s = ‚®Ü (r : ‚Ñù‚â•0‚àû) (hr : 0 < r),
    ‚®Ö (t : ‚Ñï ‚Üí set X) (h : s ‚äÜ Union t) (h' : ‚àÄ n, diam (t n) ‚â§ r),
      ‚àë' n, ‚®Ü (h : (t n).nonempty), m (diam (t n)) :=
begin
lemma mk_metric_le_liminf_tsum {Œ≤ : Type*} {Œπ : Œ≤ ‚Üí Type*} [‚àÄ n, encodable (Œπ n)] (s : set X)
  {l : filter Œ≤} (r : Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (hr : tendsto r l (ùìù 0)) (t : Œ† (n : Œ≤), Œπ n ‚Üí set X)
  (ht : ‚àÄ·∂† n in l, ‚àÄ i, diam (t n i) ‚â§ r n) (hst : ‚àÄ·∂† n in l, s ‚äÜ ‚ãÉ i, t n i)
  (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) :
  mk_metric m s ‚â§ liminf l (Œª n, ‚àë' i, m (diam (t n i))) :=
begin
  simp only [mk_metric_apply],
  refine supr‚ÇÇ_le (Œª Œµ hŒµ, _),
  refine le_of_forall_le_of_dense (Œª c hc, _),
  rcases ((frequently_lt_of_liminf_lt (by apply_auto_param) hc).and_eventually
    ((hr.eventually (gt_mem_nhds hŒµ)).and (ht.and hst))).exists with ‚ü®n, hn, hrn, htn, hstn‚ü©,
  set u : ‚Ñï ‚Üí set X := Œª j, ‚ãÉ b ‚àà decode‚ÇÇ (Œπ n) j, t n b,
  refine infi‚ÇÇ_le_of_le u (by rwa Union_decode‚ÇÇ) _,
  refine infi_le_of_le (Œª j, _) _,
  { rw emetric.diam_Union_mem_option,
    exact supr‚ÇÇ_le (Œª _ _, (htn _).trans hrn.le) },
  { calc (‚àë' (j : ‚Ñï), ‚®Ü (h : (u j).nonempty), m (diam (u j))) = _ :
              tsum_Union_decode‚ÇÇ (Œª t : set X, ‚®Ü (h : t.nonempty), m (diam t)) (by simp) _
    ... ‚â§ ‚àë' (i : Œπ n), m (diam (t n i)) :
      ennreal.tsum_le_tsum (Œª b, supr_le $ Œª htb, le_rfl)
    ... ‚â§ c : hn.le }
end
lemma mk_metric_le_liminf_sum {Œ≤ : Type*} {Œπ : Œ≤ ‚Üí Type*} [hŒπ : ‚àÄ n, fintype (Œπ n)] (s : set X)
  {l : filter Œ≤} (r : Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (hr : tendsto r l (ùìù 0)) (t : Œ† (n : Œ≤), Œπ n ‚Üí set X)
  (ht : ‚àÄ·∂† n in l, ‚àÄ i, diam (t n i) ‚â§ r n) (hst : ‚àÄ·∂† n in l, s ‚äÜ ‚ãÉ i, t n i)
  (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) :
  mk_metric m s ‚â§ liminf l (Œª n, ‚àë i, m (diam (t n i))) :=
begin
  haveI : ‚àÄ n, encodable (Œπ n), from Œª n, fintype.to_encodable _,
  simpa only [tsum_fintype] using mk_metric_le_liminf_tsum s r hr t ht hst m,
end
def hausdorff_measure (d : ‚Ñù) : measure X := mk_metric (Œª r, r ^ d)
localized "notation `ŒºH[` d `]` := measure_theory.measure.hausdorff_measure d" in measure_theory
lemma le_hausdorff_measure (d : ‚Ñù) (Œº : measure X) (Œµ : ‚Ñù‚â•0‚àû) (h‚ÇÄ : 0 < Œµ)
  (h : ‚àÄ s : set X, diam s ‚â§ Œµ ‚Üí Œº s ‚â§ diam s ^ d) :
  Œº ‚â§ ŒºH[d] :=
le_mk_metric _ Œº Œµ h‚ÇÄ h
lemma hausdorff_measure_apply (d : ‚Ñù) (s : set X) :
  ŒºH[d] s = ‚®Ü (r : ‚Ñù‚â•0‚àû) (hr : 0 < r), ‚®Ö (t : ‚Ñï ‚Üí set X) (hts : s ‚äÜ ‚ãÉ n, t n)
    (ht : ‚àÄ n, diam (t n) ‚â§ r), ‚àë' n, ‚®Ü (h : (t n).nonempty), (diam (t n)) ^ d :=
mk_metric_apply _ _
lemma hausdorff_measure_le_liminf_tsum {Œ≤ : Type*}  {Œπ : Œ≤ ‚Üí Type*} [hŒπ : ‚àÄ n, encodable (Œπ n)]
  (d : ‚Ñù) (s : set X)
  {l : filter Œ≤} (r : Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (hr : tendsto r l (ùìù 0)) (t : Œ† (n : Œ≤), Œπ n ‚Üí set X)
  (ht : ‚àÄ·∂† n in l, ‚àÄ i, diam (t n i) ‚â§ r n) (hst : ‚àÄ·∂† n in l, s ‚äÜ ‚ãÉ i, t n i) :
  ŒºH[d] s ‚â§ liminf l (Œª n, ‚àë' i, diam (t n i) ^ d) :=
mk_metric_le_liminf_tsum s r hr t ht hst _
lemma hausdorff_measure_le_liminf_sum {Œ≤ : Type*}  {Œπ : Œ≤ ‚Üí Type*} [hŒπ : ‚àÄ n, fintype (Œπ n)]
  (d : ‚Ñù) (s : set X)
  {l : filter Œ≤} (r : Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (hr : tendsto r l (ùìù 0)) (t : Œ† (n : Œ≤), Œπ n ‚Üí set X)
  (ht : ‚àÄ·∂† n in l, ‚àÄ i, diam (t n i) ‚â§ r n) (hst : ‚àÄ·∂† n in l, s ‚äÜ ‚ãÉ i, t n i) :
  ŒºH[d] s ‚â§ liminf l (Œª n, ‚àë i, diam (t n i) ^ d) :=
mk_metric_le_liminf_sum s r hr t ht hst _
lemma hausdorff_measure_zero_or_top {d‚ÇÅ d‚ÇÇ : ‚Ñù} (h : d‚ÇÅ < d‚ÇÇ) (s : set X) :
  ŒºH[d‚ÇÇ] s = 0 ‚à® ŒºH[d‚ÇÅ] s = ‚àû :=
begin
  by_contra' H,
  suffices : ‚àÄ (c : ‚Ñù‚â•0), c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s,
  { rcases ennreal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©,
    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0)) },
  intros c hc,
  refine le_iff'.1 (mk_metric_mono_smul ennreal.coe_ne_top (by exact_mod_cast hc) _) s,
  have : 0 < (c ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π : ‚Ñù‚â•0‚àû),
  { rw [ennreal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, ne.def, ennreal.coe_eq_zero,
      nnreal.rpow_eq_zero_iff],
    exact mt and.left hc },
  filter_upwards [Ico_mem_nhds_within_Ici ‚ü®le_rfl, this‚ü©],
  rintro r ‚ü®hr‚ÇÄ, hrc‚ü©,
  lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc,
  rw [pi.smul_apply, smul_eq_mul, ‚Üê ennreal.div_le_iff_le_mul (or.inr ennreal.coe_ne_top)
    (or.inr $ mt ennreal.coe_eq_zero.1 hc)],
  rcases eq_or_ne r 0 with rfl|hr‚ÇÄ,
  { rcases lt_or_le 0 d‚ÇÇ with h‚ÇÇ|h‚ÇÇ,
    { simp only [h‚ÇÇ, ennreal.zero_rpow_of_pos, zero_le', ennreal.coe_nonneg, ennreal.zero_div,
        ennreal.coe_zero] },
    { simp only [h.trans_le h‚ÇÇ, ennreal.div_top, zero_le', ennreal.coe_nonneg,
        ennreal.zero_rpow_of_neg, ennreal.coe_zero] } },
  { have : (r : ‚Ñù‚â•0‚àû) ‚â† 0, by simpa only [ennreal.coe_eq_zero, ne.def] using hr‚ÇÄ,
    rw [‚Üê ennreal.rpow_sub _ _ this ennreal.coe_ne_top],
    refine (ennreal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans _,
    rw [‚Üê ennreal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ennreal.rpow_one],
    exact le_rfl }
end
lemma hausdorff_measure_mono {d‚ÇÅ d‚ÇÇ : ‚Ñù} (h : d‚ÇÅ ‚â§ d‚ÇÇ) (s : set X) : ŒºH[d‚ÇÇ] s ‚â§ ŒºH[d‚ÇÅ] s :=
begin
  rcases h.eq_or_lt with rfl|h, { exact le_rfl },
  cases hausdorff_measure_zero_or_top h s with hs hs,
  { rw hs, exact zero_le _ },
  { rw hs, exact le_top }
end
variables (X)
lemma no_atoms_hausdorff {d : ‚Ñù} (hd : 0 < d) : has_no_atoms (hausdorff_measure d : measure X) :=
begin
  refine ‚ü®Œª x, _‚ü©,
  rw [‚Üê nonpos_iff_eq_zero, hausdorff_measure_apply],
  refine supr‚ÇÇ_le (Œª Œµ Œµ0, infi‚ÇÇ_le_of_le (Œª n, {x}) _ $ infi_le_of_le (Œª n, _) _),
  { exact subset_Union (Œª n, {x} : ‚Ñï ‚Üí set X) 0 },
  { simp only [emetric.diam_singleton, zero_le] },
  { simp [hd] }
end
variables {X}
@[simp] lemma hausdorff_measure_zero_singleton (x : X) : ŒºH[0] ({x} : set X) = 1 :=
begin
  apply le_antisymm,
  { let r : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû := Œª _, 0,
    let t : ‚Ñï ‚Üí unit ‚Üí set X := Œª n _, {x},
    have ht : ‚àÄ·∂† n in at_top, ‚àÄ i, diam (t n i) ‚â§ r n,
      by simp only [implies_true_iff, eq_self_iff_true, diam_singleton, eventually_at_top,
        nonpos_iff_eq_zero, exists_const],
    simpa [liminf_const] using hausdorff_measure_le_liminf_sum 0 {x} r tendsto_const_nhds t ht },
  { rw hausdorff_measure_apply,
    suffices : (1 : ‚Ñù‚â•0‚àû) ‚â§ ‚®Ö (t : ‚Ñï ‚Üí set X) (hts : {x} ‚äÜ ‚ãÉ n, t n)
      (ht : ‚àÄ n, diam (t n) ‚â§ 1), ‚àë' n, ‚®Ü (h : (t n).nonempty), (diam (t n)) ^ (0 : ‚Ñù),
    { apply le_trans this _,
      convert le_supr‚ÇÇ (1 : ‚Ñù‚â•0‚àû) (ennreal.zero_lt_one),
      refl },
    simp only [ennreal.rpow_zero, le_infi_iff],
    assume t hst h't,
    rcases mem_Union.1 (hst (mem_singleton x)) with ‚ü®m, hm‚ü©,
    have A : (t m).nonempty := ‚ü®x, hm‚ü©,
    calc (1 : ‚Ñù‚â•0‚àû) = ‚®Ü (h : (t m).nonempty), 1 : by simp only [A, csupr_pos]
    ... ‚â§ ‚àë' n, ‚®Ü (h : (t n).nonempty), 1 : ennreal.le_tsum _ }
end
lemma one_le_hausdorff_measure_zero_of_nonempty {s : set X} (h : s.nonempty) :
  1 ‚â§ ŒºH[0] s :=
begin
  rcases h with ‚ü®x, hx‚ü©,
  calc (1 : ‚Ñù‚â•0‚àû) = ŒºH[0] ({x} : set X) : (hausdorff_measure_zero_singleton x).symm
  ... ‚â§ ŒºH[0] s : measure_mono (singleton_subset_iff.2 hx)
end
lemma hausdorff_measure_le_one_of_subsingleton
  {s : set X} (hs : s.subsingleton) {d : ‚Ñù} (hd : 0 ‚â§ d) :
  ŒºH[d] s ‚â§ 1 :=
begin
  rcases eq_empty_or_nonempty s with rfl|‚ü®x, hx‚ü©,
  { simp only [measure_empty, zero_le] },
  { rw (subsingleton_iff_singleton hx).1 hs,
    rcases eq_or_lt_of_le hd with rfl|dpos,
    { simp only [le_refl, hausdorff_measure_zero_singleton] },
    { haveI := no_atoms_hausdorff X dpos,
      simp only [zero_le, measure_singleton] } }
end
end measure
open_locale measure_theory
open measure
@[simp] theorem hausdorff_measure_pi_real {Œπ : Type*} [fintype Œπ] :
  (ŒºH[fintype.card Œπ] : measure (Œπ ‚Üí ‚Ñù)) = volume :=
begin
  classical,
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := Œª i, by simpa only [sub_nonneg, rat.cast_le] using (H i).le,
  let Œ≥ := Œª (n : ‚Ñï), (Œ† (i : Œπ), fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä),
  let t : Œ† (n : ‚Ñï), Œ≥ n ‚Üí set (Œπ ‚Üí ‚Ñù) :=
    Œª n f, set.pi univ (Œª i, Icc (a i + f i / n) (a i + (f i + 1) / n)),
  have A : tendsto (Œª (n : ‚Ñï), 1/(n : ‚Ñù‚â•0‚àû)) at_top (ùìù 0),
    by simp only [one_div, ennreal.tendsto_inv_nat_nhds_zero],
  have B : ‚àÄ·∂† n in at_top, ‚àÄ (i : Œ≥ n), diam (t n i) ‚â§ 1 / n,
  { apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©,
    assume f,
    apply diam_pi_le_of_le (Œª b, _),
    simp only [real.ediam_Icc, add_div, ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel', ennreal.of_real_one, ennreal.of_real_coe_nat] },
  have C : ‚àÄ·∂† n in at_top, set.pi univ (Œª (i : Œπ), Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ (i : Œ≥ n), t n i,
  { apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©,
    have npos : (0 : ‚Ñù) < n := nat.cast_pos.2 hn,
    assume x hx,
    simp only [mem_Ioo, mem_univ_pi] at hx,
    simp only [mem_Union, mem_Ioo, mem_univ_pi, coe_coe],
    let f : Œ≥ n := Œª i, ‚ü®‚åä(x i - a i) * n‚åã‚Çä,
    begin
      apply nat.floor_lt_ceil_of_lt_of_pos,
      { refine (mul_lt_mul_right npos).2 _,
        simp only [(hx i).right, sub_lt_sub_iff_right] },
      { refine mul_pos _ npos,
        simpa only [rat.cast_lt, sub_pos] using H i }
    end‚ü©,
    refine ‚ü®f, Œª i, ‚ü®_, _‚ü©‚ü©,
    { calc (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n
      ‚â§ (a i : ‚Ñù) + ((x i - a i) * n) / n :
          begin
            refine add_le_add le_rfl ((div_le_div_right npos).2 _),
            exact nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le),
          end
      ... = x i : by field_simp [npos.ne'] },
    { calc x i
      = (a i : ‚Ñù) + ((x i - a i) * n) / n : by field_simp [npos.ne']
      ... ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n :
        add_le_add le_rfl ((div_le_div_right npos).2 (nat.lt_floor_add_one _).le) } },
  calc ŒºH[fintype.card Œπ] (set.pi univ (Œª (i : Œπ), Ioo (a i : ‚Ñù) (b i)))
    ‚â§ liminf at_top (Œª (n : ‚Ñï), ‚àë (i : Œ≥ n), diam (t n i) ^ ‚Üë(fintype.card Œπ)) :
      hausdorff_measure_le_liminf_sum _ (set.pi univ (Œª i, Ioo (a i : ‚Ñù) (b i)))
        (Œª (n : ‚Ñï), 1/(n : ‚Ñù‚â•0‚àû)) A t B C
  ... ‚â§ liminf at_top (Œª (n : ‚Ñï), ‚àë (i : Œ≥ n), (1/n) ^ (fintype.card Œπ)) :
    begin
      refine liminf_le_liminf _ (by is_bounded_default),
      filter_upwards [B] with _ hn,
      apply finset.sum_le_sum (Œª i _, _),
      rw ennreal.rpow_nat_cast,
      exact pow_le_pow_of_le_left' (hn i) _,
    end
  ... = liminf at_top (Œª (n : ‚Ñï), ‚àè (i : Œπ), (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) :
  begin
    simp only [finset.card_univ, nat.cast_prod, one_mul, fintype.card_fin,
      finset.sum_const, nsmul_eq_mul, fintype.card_pi, div_eq_mul_inv, finset.prod_mul_distrib,
      finset.prod_const]
  end
  ... = ‚àè (i : Œπ), volume (Ioo (a i : ‚Ñù) (b i)) :
  begin
    simp only [real.volume_Ioo],
    apply tendsto.liminf_eq,
    refine ennreal.tendsto_finset_prod_of_ne_top _ (Œª i hi, _) (Œª i hi, _),
    { apply tendsto.congr' _ ((ennreal.continuous_of_real.tendsto _).comp
        ((tendsto_nat_ceil_mul_div_at_top (I i)).comp tendsto_coe_nat_at_top_at_top)),
      apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©,
      simp only [ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), comp_app,
        ennreal.of_real_coe_nat] },
    { simp only [ennreal.of_real_ne_top, ne.def, not_false_iff] }
  end
end
end measure_theory
open_locale measure_theory
open measure_theory measure_theory.measure
variables [measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y]
namespace holder_on_with
variables {C r : ‚Ñù‚â•0} {f : X ‚Üí Y} {s t : set X}
lemma hausdorff_measure_image_le (h : holder_on_with C r f s) (hr : 0 < r) {d : ‚Ñù} (hd : 0 ‚â§ d) :
  ŒºH[d] (f '' s) ‚â§ C ^ d * ŒºH[r * d] s :=
begin
lemma hausdorff_measure_image_le (h : lipschitz_on_with K f s) {d : ‚Ñù} (hd : 0 ‚â§ d) :
  ŒºH[d] (f '' s) ‚â§ K ^ d * ŒºH[d] s :=
by simpa only [nnreal.coe_one, one_mul]
  using h.holder_on_with.hausdorff_measure_image_le zero_lt_one hd
end lipschitz_on_with
namespace lipschitz_with
variables {K : ‚Ñù‚â•0} {f : X ‚Üí Y}
lemma hausdorff_measure_image_le (h : lipschitz_with K f) {d : ‚Ñù} (hd : 0 ‚â§ d) (s : set X) :
  ŒºH[d] (f '' s) ‚â§ K ^ d * ŒºH[d] s :=
(h.lipschitz_on_with s).hausdorff_measure_image_le hd
end lipschitz_with
namespace antilipschitz_with
variables {f : X ‚Üí Y} {K : ‚Ñù‚â•0} {d : ‚Ñù}
lemma hausdorff_measure_preimage_le (hf : antilipschitz_with K f) (hd : 0 ‚â§ d) (s : set Y) :
  ŒºH[d] (f ‚Åª¬π' s) ‚â§ K ^ d * ŒºH[d] s :=
begin
  rcases eq_or_ne K 0 with rfl|h0,
  { rcases eq_empty_or_nonempty (f ‚Åª¬π' s) with hs|‚ü®x, hx‚ü©,
    { simp only [hs, measure_empty, zero_le], },
    have : f ‚Åª¬π' s = {x},
    { haveI : subsingleton X := hf.subsingleton,
      have : (f ‚Åª¬π' s).subsingleton, from subsingleton_univ.mono (subset_univ _),
      exact (subsingleton_iff_singleton hx).1 this },
    rw this,
    rcases eq_or_lt_of_le hd with rfl|h'd,
    { simp only [ennreal.rpow_zero, one_mul, mul_zero],
      rw hausdorff_measure_zero_singleton,
      exact one_le_hausdorff_measure_zero_of_nonempty ‚ü®f x, hx‚ü© },
    { haveI := no_atoms_hausdorff X h'd,
      simp only [zero_le, measure_singleton] } },
  have hKd0 : (K : ‚Ñù‚â•0‚àû) ^ d ‚â† 0, by simp [h0],
  have hKd : (K : ‚Ñù‚â•0‚àû) ^ d ‚â† ‚àû, by simp [hd],
  simp only [hausdorff_measure_apply, ennreal.mul_supr, ennreal.mul_infi_of_ne hKd0 hKd,
    ‚Üê ennreal.tsum_mul_left],
  refine supr‚ÇÇ_le (Œª Œµ Œµ0, _),
  refine le_supr‚ÇÇ_of_le (Œµ / K) (by simp [Œµ0.ne']) _,
  refine le_infi‚ÇÇ (Œª t hst, le_infi $ Œª htŒµ, _),
  replace hst : f ‚Åª¬π' s ‚äÜ _ := preimage_mono hst, rw preimage_Union at hst,
  refine infi‚ÇÇ_le_of_le _ hst (infi_le_of_le (Œª n, _) _),
  { exact (hf.ediam_preimage_le _).trans (ennreal.mul_le_of_le_div' $ htŒµ n) },
  { refine ennreal.tsum_le_tsum (Œª n, supr_le_iff.2 (Œª hft, _)),
    simp only [nonempty_of_nonempty_preimage hft, csupr_pos],
    rw [‚Üê ennreal.mul_rpow_of_nonneg _ _ hd],
    exact ennreal.rpow_le_rpow (hf.ediam_preimage_le _) hd }
end
lemma le_hausdorff_measure_image (hf : antilipschitz_with K f) (hd : 0 ‚â§ d) (s : set X) :
  ŒºH[d] s ‚â§ K ^ d * ŒºH[d] (f '' s) :=
calc ŒºH[d] s ‚â§ ŒºH[d] (f ‚Åª¬π' (f '' s)) : measure_mono (subset_preimage_image _ _)
         ... ‚â§ K ^ d * ŒºH[d] (f '' s) : hf.hausdorff_measure_preimage_le hd (f '' s)
end antilipschitz_with
namespace isometry
variables {f : X ‚Üí Y} {d : ‚Ñù}
lemma hausdorff_measure_image (hf : isometry f) (hd : 0 ‚â§ d ‚à® surjective f) (s : set X) :
  ŒºH[d] (f '' s) = ŒºH[d] s :=
begin
  simp only [hausdorff_measure, ‚Üê outer_measure.coe_mk_metric, ‚Üê outer_measure.comap_apply],
  rw [outer_measure.isometry_comap_mk_metric _ hf (hd.imp_left _)],
  exact Œª hd x y hxy, ennreal.rpow_le_rpow hxy hd
end
lemma hausdorff_measure_preimage (hf : isometry f) (hd : 0 ‚â§ d ‚à® surjective f) (s : set Y) :
  ŒºH[d] (f ‚Åª¬π' s) = ŒºH[d] (s ‚à© range f) :=
by rw [‚Üê hf.hausdorff_measure_image hd, image_preimage_eq_inter_range]
lemma map_hausdorff_measure (hf : isometry f) (hd : 0 ‚â§ d ‚à® surjective f) :
  measure.map f ŒºH[d] = (ŒºH[d]).restrict (range f) :=
begin
  ext1 s hs,
  rw [map_apply hf.continuous.measurable hs, restrict_apply hs, hf.hausdorff_measure_preimage hd]
end
end isometry
namespace isometric
@[simp] lemma hausdorff_measure_image (e : X ‚âÉ·µ¢ Y) (d : ‚Ñù) (s : set X) :
  ŒºH[d] (e '' s) = ŒºH[d] s :=
e.isometry.hausdorff_measure_image (or.inr e.surjective) s
@[simp] lemma hausdorff_measure_preimage (e : X ‚âÉ·µ¢ Y) (d : ‚Ñù) (s : set Y) :
  ŒºH[d] (e ‚Åª¬π' s) = ŒºH[d] s :=
by rw [‚Üê e.image_symm, e.symm.hausdorff_measure_image]
end isometric
