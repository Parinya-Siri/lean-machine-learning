import category_theory.monoidal.braided
import category_theory.monoidal.discrete
import category_theory.monoidal.coherence_lemmas
import category_theory.limits.shapes.terminal
import algebra.punit_instances
universes vâ‚ vâ‚‚ uâ‚ uâ‚‚ u
open category_theory
open category_theory.monoidal_category
variables (C : Type uâ‚) [category.{vâ‚} C] [monoidal_category.{vâ‚} C]
structure Mon_ :=
(X : C)
(one : ğŸ™_ C âŸ¶ X)
(mul : X âŠ— X âŸ¶ X)
(one_mul' : (one âŠ— ğŸ™ X) â‰« mul = (Î»_ X).hom . obviously)
(mul_one' : (ğŸ™ X âŠ— one) â‰« mul = (Ï_ X).hom . obviously)
@[simps]
def trivial : Mon_ C :=
{ X := ğŸ™_ C,
  one := ğŸ™ _,
  mul := (Î»_ _).hom,
  mul_assoc' := by coherence,
  mul_one' := by coherence }
instance : inhabited (Mon_ C) := âŸ¨trivial CâŸ©
variables {C} {M : Mon_ C}
@[simp] lemma one_mul_hom {Z : C} (f : Z âŸ¶ M.X) : (M.one âŠ— f) â‰« M.mul = (Î»_ Z).hom â‰« f :=
by rw [â†id_tensor_comp_tensor_id, category.assoc, M.one_mul, left_unitor_naturality]
@[simp] lemma mul_one_hom {Z : C} (f : Z âŸ¶ M.X) : (f âŠ— M.one) â‰« M.mul = (Ï_ Z).hom â‰« f :=
by rw [â†tensor_id_comp_id_tensor, category.assoc, M.mul_one, right_unitor_naturality]
lemma assoc_flip : (ğŸ™ M.X âŠ— M.mul) â‰« M.mul = (Î±_ M.X M.X M.X).inv â‰« (M.mul âŠ— ğŸ™ M.X) â‰« M.mul :=
by simp
@[ext]
structure hom (M N : Mon_ C) :=
(hom : M.X âŸ¶ N.X)
(one_hom' : M.one â‰« hom = N.one . obviously)
(mul_hom' : M.mul â‰« hom = (hom âŠ— hom) â‰« N.mul . obviously)
restate_axiom hom.one_hom'
restate_axiom hom.mul_hom'
attribute [simp, reassoc] hom.one_hom hom.mul_hom
@[simps]
def id (M : Mon_ C) : hom M M :=
{ hom := ğŸ™ M.X, }
instance hom_inhabited (M : Mon_ C) : inhabited (hom M M) := âŸ¨id MâŸ©
@[simps]
def comp {M N O : Mon_ C} (f : hom M N) (g : hom N O) : hom M O :=
{ hom := f.hom â‰« g.hom, }
instance : category (Mon_ C) :=
{ hom := Î» M N, hom M N,
  id := id,
  comp := Î» M N O f g, comp f g, }
@[simp] lemma id_hom' (M : Mon_ C) : (ğŸ™ M : hom M M).hom = ğŸ™ M.X := rfl
@[simp] lemma comp_hom' {M N K : Mon_ C} (f : M âŸ¶ N) (g : N âŸ¶ K) :
  (f â‰« g : hom M K).hom = f.hom â‰« g.hom := rfl
section
variables (C)
@[simps]
def forget : Mon_ C â¥¤ C :=
{ obj := Î» A, A.X,
  map := Î» A B f, f.hom, }
end
instance forget_faithful : faithful (@forget C _ _) := { }
instance {A B : Mon_ C} (f : A âŸ¶ B) [e : is_iso ((forget C).map f)] : is_iso f.hom := e
instance : reflects_isomorphisms (forget C) :=
{ reflects := Î» X Y f e, by exactI âŸ¨âŸ¨
{ hom := inv f.hom,
  mul_hom' :=
  begin
    simp only [is_iso.comp_inv_eq, hom.mul_hom, category.assoc, â†tensor_comp_assoc,
      is_iso.inv_hom_id, tensor_id, category.id_comp],
  end }, by tidyâŸ©âŸ© }
def iso_of_iso {M N : Mon_ C}
  (f : M.X â‰… N.X)
  (one_f : M.one â‰« f.hom = N.one)
  (mul_f : M.mul â‰« f.hom = (f.hom âŠ— f.hom) â‰« N.mul) :
  M â‰… N :=
{ hom := { hom := f.hom, one_hom' := one_f, mul_hom' := mul_f },
  inv :=
  { hom := f.inv,
    one_hom' := by { rw â†one_f, simp },
    mul_hom' :=
    begin
      rw â†(cancel_mono f.hom),
      slice_rhs 2 3 { rw mul_f },
      simp,
    end } }
instance unique_hom_from_trivial (A : Mon_ C) : unique (trivial C âŸ¶ A) :=
{ default :=
  { hom := A.one,
    one_hom' := by { dsimp, simp, },
    mul_hom' := by { dsimp, simp [A.one_mul, unitors_equal], } },
  uniq := Î» f,
  begin
    ext, simp,
    rw [â†category.id_comp f.hom],
    erw f.one_hom,
  end }
open category_theory.limits
instance : has_initial (Mon_ C) :=
has_initial_of_unique (trivial C)
end Mon_
namespace category_theory.lax_monoidal_functor
variables {C} {D : Type uâ‚‚} [category.{vâ‚‚} D] [monoidal_category.{vâ‚‚} D]
def map_Mon_functor : (lax_monoidal_functor C D) â¥¤ (Mon_ C â¥¤ Mon_ D) :=
{ obj := map_Mon,
  map := Î» F G Î±,
  { app := Î» A,
    { hom := Î±.app A.X, } } }
end category_theory.lax_monoidal_functor
namespace Mon_
open category_theory.lax_monoidal_functor
namespace equiv_lax_monoidal_functor_punit
@[simps]
def lax_monoidal_to_Mon : lax_monoidal_functor (discrete punit.{u+1}) C â¥¤ Mon_ C :=
{ obj := Î» F, (F.map_Mon : Mon_ _ â¥¤ Mon_ C).obj (trivial (discrete punit)),
  map := Î» F G Î±, ((map_Mon_functor (discrete punit) C).map Î±).app _ }
@[simps]
def Mon_to_lax_monoidal : Mon_ C â¥¤ lax_monoidal_functor (discrete punit.{u+1}) C :=
{ obj := Î» A,
  { obj := Î» _, A.X,
    map := Î» _ _ _, ğŸ™ _,
    Îµ := A.one,
    Î¼ := Î» _ _, A.mul,
    map_id' := Î» _, rfl,
    map_comp' := Î» _ _ _ _ _, (category.id_comp (ğŸ™ A.X)).symm, },
  map := Î» A B f,
  { app := Î» _, f.hom,
    naturality' := Î» _ _ _, by { dsimp, rw [category.id_comp, category.comp_id], },
    unit' := f.one_hom,
    tensor' := Î» _ _, f.mul_hom, }, }
local attribute [tidy] tactic.discrete_cases
local attribute [simp] eq_to_iso_map
@[simps]
def unit_iso :
  ğŸ­ (lax_monoidal_functor (discrete punit.{u+1}) C) â‰…
    lax_monoidal_to_Mon C â‹™ Mon_to_lax_monoidal C :=
nat_iso.of_components (Î» F,
  monoidal_nat_iso.of_components
    (Î» _, F.to_functor.map_iso (eq_to_iso (by ext)))
    (by tidy) (by tidy) (by tidy))
  (by tidy)
@[simps]
def counit_iso : Mon_to_lax_monoidal C â‹™ lax_monoidal_to_Mon C â‰… ğŸ­ (Mon_ C) :=
nat_iso.of_components (Î» F, { hom := { hom := ğŸ™ _, }, inv := { hom := ğŸ™ _, } })
  (by tidy)
end equiv_lax_monoidal_functor_punit
open equiv_lax_monoidal_functor_punit
local attribute [simp] eq_to_iso_map
@[simps]
def equiv_lax_monoidal_functor_punit : lax_monoidal_functor (discrete punit.{u+1}) C â‰Œ Mon_ C :=
{ functor := lax_monoidal_to_Mon C,
  inverse := Mon_to_lax_monoidal C,
  unit_iso := unit_iso C,
  counit_iso := counit_iso C, }
end Mon_
namespace Mon_
variable {C}
