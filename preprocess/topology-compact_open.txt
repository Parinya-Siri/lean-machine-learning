import tactic.tidy
import topology.continuous_function.basic
import topology.homeomorph
import topology.subset_properties
import topology.maps
open set
open_locale topological_space
namespace continuous_map
section compact_open
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*}
variables [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥]
def compact_open.gen (s : set Œ±) (u : set Œ≤) : set C(Œ±,Œ≤) := {f | f '' s ‚äÜ u}
@[simp] lemma gen_empty (u : set Œ≤) : compact_open.gen (‚àÖ : set Œ±) u = set.univ :=
set.ext (Œª f, iff_true_intro ((congr_arg (‚äÜ u) (image_empty f)).mpr u.empty_subset))
@[simp] lemma gen_univ (s : set Œ±) : compact_open.gen s (set.univ : set Œ≤) = set.univ :=
set.ext (Œª f, iff_true_intro (f '' s).subset_univ)
@[simp] lemma gen_inter (s : set Œ±) (u v : set Œ≤) :
  compact_open.gen s (u ‚à© v) = compact_open.gen s u ‚à© compact_open.gen s v :=
set.ext (Œª f, subset_inter_iff)
@[simp] lemma gen_union (s t : set Œ±) (u : set Œ≤) :
  compact_open.gen (s ‚à™ t) u = compact_open.gen s u ‚à© compact_open.gen t u :=
set.ext (Œª f, (iff_of_eq (congr_arg (‚äÜ u) (image_union f s t))).trans union_subset_iff)
lemma gen_empty_right {s : set Œ±} (h : s.nonempty) : compact_open.gen s (‚àÖ : set Œ≤) = ‚àÖ :=
eq_empty_of_forall_not_mem $ Œª f, (h.image _).not_subset_empty
lemma continuous_comp : continuous (continuous_map.comp g : C(Œ±, Œ≤) ‚Üí C(Œ±, Œ≥)) :=
continuous_generated_from $ assume m ‚ü®s, hs, u, hu, hm‚ü©,
  by rw [hm, preimage_gen g hs hu]; exact continuous_map.is_open_gen hs (hu.preimage g.2)
variable (f : C(Œ±, Œ≤))
private lemma image_gen {s : set Œ±} (hs : is_compact s) {u : set Œ≥} (hu : is_open u) :
  (Œª g : C(Œ≤, Œ≥), g.comp f) ‚Åª¬π' compact_open.gen s u = compact_open.gen (f '' s) u :=
begin
  ext ‚ü®g, _‚ü©,
  change g ‚àò f '' s ‚äÜ u ‚Üî g '' (f '' s) ‚äÜ u,
  rw set.image_comp,
end
lemma continuous_comp_left : continuous (Œª g, g.comp f : C(Œ≤, Œ≥) ‚Üí C(Œ±, Œ≥)) :=
continuous_generated_from $ assume m ‚ü®s, hs, u, hu, hm‚ü©,
  by { rw [hm, image_gen f hs hu], exact continuous_map.is_open_gen (hs.image f.2) hu }
end functorial
section ev
variables {Œ± Œ≤}
lemma continuous_eval' [locally_compact_space Œ±] : continuous (Œª p : C(Œ±, Œ≤) √ó Œ±, p.1 p.2) :=
continuous_iff_continuous_at.mpr $ assume ‚ü®f, x‚ü© n hn,
  let ‚ü®v, vn, vo, fxv‚ü© := mem_nhds_iff.mp hn in
  have v ‚àà ùìù (f x), from is_open.mem_nhds vo fxv,
  let ‚ü®s, hs, sv, sc‚ü© :=
    locally_compact_space.local_compact_nhds x (f ‚Åª¬π' v)
      (f.continuous.tendsto x this) in
  let ‚ü®u, us, uo, xu‚ü© := mem_nhds_iff.mp hs in
  show (Œª p : C(Œ±, Œ≤) √ó Œ±, p.1 p.2) ‚Åª¬π' n ‚àà ùìù (f, x), from
  let w := compact_open.gen s v √óÀ¢ u in
  have w ‚äÜ (Œª p : C(Œ±, Œ≤) √ó Œ±, p.1 p.2) ‚Åª¬π' n, from assume ‚ü®f', x'‚ü© ‚ü®hf', hx'‚ü©, calc
    f' x' ‚àà f' '' s  : mem_image_of_mem f' (us hx')
    ...       ‚äÜ v            : hf'
    ...       ‚äÜ n            : vn,
  have is_open w, from (continuous_map.is_open_gen sc vo).prod uo,
  have (f, x) ‚àà w, from ‚ü®image_subset_iff.mpr sv, xu‚ü©,
  mem_nhds_iff.mpr ‚ü®w, by assumption, by assumption, by assumption‚ü©
lemma continuous_eval_const' [locally_compact_space Œ±] (a : Œ±) : continuous (Œª f : C(Œ±, Œ≤), f a) :=
continuous_eval'.comp (continuous_id.prod_mk continuous_const)
lemma continuous_coe' [locally_compact_space Œ±] : @continuous (C(Œ±, Œ≤)) (Œ± ‚Üí Œ≤) _ _ coe_fn :=
continuous_pi continuous_eval_const'
instance [t2_space Œ≤] : t2_space C(Œ±, Œ≤) :=
‚ü® begin
    intros f‚ÇÅ f‚ÇÇ h,
    obtain ‚ü®x, hx‚ü© := not_forall.mp (mt (fun_like.ext f‚ÇÅ f‚ÇÇ) h),
    obtain ‚ü®u, v, hu, hv, hxu, hxv, huv‚ü© := t2_separation hx,
    refine ‚ü®compact_open.gen {x} u, compact_open.gen {x} v, continuous_map.is_open_gen
      is_compact_singleton hu, continuous_map.is_open_gen is_compact_singleton hv, _, _, _‚ü©,
    { rwa [compact_open.gen, mem_set_of_eq, image_singleton, singleton_subset_iff] },
    { rwa [compact_open.gen, mem_set_of_eq, image_singleton, singleton_subset_iff] },
    { rw [disjoint_iff_inter_eq_empty, ‚Üêgen_inter, huv.inter_eq,
        gen_empty_right (singleton_nonempty _)] }
  end ‚ü©
end ev
section Inf_induced
lemma compact_open_le_induced (s : set Œ±) :
  (continuous_map.compact_open : topological_space C(Œ±, Œ≤))
  ‚â§ topological_space.induced (continuous_map.restrict s) continuous_map.compact_open :=
begin
  simp only [induced_generate_from_eq, continuous_map.compact_open],
  apply generate_from_mono,
  rintros b ‚ü®a, ‚ü®c, hc, u, hu, rfl‚ü©, rfl‚ü©,
  refine ‚ü®coe '' c, hc.image continuous_subtype_coe, u, hu, _‚ü©,
  ext f,
  simp only [compact_open.gen, mem_set_of_eq, mem_preimage, continuous_map.coe_restrict],
  rw image_comp f (coe : s ‚Üí Œ±),
end
lemma compact_open_eq_Inf_induced :
  (continuous_map.compact_open : topological_space C(Œ±, Œ≤))
  = ‚®Ö (s : set Œ±) (hs : is_compact s),
    topological_space.induced (continuous_map.restrict s) continuous_map.compact_open :=
begin
  refine le_antisymm _ _,
  { refine le_infi‚ÇÇ _,
    exact Œª s hs, compact_open_le_induced s },
  simp only [‚Üê generate_from_Union, induced_generate_from_eq, continuous_map.compact_open],
  apply generate_from_mono,
  rintros _ ‚ü®s, hs, u, hu, rfl‚ü©,
  rw mem_Union‚ÇÇ,
  refine ‚ü®s, hs, _, ‚ü®univ, is_compact_iff_is_compact_univ.mp hs, u, hu, rfl‚ü©, _‚ü©,
  ext f,
  simp only [compact_open.gen, mem_set_of_eq, mem_preimage, continuous_map.coe_restrict],
  rw image_comp f (coe : s ‚Üí Œ±),
  simp
end
lemma continuous_restrict (s : set Œ±) : continuous (Œª F : C(Œ±, Œ≤), F.restrict s) :=
by { rw continuous_iff_le_induced, exact compact_open_le_induced s }
lemma nhds_compact_open_eq_Inf_nhds_induced (f : C(Œ±, Œ≤)) :
  ùìù f = ‚®Ö s (hs : is_compact s), (ùìù (f.restrict s)).comap (continuous_map.restrict s) :=
by { rw [compact_open_eq_Inf_induced], simp [nhds_infi, nhds_induced] }
lemma tendsto_compact_open_restrict {Œπ : Type*} {l : filter Œπ} {F : Œπ ‚Üí C(Œ±, Œ≤)} {f : C(Œ±, Œ≤)}
  (hFf : filter.tendsto F l (ùìù f)) (s : set Œ±) :
  filter.tendsto (Œª i, (F i).restrict s) l (ùìù (f.restrict s)) :=
(continuous_restrict s).continuous_at.tendsto.comp hFf
lemma tendsto_compact_open_iff_forall {Œπ : Type*} {l : filter Œπ} (F : Œπ ‚Üí C(Œ±, Œ≤)) (f : C(Œ±, Œ≤)) :
  filter.tendsto F l (ùìù f)
  ‚Üî ‚àÄ s (hs : is_compact s), filter.tendsto (Œª i, (F i).restrict s) l (ùìù (f.restrict s)) :=
by { rw [compact_open_eq_Inf_induced], simp [nhds_infi, nhds_induced, filter.tendsto_comap_iff] }
lemma exists_tendsto_compact_open_iff_forall [locally_compact_space Œ±] [t2_space Œ±] [t2_space Œ≤]
  {Œπ : Type*} {l : filter Œπ} [filter.ne_bot l] (F : Œπ ‚Üí C(Œ±, Œ≤)) :
  (‚àÉ f, filter.tendsto F l (ùìù f))
  ‚Üî ‚àÄ (s : set Œ±) (hs : is_compact s), ‚àÉ f, filter.tendsto (Œª i, (F i).restrict s) l (ùìù f) :=
begin
  split,
  { rintros ‚ü®f, hf‚ü© s hs,
    exact ‚ü®f.restrict s, tendsto_compact_open_restrict hf s‚ü© },
  { intros h,
    choose f hf using h,
def coev (b : Œ≤) : C(Œ±, Œ≤ √ó Œ±) := ‚ü®prod.mk b, continuous_const.prod_mk continuous_id‚ü©
variables {Œ± Œ≤}
lemma image_coev {y : Œ≤} (s : set Œ±) : (coev Œ± Œ≤ y) '' s = ({y} : set Œ≤) √óÀ¢ s := by tidy
def curry' (f : C(Œ± √ó Œ≤, Œ≥)) (a : Œ±) : C(Œ≤, Œ≥) := ‚ü®function.curry f a‚ü©
lemma continuous_curry' (f : C(Œ± √ó Œ≤, Œ≥)) : continuous (curry' f) :=
have hf : curry' f = continuous_map.comp f ‚àò coev _ _, by { ext, refl },
hf ‚ñ∏ continuous.comp (continuous_comp f) continuous_coev
lemma continuous_of_continuous_uncurry (f : Œ± ‚Üí C(Œ≤, Œ≥))
  (h : continuous (function.uncurry (Œª x y, f x y))) : continuous f :=
by { convert continuous_curry' ‚ü®_, h‚ü©, ext, refl }
def curry (f : C(Œ± √ó Œ≤, Œ≥)) : C(Œ±, C(Œ≤, Œ≥)) :=
‚ü®_, continuous_curry' f‚ü©
lemma continuous_curry [locally_compact_space (Œ± √ó Œ≤)] :
  continuous (curry : C(Œ± √ó Œ≤, Œ≥) ‚Üí C(Œ±, C(Œ≤, Œ≥))) :=
begin
  apply continuous_of_continuous_uncurry,
  apply continuous_of_continuous_uncurry,
  rw ‚Üêhomeomorph.comp_continuous_iff' (homeomorph.prod_assoc _ _ _).symm,
  convert continuous_eval';
  tidy
end
@[simp]
lemma curry_apply (f : C(Œ± √ó Œ≤, Œ≥)) (a : Œ±) (b : Œ≤) : f.curry a b = f (a, b) := rfl
lemma continuous_uncurry_of_continuous [locally_compact_space Œ≤] (f : C(Œ±, C(Œ≤, Œ≥))) :
  continuous (function.uncurry (Œª x y, f x y)) :=
continuous_eval'.comp $ f.continuous.prod_map continuous_id
def uncurry [locally_compact_space Œ≤] (f : C(Œ±, C(Œ≤, Œ≥))) : C(Œ± √ó Œ≤, Œ≥) :=
‚ü®_, continuous_uncurry_of_continuous f‚ü©
lemma continuous_uncurry [locally_compact_space Œ±] [locally_compact_space Œ≤] :
  continuous (uncurry : C(Œ±, C(Œ≤, Œ≥)) ‚Üí C(Œ± √ó Œ≤, Œ≥)) :=
begin
  apply continuous_of_continuous_uncurry,
  rw ‚Üêhomeomorph.comp_continuous_iff' (homeomorph.prod_assoc _ _ _),
  apply continuous.comp continuous_eval' (continuous.prod_map continuous_eval' continuous_id);
  apply_instance
end
def const' : C(Œ≤, C(Œ±, Œ≤)) := curry ‚ü®prod.fst, continuous_fst‚ü©
@[simp] lemma coe_const' : (const' : Œ≤ ‚Üí C(Œ±, Œ≤)) = const Œ± := rfl
lemma continuous_const' : continuous (const Œ± : Œ≤ ‚Üí C(Œ±, Œ≤)) := const'.continuous
end curry
end compact_open
end continuous_map
open continuous_map
namespace homeomorph
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*}
variables [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥]
def curry [locally_compact_space Œ±] [locally_compact_space Œ≤] : C(Œ± √ó Œ≤, Œ≥) ‚âÉ‚Çú C(Œ±, C(Œ≤, Œ≥)) :=
‚ü®‚ü®curry, uncurry, by tidy, by tidy‚ü©, continuous_curry, continuous_uncurry‚ü©
def continuous_map_of_unique [unique Œ±] : Œ≤ ‚âÉ‚Çú C(Œ±, Œ≤) :=
{ to_fun := const Œ±,
  inv_fun := Œª f, f default,
  left_inv := Œª a, rfl,
  right_inv := Œª f, by { ext, rw unique.eq_default a, refl },
  continuous_to_fun := continuous_const',
  continuous_inv_fun := continuous_eval'.comp (continuous_id.prod_mk continuous_const) }
@[simp] lemma continuous_map_of_unique_apply [unique Œ±] (b : Œ≤) (a : Œ±) :
  continuous_map_of_unique b a = b :=
rfl
@[simp] lemma continuous_map_of_unique_symm_apply [unique Œ±] (f : C(Œ±, Œ≤)) :
  continuous_map_of_unique.symm f = f default :=
rfl
end homeomorph
section quotient_map
variables {X‚ÇÄ X Y Z : Type*} [topological_space X‚ÇÄ] [topological_space X]
  [topological_space Y] [topological_space Z] [locally_compact_space Y] {f : X‚ÇÄ ‚Üí X}
lemma quotient_map.continuous_lift_prod_left (hf : quotient_map f) {g : X √ó Y ‚Üí Z}
  (hg : continuous (Œª p : X‚ÇÄ √ó Y, g (f p.1, p.2))) : continuous g :=
begin
  let Gf : C(X‚ÇÄ, C(Y, Z)) := continuous_map.curry ‚ü®_, hg‚ü©,
  have h : ‚àÄ x : X, continuous (Œª y, g (x, y)),
  { intros x,
    obtain ‚ü®x‚ÇÄ, rfl‚ü© := hf.surjective x,
    exact (Gf x‚ÇÄ).continuous },
  let G : X ‚Üí C(Y, Z) := Œª x, ‚ü®_, h x‚ü©,
  have : continuous G,
  { rw hf.continuous_iff,
    exact Gf.continuous },
  convert continuous_map.continuous_uncurry_of_continuous ‚ü®G, this‚ü©,
  ext x,
  cases x,
  refl,
end
lemma quotient_map.continuous_lift_prod_right (hf : quotient_map f) {g : Y √ó X ‚Üí Z}
  (hg : continuous (Œª p : Y √ó X‚ÇÄ, g (p.1, f p.2))) : continuous g :=
begin
  have : continuous (Œª p : X‚ÇÄ √ó Y, g ((prod.swap p).1, f (prod.swap p).2)),
  { exact hg.comp continuous_swap },
  have : continuous (Œª p : X‚ÇÄ √ó Y, (g ‚àò prod.swap) (f p.1, p.2)) := this,
  convert (hf.continuous_lift_prod_left this).comp continuous_swap,
  ext x,
  simp,
end
end quotient_map
