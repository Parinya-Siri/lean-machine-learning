import analysis.normed.field.basic
import analysis.normed.group.infinite_sum
import data.matrix.basic
import topology.sequences
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œπ : Type*}
noncomputable theory
open filter metric function set
open_locale topological_space big_operators nnreal ennreal uniformity pointwise
section semi_normed_group
section prio
set_option extends_priority 920
class normed_space (Œ± : Type*) (Œ≤ : Type*) [normed_field Œ±] [semi_normed_group Œ≤]
  extends module Œ± Œ≤ :=
(norm_smul_le : ‚àÄ (a:Œ±) (b:Œ≤), ‚à•a ‚Ä¢ b‚à• ‚â§ ‚à•a‚à• * ‚à•b‚à•)
end prio
variables [normed_field Œ±] [semi_normed_group Œ≤]
@[simps { attrs := [] }]
def homeomorph_unit_ball {E : Type*} [semi_normed_group E] [normed_space ‚Ñù E] :
  E ‚âÉ‚Çú ball (0 : E) 1 :=
{ to_fun := Œª x, ‚ü®(1 + ‚à•x‚à•)‚Åª¬π ‚Ä¢ x, begin
    have : ‚à•x‚à• < |1 + ‚à•x‚à•| := (lt_one_add _).trans_le (le_abs_self _),
    rwa [mem_ball_zero_iff, norm_smul, real.norm_eq_abs, abs_inv, ‚Üê div_eq_inv_mul,
      div_lt_one ((norm_nonneg x).trans_lt this)],
  end‚ü©,
  inv_fun := Œª x, (1 - ‚à•(x : E)‚à•)‚Åª¬π ‚Ä¢ (x : E),
  left_inv := Œª x,
    begin
      have : 0 < 1 + ‚à•x‚à• := (norm_nonneg x).trans_lt (lt_one_add _),
      field_simp [this.ne', abs_of_pos this, norm_smul, smul_smul, abs_div]
    end,
  right_inv := Œª x, subtype.ext
    begin
      have : 0 < 1 - ‚à•(x : E)‚à• := sub_pos.2 (mem_ball_zero_iff.1 x.2),
      field_simp [norm_smul, smul_smul, abs_div, abs_of_pos this, this.ne']
    end,
  continuous_to_fun := continuous_subtype_mk _ $
    ((continuous_const.add continuous_norm).inv‚ÇÄ
      (Œª x, ((norm_nonneg x).trans_lt (lt_one_add _)).ne')).smul continuous_id,
  continuous_inv_fun := continuous.smul
    ((continuous_const.sub continuous_subtype_coe.norm).inv‚ÇÄ $
      Œª x, (sub_pos.2 $ mem_ball_zero_iff.1 x.2).ne') continuous_subtype_coe }
open normed_field
instance : normed_space Œ± (ulift E) :=
{ norm_smul_le := Œª s x, (normed_space.norm_smul_le s x.down : _),
  ..ulift.normed_group,
  ..ulift.module' }
instance prod.normed_space : normed_space Œ± (E √ó F) :=
{ norm_smul_le := Œª s x, le_of_eq $ by simp [prod.norm_def, norm_smul, mul_max_of_nonneg],
  ..prod.normed_group,
  ..prod.module }
instance pi.normed_space {E : Œπ ‚Üí Type*} [fintype Œπ] [‚àÄi, semi_normed_group (E i)]
  [‚àÄi, normed_space Œ± (E i)] : normed_space Œ± (Œ†i, E i) :=
{ norm_smul_le := Œª a f, le_of_eq $
    show (‚Üë(finset.sup finset.univ (Œª (b : Œπ), ‚à•a ‚Ä¢ f b‚à•‚Çä)) : ‚Ñù) =
      ‚à•a‚à•‚Çä * ‚Üë(finset.sup finset.univ (Œª (b : Œπ), ‚à•f b‚à•‚Çä)),
    by simp only [(nnreal.coe_mul _ _).symm, nnreal.mul_finset_sup, nnnorm_smul] }
instance submodule.normed_space {ùïú R : Type*} [has_smul ùïú R] [normed_field ùïú] [ring R]
  {E : Type*} [semi_normed_group E] [normed_space ùïú E] [module R E]
  [is_scalar_tower ùïú R E] (s : submodule R E) :
  normed_space ùïú s :=
{ norm_smul_le := Œªc x, le_of_eq $ norm_smul c (x : E) }
lemma rescale_to_shell_semi_normed {c : Œ±} (hc : 1 < ‚à•c‚à•) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) {x : E}
  (hx : ‚à•x‚à• ‚â† 0) : ‚àÉd:Œ±, d ‚â† 0 ‚àß ‚à•d ‚Ä¢ x‚à• < Œµ ‚àß (Œµ/‚à•c‚à• ‚â§ ‚à•d ‚Ä¢ x‚à•) ‚àß (‚à•d‚à•‚Åª¬π ‚â§ Œµ‚Åª¬π * ‚à•c‚à• * ‚à•x‚à•) :=
begin
  have xŒµpos : 0 < ‚à•x‚à•/Œµ := div_pos ((ne.symm hx).le_iff_lt.1 (norm_nonneg x)) Œµpos,
  rcases exists_mem_Ico_zpow xŒµpos hc with ‚ü®n, hn‚ü©,
  have cpos : 0 < ‚à•c‚à• := lt_trans (zero_lt_one : (0 :‚Ñù) < 1) hc,
  have cnpos : 0 < ‚à•c^(n+1)‚à• := by { rw norm_zpow, exact lt_trans xŒµpos hn.2 },
  refine ‚ü®(c^(n+1))‚Åª¬π, _, _, _, _‚ü©,
  show (c ^ (n + 1))‚Åª¬π  ‚â† 0,
    by rwa [ne.def, inv_eq_zero, ‚Üê ne.def, ‚Üê norm_pos_iff],
  show ‚à•(c ^ (n + 1))‚Åª¬π ‚Ä¢ x‚à• < Œµ,
  { rw [norm_smul, norm_inv, ‚Üê div_eq_inv_mul, div_lt_iff cnpos, mul_comm, norm_zpow],
    exact (div_lt_iff Œµpos).1 (hn.2) },
  show Œµ / ‚à•c‚à• ‚â§ ‚à•(c ^ (n + 1))‚Åª¬π ‚Ä¢ x‚à•,
  { rw [div_le_iff cpos, norm_smul, norm_inv, norm_zpow, zpow_add‚ÇÄ (ne_of_gt cpos),
        zpow_one, mul_inv_rev, mul_comm, ‚Üê mul_assoc, ‚Üê mul_assoc, mul_inv_cancel (ne_of_gt cpos),
        one_mul, ‚Üê div_eq_inv_mul, le_div_iff (zpow_pos_of_pos cpos _), mul_comm],
    exact (le_div_iff Œµpos).1 hn.1 },
  show ‚à•(c ^ (n + 1))‚Åª¬π‚à•‚Åª¬π ‚â§ Œµ‚Åª¬π * ‚à•c‚à• * ‚à•x‚à•,
  { have : Œµ‚Åª¬π * ‚à•c‚à• * ‚à•x‚à• = Œµ‚Åª¬π * ‚à•x‚à• * ‚à•c‚à•, by ring,
    rw [norm_inv, inv_inv, norm_zpow, zpow_add‚ÇÄ (ne_of_gt cpos), zpow_one, this, ‚Üê div_eq_inv_mul],
    exact mul_le_mul_of_nonneg_right hn.1 (norm_nonneg _) }
end
end semi_normed_group
section normed_group
variables [normed_field Œ±]
variables {E : Type*} [normed_group E] [normed_space Œ± E]
variables {F : Type*} [normed_group F] [normed_space Œ± F]
open normed_field
@[priority 100]
instance normed_space.to_module' : module Œ± F := normed_space.to_module
section surj
variables (E) [normed_space ‚Ñù E] [nontrivial E]
lemma exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚à•x‚à• = c :=
begin
  rcases exists_ne (0 : E) with ‚ü®x, hx‚ü©,
  rw ‚Üê norm_ne_zero_iff at hx,
  use c ‚Ä¢ ‚à•x‚à•‚Åª¬π ‚Ä¢ x,
  simp [norm_smul, real.norm_of_nonneg hc, hx]
end
@[simp] lemma range_norm : range (norm : E ‚Üí ‚Ñù) = Ici 0 :=
subset.antisymm (range_subset_iff.2 norm_nonneg) (Œª _, exists_norm_eq E)
lemma nnnorm_surjective : surjective (nnnorm : E ‚Üí ‚Ñù‚â•0) :=
Œª c, (exists_norm_eq E c.coe_nonneg).imp $ Œª x h, nnreal.eq h
@[simp] lemma range_nnnorm : range (nnnorm : E ‚Üí ‚Ñù‚â•0) = univ :=
(nnnorm_surjective E).range_eq
end surj
theorem interior_closed_ball' [normed_space ‚Ñù E] [nontrivial E] (x : E) (r : ‚Ñù) :
  interior (closed_ball x r) = ball x r :=
begin
  rcases eq_or_ne r 0 with rfl|hr,
  { rw [closed_ball_zero, ball_zero, interior_singleton] },
  { exact interior_closed_ball x hr }
end
theorem frontier_closed_ball' [normed_space ‚Ñù E] [nontrivial E] (x : E) (r : ‚Ñù) :
  frontier (closed_ball x r) = sphere x r :=
by rw [frontier, closure_closed_ball, interior_closed_ball' x r, closed_ball_diff_ball]
variables {Œ±}
lemma rescale_to_shell {c : Œ±} (hc : 1 < ‚à•c‚à•) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) {x : E} (hx : x ‚â† 0) :
  ‚àÉd:Œ±, d ‚â† 0 ‚àß ‚à•d ‚Ä¢ x‚à• < Œµ ‚àß (Œµ/‚à•c‚à• ‚â§ ‚à•d ‚Ä¢ x‚à•) ‚àß (‚à•d‚à•‚Åª¬π ‚â§ Œµ‚Åª¬π * ‚à•c‚à• * ‚à•x‚à•) :=
rescale_to_shell_semi_normed hc Œµpos (ne_of_lt (norm_pos_iff.2 hx)).symm
end normed_group
section normed_space_nondiscrete
variables (ùïú E : Type*) [nondiscrete_normed_field ùïú] [normed_group E] [normed_space ùïú E]
  [nontrivial E]
include ùïú
lemma normed_space.exists_lt_norm (c : ‚Ñù) : ‚àÉ x : E, c < ‚à•x‚à• :=
begin
  rcases exists_ne (0 : E) with ‚ü®x, hx‚ü©,
  rcases normed_field.exists_lt_norm ùïú (c / ‚à•x‚à•) with ‚ü®r, hr‚ü©,
  use r ‚Ä¢ x,
  rwa [norm_smul, ‚Üê div_lt_iff],
  rwa norm_pos_iff
end
protected lemma normed_space.unbounded_univ : ¬¨bounded (univ : set E) :=
Œª h, let ‚ü®R, hR‚ü© := bounded_iff_forall_norm_le.1 h, ‚ü®x, hx‚ü© := normed_space.exists_lt_norm ùïú E R
in hx.not_le (hR x trivial)
protected lemma normed_space.noncompact_space : noncompact_space E :=
‚ü®Œª h, normed_space.unbounded_univ ùïú _ h.bounded‚ü©
@[priority 100]
instance nondiscrete_normed_field.noncompact_space : noncompact_space ùïú :=
normed_space.noncompact_space ùïú ùïú
omit ùïú
@[priority 100]
instance real_normed_space.noncompact_space [normed_space ‚Ñù E] : noncompact_space E :=
normed_space.noncompact_space ‚Ñù E
end normed_space_nondiscrete
section normed_algebra
class normed_algebra (ùïú : Type*) (ùïú' : Type*) [normed_field ùïú] [semi_normed_ring ùïú']
  extends algebra ùïú ùïú' :=
(norm_smul_le : ‚àÄ (r : ùïú) (x : ùïú'), ‚à•r ‚Ä¢ x‚à• ‚â§ ‚à•r‚à• * ‚à•x‚à•)
variables {ùïú : Type*} (ùïú' : Type*) [normed_field ùïú] [semi_normed_ring ùïú'] [normed_algebra ùïú ùïú']
@[priority 100]
instance normed_algebra.to_normed_space : normed_space ùïú ùïú' :=
{ norm_smul_le := normed_algebra.norm_smul_le }
@[priority 100]
instance normed_algebra.to_normed_space' {ùïú'} [normed_ring ùïú'] [normed_algebra ùïú ùïú'] :
  normed_space ùïú ùïú' := by apply_instance
lemma norm_algebra_map (x : ùïú) : ‚à•algebra_map ùïú ùïú' x‚à• = ‚à•x‚à• * ‚à•(1 : ùïú')‚à• :=
begin
  rw algebra.algebra_map_eq_smul_one,
  exact norm_smul _ _,
end
lemma nnnorm_algebra_map (x : ùïú) : ‚à•algebra_map ùïú ùïú' x‚à•‚Çä = ‚à•x‚à•‚Çä * ‚à•(1 : ùïú')‚à•‚Çä :=
subtype.ext $ norm_algebra_map ùïú' x
@[simp] lemma norm_algebra_map' [norm_one_class ùïú'] (x : ùïú) : ‚à•algebra_map ùïú ùïú' x‚à• = ‚à•x‚à• :=
by rw [norm_algebra_map, norm_one, mul_one]
@[simp] lemma nnnorm_algebra_map' [norm_one_class ùïú'] (x : ùïú) : ‚à•algebra_map ùïú ùïú' x‚à•‚Çä = ‚à•x‚à•‚Çä :=
subtype.ext $ norm_algebra_map' _ _
variables (ùïú ùïú')
lemma algebra_map_isometry [norm_one_class ùïú'] : isometry (algebra_map ùïú ùïú') :=
begin
  refine isometry_emetric_iff_metric.2 (Œªx y, _),
  rw [dist_eq_norm, dist_eq_norm, ‚Üê ring_hom.map_sub, norm_algebra_map'],
end
@[simps]
def algebra_map_clm : ùïú ‚ÜíL[ùïú] ùïú' :=
{ to_fun := algebra_map ùïú ùïú',
  map_add' := (algebra_map ùïú ùïú').map_add,
  map_smul' := Œª r x, by rw [algebra.id.smul_eq_mul, map_mul, ring_hom.id_apply, algebra.smul_def],
  cont :=
    have lipschitz_with ‚à•(1 : ùïú')‚à•‚Çä (algebra_map ùïú ùïú') := Œª x y, begin
      rw [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm_sub, ‚Üêmap_sub, ‚Üêennreal.coe_mul,
        ennreal.coe_le_coe, mul_comm],
      exact (nnnorm_algebra_map _ _).le,
    end, this.continuous }
lemma algebra_map_clm_coe :
  (algebra_map_clm ùïú ùïú' : ùïú ‚Üí ùïú') = (algebra_map ùïú ùïú' : ùïú ‚Üí ùïú') := rfl
lemma algebra_map_clm_to_linear_map :
  (algebra_map_clm ùïú ùïú').to_linear_map = algebra.linear_map ùïú ùïú' := rfl
instance normed_algebra.id : normed_algebra ùïú ùïú :=
{ .. normed_field.to_normed_space,
  .. algebra.id ùïú}
instance normed_algebra_rat {ùïú} [normed_division_ring ùïú] [char_zero ùïú] [normed_algebra ‚Ñù ùïú] :
  normed_algebra ‚Ñö ùïú :=
{ norm_smul_le := Œª q x,
    by rw [‚Üêsmul_one_smul ‚Ñù q x, rat.smul_one_eq_coe, norm_smul, rat.norm_cast_real], }
instance punit.normed_algebra : normed_algebra ùïú punit :=
{ norm_smul_le := Œª q x, by simp only [punit.norm_eq_zero, mul_zero] }
instance : normed_algebra ùïú (ulift ùïú') :=
{ ..ulift.normed_space }
instance prod.normed_algebra {E F : Type*} [semi_normed_ring E] [semi_normed_ring F]
  [normed_algebra ùïú E] [normed_algebra ùïú F] :
  normed_algebra ùïú (E √ó F) :=
{ ..prod.normed_space }
instance pi.normed_algebra {E : Œπ ‚Üí Type*} [fintype Œπ]
  [Œ† i, semi_normed_ring (E i)] [Œ† i, normed_algebra ùïú (E i)] :
  normed_algebra ùïú (Œ† i, E i) :=
{ .. pi.normed_space,
  .. pi.algebra _ E }
end normed_algebra
section restrict_scalars
variables (ùïú : Type*) (ùïú' : Type*) [normed_field ùïú] [normed_field ùïú'] [normed_algebra ùïú ùïú']
(E : Type*) [semi_normed_group E] [normed_space ùïú' E]
instance {ùïú : Type*} {ùïú' : Type*} {E : Type*} [I : semi_normed_group E] :
  semi_normed_group (restrict_scalars ùïú ùïú' E) := I
instance {ùïú : Type*} {ùïú' : Type*} {E : Type*} [I : normed_group E] :
  normed_group (restrict_scalars ùïú ùïú' E) := I
instance : normed_space ùïú (restrict_scalars ùïú ùïú' E) :=
{ norm_smul_le := Œª c x, (normed_space.norm_smul_le (algebra_map ùïú ùïú' c) (_ : E)).trans_eq $
    by rw norm_algebra_map',
  ..restrict_scalars.module ùïú ùïú' E }
def normed_space.restrict_scalars : normed_space ùïú E :=
restrict_scalars.normed_space _ ùïú' _
end restrict_scalars
