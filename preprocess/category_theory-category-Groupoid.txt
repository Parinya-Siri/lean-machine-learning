import category_theory.single_obj
import category_theory.limits.shapes.products
import category_theory.pi.basic
import category_theory.limits.is_limit
universes v u
namespace category_theory
def of (C : Type u) [groupoid.{v} C] : Groupoid.{v u} := bundled.of C
@[simp] lemma coe_of (C : Type u) [groupoid C] : (of C : Type u) = C := rfl
instance category : large_category.{max v u} Groupoid.{v u} :=
{ hom := Î» C D, C â¥¤ D,
  id := Î» C, ğŸ­ C,
  comp := Î» C D E F G, F â‹™ G,
  id_comp' := Î» C D F, by cases F; refl,
  comp_id' := Î» C D F, by cases F; refl,
  assoc' := by intros; refl }
def objects : Groupoid.{v u} â¥¤ Type u :=
{ obj := bundled.Î±,
  map := Î» C D F, F.obj }
def forget_to_Cat : Groupoid.{v u} â¥¤ Cat.{v u} :=
{ obj := Î» C, Cat.of C,
  map := Î» C D, id }
instance forget_to_Cat_full : full forget_to_Cat :=
{ preimage := Î» C D, id }
instance forget_to_Cat_faithful : faithful forget_to_Cat := { }
lemma hom_to_functor {C D E : Groupoid.{v u}} (f : C âŸ¶ D) (g : D âŸ¶ E) : f â‰« g = f â‹™ g := rfl
lemma id_to_functor {C : Groupoid.{v u}} : ğŸ­ C = ğŸ™ C := rfl
section products
local attribute [tidy] tactic.discrete_cases
def pi_limit_fan â¦ƒJ : Type uâ¦„ (F : J â†’ Groupoid.{u u}) : limits.fan F :=
limits.fan.mk (@of (Î  j : J, F j) _) (Î» j, category_theory.pi.eval _ j)
def pi_limit_fan_is_limit â¦ƒJ : Type uâ¦„ (F : J â†’ Groupoid.{u u}) :
  limits.is_limit (pi_limit_fan F) :=
limits.mk_fan_limit (pi_limit_fan F)
(Î» s, functor.pi' (Î» j, s.proj j))
(by { intros, dunfold pi_limit_fan, simp [hom_to_functor], })
begin
  intros s m w,
  apply functor.pi_ext,
  intro j, specialize w j,
  simpa,
end
instance has_pi : limits.has_products Groupoid.{u u} :=
limits.has_products_of_limit_fans pi_limit_fan pi_limit_fan_is_limit
noncomputable def pi_iso_pi (J : Type u) (f : J â†’ Groupoid.{u u}) : @of (Î  j, f j) _ â‰… âˆ f :=
limits.is_limit.cone_point_unique_up_to_iso
  (pi_limit_fan_is_limit f)
  (limits.limit.is_limit (discrete.functor f))
@[simp]
lemma pi_iso_pi_hom_Ï€ (J : Type u) (f : J â†’ Groupoid.{u u}) (j : J) :
  (pi_iso_pi J f).hom â‰« (limits.pi.Ï€ f j) = category_theory.pi.eval _ j :=
by { simp [pi_iso_pi], refl, }
end products
end Groupoid
end category_theory
