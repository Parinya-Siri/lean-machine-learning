import category_theory.equivalence
instance category.opposite : category.{vโ} Cแตแต :=
{ comp := ฮป _ _ _ f g, (g.unop โซ f.unop).op,
  id   := ฮป X, (๐ (unop X)).op }
@[simp] lemma op_comp {X Y Z : C} {f : X โถ Y} {g : Y โถ Z} :
  (f โซ g).op = g.op โซ f.op := rfl
@[simp] lemma op_id {X : C} : (๐ X).op = ๐ (op X) := rfl
@[simp] lemma unop_comp {X Y Z : Cแตแต} {f : X โถ Y} {g : Y โถ Z} :
  (f โซ g).unop = g.unop โซ f.unop := rfl
@[simp] lemma unop_id {X : Cแตแต} : (๐ X).unop = ๐ (unop X) := rfl
@[simp] lemma unop_id_op {X : C} : (๐ (op X)).unop = ๐ X := rfl
@[simp] lemma op_id_unop {X : Cแตแต} : (๐ (unop X)).op = ๐ X := rfl
section
variables (C)
@[simps]
def op_op : (Cแตแต)แตแต โฅค C :=
{ obj := ฮป X, unop (unop X),
  map := ฮป X Y f, f.unop.unop }
@[simps]
def unop_unop : C โฅค Cแตแตแตแต :=
{ obj := ฮป X, op (op X),
  map := ฮป X Y f, f.op.op }
@[simps]
def op_op_equivalence : Cแตแตแตแต โ C :=
{ functor := op_op C,
  inverse := unop_unop C,
  unit_iso := iso.refl (๐ญ Cแตแตแตแต),
  counit_iso := iso.refl (unop_unop C โ op_op C) }
end
instance is_iso_op {X Y : C} (f : X โถ Y) [is_iso f] : is_iso f.op :=
โจโจ(inv f).op,
  โจquiver.hom.unop_inj (by tidy), quiver.hom.unop_inj (by tidy)โฉโฉโฉ
lemma is_iso_of_op {X Y : C} (f : X โถ Y) [is_iso f.op] : is_iso f :=
โจโจ(inv (f.op)).unop,
  โจquiver.hom.op_inj (by simp), quiver.hom.op_inj (by simp)โฉโฉโฉ
lemma is_iso_op_iff {X Y : C} (f : X โถ Y) : is_iso f.op โ is_iso f :=
โจฮป hf, by exactI is_iso_of_op _, ฮป hf, by exactI infer_instanceโฉ
lemma is_iso_unop_iff {X Y : Cแตแต} (f : X โถ Y) : is_iso f.unop โ is_iso f :=
by rw [โ is_iso_op_iff f.unop, quiver.hom.op_unop]
instance is_iso_unop {X Y : Cแตแต} (f : X โถ Y) [is_iso f] : is_iso f.unop :=
(is_iso_unop_iff _).2 infer_instance
@[simp] lemma op_inv {X Y : C} (f : X โถ Y) [is_iso f] : (inv f).op = inv f.op :=
by { ext, rw [โ op_comp, is_iso.inv_hom_id, op_id] }
@[simp] lemma unop_inv {X Y : Cแตแต} (f : X โถ Y) [is_iso f] : (inv f).unop = inv f.unop :=
by { ext, rw [โ unop_comp, is_iso.inv_hom_id, unop_id] }
namespace functor
section
variables {D : Type uโ} [category.{vโ} D]
variables {C D}
@[simps]
protected def op (F : C โฅค D) : Cแตแต โฅค Dแตแต :=
{ obj := ฮป X, op (F.obj (unop X)),
  map := ฮป X Y f, (F.map f.unop).op }
@[simps]
protected def unop (F : Cแตแต โฅค Dแตแต) : C โฅค D :=
{ obj := ฮป X, unop (F.obj (op X)),
  map := ฮป X Y f, (F.map f.op).unop }
@[simps] def op_unop_iso (F : C โฅค D) : F.op.unop โ F :=
nat_iso.of_components (ฮป X, iso.refl _) (by tidy)
@[simps] def unop_op_iso (F : Cแตแต โฅค Dแตแต) : F.unop.op โ F :=
nat_iso.of_components (ฮป X, iso.refl _) (by tidy)
variables (C D)
@[simps]
def op_hom : (C โฅค D)แตแต โฅค (Cแตแต โฅค Dแตแต) :=
{ obj := ฮป F, (unop F).op,
  map := ฮป F G ฮฑ,
  { app := ฮป X, (ฮฑ.unop.app (unop X)).op,
    naturality' := ฮป X Y f, quiver.hom.unop_inj (ฮฑ.unop.naturality f.unop).symm } }
@[simps]
def op_inv : (Cแตแต โฅค Dแตแต) โฅค (C โฅค D)แตแต :=
{ obj := ฮป F, op F.unop,
  map := ฮป F G ฮฑ, quiver.hom.op
  { app := ฮป X, (ฮฑ.app (op X)).unop,
    naturality' := ฮป X Y f, quiver.hom.op_inj $ (ฮฑ.naturality f.op).symm } }
variables {C D}
@[simps]
protected def left_op (F : C โฅค Dแตแต) : Cแตแต โฅค D :=
{ obj := ฮป X, unop (F.obj (unop X)),
  map := ฮป X Y f, (F.map f.unop).unop }
@[simps]
protected def right_op (F : Cแตแต โฅค D) : C โฅค Dแตแต :=
{ obj := ฮป X, op (F.obj (op X)),
  map := ฮป X Y f, (F.map f.op).op }
instance {F : C โฅค D} [full F] : full F.op :=
{ preimage := ฮป X Y f, (F.preimage f.unop).op }
instance {F : C โฅค D} [faithful F] : faithful F.op :=
{ map_injective' := ฮป X Y f g h,
    quiver.hom.unop_inj $ by simpa using map_injective F (quiver.hom.op_inj h) }
instance right_op_faithful {F : Cแตแต โฅค D} [faithful F] : faithful F.right_op :=
{ map_injective' := ฮป X Y f g h, quiver.hom.op_inj (map_injective F (quiver.hom.op_inj h)) }
instance left_op_faithful {F : C โฅค Dแตแต} [faithful F] : faithful F.left_op :=
{ map_injective' := ฮป X Y f g h, quiver.hom.unop_inj (map_injective F (quiver.hom.unop_inj h)) }
@[simps]
def left_op_right_op_iso (F : C โฅค Dแตแต) : F.left_op.right_op โ F :=
nat_iso.of_components (ฮป X, iso.refl _) (by tidy)
@[simps]
def right_op_left_op_iso (F : Cแตแต โฅค D) : F.right_op.left_op โ F :=
nat_iso.of_components (ฮป X, iso.refl _) (by tidy)
end
end functor
namespace nat_trans
variables {D : Type uโ} [category.{vโ} D]
section
variables {F G : C โฅค D}
@[simps] protected def op (ฮฑ : F โถ G) : G.op โถ F.op :=
{ app         := ฮป X, (ฮฑ.app (unop X)).op,
  naturality' := ฮป X Y f, quiver.hom.unop_inj (by simp) }
@[simp] lemma op_id (F : C โฅค D) : nat_trans.op (๐ F) = ๐ (F.op) := rfl
@[simps] protected def unop {F G : Cแตแต โฅค Dแตแต} (ฮฑ : F โถ G) : G.unop โถ F.unop :=
{ app         := ฮป X, (ฮฑ.app (op X)).unop,
  naturality' := ฮป X Y f, quiver.hom.op_inj (by simp) }
@[simp] lemma unop_id (F : Cแตแต โฅค Dแตแต) : nat_trans.unop (๐ F) = ๐ (F.unop) := rfl
@[simps] protected def remove_op (ฮฑ : F.op โถ G.op) : G โถ F :=
{ app         := ฮป X, (ฮฑ.app (op X)).unop,
  naturality' := ฮป X Y f, quiver.hom.op_inj $
    by simpa only [functor.op_map] using (ฮฑ.naturality f.op).symm }
@[simp] lemma remove_op_id (F : C โฅค D) : nat_trans.remove_op (๐ F.op) = ๐ F := rfl
@[simps] protected def remove_unop {F G : Cแตแต โฅค Dแตแต} (ฮฑ : F.unop โถ G.unop) : G โถ F :=
{ app := ฮป X, (ฮฑ.app (unop X)).op,
  naturality' := ฮป X Y f, quiver.hom.unop_inj $
    by simpa only [functor.unop_map] using (ฮฑ.naturality f.unop).symm }
@[simp] lemma remove_unop_id (F : Cแตแต โฅค Dแตแต) : nat_trans.remove_unop (๐ F.unop) = ๐ F := rfl
end
section
variables {F G H : C โฅค Dแตแต}
@[simps] protected def left_op (ฮฑ : F โถ G) : G.left_op โถ F.left_op :=
{ app         := ฮป X, (ฮฑ.app (unop X)).unop,
  naturality' := ฮป X Y f, quiver.hom.op_inj (by simp) }
@[simp] lemma left_op_id : (๐ F : F โถ F).left_op = ๐ F.left_op := rfl
@[simp] lemma left_op_comp (ฮฑ : F โถ G) (ฮฒ : G โถ H) :
  (ฮฑ โซ ฮฒ).left_op = ฮฒ.left_op โซ ฮฑ.left_op := rfl
@[simps] protected def remove_left_op (ฮฑ : F.left_op โถ G.left_op) : G โถ F :=
{ app         := ฮป X, (ฮฑ.app (op X)).op,
  naturality' := ฮป X Y f, quiver.hom.unop_inj $
    by simpa only [functor.left_op_map] using (ฮฑ.naturality f.op).symm }
@[simp] lemma remove_left_op_id : nat_trans.remove_left_op (๐ F.left_op) = ๐ F := rfl
end
section
variables {F G H : Cแตแต โฅค D}
@[simps] protected def right_op (ฮฑ : F โถ G) : G.right_op โถ F.right_op :=
{ app := ฮป X, (ฮฑ.app _).op,
  naturality' := ฮป X Y f, quiver.hom.unop_inj (by simp) }
@[simp] lemma right_op_id : (๐ F : F โถ F).right_op = ๐ F.right_op := rfl
@[simp] lemma right_op_comp (ฮฑ : F โถ G) (ฮฒ : G โถ H) :
  (ฮฑ โซ ฮฒ).right_op = ฮฒ.right_op โซ ฮฑ.right_op := rfl
@[simps] protected def remove_right_op (ฮฑ : F.right_op โถ G.right_op) : G โถ F :=
{ app := ฮป X, (ฮฑ.app X.unop).unop,
  naturality' := ฮป X Y f, quiver.hom.op_inj $
    by simpa only [functor.right_op_map] using (ฮฑ.naturality f.unop).symm }
@[simp] lemma remove_right_op_id : nat_trans.remove_right_op (๐ F.right_op) = ๐ F := rfl
end
end nat_trans
namespace iso
variables {X Y : C}
@[simps]
protected def op (ฮฑ : X โ Y) : op Y โ op X :=
{ hom := ฮฑ.hom.op,
  inv := ฮฑ.inv.op,
  hom_inv_id' := quiver.hom.unop_inj ฮฑ.inv_hom_id,
  inv_hom_id' := quiver.hom.unop_inj ฮฑ.hom_inv_id }
@[simps] def unop {X Y : Cแตแต} (f : X โ Y) : Y.unop โ X.unop :=
{ hom := f.hom.unop,
  inv := f.inv.unop,
  hom_inv_id' := by simp only [โ unop_comp, f.inv_hom_id, unop_id],
  inv_hom_id' := by simp only [โ unop_comp, f.hom_inv_id, unop_id] }
@[simp] lemma unop_op {X Y : Cแตแต} (f : X โ Y) : f.unop.op = f :=
by ext; refl
@[simp] lemma op_unop {X Y : C} (f : X โ Y) : f.op.unop = f :=
by ext; refl
end iso
namespace nat_iso
variables {D : Type uโ} [category.{vโ} D]
variables {F G : C โฅค D}
@[simps] protected def op (ฮฑ : F โ G) : G.op โ F.op :=
{ hom := nat_trans.op ฮฑ.hom,
  inv := nat_trans.op ฮฑ.inv,
  hom_inv_id' := begin ext, dsimp, rw โop_comp, rw ฮฑ.inv_hom_id_app, refl, end,
  inv_hom_id' := begin ext, dsimp, rw โop_comp, rw ฮฑ.hom_inv_id_app, refl, end }
@[simps] protected def remove_op (ฮฑ : F.op โ G.op) : G โ F :=
{ hom := nat_trans.remove_op ฮฑ.hom,
  inv := nat_trans.remove_op ฮฑ.inv,
  hom_inv_id' := begin ext, dsimp, rw โunop_comp, rw ฮฑ.inv_hom_id_app, refl, end,
  inv_hom_id' := begin ext, dsimp, rw โunop_comp, rw ฮฑ.hom_inv_id_app, refl, end }
@[simps] protected def unop {F G : Cแตแต โฅค Dแตแต} (ฮฑ : F โ G) : G.unop โ F.unop :=
{ hom := nat_trans.unop ฮฑ.hom,
  inv := nat_trans.unop ฮฑ.inv,
  hom_inv_id' := begin ext, dsimp, rw โunop_comp, rw ฮฑ.inv_hom_id_app, refl, end,
  inv_hom_id' := begin ext, dsimp, rw โunop_comp, rw ฮฑ.hom_inv_id_app, refl, end }
end nat_iso
namespace equivalence
variables {D : Type uโ} [category.{vโ} D]
@[simps]
def op (e : C โ D) : Cแตแต โ Dแตแต :=
{ functor := e.functor.op,
  inverse := e.inverse.op,
  unit_iso := (nat_iso.op e.unit_iso).symm,
  counit_iso := (nat_iso.op e.counit_iso).symm,
  functor_unit_iso_comp' := ฮป X, by { apply quiver.hom.unop_inj, dsimp, simp, }, }
@[simps]
def unop (e : Cแตแต โ Dแตแต) : C โ D :=
{ functor := e.functor.unop,
  inverse := e.inverse.unop,
  unit_iso := (nat_iso.unop e.unit_iso).symm,
  counit_iso := (nat_iso.unop e.counit_iso).symm,
  functor_unit_iso_comp' := ฮป X, by { apply quiver.hom.op_inj, dsimp, simp, }, }
end equivalence
@[simps] def op_equiv (A B : Cแตแต) : (A โถ B) โ (B.unop โถ A.unop) :=
{ to_fun := ฮป f, f.unop,
  inv_fun := ฮป g, g.op,
  left_inv := ฮป _, rfl,
  right_inv := ฮป _, rfl }
instance subsingleton_of_unop (A B : Cแตแต) [subsingleton (unop B โถ unop A)] : subsingleton (A โถ B) :=
(op_equiv A B).subsingleton
instance decidable_eq_of_unop (A B : Cแตแต) [decidable_eq (unop B โถ unop A)] : decidable_eq (A โถ B) :=
(op_equiv A B).decidable_eq
@[simps] def iso_op_equiv (A B : Cแตแต) : (A โ B) โ (B.unop โ A.unop) :=
{ to_fun := ฮป f, f.unop,
  inv_fun := ฮป g, g.op,
  left_inv := ฮป _, by { ext, refl, },
  right_inv := ฮป _, by { ext, refl, } }
namespace functor
variables (C)
variables (D : Type uโ) [category.{vโ} D]
@[simps]
def op_unop_equiv : (C โฅค D)แตแต โ Cแตแต โฅค Dแตแต :=
{ functor := op_hom _ _,
  inverse := op_inv _ _,
  unit_iso := nat_iso.of_components (ฮป F, F.unop.op_unop_iso.op) begin
    intros F G f,
    dsimp [op_unop_iso],
    rw [(show f = f.unop.op, by simp), โ op_comp, โ op_comp],
    congr' 1,
    tidy,
  end,
  counit_iso := nat_iso.of_components (ฮป F, F.unop_op_iso) (by tidy) }.
@[simps]
def left_op_right_op_equiv : (Cแตแต โฅค D)แตแต โ (C โฅค Dแตแต) :=
{ functor :=
  { obj := ฮป F, F.unop.right_op,
    map := ฮป F G ฮท, ฮท.unop.right_op },
  inverse :=
  { obj := ฮป F, op F.left_op,
    map := ฮป F G ฮท, ฮท.left_op.op },
  unit_iso := nat_iso.of_components (ฮป F, F.unop.right_op_left_op_iso.op) begin
    intros F G ฮท,
    dsimp,
    rw [(show ฮท = ฮท.unop.op, by simp), โ op_comp, โ op_comp],
    congr' 1,
    tidy,
  end,
  counit_iso := nat_iso.of_components (ฮป F, F.left_op_right_op_iso) (by tidy) }
end functor
end category_theory
