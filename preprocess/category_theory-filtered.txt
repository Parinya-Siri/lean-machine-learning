import category_theory.fin_category
import category_theory.limits.cones
import category_theory.adjunction.basic
import category_theory.category.preorder
import category_theory.category.ulift
import order.bounded_order
open function
class is_filtered_or_empty : Prop :=
(cocone_objs : ‚àÄ (X Y : C), ‚àÉ Z (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z), true)
(cocone_maps : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f g : X ‚ü∂ Y), ‚àÉ Z (h : Y ‚ü∂ Z), f ‚â´ h = g ‚â´ h)
class is_filtered extends is_filtered_or_empty C : Prop :=
[nonempty : nonempty C]
@[priority 100]
instance is_filtered_or_empty_of_semilattice_sup
  (Œ± : Type u) [semilattice_sup Œ±] : is_filtered_or_empty Œ± :=
{ cocone_objs := Œª X Y, ‚ü®X ‚äî Y, hom_of_le le_sup_left, hom_of_le le_sup_right, trivial‚ü©,
  cocone_maps := Œª X Y f g, ‚ü®Y, ùüô _, (by ext)‚ü©, }
@[priority 100]
instance is_filtered_of_semilattice_sup_nonempty
  (Œ± : Type u) [semilattice_sup Œ±] [nonempty Œ±] : is_filtered Œ± := {}
@[priority 100]
instance is_filtered_or_empty_of_directed_le (Œ± : Type u) [preorder Œ±] [is_directed Œ± (‚â§)] :
  is_filtered_or_empty Œ± :=
{ cocone_objs := Œª X Y, let ‚ü®Z, h1, h2‚ü© := exists_ge_ge X Y in
    ‚ü®Z, hom_of_le h1, hom_of_le h2, trivial‚ü©,
  cocone_maps := Œª X Y f g, ‚ü®Y, ùüô _, by simp‚ü© }
@[priority 100]
instance is_filtered_of_directed_le_nonempty  (Œ± : Type u) [preorder Œ±] [is_directed Œ± (‚â§)]
  [nonempty Œ±] :
  is_filtered Œ± := {}
noncomputable def max (j j' : C) : C :=
(is_filtered_or_empty.cocone_objs j j').some
noncomputable def left_to_max (j j' : C) : j ‚ü∂ max j j' :=
(is_filtered_or_empty.cocone_objs j j').some_spec.some
noncomputable def right_to_max (j j' : C) : j' ‚ü∂ max j j' :=
(is_filtered_or_empty.cocone_objs j j').some_spec.some_spec.some
noncomputable def coeq {j j' : C} (f f' : j ‚ü∂ j') : C :=
(is_filtered_or_empty.cocone_maps f f').some
noncomputable def coeq_hom {j j' : C} (f f' : j ‚ü∂ j') : j' ‚ü∂ coeq f f' :=
(is_filtered_or_empty.cocone_maps f f').some_spec.some
@[simp, reassoc]
lemma coeq_condition {j j' : C} (f f' : j ‚ü∂ j') : f ‚â´ coeq_hom f f' = f' ‚â´ coeq_hom f f' :=
(is_filtered_or_empty.cocone_maps f f').some_spec.some_spec
open category_theory.limits
lemma sup_objs_exists (O : finset C) : ‚àÉ (S : C), ‚àÄ {X}, X ‚àà O ‚Üí _root_.nonempty (X ‚ü∂ S) :=
begin
  classical,
  apply finset.induction_on O,
  { exact ‚ü®is_filtered.nonempty.some, (by rintros - ‚ü®‚ü©)‚ü©, },
  { rintros X O' nm ‚ü®S', w'‚ü©,
    use max X S',
    rintros Y mY,
    obtain rfl|h := eq_or_ne Y X,
    { exact ‚ü®left_to_max _ _‚ü©, },
    { exact ‚ü®(w' (finset.mem_of_mem_insert_of_ne mY h)).some ‚â´ right_to_max _ _‚ü©, }, }
end
variables (O : finset C) (H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y))
lemma sup_exists :
  ‚àÉ (S : C) (T : Œ† {X : C}, X ‚àà O ‚Üí (X ‚ü∂ S)), ‚àÄ {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y},
    (‚ü®X, Y, mX, mY, f‚ü© : (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) ‚àà H ‚Üí f ‚â´ T mY = T mX :=
begin
  classical,
  apply finset.induction_on H,
  { obtain ‚ü®S, f‚ü© := sup_objs_exists O,
    refine ‚ü®S, Œª X mX, (f mX).some, _‚ü©,
    rintros - - - - - ‚ü®‚ü©, },
  { rintros ‚ü®X, Y, mX, mY, f‚ü© H' nmf ‚ü®S', T', w'‚ü©,
    refine ‚ü®coeq (f ‚â´ T' mY) (T' mX), Œª Z mZ, T' mZ ‚â´ coeq_hom (f ‚â´ T' mY) (T' mX), _‚ü©,
    intros X' Y' mX' mY' f' mf',
    rw [‚Üêcategory.assoc],
    by_cases h : X = X' ‚àß Y = Y',
    { rcases h with ‚ü®rfl, rfl‚ü©,
      by_cases hf : f = f',
      { subst hf,
        apply coeq_condition, },
      { rw @w' _ _ mX mY f' (by simpa [hf ‚àò eq.symm] using mf') }, },
    { rw @w' _ _ mX' mY' f' _,
      apply finset.mem_of_mem_insert_of_ne mf',
      contrapose! h,
      obtain ‚ü®rfl, h‚ü© := h,
      rw [heq_iff_eq, psigma.mk.inj_iff] at h,
      exact ‚ü®rfl, h.1.symm‚ü© }, },
end
noncomputable
def sup : C :=
(sup_exists O H).some
noncomputable
def to_sup {X : C} (m : X ‚àà O) :
  X ‚ü∂ sup O H :=
(sup_exists O H).some_spec.some m
lemma to_sup_commutes
  {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y}
  (mf : (‚ü®X, Y, mX, mY, f‚ü© : Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) ‚àà H) :
  f ‚â´ to_sup O H mY = to_sup O H mX :=
(sup_exists O H).some_spec.some_spec mX mY mf
variables {J : Type v} [small_category J] [fin_category J]
lemma cocone_nonempty (F : J ‚•§ C) : _root_.nonempty (cocone F) :=
begin
  classical,
  let O := (finset.univ.image F.obj),
  let H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) :=
    finset.univ.bUnion (Œª X : J, finset.univ.bUnion (Œª Y : J, finset.univ.image (Œª f : X ‚ü∂ Y,
      ‚ü®F.obj X, F.obj Y, by simp, by simp, F.map f‚ü©))),
  obtain ‚ü®Z, f, w‚ü© := sup_exists O H,
  refine ‚ü®‚ü®Z, ‚ü®Œª X, f (by simp), _‚ü©‚ü©‚ü©,
  intros j j' g,
  dsimp,
  simp only [category.comp_id],
  apply w,
  simp only [finset.mem_univ, finset.mem_bUnion, exists_and_distrib_left,
    exists_prop_of_true, finset.mem_image],
  exact ‚ü®j, rfl, j', g, (by simp)‚ü©,
end
noncomputable def cocone (F : J ‚•§ C) : cocone F :=
(cocone_nonempty F).some
variables {D : Type u‚ÇÅ} [category.{v‚ÇÅ} D]
lemma of_right_adjoint {L : D ‚•§ C} {R : C ‚•§ D} (h : L ‚ä£ R) : is_filtered D :=
{ cocone_objs := Œª X Y,
    ‚ü®_, h.hom_equiv _ _ (left_to_max _ _), h.hom_equiv _ _ (right_to_max _ _), ‚ü®‚ü©‚ü©,
  cocone_maps := Œª X Y f g,
    ‚ü®_, h.hom_equiv _ _ (coeq_hom _ _),
     by rw [‚Üê h.hom_equiv_naturality_left, ‚Üê h.hom_equiv_naturality_left, coeq_condition]‚ü©,
  nonempty := is_filtered.nonempty.map R.obj }
lemma of_is_right_adjoint (R : C ‚•§ D) [is_right_adjoint R] : is_filtered D :=
of_right_adjoint (adjunction.of_right_adjoint R)
lemma of_equivalence (h : C ‚âå D) : is_filtered D :=
of_right_adjoint h.symm.to_adjunction
section special_shapes
noncomputable def max‚ÇÉ (j‚ÇÅ j‚ÇÇ j‚ÇÉ : C) : C := max (max j‚ÇÅ j‚ÇÇ) j‚ÇÉ
noncomputable def first_to_max‚ÇÉ (j‚ÇÅ j‚ÇÇ j‚ÇÉ : C) : j‚ÇÅ ‚ü∂ max‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ :=
left_to_max j‚ÇÅ j‚ÇÇ ‚â´ left_to_max (max j‚ÇÅ j‚ÇÇ) j‚ÇÉ
noncomputable def second_to_max‚ÇÉ (j‚ÇÅ j‚ÇÇ j‚ÇÉ : C) : j‚ÇÇ ‚ü∂ max‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ :=
right_to_max j‚ÇÅ j‚ÇÇ ‚â´ left_to_max (max j‚ÇÅ j‚ÇÇ) j‚ÇÉ
noncomputable def third_to_max‚ÇÉ (j‚ÇÅ j‚ÇÇ j‚ÇÉ : C) : j‚ÇÉ ‚ü∂ max‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ :=
right_to_max (max j‚ÇÅ j‚ÇÇ) j‚ÇÉ
noncomputable def coeq‚ÇÉ {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) : C :=
coeq (coeq_hom f g ‚â´ left_to_max (coeq f g) (coeq g h))
  (coeq_hom g h ‚â´ right_to_max (coeq f g) (coeq g h))
noncomputable def coeq‚ÇÉ_hom {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) : j‚ÇÇ ‚ü∂ coeq‚ÇÉ f g h :=
coeq_hom f g ‚â´ left_to_max (coeq f g) (coeq g h) ‚â´
coeq_hom (coeq_hom f g ‚â´ left_to_max (coeq f g) (coeq g h))
  (coeq_hom g h ‚â´ right_to_max (coeq f g) (coeq g h))
lemma coeq‚ÇÉ_condition‚ÇÅ {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) :
  f ‚â´ coeq‚ÇÉ_hom f g h = g ‚â´ coeq‚ÇÉ_hom f g h :=
begin
  dsimp [coeq‚ÇÉ_hom],
  slice_lhs 1 2 { rw coeq_condition f g },
  simp only [category.assoc],
end
lemma coeq‚ÇÉ_condition‚ÇÇ {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) :
  g ‚â´ coeq‚ÇÉ_hom f g h = h ‚â´ coeq‚ÇÉ_hom f g h :=
begin
  dsimp [coeq‚ÇÉ_hom],
  slice_lhs 2 4 { rw [‚Üê category.assoc, coeq_condition _ _] },
  slice_rhs 2 4 { rw [‚Üê category.assoc, coeq_condition _ _] },
  slice_lhs 1 3 { rw [‚Üê category.assoc, coeq_condition _ _] },
  simp only [category.assoc],
end
lemma coeq‚ÇÉ_condition‚ÇÉ {j‚ÇÅ j‚ÇÇ : C} (f g h : j‚ÇÅ ‚ü∂ j‚ÇÇ) :
  f ‚â´ coeq‚ÇÉ_hom f g h = h ‚â´ coeq‚ÇÉ_hom f g h :=
eq.trans (coeq‚ÇÉ_condition‚ÇÅ f g h) (coeq‚ÇÉ_condition‚ÇÇ f g h)
lemma bowtie {j‚ÇÅ j‚ÇÇ k‚ÇÅ k‚ÇÇ : C}
  (f‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÅ) (g‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÇ) (f‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÅ) (g‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÇ) :
  ‚àÉ (s : C) (Œ± : k‚ÇÅ ‚ü∂ s) (Œ≤ : k‚ÇÇ ‚ü∂ s), f‚ÇÅ ‚â´ Œ± = g‚ÇÅ ‚â´ Œ≤ ‚àß f‚ÇÇ ‚â´ Œ± = g‚ÇÇ ‚â´ Œ≤ :=
begin
  let sa := max k‚ÇÅ k‚ÇÇ,
  let sb := coeq (f‚ÇÅ ‚â´ left_to_max _ _) (g‚ÇÅ ‚â´ right_to_max _ _),
  let sc := coeq (f‚ÇÇ ‚â´ left_to_max _ _) (g‚ÇÇ ‚â´ right_to_max _ _),
  let sd := max sb sc,
  let s := coeq ((coeq_hom _ _ : sa ‚ü∂ sb) ‚â´ left_to_max _ _)
    ((coeq_hom _ _ : sa ‚ü∂ sc) ‚â´ right_to_max _ _),
  use s,
  fsplit,
  exact left_to_max k‚ÇÅ k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ left_to_max sb sc ‚â´ coeq_hom _ _,
  fsplit,
  exact right_to_max k‚ÇÅ k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ right_to_max sb sc ‚â´ coeq_hom _ _,
  fsplit,
  { slice_lhs 1 3 { rw [‚Üêcategory.assoc, coeq_condition], },
    slice_lhs 3 5 { rw [‚Üêcategory.assoc, coeq_condition], },
    simp only [category.assoc], },
  { slice_lhs 3 5 { rw [‚Üêcategory.assoc, coeq_condition], },
    slice_lhs 1 3 { rw [‚Üêcategory.assoc, coeq_condition], },
    simp only [category.assoc], }
end
lemma tulip {j‚ÇÅ j‚ÇÇ j‚ÇÉ k‚ÇÅ k‚ÇÇ l : C} (f‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÅ) (f‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÅ) (f‚ÇÉ : j‚ÇÇ ‚ü∂ k‚ÇÇ) (f‚ÇÑ : j‚ÇÉ ‚ü∂ k‚ÇÇ)
  (g‚ÇÅ : j‚ÇÅ ‚ü∂ l) (g‚ÇÇ : j‚ÇÉ ‚ü∂ l) :
  ‚àÉ (s : C) (Œ± : k‚ÇÅ ‚ü∂ s) (Œ≤ : l ‚ü∂ s) (Œ≥ : k‚ÇÇ ‚ü∂ s),
    f‚ÇÅ ‚â´ Œ± = g‚ÇÅ ‚â´ Œ≤ ‚àß f‚ÇÇ ‚â´ Œ± = f‚ÇÉ ‚â´ Œ≥ ‚àß f‚ÇÑ ‚â´ Œ≥ = g‚ÇÇ ‚â´ Œ≤ :=
begin
  let sa := max‚ÇÉ k‚ÇÅ l k‚ÇÇ,
  let sb := coeq (f‚ÇÅ ‚â´ first_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ) (g‚ÇÅ ‚â´ second_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ),
  let sc := coeq (f‚ÇÇ ‚â´ first_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ) (f‚ÇÉ ‚â´ third_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ),
  let sd := coeq (f‚ÇÑ ‚â´ third_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ) (g‚ÇÇ ‚â´ second_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ),
  let se := max‚ÇÉ sb sc sd,
  let sf := coeq‚ÇÉ (coeq_hom _ _ ‚â´ first_to_max‚ÇÉ sb sc sd)
    (coeq_hom _ _ ‚â´ second_to_max‚ÇÉ sb sc sd) (coeq_hom _ _ ‚â´ third_to_max‚ÇÉ sb sc sd),
  use sf,
  use first_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ first_to_max‚ÇÉ sb sc sd ‚â´ coeq‚ÇÉ_hom _ _ _,
  use second_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ second_to_max‚ÇÉ sb sc sd ‚â´ coeq‚ÇÉ_hom _ _ _,
  use third_to_max‚ÇÉ k‚ÇÅ l k‚ÇÇ ‚â´ coeq_hom _ _ ‚â´ third_to_max‚ÇÉ sb sc sd ‚â´ coeq‚ÇÉ_hom _ _ _,
  fsplit,
  slice_lhs 1 3 { rw [‚Üê category.assoc, coeq_condition] },
  slice_lhs 3 6 { rw [‚Üê category.assoc, coeq‚ÇÉ_condition‚ÇÅ] },
  simp only [category.assoc],
  fsplit,
  slice_lhs 3 6 { rw [‚Üê category.assoc, coeq‚ÇÉ_condition‚ÇÅ] },
  slice_lhs 1 3 { rw [‚Üê category.assoc, coeq_condition] },
  slice_rhs 3 6 { rw [‚Üê category.assoc, ‚Üê coeq‚ÇÉ_condition‚ÇÇ] },
  simp only [category.assoc],
  slice_rhs 3 6 { rw [‚Üê category.assoc, coeq‚ÇÉ_condition‚ÇÇ] },
  slice_rhs 1 3 { rw [‚Üê category.assoc, ‚Üê coeq_condition] },
  simp only [category.assoc],
end
end special_shapes
end is_filtered
class is_cofiltered_or_empty : Prop :=
(cocone_objs : ‚àÄ (X Y : C), ‚àÉ W (f : W ‚ü∂ X) (g : W ‚ü∂ Y), true)
(cocone_maps : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f g : X ‚ü∂ Y), ‚àÉ W (h : W ‚ü∂ X), h ‚â´ f = h ‚â´ g)
class is_cofiltered extends is_cofiltered_or_empty C : Prop :=
[nonempty : nonempty C]
@[priority 100]
instance is_cofiltered_or_empty_of_semilattice_inf
  (Œ± : Type u) [semilattice_inf Œ±] : is_cofiltered_or_empty Œ± :=
{ cocone_objs := Œª X Y, ‚ü®X ‚äì Y, hom_of_le inf_le_left, hom_of_le inf_le_right, trivial‚ü©,
  cocone_maps := Œª X Y f g, ‚ü®X, ùüô _, (by ext)‚ü©, }
@[priority 100]
instance is_cofiltered_of_semilattice_inf_nonempty
  (Œ± : Type u) [semilattice_inf Œ±] [nonempty Œ±] : is_cofiltered Œ± := {}
@[priority 100]
instance is_cofiltered_or_empty_of_directed_ge (Œ± : Type u) [preorder Œ±]
  [is_directed Œ± (‚â•)] :
  is_cofiltered_or_empty Œ± :=
{ cocone_objs := Œª X Y, let ‚ü®Z, hX, hY‚ü© := exists_le_le X Y in
    ‚ü®Z, hom_of_le hX, hom_of_le hY, trivial‚ü©,
  cocone_maps := Œª X Y f g, ‚ü®X, ùüô _, by simp‚ü© }
@[priority 100]
instance is_cofiltered_of_directed_ge_nonempty  (Œ± : Type u) [preorder Œ±] [is_directed Œ± (‚â•)]
  [nonempty Œ±] :
  is_cofiltered Œ± := {}
noncomputable def min (j j' : C) : C :=
(is_cofiltered_or_empty.cocone_objs j j').some
noncomputable def min_to_left (j j' : C) : min j j' ‚ü∂ j :=
(is_cofiltered_or_empty.cocone_objs j j').some_spec.some
noncomputable def min_to_right (j j' : C) : min j j' ‚ü∂ j' :=
(is_cofiltered_or_empty.cocone_objs j j').some_spec.some_spec.some
noncomputable def eq {j j' : C} (f f' : j ‚ü∂ j') : C :=
(is_cofiltered_or_empty.cocone_maps f f').some
noncomputable def eq_hom {j j' : C} (f f' : j ‚ü∂ j') : eq f f' ‚ü∂ j :=
(is_cofiltered_or_empty.cocone_maps f f').some_spec.some
@[simp, reassoc]
lemma eq_condition {j j' : C} (f f' : j ‚ü∂ j') : eq_hom f f' ‚â´ f = eq_hom f f' ‚â´ f' :=
(is_cofiltered_or_empty.cocone_maps f f').some_spec.some_spec
open category_theory.limits
lemma inf_objs_exists (O : finset C) : ‚àÉ (S : C), ‚àÄ {X}, X ‚àà O ‚Üí _root_.nonempty (S ‚ü∂ X) :=
begin
  classical,
  apply finset.induction_on O,
  { exact ‚ü®is_cofiltered.nonempty.some, (by rintros - ‚ü®‚ü©)‚ü©, },
  { rintros X O' nm ‚ü®S', w'‚ü©,
    use min X S',
    rintros Y mY,
    obtain rfl|h := eq_or_ne Y X,
    { exact ‚ü®min_to_left _ _‚ü©, },
    { exact ‚ü®min_to_right _ _ ‚â´ (w' (finset.mem_of_mem_insert_of_ne mY h)).some‚ü©, }, }
end
variables (O : finset C) (H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y))
lemma inf_exists :
  ‚àÉ (S : C) (T : Œ† {X : C}, X ‚àà O ‚Üí (S ‚ü∂ X)), ‚àÄ {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y},
    (‚ü®X, Y, mX, mY, f‚ü© : (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) ‚àà H ‚Üí T mX ‚â´ f = T mY :=
begin
  classical,
  apply finset.induction_on H,
  { obtain ‚ü®S, f‚ü© := inf_objs_exists O,
    refine ‚ü®S, Œª X mX, (f mX).some, _‚ü©,
    rintros - - - - - ‚ü®‚ü©, },
  { rintros ‚ü®X, Y, mX, mY, f‚ü© H' nmf ‚ü®S', T', w'‚ü©,
    refine ‚ü®eq (T' mX ‚â´ f) (T' mY), Œª Z mZ, eq_hom (T' mX ‚â´ f) (T' mY) ‚â´ T' mZ, _‚ü©,
    intros X' Y' mX' mY' f' mf',
    rw [category.assoc],
    by_cases h : X = X' ‚àß Y = Y',
    { rcases h with ‚ü®rfl, rfl‚ü©,
      by_cases hf : f = f',
      { subst hf,
        apply eq_condition, },
      { rw @w' _ _ mX mY f' (by simpa [hf ‚àò eq.symm] using mf') }, },
    { rw @w' _ _ mX' mY' f' _,
      apply finset.mem_of_mem_insert_of_ne mf',
      contrapose! h,
      obtain ‚ü®rfl, h‚ü© := h,
      rw [heq_iff_eq, psigma.mk.inj_iff] at h,
      exact ‚ü®rfl, h.1.symm‚ü© }, },
end
noncomputable
def inf : C :=
(inf_exists O H).some
noncomputable
def inf_to {X : C} (m : X ‚àà O) :
  inf O H ‚ü∂ X :=
(inf_exists O H).some_spec.some m
lemma inf_to_commutes
  {X Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y}
  (mf : (‚ü®X, Y, mX, mY, f‚ü© : Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) ‚àà H) :
  inf_to O H mX ‚â´ f = inf_to O H mY :=
(inf_exists O H).some_spec.some_spec mX mY mf
variables {J : Type w} [small_category J] [fin_category J]
lemma cone_nonempty (F : J ‚•§ C) : _root_.nonempty (cone F) :=
begin
  classical,
  let O := (finset.univ.image F.obj),
  let H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) :=
    finset.univ.bUnion (Œª X : J, finset.univ.bUnion (Œª Y : J, finset.univ.image (Œª f : X ‚ü∂ Y,
      ‚ü®F.obj X, F.obj Y, by simp, by simp, F.map f‚ü©))),
  obtain ‚ü®Z, f, w‚ü© := inf_exists O H,
  refine ‚ü®‚ü®Z, ‚ü®Œª X, f (by simp), _‚ü©‚ü©‚ü©,
  intros j j' g,
  dsimp,
  simp only [category.id_comp],
  symmetry,
  apply w,
  simp only [finset.mem_univ, finset.mem_bUnion, exists_and_distrib_left,
    exists_prop_of_true, finset.mem_image],
  exact ‚ü®j, rfl, j', g, (by simp)‚ü©,
end
noncomputable def cone (F : J ‚•§ C) : cone F :=
(cone_nonempty F).some
variables {D : Type u‚ÇÅ} [category.{v‚ÇÅ} D]
lemma of_left_adjoint {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R) : is_cofiltered D :=
{ cocone_objs := Œª X Y,
    ‚ü®L.obj (min (R.obj X) (R.obj Y)),
      (h.hom_equiv _ X).symm (min_to_left _ _), (h.hom_equiv _ Y).symm (min_to_right _ _), ‚ü®‚ü©‚ü©,
  cocone_maps := Œª X Y f g,
    ‚ü®L.obj (eq (R.map f) (R.map g)), (h.hom_equiv _ _).symm (eq_hom _ _),
     by rw [‚Üê h.hom_equiv_naturality_right_symm, ‚Üê h.hom_equiv_naturality_right_symm,
       eq_condition]‚ü©,
  nonempty := is_cofiltered.nonempty.map L.obj }
lemma of_is_left_adjoint (L : C ‚•§ D) [is_left_adjoint L] : is_cofiltered D :=
of_left_adjoint (adjunction.of_left_adjoint L)
lemma of_equivalence (h : C ‚âå D) : is_cofiltered D :=
of_left_adjoint h.to_adjunction
end is_cofiltered
section opposite
open opposite
instance is_cofiltered_op_of_is_filtered [is_filtered C] : is_cofiltered C·µí·µñ :=
{ cocone_objs := Œª X Y, ‚ü®op (is_filtered.max X.unop Y.unop),
    (is_filtered.left_to_max _ _).op, (is_filtered.right_to_max _ _).op, trivial‚ü©,
  cocone_maps := Œª X Y f g, ‚ü®op (is_filtered.coeq f.unop g.unop),
    (is_filtered.coeq_hom _ _).op, begin
      rw [(show f = f.unop.op, by simp), (show g = g.unop.op, by simp),
        ‚Üê op_comp, ‚Üê op_comp],
      congr' 1,
      exact is_filtered.coeq_condition f.unop g.unop,
    end‚ü©,
  nonempty := ‚ü®op is_filtered.nonempty.some‚ü© }
instance is_filtered_op_of_is_cofiltered [is_cofiltered C] : is_filtered C·µí·µñ :=
{ cocone_objs := Œª X Y, ‚ü®op (is_cofiltered.min X.unop Y.unop),
    (is_cofiltered.min_to_left X.unop Y.unop).op,
    (is_cofiltered.min_to_right X.unop Y.unop).op, trivial‚ü©,
  cocone_maps := Œª X Y f g, ‚ü®op (is_cofiltered.eq f.unop g.unop),
    (is_cofiltered.eq_hom f.unop g.unop).op, begin
      rw [(show f = f.unop.op, by simp), (show g = g.unop.op, by simp),
        ‚Üê op_comp, ‚Üê op_comp],
      congr' 1,
      exact is_cofiltered.eq_condition f.unop g.unop,
    end‚ü©,
  nonempty := ‚ü®op is_cofiltered.nonempty.some‚ü© }
end opposite
section ulift
instance [is_filtered C] : is_filtered (ulift.{u‚ÇÇ} C) :=
is_filtered.of_equivalence ulift.equivalence
instance [is_cofiltered C] : is_cofiltered (ulift.{u‚ÇÇ} C) :=
is_cofiltered.of_equivalence ulift.equivalence
instance [is_filtered C] : is_filtered (ulift_hom C) :=
is_filtered.of_equivalence ulift_hom.equiv
instance [is_cofiltered C] : is_cofiltered (ulift_hom C) :=
is_cofiltered.of_equivalence ulift_hom.equiv
instance [is_filtered C] : is_filtered (as_small C) :=
is_filtered.of_equivalence as_small.equiv
instance [is_cofiltered C] : is_cofiltered (as_small C) :=
is_cofiltered.of_equivalence as_small.equiv
end ulift
end category_theory
