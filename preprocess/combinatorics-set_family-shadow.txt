import data.finset.slice
import logic.function.iterate
open finset nat
variables {Î± : Type*}
namespace finset
section shadow
variables [decidable_eq Î±] {ğ’œ : finset (finset Î±)} {s t : finset Î±} {a : Î±} {k r : â„•}
def shadow (ğ’œ : finset (finset Î±)) : finset (finset Î±) := ğ’œ.sup (Î» s, s.image (erase s))
localized "notation `âˆ‚ `:90 := finset.shadow" in finset_family
@[simp] lemma shadow_empty : âˆ‚ (âˆ… : finset (finset Î±)) = âˆ… := rfl
@[simp] lemma shadow_singleton_empty : âˆ‚ ({âˆ…} : finset (finset Î±)) = âˆ… := rfl
@[mono] lemma shadow_monotone : monotone (shadow : finset (finset Î±) â†’ finset (finset Î±)) :=
Î» ğ’œ â„¬, sup_mono
lemma mem_shadow_iff : s âˆˆ âˆ‚ ğ’œ â†” âˆƒ t âˆˆ ğ’œ, âˆƒ a âˆˆ t, erase t a = s :=
by simp only [shadow, mem_sup, mem_image]
lemma erase_mem_shadow (hs : s âˆˆ ğ’œ) (ha : a âˆˆ s) : erase s a âˆˆ âˆ‚ ğ’œ :=
mem_shadow_iff.2 âŸ¨s, hs, a, ha, rflâŸ©
lemma mem_shadow_iff_insert_mem : s âˆˆ âˆ‚ ğ’œ â†” âˆƒ a âˆ‰ s, insert a s âˆˆ ğ’œ :=
begin
  refine mem_shadow_iff.trans âŸ¨_, _âŸ©,
  { rintro âŸ¨s, hs, a, ha, rflâŸ©,
    refine âŸ¨a, not_mem_erase a s, _âŸ©,
    rwa insert_erase ha },
  { rintro âŸ¨a, ha, hsâŸ©,
    exact âŸ¨insert a s, hs, a, mem_insert_self _ _, erase_insert haâŸ© }
end
protected lemma _root_.set.sized.shadow (hğ’œ : (ğ’œ : set (finset Î±)).sized r) :
  (âˆ‚ ğ’œ : set (finset Î±)).sized (r - 1) :=
begin
  intros A h,
  obtain âŸ¨A, hA, i, hi, rflâŸ© := mem_shadow_iff.1 h,
  rw [card_erase_of_mem hi, hğ’œ hA],
end
lemma sized_shadow_iff (h : âˆ… âˆ‰ ğ’œ) :
  (âˆ‚ ğ’œ : set (finset Î±)).sized r â†” (ğ’œ : set (finset Î±)).sized (r + 1) :=
begin
  refine âŸ¨Î» hğ’œ s hs, _, set.sized.shadowâŸ©,
  obtain âŸ¨a, haâŸ© := nonempty_iff_ne_empty.2 (ne_of_mem_of_not_mem hs h),
  rw [â†hğ’œ (erase_mem_shadow hs ha), card_erase_add_one ha],
end
lemma mem_shadow_iff_exists_mem_card_add_one :
  s âˆˆ âˆ‚ ğ’œ â†” âˆƒ t âˆˆ ğ’œ, s âŠ† t âˆ§ t.card = s.card + 1 :=
begin
  refine mem_shadow_iff_insert_mem.trans âŸ¨_, _âŸ©,
  { rintro âŸ¨a, ha, hsâŸ©,
    exact âŸ¨insert a s, hs, subset_insert _ _, card_insert_of_not_mem haâŸ© },
  { rintro âŸ¨t, ht, hst, hâŸ©,
    obtain âŸ¨a, haâŸ© : âˆƒ a, t \ s = {a} :=
      card_eq_one.1 (by rw [card_sdiff hst, h, add_tsub_cancel_left]),
    exact âŸ¨a, Î» hat,
      not_mem_sdiff_of_mem_right hat ((ha.ge : _ âŠ† _) $ mem_singleton_self a),
      by rwa [insert_eq a s, â†ha, sdiff_union_of_subset hst]âŸ© }
end
lemma exists_subset_of_mem_shadow (hs : s âˆˆ âˆ‚ ğ’œ) : âˆƒ t âˆˆ ğ’œ, s âŠ† t :=
let âŸ¨t, ht, hstâŸ© := mem_shadow_iff_exists_mem_card_add_one.1 hs in âŸ¨t, ht, hst.1âŸ©
lemma mem_shadow_iff_exists_mem_card_add :
  s âˆˆ (âˆ‚^[k]) ğ’œ â†” âˆƒ t âˆˆ ğ’œ, s âŠ† t âˆ§ t.card = s.card + k :=
begin
  induction k with k ih generalizing ğ’œ s,
  { refine âŸ¨Î» hs, âŸ¨s, hs, subset.refl _, rflâŸ©, _âŸ©,
    rintro âŸ¨t, ht, hst, hcardâŸ©,
    rwa eq_of_subset_of_card_le hst hcard.le },
  simp only [exists_prop, function.comp_app, function.iterate_succ],
  refine ih.trans _,
  clear ih,
  split,
  { rintro âŸ¨t, ht, hst, hcardstâŸ©,
    obtain âŸ¨u, hu, htu, hcardtuâŸ© := mem_shadow_iff_exists_mem_card_add_one.1 ht,
    refine âŸ¨u, hu, hst.trans htu, _âŸ©,
    rw [hcardtu, hcardst],
    refl },
  { rintro âŸ¨t, ht, hst, hcardâŸ©,
    obtain âŸ¨u, hsu, hut, huâŸ© := finset.exists_intermediate_set k
      (by { rw [add_comm, hcard], exact le_succ _ }) hst,
    rw add_comm at hu,
    refine âŸ¨u, mem_shadow_iff_exists_mem_card_add_one.2 âŸ¨t, ht, hut, _âŸ©, hsu, huâŸ©,
    rw [hcard, hu],
    refl }
end
end shadow
open_locale finset_family
section up_shadow
variables [decidable_eq Î±] [fintype Î±] {ğ’œ : finset (finset Î±)} {s t : finset Î±} {a : Î±} {k r : â„•}
def up_shadow (ğ’œ : finset (finset Î±)) : finset (finset Î±) :=
ğ’œ.sup $ Î» s, sá¶œ.image $ Î» a, insert a s
localized "notation `âˆ‚âº `:90 := finset.up_shadow" in finset_family
@[simp] lemma up_shadow_empty : âˆ‚âº (âˆ… : finset (finset Î±)) = âˆ… := rfl
@[mono] lemma up_shadow_monotone : monotone (up_shadow : finset (finset Î±) â†’ finset (finset Î±)) :=
Î» ğ’œ â„¬, sup_mono
lemma mem_up_shadow_iff : s âˆˆ âˆ‚âº ğ’œ â†” âˆƒ t âˆˆ ğ’œ, âˆƒ a âˆ‰ t, insert a t = s :=
by simp_rw [up_shadow, mem_sup, mem_image, exists_prop, mem_compl]
lemma insert_mem_up_shadow (hs : s âˆˆ ğ’œ) (ha : a âˆ‰ s) : insert a s âˆˆ âˆ‚âº ğ’œ :=
mem_up_shadow_iff.2 âŸ¨s, hs, a, ha, rflâŸ©
protected lemma _root_.set.sized.up_shadow (hğ’œ : (ğ’œ : set (finset Î±)).sized r) :
  (âˆ‚âº ğ’œ : set (finset Î±)).sized (r + 1) :=
begin
  intros A h,
  obtain âŸ¨A, hA, i, hi, rflâŸ© := mem_up_shadow_iff.1 h,
  rw [card_insert_of_not_mem hi, hğ’œ hA],
end
lemma mem_up_shadow_iff_erase_mem : s âˆˆ âˆ‚âº ğ’œ â†” âˆƒ a âˆˆ s, s.erase a âˆˆ ğ’œ :=
begin
  refine mem_up_shadow_iff.trans âŸ¨_, _âŸ©,
  { rintro âŸ¨s, hs, a, ha, rflâŸ©,
    refine âŸ¨a, mem_insert_self a s, _âŸ©,
    rwa erase_insert ha },
  { rintro âŸ¨a, ha, hsâŸ©,
    exact âŸ¨s.erase a, hs, a, not_mem_erase _ _, insert_erase haâŸ© }
end
lemma mem_up_shadow_iff_exists_mem_card_add_one :
  s âˆˆ âˆ‚âº ğ’œ â†” âˆƒ t âˆˆ ğ’œ, t âŠ† s âˆ§ t.card + 1 = s.card :=
begin
  refine mem_up_shadow_iff_erase_mem.trans âŸ¨_, _âŸ©,
  { rintro âŸ¨a, ha, hsâŸ©,
    exact âŸ¨s.erase a, hs, erase_subset _ _, card_erase_add_one haâŸ© },
  { rintro âŸ¨t, ht, hts, hâŸ©,
    obtain âŸ¨a, haâŸ© : âˆƒ a, s \ t = {a} :=
      card_eq_one.1 (by rw [card_sdiff hts, â†h, add_tsub_cancel_left]),
    refine âŸ¨a, sdiff_subset _ _ ((ha.ge : _ âŠ† _) $ mem_singleton_self a), _âŸ©,
    rwa [â†sdiff_singleton_eq_erase, â†ha, sdiff_sdiff_eq_self hts] }
end
lemma exists_subset_of_mem_up_shadow (hs : s âˆˆ âˆ‚âº ğ’œ) : âˆƒ t âˆˆ ğ’œ, t âŠ† s :=
let âŸ¨t, ht, hts, _âŸ© := mem_up_shadow_iff_exists_mem_card_add_one.1 hs in âŸ¨t, ht, htsâŸ©
lemma mem_up_shadow_iff_exists_mem_card_add :
  s âˆˆ (âˆ‚âº^[k]) ğ’œ â†” âˆƒ t âˆˆ ğ’œ, t âŠ† s âˆ§ t.card + k = s.card :=
begin
  induction k with k ih generalizing ğ’œ s,
  { refine âŸ¨Î» hs, âŸ¨s, hs, subset.refl _, rflâŸ©, _âŸ©,
    rintro âŸ¨t, ht, hst, hcardâŸ©,
    rwa â†eq_of_subset_of_card_le hst hcard.ge },
  simp only [exists_prop, function.comp_app, function.iterate_succ],
  refine ih.trans _,
  clear ih,
  split,
  { rintro âŸ¨t, ht, hts, hcardstâŸ©,
    obtain âŸ¨u, hu, hut, hcardtuâŸ© := mem_up_shadow_iff_exists_mem_card_add_one.1 ht,
    refine âŸ¨u, hu, hut.trans hts, _âŸ©,
    rw [â†hcardst, â†hcardtu, add_right_comm],
    refl },
  { rintro âŸ¨t, ht, hts, hcardâŸ©,
    obtain âŸ¨u, htu, hus, huâŸ© := finset.exists_intermediate_set 1
      (by { rw [add_comm, â†hcard], exact add_le_add_left (zero_lt_succ _) _ }) hts,
    rw add_comm at hu,
    refine âŸ¨u, mem_up_shadow_iff_exists_mem_card_add_one.2 âŸ¨t, ht, htu, hu.symmâŸ©, hus, _âŸ©,
    rw [hu, â†hcard, add_right_comm],
    refl }
end
@[simp] lemma shadow_image_compl : (âˆ‚ ğ’œ).image compl = âˆ‚âº (ğ’œ.image compl) :=
begin
  ext s,
  simp only [mem_image, exists_prop, mem_shadow_iff, mem_up_shadow_iff],
  split,
  { rintro âŸ¨_, âŸ¨s, hs, a, ha, rflâŸ©, rflâŸ©,
    exact âŸ¨sá¶œ, âŸ¨s, hs, rflâŸ©, a, not_mem_compl.2 ha, compl_erase.symmâŸ© },
  { rintro âŸ¨_, âŸ¨s, hs, rflâŸ©, a, ha, rflâŸ©,
    exact âŸ¨s.erase a, âŸ¨s, hs, a, not_mem_compl.1 ha, rflâŸ©, compl_eraseâŸ© }
end
@[simp] lemma up_shadow_image_compl : (âˆ‚âº ğ’œ).image compl = âˆ‚ (ğ’œ.image compl) :=
begin
  ext s,
  simp only [mem_image, exists_prop, mem_shadow_iff, mem_up_shadow_iff],
  split,
  { rintro âŸ¨_, âŸ¨s, hs, a, ha, rflâŸ©, rflâŸ©,
    exact âŸ¨sá¶œ, âŸ¨s, hs, rflâŸ©, a, mem_compl.2 ha, compl_insert.symmâŸ© },
  { rintro âŸ¨_, âŸ¨s, hs, rflâŸ©, a, ha, rflâŸ©,
    exact âŸ¨insert a s, âŸ¨s, hs, a, mem_compl.1 ha, rflâŸ©, compl_insertâŸ© }
end
end up_shadow
end finset
