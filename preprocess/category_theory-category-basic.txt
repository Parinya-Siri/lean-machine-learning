import combinatorics.quiver.basic
import tactic.basic
library_note "category_theory universes"
universes v u
namespace category_theory
class category_struct (obj : Type u)
extends quiver.{v+1} obj : Type (max u (v+1)) :=
(id       : Î  X : obj, hom X X)
(comp     : Î  {X Y Z : obj}, (X âŸ¶ Y) â†’ (Y âŸ¶ Z) â†’ (X âŸ¶ Z))
class category (obj : Type u)
extends category_struct.{v} obj : Type (max u (v+1)) :=
(id_comp' : âˆ€ {X Y : obj} (f : hom X Y), ğŸ™ X â‰« f = f . obviously)
(comp_id' : âˆ€ {X Y : obj} (f : hom X Y), f â‰« ğŸ™ Y = f . obviously)
(assoc'   : âˆ€ {W X Y Z : obj} (f : hom W X) (g : hom X Y) (h : hom Y Z),
  (f â‰« g) â‰« h = f â‰« (g â‰« h) . obviously)
abbreviation large_category (C : Type (u+1)) : Type (u+1) := category.{u} C
abbreviation small_category (C : Type u) : Type (u+1) := category.{u} C
section
variables {C : Type u} [category.{v} C] {X Y Z : C}
initialize_simps_projections category (to_category_struct_to_quiver_hom â†’ hom,
  to_category_struct_comp â†’ comp, to_category_struct_id â†’ id, -to_category_struct)
lemma eq_whisker {f g : X âŸ¶ Y} (w : f = g) (h : Y âŸ¶ Z) : f â‰« h = g â‰« h :=
by rw w
lemma whisker_eq (f : X âŸ¶ Y) {g h : Y âŸ¶ Z} (w : g = h) : f â‰« g = f â‰« h :=
by rw w
infixr ` =â‰« `:80 := eq_whisker
infixr ` â‰«= `:80 := whisker_eq
lemma eq_of_comp_left_eq {f g : X âŸ¶ Y} (w : âˆ€ {Z : C} (h : Y âŸ¶ Z), f â‰« h = g â‰« h) : f = g :=
by { convert w (ğŸ™ Y), tidy }
lemma eq_of_comp_right_eq {f g : Y âŸ¶ Z} (w : âˆ€ {X : C} (h : X âŸ¶ Y), h â‰« f = h â‰« g) : f = g :=
by { convert w (ğŸ™ Y), tidy }
lemma eq_of_comp_left_eq' (f g : X âŸ¶ Y)
  (w : (Î» {Z : C} (h : Y âŸ¶ Z), f â‰« h) = (Î» {Z : C} (h : Y âŸ¶ Z), g â‰« h)) : f = g :=
eq_of_comp_left_eq (Î» Z h, by convert congr_fun (congr_fun w Z) h)
lemma eq_of_comp_right_eq' (f g : Y âŸ¶ Z)
  (w : (Î» {X : C} (h : X âŸ¶ Y), h â‰« f) = (Î» {X : C} (h : X âŸ¶ Y), h â‰« g)) : f = g :=
eq_of_comp_right_eq (Î» X h, by convert congr_fun (congr_fun w X) h)
lemma id_of_comp_left_id (f : X âŸ¶ X) (w : âˆ€ {Y : C} (g : X âŸ¶ Y), f â‰« g = g) : f = ğŸ™ X :=
by { convert w (ğŸ™ X), tidy }
lemma id_of_comp_right_id (f : X âŸ¶ X) (w : âˆ€ {Y : C} (g : Y âŸ¶ X), g â‰« f = g) : f = ğŸ™ X :=
by { convert w (ğŸ™ X), tidy }
lemma comp_ite {P : Prop} [decidable P]
  {X Y Z : C} (f : X âŸ¶ Y) (g g' : (Y âŸ¶ Z)) :
  (f â‰« if P then g else g') = (if P then f â‰« g else f â‰« g') :=
by { split_ifs; refl }
lemma ite_comp {P : Prop} [decidable P]
  {X Y Z : C} (f f' : (X âŸ¶ Y))  (g : Y âŸ¶ Z) :
  (if P then f else f') â‰« g = (if P then f â‰« g else f' â‰« g) :=
by { split_ifs; refl }
lemma comp_dite {P : Prop} [decidable P]
  {X Y Z : C} (f : X âŸ¶ Y) (g : P â†’ (Y âŸ¶ Z)) (g' : Â¬P â†’ (Y âŸ¶ Z)) :
  (f â‰« if h : P then g h else g' h) = (if h : P then f â‰« g h else f â‰« g' h) :=
by { split_ifs; refl }
lemma dite_comp {P : Prop} [decidable P]
  {X Y Z : C} (f : P â†’ (X âŸ¶ Y)) (f' : Â¬P â†’ (X âŸ¶ Y)) (g : Y âŸ¶ Z) :
  (if h : P then f h else f' h) â‰« g = (if h : P then f h â‰« g else f' h â‰« g) :=
by { split_ifs; refl }
class epi (f : X âŸ¶ Y) : Prop :=
(left_cancellation : Î  {Z : C} (g h : Y âŸ¶ Z) (w : f â‰« g = f â‰« h), g = h)
class mono (f : X âŸ¶ Y) : Prop :=
(right_cancellation : Î  {Z : C} (g h : Z âŸ¶ X) (w : g â‰« f = h â‰« f), g = h)
instance (X : C) : epi (ğŸ™ X) :=
âŸ¨Î» Z g h w, by simpa using wâŸ©
instance (X : C) : mono (ğŸ™ X) :=
âŸ¨Î» Z g h w, by simpa using wâŸ©
lemma cancel_epi (f : X âŸ¶ Y) [epi f] {g h : Y âŸ¶ Z} : (f â‰« g = f â‰« h) â†” g = h :=
âŸ¨Î» p, epi.left_cancellation g h p, congr_arg _âŸ©
lemma cancel_mono (f : X âŸ¶ Y) [mono f] {g h : Z âŸ¶ X} : (g â‰« f = h â‰« f) â†” g = h :=
âŸ¨Î» p, mono.right_cancellation g h p, congr_arg _âŸ©
lemma cancel_epi_id (f : X âŸ¶ Y) [epi f] {h : Y âŸ¶ Y} : (f â‰« h = f) â†” h = ğŸ™ Y :=
by { convert cancel_epi f, simp, }
lemma cancel_mono_id (f : X âŸ¶ Y) [mono f] {g : X âŸ¶ X} : (g â‰« f = f) â†” g = ğŸ™ X :=
by { convert cancel_mono f, simp, }
lemma epi_comp {X Y Z : C} (f : X âŸ¶ Y) [epi f] (g : Y âŸ¶ Z) [epi g] : epi (f â‰« g) :=
begin
  split, intros Z a b w,
  apply (cancel_epi g).1,
  apply (cancel_epi f).1,
  simpa using w,
end
lemma mono_comp {X Y Z : C} (f : X âŸ¶ Y) [mono f] (g : Y âŸ¶ Z) [mono g] : mono (f â‰« g) :=
begin
  split, intros Z a b w,
  apply (cancel_mono f).1,
  apply (cancel_mono g).1,
  simpa using w,
end
lemma mono_of_mono {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [mono (f â‰« g)] : mono f :=
begin
  split, intros Z a b w,
  replace w := congr_arg (Î» k, k â‰« g) w,
  dsimp at w,
  rw [category.assoc, category.assoc] at w,
  exact (cancel_mono _).1 w,
end
lemma mono_of_mono_fac {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} {h : X âŸ¶ Z} [mono h] (w : f â‰« g = h) :
  mono f :=
by { substI h, exact mono_of_mono f g, }
lemma epi_of_epi {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [epi (f â‰« g)] : epi g :=
begin
  split, intros Z a b w,
  replace w := congr_arg (Î» k, f â‰« k) w,
  dsimp at w,
  rw [â†category.assoc, â†category.assoc] at w,
  exact (cancel_epi _).1 w,
end
lemma epi_of_epi_fac {X Y Z : C} {f : X âŸ¶ Y} {g : Y âŸ¶ Z} {h : X âŸ¶ Z} [epi h] (w : f â‰« g = h) :
  epi g :=
by substI h; exact epi_of_epi f g
end
section
variable (C : Type u)
variable [category.{v} C]
universe u'
instance ulift_category : category.{v} (ulift.{u'} C) :=
{ hom  := Î» X Y, (X.down âŸ¶ Y.down),
  id   := Î» X, ğŸ™ X.down,
  comp := Î» _ _ _ f g, f â‰« g }
library_note "dsimp, simp"
