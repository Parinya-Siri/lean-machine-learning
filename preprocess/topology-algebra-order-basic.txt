import algebra.group_with_zero.power
import data.set.intervals.pi
import order.filter.interval
import topology.algebra.group
import tactic.linarith
import tactic.tfae
open classical set filter topological_space
open function
open order_dual (to_dual of_dual)
open_locale topological_space classical filter
universes u v w
variables {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}
class order_closed_topology (Œ± : Type*) [topological_space Œ±] [preorder Œ±] : Prop :=
(is_closed_le' : is_closed {p:Œ±√óŒ± | p.1 ‚â§ p.2})
instance : Œ† [topological_space Œ±], topological_space Œ±·µí·µà := id
instance [topological_space Œ±] [h : first_countable_topology Œ±] : first_countable_topology Œ±·µí·µà := h
instance [topological_space Œ±] [h : second_countable_topology Œ±] : second_countable_topology Œ±·µí·µà :=
h
@[to_additive]
instance [topological_space Œ±] [has_mul Œ±] [h : has_continuous_mul Œ±] : has_continuous_mul Œ±·µí·µà := h
lemma dense.order_dual [topological_space Œ±] {s : set Œ±} (hs : dense s) :
  dense (order_dual.of_dual ‚Åª¬π' s) := hs
section order_closed_topology
section preorder
variables [topological_space Œ±] [preorder Œ±] [t : order_closed_topology Œ±]
include t
namespace subtype
instance {p : Œ± ‚Üí Prop} : order_closed_topology (subtype p) :=
have this : continuous (Œª (p : (subtype p) √ó (subtype p)), ((p.fst : Œ±), (p.snd : Œ±))) :=
  (continuous_subtype_coe.comp continuous_fst).prod_mk
  (continuous_subtype_coe.comp continuous_snd),
order_closed_topology.mk (t.is_closed_le'.preimage this)
end subtype
lemma is_closed_le_prod : is_closed {p : Œ± √ó Œ± | p.1 ‚â§ p.2} :=
t.is_closed_le'
lemma is_closed_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  is_closed {b | f b ‚â§ g b} :=
continuous_iff_is_closed.mp (hf.prod_mk hg) _ is_closed_le_prod
lemma is_closed_le' (a : Œ±) : is_closed {b | b ‚â§ a} :=
is_closed_le continuous_id continuous_const
lemma is_closed_Iic {a : Œ±} : is_closed (Iic a) :=
is_closed_le' a
lemma is_closed_ge' (a : Œ±) : is_closed {b | a ‚â§ b} :=
is_closed_le continuous_const continuous_id
lemma is_closed_Ici {a : Œ±} : is_closed (Ici a) :=
is_closed_ge' a
instance : order_closed_topology Œ±·µí·µà :=
‚ü®(@order_closed_topology.is_closed_le' Œ± _ _ _).preimage continuous_swap‚ü©
lemma is_closed_Icc {a b : Œ±} : is_closed (Icc a b) :=
is_closed.inter is_closed_Ici is_closed_Iic
@[simp] lemma closure_Icc (a b : Œ±) : closure (Icc a b) = Icc a b :=
is_closed_Icc.closure_eq
@[simp] lemma closure_Iic (a : Œ±) : closure (Iic a) = Iic a :=
is_closed_Iic.closure_eq
@[simp] lemma closure_Ici (a : Œ±) : closure (Ici a) = Ici a :=
is_closed_Ici.closure_eq
lemma le_of_tendsto_of_tendsto {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [ne_bot b]
  (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) (h : f ‚â§·∂†[b] g) :
  a‚ÇÅ ‚â§ a‚ÇÇ :=
have tendsto (Œªb, (f b, g b)) b (ùìù (a‚ÇÅ, a‚ÇÇ)),
  by rw [nhds_prod_eq]; exact hf.prod_mk hg,
show (a‚ÇÅ, a‚ÇÇ) ‚àà {p:Œ±√óŒ± | p.1 ‚â§ p.2},
  from t.is_closed_le'.mem_of_tendsto this h
alias le_of_tendsto_of_tendsto ‚Üê tendsto_le_of_eventually_le
lemma le_of_tendsto_of_tendsto' {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [ne_bot b]
  (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) (h : ‚àÄ x, f x ‚â§ g x) :
  a‚ÇÅ ‚â§ a‚ÇÇ :=
le_of_tendsto_of_tendsto hf hg (eventually_of_forall h)
lemma le_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  [ne_bot x] (lim : tendsto f x (ùìù a)) (h : ‚àÄ·∂† c in x, f c ‚â§ b) : a ‚â§ b :=
le_of_tendsto_of_tendsto lim tendsto_const_nhds h
lemma le_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  [ne_bot x] (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, f c ‚â§ b) : a ‚â§ b :=
le_of_tendsto lim (eventually_of_forall h)
lemma ge_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤} [ne_bot x]
  (lim : tendsto f x (ùìù a)) (h : ‚àÄ·∂† c in x, b ‚â§ f c) : b ‚â§ a :=
le_of_tendsto_of_tendsto tendsto_const_nhds lim h
lemma ge_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤} [ne_bot x]
  (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, b ‚â§ f c) : b ‚â§ a :=
ge_of_tendsto lim (eventually_of_forall h)
@[simp]
lemma closure_le_eq [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  closure {b | f b ‚â§ g b} = {b | f b ‚â§ g b} :=
(is_closed_le hf hg).closure_eq
lemma closure_lt_subset_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f)
  (hg : continuous g) :
  closure {b | f b < g b} ‚äÜ {b | f b ‚â§ g b} :=
closure_minimal (Œª x, le_of_lt) $ is_closed_le hf hg
lemma continuous_within_at.closure_le [topological_space Œ≤]
 {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} {x : Œ≤} (hx : x ‚àà closure s)
 (hf : continuous_within_at f s x)
 (hg : continuous_within_at g s x)
 (h : ‚àÄ y ‚àà s, f y ‚â§ g y) : f x ‚â§ g x :=
show (f x, g x) ‚àà {p : Œ± √ó Œ± | p.1 ‚â§ p.2},
from order_closed_topology.is_closed_le'.closure_subset ((hf.prod hg).mem_closure hx h)
lemma is_closed.is_closed_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} (hs : is_closed s)
  (hf : continuous_on f s) (hg : continuous_on g s) :
  is_closed {x ‚àà s | f x ‚â§ g x} :=
(hf.prod hg).preimage_closed_of_closed hs order_closed_topology.is_closed_le'
lemma le_on_closure [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} (h : ‚àÄ x ‚àà s, f x ‚â§ g x)
  (hf : continuous_on f (closure s)) (hg : continuous_on g (closure s)) ‚¶Éx‚¶Ñ (hx : x ‚àà closure s) :
  f x ‚â§ g x :=
have s ‚äÜ {y ‚àà closure s | f y ‚â§ g y}, from Œª y hy, ‚ü®subset_closure hy, h y hy‚ü©,
(closure_minimal this (is_closed_closure.is_closed_le hf hg) hx).2
lemma is_closed.epigraph [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} {s : set Œ≤}
  (hs : is_closed s) (hf : continuous_on f s) :
  is_closed {p : Œ≤ √ó Œ± | p.1 ‚àà s ‚àß f p.1 ‚â§ p.2} :=
(hs.preimage continuous_fst).is_closed_le (hf.comp continuous_on_fst subset.rfl) continuous_on_snd
lemma is_closed.hypograph [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} {s : set Œ≤}
  (hs : is_closed s) (hf : continuous_on f s) :
  is_closed {p : Œ≤ √ó Œ± | p.1 ‚àà s ‚àß p.2 ‚â§ f p.1} :=
(hs.preimage continuous_fst).is_closed_le continuous_on_snd (hf.comp continuous_on_fst subset.rfl)
omit t
lemma nhds_within_Ici_ne_bot {a b : Œ±} (H‚ÇÇ : a ‚â§ b) :
  ne_bot (ùìù[Ici a] b) :=
nhds_within_ne_bot_of_mem H‚ÇÇ
@[instance] lemma nhds_within_Ici_self_ne_bot (a : Œ±) :
  ne_bot (ùìù[‚â•] a) :=
nhds_within_Ici_ne_bot (le_refl a)
lemma nhds_within_Iic_ne_bot {a b : Œ±} (H : a ‚â§ b) :
  ne_bot (ùìù[Iic b] a) :=
nhds_within_ne_bot_of_mem H
@[instance] lemma nhds_within_Iic_self_ne_bot (a : Œ±) :
  ne_bot (ùìù[‚â§] a) :=
nhds_within_Iic_ne_bot (le_refl a)
end preorder
section partial_order
variables [topological_space Œ±] [partial_order Œ±] [t : order_closed_topology Œ±]
include t
lemma Ioo_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ioo a c ‚àà ùìù[>] b :=
mem_nhds_within.2 ‚ü®Iio c, is_open_Iio, H.2,
  by rw [inter_comm, Ioi_inter_Iio]; exact Ioo_subset_Ioo_left H.1‚ü©
lemma Ioc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ioc a c ‚àà ùìù[>] b :=
mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ioc_self
lemma Ico_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ico a c ‚àà ùìù[>] b :=
mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ico_self
lemma Icc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Icc a c ‚àà ùìù[>] b :=
mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Icc_self
@[simp] lemma nhds_within_Ioc_eq_nhds_within_Ioi {a b : Œ±} (h : a < b) :
  ùìù[Ioc a b] a = ùìù[>] a :=
le_antisymm (nhds_within_mono _ Ioc_subset_Ioi_self) $
  nhds_within_le_of_mem $ Ioc_mem_nhds_within_Ioi $ left_mem_Ico.2 h
@[simp] lemma nhds_within_Ioo_eq_nhds_within_Ioi {a b : Œ±} (h : a < b) :
  ùìù[Ioo a b] a = ùìù[>] a :=
le_antisymm (nhds_within_mono _ Ioo_subset_Ioi_self) $
  nhds_within_le_of_mem $ Ioo_mem_nhds_within_Ioi $ left_mem_Ico.2 h
@[simp]
lemma continuous_within_at_Ioc_iff_Ioi [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioc a b) a ‚Üî continuous_within_at f (Ioi a) a :=
by simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Ioi h]
@[simp]
lemma continuous_within_at_Ioo_iff_Ioi [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioo a b) a ‚Üî continuous_within_at f (Ioi a) a :=
by simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Ioi h]
lemma Ioo_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ioo a c ‚àà ùìù[<] b :=
by simpa only [dual_Ioo] using Ioo_mem_nhds_within_Ioi
  (show to_dual b ‚àà Ico (to_dual c) (to_dual a), from H.symm)
lemma Ico_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ico a c ‚àà ùìù[<] b :=
mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ico_self
lemma Ioc_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ioc a c ‚àà ùìù[<] b :=
mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ioc_self
lemma Icc_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Icc a c ‚àà ùìù[<] b :=
mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Icc_self
@[simp] lemma nhds_within_Ico_eq_nhds_within_Iio {a b : Œ±} (h : a < b) :
  ùìù[Ico a b] b = ùìù[<] b :=
by simpa only [dual_Ioc] using nhds_within_Ioc_eq_nhds_within_Ioi h.dual
@[simp] lemma nhds_within_Ioo_eq_nhds_within_Iio {a b : Œ±} (h : a < b) :
  ùìù[Ioo a b] b = ùìù[<] b :=
by simpa only [dual_Ioo] using nhds_within_Ioo_eq_nhds_within_Ioi h.dual
@[simp] lemma continuous_within_at_Ico_iff_Iio {a b : Œ±} {f : Œ± ‚Üí Œ≥} (h : a < b) :
  continuous_within_at f (Ico a b) b ‚Üî continuous_within_at f (Iio b) b :=
by simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Iio h]
@[simp] lemma continuous_within_at_Ioo_iff_Iio {a b : Œ±} {f : Œ± ‚Üí Œ≥} (h : a < b) :
  continuous_within_at f (Ioo a b) b ‚Üî continuous_within_at f (Iio b) b :=
by simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Iio h]
lemma Ioo_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ioo a c ‚àà ùìù[‚â•] b :=
mem_nhds_within_of_mem_nhds $ is_open.mem_nhds is_open_Ioo H
lemma Ioc_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ioc a c ‚àà ùìù[‚â•] b :=
mem_of_superset (Ioo_mem_nhds_within_Ici H) Ioo_subset_Ioc_self
lemma Ico_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ico a c ‚àà ùìù[‚â•] b :=
mem_nhds_within.2 ‚ü®Iio c, is_open_Iio, H.2,
  by simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]‚ü©
lemma Icc_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ico a c) :
  Icc a c ‚àà ùìù[‚â•] b :=
mem_of_superset (Ico_mem_nhds_within_Ici H) Ico_subset_Icc_self
@[simp] lemma nhds_within_Icc_eq_nhds_within_Ici {a b : Œ±} (h : a < b) :
  ùìù[Icc a b] a = ùìù[‚â•] a :=
le_antisymm (nhds_within_mono _ Icc_subset_Ici_self) $
  nhds_within_le_of_mem $ Icc_mem_nhds_within_Ici $ left_mem_Ico.2 h
@[simp] lemma nhds_within_Ico_eq_nhds_within_Ici {a b : Œ±} (h : a < b) :
  ùìù[Ico a b] a = ùìù[‚â•] a :=
le_antisymm (nhds_within_mono _ (Œª x, and.left)) $
  nhds_within_le_of_mem $ Ico_mem_nhds_within_Ici $ left_mem_Ico.2 h
@[simp]
lemma continuous_within_at_Icc_iff_Ici [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Icc a b) a ‚Üî continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Ici h]
@[simp]
lemma continuous_within_at_Ico_iff_Ici [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ico a b) a ‚Üî continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Ici h]
lemma Ioo_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ioo a c ‚àà ùìù[‚â§] b :=
mem_nhds_within_of_mem_nhds $ is_open.mem_nhds is_open_Ioo H
lemma Ico_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ico a c ‚àà ùìù[‚â§] b :=
mem_of_superset (Ioo_mem_nhds_within_Iic H) Ioo_subset_Ico_self
lemma Ioc_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ioc a c ‚àà ùìù[‚â§] b :=
by simpa only [dual_Ico] using Ico_mem_nhds_within_Ici
  (show to_dual b ‚àà Ico (to_dual c) (to_dual a), from H.symm)
lemma Icc_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Icc a c ‚àà ùìù[‚â§] b :=
mem_of_superset (Ioc_mem_nhds_within_Iic H) Ioc_subset_Icc_self
@[simp] lemma nhds_within_Icc_eq_nhds_within_Iic {a b : Œ±} (h : a < b) :
  ùìù[Icc a b] b = ùìù[‚â§] b :=
by simpa only [dual_Icc] using nhds_within_Icc_eq_nhds_within_Ici h.dual
@[simp] lemma nhds_within_Ioc_eq_nhds_within_Iic {a b : Œ±} (h : a < b) :
  ùìù[Ioc a b] b = ùìù[‚â§] b :=
by simpa only [dual_Ico] using nhds_within_Ico_eq_nhds_within_Ici h.dual
@[simp]
lemma continuous_within_at_Icc_iff_Iic [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Icc a b) b ‚Üî continuous_within_at f (Iic b) b :=
by simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Iic h]
@[simp]
lemma continuous_within_at_Ioc_iff_Iic [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioc a b) b ‚Üî continuous_within_at f (Iic b) b :=
by simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Iic h]
end linear_order
section linear_order
variables [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {f g : Œ≤ ‚Üí Œ±}
section
variables [topological_space Œ≤]
lemma lt_subset_interior_le (hf : continuous f) (hg : continuous g) :
  {b | f b < g b} ‚äÜ interior {b | f b ‚â§ g b} :=
interior_maximal (Œª p, le_of_lt) $ is_open_lt hf hg
lemma frontier_le_subset_eq (hf : continuous f) (hg : continuous g) :
  frontier {b | f b ‚â§ g b} ‚äÜ {b | f b = g b} :=
begin
  rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg],
  rintros b ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©,
  refine le_antisymm hb‚ÇÅ (closure_lt_subset_le hg hf _),
  convert hb‚ÇÇ using 2, simp only [not_le.symm], refl
end
lemma frontier_Iic_subset (a : Œ±) : frontier (Iic a) ‚äÜ {a} :=
frontier_le_subset_eq (@continuous_id Œ± _) continuous_const
lemma frontier_Ici_subset (a : Œ±) : frontier (Ici a) ‚äÜ {a} := @frontier_Iic_subset Œ±·µí·µà _ _ _ _
lemma frontier_lt_subset_eq (hf : continuous f) (hg : continuous g) :
  frontier {b | f b < g b} ‚äÜ {b | f b = g b} :=
by rw ‚Üê frontier_compl;
   convert frontier_le_subset_eq hg hf; simp [ext_iff, eq_comm]
lemma continuous_if_le [topological_space Œ≥] [Œ† x, decidable (f x ‚â§ g x)]
  {f' g' : Œ≤ ‚Üí Œ≥} (hf : continuous f) (hg : continuous g)
  (hf' : continuous_on f' {x | f x ‚â§ g x}) (hg' : continuous_on g' {x | g x ‚â§ f x})
  (hfg : ‚àÄ x, f x = g x ‚Üí f' x = g' x) :
  continuous (Œª x, if f x ‚â§ g x then f' x else g' x) :=
begin
  refine continuous_if (Œª a ha, hfg _ (frontier_le_subset_eq hf hg ha)) _ (hg'.mono _),
  { rwa [(is_closed_le hf hg).closure_eq] },
  { simp only [not_le], exact closure_lt_subset_le hg hf }
end
lemma continuous.if_le [topological_space Œ≥] [Œ† x, decidable (f x ‚â§ g x)] {f' g' : Œ≤ ‚Üí Œ≥}
  (hf' : continuous f') (hg' : continuous g') (hf : continuous f) (hg : continuous g)
  (hfg : ‚àÄ x, f x = g x ‚Üí f' x = g' x) :
  continuous (Œª x, if f x ‚â§ g x then f' x else g' x) :=
continuous_if_le hf hg hf'.continuous_on hg'.continuous_on hfg
lemma tendsto.eventually_lt {l : filter Œ≥} {f g : Œ≥ ‚Üí Œ±} {y z : Œ±}
  (hf : tendsto f l (ùìù y)) (hg : tendsto g l (ùìù z)) (hyz : y < z) : ‚àÄ·∂† x in l, f x < g x :=
begin
  by_cases h : y ‚ãñ z,
  { filter_upwards [hf (Iio_mem_nhds hyz), hg (Ioi_mem_nhds hyz)],
    rw [h.Iio_eq],
    exact Œª x hfx hgx, lt_of_le_of_lt hfx hgx },
  { obtain ‚ü®w, hyw, hwz‚ü© := (not_covby_iff hyz).mp h,
    filter_upwards [hf (Iio_mem_nhds hyw), hg (Ioi_mem_nhds hwz)],
    exact Œª x, lt_trans },
end
lemma continuous_at.eventually_lt {x‚ÇÄ : Œ≤} (hf : continuous_at f x‚ÇÄ)
  (hg : continuous_at g x‚ÇÄ) (hfg : f x‚ÇÄ < g x‚ÇÄ) : ‚àÄ·∂† x in ùìù x‚ÇÄ, f x < g x :=
tendsto.eventually_lt hf hg hfg
@[continuity] lemma continuous.min (hf : continuous f) (hg : continuous g) :
  continuous (Œªb, min (f b) (g b)) :=
by { simp only [min_def], exact hf.if_le hg hf hg (Œª x, id) }
@[continuity] lemma continuous.max (hf : continuous f) (hg : continuous g) :
  continuous (Œªb, max (f b) (g b)) :=
@continuous.min Œ±·µí·µà _ _ _ _ _ _ _ hf hg
end
lemma continuous_min : continuous (Œª p : Œ± √ó Œ±, min p.1 p.2) := continuous_fst.min continuous_snd
lemma continuous_max : continuous (Œª p : Œ± √ó Œ±, max p.1 p.2) := continuous_fst.max continuous_snd
lemma filter.tendsto.max {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ))
  (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, max (f b) (g b)) b (ùìù (max a‚ÇÅ a‚ÇÇ)) :=
(continuous_max.tendsto (a‚ÇÅ, a‚ÇÇ)).comp (hf.prod_mk_nhds hg)
lemma filter.tendsto.min {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ))
  (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, min (f b) (g b)) b (ùìù (min a‚ÇÅ a‚ÇÇ)) :=
(continuous_min.tendsto (a‚ÇÅ, a‚ÇÇ)).comp (hf.prod_mk_nhds hg)
lemma dense.exists_lt [no_min_order Œ±] {s : set Œ±} (hs : dense s) (x : Œ±) : ‚àÉ y ‚àà s, y < x :=
hs.exists_mem_open is_open_Iio (exists_lt x)
lemma dense.exists_gt [no_max_order Œ±] {s : set Œ±} (hs : dense s) (x : Œ±) : ‚àÉ y ‚àà s, x < y :=
hs.order_dual.exists_lt x
lemma dense.exists_le [no_min_order Œ±] {s : set Œ±} (hs : dense s) (x : Œ±) : ‚àÉ y ‚àà s, y ‚â§ x :=
(hs.exists_lt x).imp $ Œª y hy, ‚ü®hy.fst, hy.snd.le‚ü©
lemma dense.exists_ge [no_max_order Œ±] {s : set Œ±} (hs : dense s) (x : Œ±) : ‚àÉ y ‚àà s, x ‚â§ y :=
hs.order_dual.exists_le x
lemma dense.exists_le' {s : set Œ±} (hs : dense s) (hbot : ‚àÄ x, is_bot x ‚Üí x ‚àà s) (x : Œ±) :
  ‚àÉ y ‚àà s, y ‚â§ x :=
begin
  by_cases hx : is_bot x,
  { exact ‚ü®x, hbot x hx, le_rfl‚ü© },
  { simp only [is_bot, not_forall, not_le] at hx,
    rcases hs.exists_mem_open is_open_Iio hx with ‚ü®y, hys, hy : y < x‚ü©,
    exact ‚ü®y, hys, hy.le‚ü© }
end
lemma dense.exists_ge' {s : set Œ±} (hs : dense s) (htop : ‚àÄ x, is_top x ‚Üí x ‚àà s) (x : Œ±) :
  ‚àÉ y ‚àà s, x ‚â§ y :=
hs.order_dual.exists_le' htop x
lemma dense.exists_between [densely_ordered Œ±] {s : set Œ±} (hs : dense s) {x y : Œ±} (h : x < y) :
  ‚àÉ z ‚àà s, z ‚àà Ioo x y :=
hs.exists_mem_open is_open_Ioo (nonempty_Ioo.2 h)
variables [nonempty Œ±] [topological_space Œ≤]
lemma is_compact.bdd_below {s : set Œ±} (hs : is_compact s) : bdd_below s :=
begin
  by_contra H,
  rcases hs.elim_finite_subcover_image (Œª x (_ : x ‚àà s), @is_open_Ioi _ _ _ _ x) _
    with ‚ü®t, st, ft, ht‚ü©,
  { refine H (ft.bdd_below.imp $ Œª C hC y hy, _),
    rcases mem_Union‚ÇÇ.1 (ht hy) with ‚ü®x, hx, xy‚ü©,
    exact le_trans (hC hx) (le_of_lt xy) },
  { refine Œª x hx, mem_Union‚ÇÇ.2 (not_imp_comm.1 _ H),
    exact Œª h, ‚ü®x, Œª y hy, le_of_not_lt (h.imp $ Œª ys, ‚ü®_, hy, ys‚ü©)‚ü© }
end
lemma is_compact.bdd_above {s : set Œ±} (hs : is_compact s) : bdd_above s :=
@is_compact.bdd_below Œ±·µí·µà _ _ _ _ _ hs
lemma is_compact.bdd_below_image {f : Œ≤ ‚Üí Œ±} {K : set Œ≤}
  (hK : is_compact K) (hf : continuous_on f K) : bdd_below (f '' K) :=
(hK.image_of_continuous_on hf).bdd_below
lemma is_compact.bdd_above_image {f : Œ≤ ‚Üí Œ±} {K : set Œ≤}
  (hK : is_compact K) (hf : continuous_on f K) : bdd_above (f '' K) :=
@is_compact.bdd_below_image Œ±·µí·µà _ _ _ _ _ _ _ _ hK hf
lemma continuous.bdd_below_range_of_has_compact_mul_support [has_one Œ±] {f : Œ≤ ‚Üí Œ±}
  (hf : continuous f) (h : has_compact_mul_support f) : bdd_below (range f) :=
(h.is_compact_range hf).bdd_below
lemma continuous.bdd_above_range_of_has_compact_mul_support [has_one Œ±]
  {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (h : has_compact_mul_support f) :
  bdd_above (range f) :=
@continuous.bdd_below_range_of_has_compact_mul_support Œ±·µí·µà _ _ _ _ _ _ _ _ hf h
end linear_order
end order_closed_topology
instance [preorder Œ±] [topological_space Œ±] [order_closed_topology Œ±]
  [preorder Œ≤] [topological_space Œ≤] [order_closed_topology Œ≤] :
  order_closed_topology (Œ± √ó Œ≤) :=
‚ü®(is_closed_le (continuous_fst.comp continuous_fst) (continuous_fst.comp continuous_snd)).inter
  (is_closed_le (continuous_snd.comp continuous_fst) (continuous_snd.comp continuous_snd))‚ü©
instance {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [Œ† i, preorder (Œ± i)] [Œ† i, topological_space (Œ± i)]
  [Œ† i, order_closed_topology (Œ± i)] : order_closed_topology (Œ† i, Œ± i) :=
begin
  constructor,
  simp only [pi.le_def, set_of_forall],
  exact is_closed_Inter (Œª i, is_closed_le ((continuous_apply i).comp continuous_fst)
    ((continuous_apply i).comp continuous_snd))
end
instance pi.order_closed_topology' [preorder Œ≤] [topological_space Œ≤]
  [order_closed_topology Œ≤] : order_closed_topology (Œ± ‚Üí Œ≤) :=
pi.order_closed_topology
class order_topology (Œ± : Type*) [t : topological_space Œ±] [preorder Œ±] : Prop :=
(topology_eq_generate_intervals : t = generate_from {s | ‚àÉa, s = Ioi a ‚à® s = Iio a})
def preorder.topology (Œ± : Type*) [preorder Œ±] : topological_space Œ± :=
generate_from {s : set Œ± | ‚àÉ (a : Œ±), s = {b : Œ± | a < b} ‚à® s = {b : Œ± | b < a}}
section order_topology
instance {Œ± : Type*} [topological_space Œ±] [partial_order Œ±] [order_topology Œ±] :
  order_topology Œ±·µí·µà :=
‚ü®by convert @order_topology.topology_eq_generate_intervals Œ± _ _ _;
  conv in (_ ‚à® _) { rw or.comm }; refl‚ü©
section partial_order
variables [topological_space Œ±] [partial_order Œ±] [t : order_topology Œ±]
include t
lemma is_open_iff_generate_intervals {s : set Œ±} :
  is_open s ‚Üî generate_open {s | ‚àÉa, s = Ioi a ‚à® s = Iio a} s :=
by rw [t.topology_eq_generate_intervals]; refl
lemma is_open_lt' (a : Œ±) : is_open {b:Œ± | a < b} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inl rfl‚ü©
lemma is_open_gt' (a : Œ±) : is_open {b:Œ± | b < a} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inr rfl‚ü©
lemma lt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a < x :=
is_open.mem_nhds (is_open_lt' _) h
lemma le_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a ‚â§ x :=
(ùìù b).sets_of_superset (lt_mem_nhds h) $ assume b hb, le_of_lt hb
lemma gt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
is_open.mem_nhds (is_open_gt' _) h
lemma ge_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
(ùìù a).sets_of_superset (gt_mem_nhds h) $ assume b hb, le_of_lt hb
lemma nhds_eq_order (a : Œ±) :
  ùìù a = (‚®Öb ‚àà Iio a, ùìü (Ioi b)) ‚äì (‚®Öb ‚àà Ioi a, ùìü (Iio b)) :=
by rw [t.topology_eq_generate_intervals, nhds_generate_from];
from le_antisymm
  (le_inf
    (le_infi‚ÇÇ $ assume b hb, infi_le_of_le {c : Œ± | b < c} $ infi_le _ ‚ü®hb, b, or.inl rfl‚ü©)
    (le_infi‚ÇÇ $ assume b hb, infi_le_of_le {c : Œ± | c < b} $ infi_le _ ‚ü®hb, b, or.inr rfl‚ü©))
  (le_infi $ assume s, le_infi $ assume ‚ü®ha, b, hs‚ü©,
    match s, ha, hs with
    | _, h, (or.inl rfl) := inf_le_of_left_le $ infi_le_of_le b $ infi_le _ h
    | _, h, (or.inr rfl) := inf_le_of_right_le $ infi_le_of_le b $ infi_le _ h
    end)
lemma tendsto_order {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤} :
  tendsto f x (ùìù a) ‚Üî (‚àÄ a' < a, ‚àÄ·∂† b in x, a' < f b) ‚àß (‚àÄ a' > a, ‚àÄ·∂† b in x, f b < a') :=
by simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]
instance tendsto_Icc_class_nhds (a : Œ±) : tendsto_Ixx_class Icc (ùìù a) (ùìù a) :=
begin
  simp only [nhds_eq_order, infi_subtype'],
  refine ((has_basis_infi_principal_finite _).inf
    (has_basis_infi_principal_finite _)).tendsto_Ixx_class (Œª s hs, _),
  refine ((ord_connected_bInter _).inter (ord_connected_bInter _)).out; intros _ _,
  exacts [ord_connected_Ioi, ord_connected_Iio]
end
instance tendsto_Ico_class_nhds (a : Œ±) : tendsto_Ixx_class Ico (ùìù a) (ùìù a) :=
tendsto_Ixx_class_of_subset (Œª _ _, Ico_subset_Icc_self)
instance tendsto_Ioc_class_nhds (a : Œ±) : tendsto_Ixx_class Ioc (ùìù a) (ùìù a) :=
tendsto_Ixx_class_of_subset (Œª _ _, Ioc_subset_Icc_self)
instance tendsto_Ioo_class_nhds (a : Œ±) : tendsto_Ixx_class Ioo (ùìù a) (ùìù a) :=
tendsto_Ixx_class_of_subset (Œª _ _, Ioo_subset_Icc_self)
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±}
  (hg : tendsto g b (ùìù a)) (hh : tendsto h b (ùìù a))
  (hgf : ‚àÄ·∂† b in b, g b ‚â§ f b) (hfh : ‚àÄ·∂† b in b, f b ‚â§ h b) :
  tendsto f b (ùìù a) :=
tendsto_order.2
  ‚ü®assume a' h',
    have ‚àÄ·∂† b in b, a' < g b, from (tendsto_order.1 hg).left a' h',
    by filter_upwards [this, hgf] with _ using lt_of_lt_of_le,
    assume a' h',
    have ‚àÄ·∂† b in b, h b < a', from (tendsto_order.1 hh).right a' h',
    by filter_upwards [this, hfh] with a h‚ÇÅ h‚ÇÇ using lt_of_le_of_lt h‚ÇÇ h‚ÇÅ‚ü©
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±}
  (hg : tendsto g b (ùìù a)) (hh : tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) :
  tendsto f b (ùìù a) :=
tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh
  (eventually_of_forall hgf) (eventually_of_forall hfh)
lemma nhds_order_unbounded {a : Œ±} (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) :
  ùìù a = (‚®Öl (h‚ÇÇ : l < a) u (h‚ÇÇ : a < u), ùìü (Ioo l u)) :=
have ‚àÉ u, u ‚àà Ioi a, from hu, have ‚àÉ l, l ‚àà Iio a, from hl,
by { simp only [nhds_eq_order, inf_binfi, binfi_inf, *, inf_principal, Ioi_inter_Iio], refl }
lemma tendsto_order_unbounded {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤}
  (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) (h : ‚àÄl u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂† b in x, l < f b ‚àß f b < u) :
  tendsto f x (ùìù a) :=
by rw [nhds_order_unbounded hu hl];
from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl,
  tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)
end partial_order
instance tendsto_Ixx_nhds_within {Œ± : Type*} [preorder Œ±] [topological_space Œ±]
  (a : Œ±) {s t : set Œ±} {Ixx}
  [tendsto_Ixx_class Ixx (ùìù a) (ùìù a)] [tendsto_Ixx_class Ixx (ùìü s) (ùìü t)]:
  tendsto_Ixx_class Ixx (ùìù[s] a) (ùìù[t] a) :=
filter.tendsto_Ixx_class_inf
instance tendsto_Icc_class_nhds_pi {Œπ : Type*} {Œ± : Œπ ‚Üí Type*}
  [Œ† i, partial_order (Œ± i)] [Œ† i, topological_space (Œ± i)] [‚àÄ i, order_topology (Œ± i)]
  (f : Œ† i, Œ± i) :
  tendsto_Ixx_class Icc (ùìù f) (ùìù f) :=
begin
  constructor,
  conv in ((ùìù f).small_sets) { rw [nhds_pi, filter.pi] },
  simp only [small_sets_infi, small_sets_comap, tendsto_infi, tendsto_lift', (‚àò), mem_powerset_iff],
  intros i s hs,
  have : tendsto (Œª g : Œ† i, Œ± i, g i) (ùìù f) (ùìù (f i)) := ((continuous_apply i).tendsto f),
  refine (tendsto_lift'.1 ((this.comp tendsto_fst).Icc (this.comp tendsto_snd)) s hs).mono _,
  exact Œª p hp g hg, hp ‚ü®hg.1 _, hg.2 _‚ü©
end
theorem induced_order_topology' {Œ± : Type u} {Œ≤ : Type v}
  [partial_order Œ±] [ta : topological_space Œ≤] [partial_order Œ≤] [order_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b)
  (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :
  @order_topology _ (induced f ta) _ :=
begin
  letI := induced f ta,
  refine ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (f a)],
  apply le_antisymm,
  { refine le_infi (Œª s, le_infi $ Œª hs, le_principal_iff.2 _),
    rcases hs with ‚ü®ab, b, rfl|rfl‚ü©,
    { exact mem_comap.2 ‚ü®{x | f b < x},
        mem_inf_of_left $ mem_infi_of_mem _ $ mem_infi_of_mem (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© },
    { exact mem_comap.2 ‚ü®{x | x < f b},
        mem_inf_of_right $ mem_infi_of_mem _ $ mem_infi_of_mem (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© } },
  { rw [‚Üê map_le_iff_le_comap],
    refine le_inf _ _; refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _); simp,
    { rcases H‚ÇÅ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_of_mem _ (mem_infi_of_mem ‚ü®ab, b, or.inl rfl‚ü© (mem_principal.2 _)),
      exact Œª c hc, lt_of_le_of_lt xb (hf.2 hc) },
    { rcases H‚ÇÇ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_of_mem _ (mem_infi_of_mem ‚ü®ab, b, or.inr rfl‚ü© (mem_principal.2 _)),
      exact Œª c hc, lt_of_lt_of_le (hf.2 hc) xb } },
end
theorem induced_order_topology {Œ± : Type u} {Œ≤ : Type v}
  [partial_order Œ±] [ta : topological_space Œ≤] [partial_order Œ≤] [order_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) :
  @order_topology _ (induced f ta) _ :=
induced_order_topology' f @hf
  (Œª a x xa, let ‚ü®b, xb, ba‚ü© := H xa in ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)
  (Œª a x ax, let ‚ü®b, ab, bx‚ü© := H ax in ‚ü®b, hf.1 ab, le_of_lt bx‚ü©)
instance order_topology_of_ord_connected {Œ± : Type u}
  [ta : topological_space Œ±] [linear_order Œ±] [order_topology Œ±]
  {t : set Œ±} [ht : ord_connected t] :
  order_topology t :=
begin
  letI := induced (coe : t ‚Üí Œ±) ta,
  refine ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (a : Œ±)],
  apply le_antisymm,
  { refine le_infi (Œª s, le_infi $ Œª hs, le_principal_iff.2 _),
    rcases hs with ‚ü®ab, b, rfl|rfl‚ü©,
    { refine ‚ü®Ioi b, _, Œª _, id‚ü©,
      refine mem_inf_of_left (mem_infi_of_mem b _),
      exact mem_infi_of_mem ab (mem_principal_self (Ioi ‚Üëb)) },
    { refine ‚ü®Iio b, _, Œª _, id‚ü©,
      refine mem_inf_of_right (mem_infi_of_mem b _),
      exact mem_infi_of_mem ab (mem_principal_self (Iio b)) } },
  { rw [‚Üê map_le_iff_le_comap],
    refine le_inf _ _,
    { refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _),
      by_cases hx : x ‚àà t,
      { refine mem_infi_of_mem (Ioi ‚ü®x, hx‚ü©) (mem_infi_of_mem ‚ü®h, ‚ü®‚ü®x, hx‚ü©, or.inl rfl‚ü©‚ü© _),
        exact Œª _, id },
      simp only [set_coe.exists, mem_set_of_eq, mem_map'],
      convert univ_sets _,
      suffices hx' : ‚àÄ (y : t), ‚Üëy ‚àà Ioi x,
      { simp [hx'] },
      intros y,
      revert hx,
      contrapose!,
lemma dense_iff_exists_between [densely_ordered Œ±] [nontrivial Œ±] {s : set Œ±} :
  dense s ‚Üî ‚àÄ a b, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b :=
‚ü®Œª h a b hab, h.exists_between hab, dense_of_exists_between‚ü©
lemma order_topology.t2_space : t2_space Œ± := by apply_instance
lemma mem_nhds_iff_exists_Ioo_subset' {a : Œ±} {s : set Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
begin
  split,
  { assume h,
    rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©,
    rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©,
    refine ‚ü®l, u, ‚ü®la, au‚ü©, Œªx hx, _‚ü©,
    cases le_total a x with hax hax,
    { exact hu ‚ü®hax, hx.2‚ü© },
    { exact hl ‚ü®hx.1, hax‚ü© } },
  { rintros ‚ü®l, u, ha, h‚ü©,
    apply mem_of_superset (is_open.mem_nhds is_open_Ioo ha) h }
end
lemma mem_nhds_iff_exists_Ioo_subset [no_max_order Œ±] [no_min_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
mem_nhds_iff_exists_Ioo_subset' (exists_lt a) (exists_gt a)
lemma nhds_basis_Ioo' {a : Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
  (ùìù a).has_basis (Œª b : Œ± √ó Œ±, b.1 < a ‚àß a < b.2) (Œª b, Ioo b.1 b.2) :=
‚ü®Œª s, (mem_nhds_iff_exists_Ioo_subset' hl hu).trans $ by simp‚ü©
lemma nhds_basis_Ioo [no_max_order Œ±] [no_min_order Œ±] (a : Œ±) :
  (ùìù a).has_basis (Œª b : Œ± √ó Œ±, b.1 < a ‚àß a < b.2) (Œª b, Ioo b.1 b.2) :=
nhds_basis_Ioo' (exists_lt a) (exists_gt a)
lemma filter.eventually.exists_Ioo_subset [no_max_order Œ±] [no_min_order Œ±] {a : Œ±} {p : Œ± ‚Üí Prop}
  (hp : ‚àÄ·∂† x in ùìù a, p x) :
  ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ {x | p x} :=
mem_nhds_iff_exists_Ioo_subset.1 hp
lemma countable_of_isolated_right [second_countable_topology Œ±] :
  set.countable {x : Œ± | ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ} :=
begin
  nontriviality Œ±,
  let s := {x : Œ± | ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ},
  have : ‚àÄ x ‚àà s, ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ := Œª x, id,
  choose! y hy h'y using this,
  have Hy : ‚àÄ x z, x ‚àà s ‚Üí z < y x ‚Üí z ‚â§ x,
  { assume x z xs hz,
    have A : Ioo x (y x) = ‚àÖ := h'y _ xs,
    contrapose! A,
    exact ne_empty_iff_nonempty.2 ‚ü®z, A, hz‚ü© },
  suffices H : ‚àÄ (a : set Œ±), is_open a ‚Üí set.countable {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a},
  { have : s ‚äÜ ‚ãÉ (a ‚àà countable_basis Œ±), {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a},
    { assume x hx,
      rcases (is_basis_countable_basis Œ±).exists_mem_of_ne (hy x hx).ne with ‚ü®a, ab, xa, ya‚ü©,
      simp only [mem_set_of_eq, mem_Union],
      exact ‚ü®a, ab, hx, xa, ya‚ü© },
    apply countable.mono this,
    refine countable.bUnion (countable_countable_basis Œ±) (Œª a ha, H _ _),
    exact is_open_of_mem_countable_basis ha },
  assume a ha,
  suffices H : set.countable {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨(is_bot x)},
  { have : {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a} ‚äÜ
      {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨(is_bot x)} ‚à™ {x | is_bot x},
    { assume x hx,
      by_cases h'x : is_bot x,
      { simp only [h'x, mem_set_of_eq, mem_union_eq, not_true, and_false, false_or] },
      { simpa only [h'x, hx.2.1, hx.2.2, mem_set_of_eq, mem_union_eq,
          not_false_iff, and_true, or_false] using hx.left } },
    exact countable.mono this (H.union (subsingleton_is_bot Œ±).countable) },
  let t := {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨(is_bot x)},
  have : ‚àÄ x ‚àà t, ‚àÉ z < x, Ioc z x ‚äÜ a,
  { assume x hx,
    apply exists_Ioc_subset_of_mem_nhds (ha.mem_nhds hx.2.1),
    simpa only [is_bot, not_forall, not_le] using hx.right.right.right },
  choose! z hz h'z using this,
  have : pairwise_disjoint t (Œª x, Ioc (z x) x),
  { assume x xt x' x't hxx',
    rcases lt_or_gt_of_ne hxx' with h'|h',
    { refine disjoint_left.2 (Œª u ux ux', xt.2.2.1 _),
      refine h'z x' x't ‚ü®ux'.1.trans_le (ux.2.trans (hy x xt.1).le), _‚ü©,
      by_contra' H,
      exact false.elim (lt_irrefl _ ((Hy _ _ xt.1 H).trans_lt h')) },
    { refine disjoint_left.2 (Œª u ux ux', x't.2.2.1 _),
      refine h'z x xt ‚ü®ux.1.trans_le (ux'.2.trans (hy x' x't.1).le), _‚ü©,
      by_contra' H,
      exact false.elim (lt_irrefl _ ((Hy _ _ x't.1 H).trans_lt h')) } },
  refine this.countable_of_is_open (Œª x hx, _) (Œª x hx, ‚ü®x, hz x hx, le_rfl‚ü©),
  suffices H : Ioc (z x) x = Ioo (z x) (y x),
  { rw H, exact is_open_Ioo },
  exact subset.antisymm (Ioc_subset_Ioo_right (hy x hx.1)) (Œª u hu, ‚ü®hu.1, Hy _ _ hx.1 hu.2‚ü©),
end
lemma countable_of_isolated_left [second_countable_topology Œ±] :
  set.countable {x : Œ± | ‚àÉ y, y < x ‚àß Ioo y x = ‚àÖ} :=
begin
  convert @countable_of_isolated_right Œ±·µí·µà _ _ _ _,
  have : ‚àÄ (x y : Œ±), Ioo x y = {z | z < y ‚àß x < z},
  { simp_rw [and_comm, Ioo], simp only [eq_self_iff_true, forall_2_true_iff] },
  simp_rw [this],
  refl
end
lemma set.pairwise_disjoint.countable_of_Ioo [second_countable_topology Œ±]
  {y : Œ± ‚Üí Œ±} {s : set Œ±} (h : pairwise_disjoint s (Œª x, Ioo x (y x))) (h' : ‚àÄ x ‚àà s, x < y x) :
  s.countable :=
begin
  let t := {x | x ‚àà s ‚àß (Ioo x (y x)).nonempty},
  have t_count : t.countable,
  { have : t ‚äÜ s := Œª x hx, hx.1,
    exact (h.subset this).countable_of_is_open (Œª x hx, is_open_Ioo) (Œª x hx, hx.2) },
  have : s ‚äÜ t ‚à™ {x : Œ± | ‚àÉ x', x < x' ‚àß Ioo x x' = ‚àÖ},
  { assume x hx,
    by_cases h'x : (Ioo x (y x)).nonempty,
    { exact or.inl ‚ü®hx, h'x‚ü© },
    { exact or.inr ‚ü®y x, h' x hx, not_nonempty_iff_eq_empty.1 h'x‚ü© } },
  exact countable.mono this (t_count.union countable_of_isolated_right),
end
section pi
variables {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [fintype Œπ] [Œ† i, linear_order (œÄ i)]
  [Œ† i, topological_space (œÄ i)] [‚àÄ i, order_topology (œÄ i)] {a b x : Œ† i, œÄ i} {a' b' x' : Œπ ‚Üí Œ±}
lemma pi_Iic_mem_nhds (ha : ‚àÄ i, x i < a i) : Iic a ‚àà ùìù x :=
pi_univ_Iic a ‚ñ∏ set_pi_mem_nhds (finite.of_fintype _) (Œª i _, Iic_mem_nhds (ha _))
lemma pi_Iic_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iic a' ‚àà ùìù x' :=
pi_Iic_mem_nhds ha
lemma pi_Ici_mem_nhds (ha : ‚àÄ i, a i < x i) : Ici a ‚àà ùìù x :=
pi_univ_Ici a ‚ñ∏ set_pi_mem_nhds (finite.of_fintype _) (Œª i _, Ici_mem_nhds (ha _))
lemma pi_Ici_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ici a' ‚àà ùìù x' :=
pi_Ici_mem_nhds ha
lemma pi_Icc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Icc a b ‚àà ùìù x :=
pi_univ_Icc a b ‚ñ∏ set_pi_mem_nhds (finite.of_fintype _) (Œª i _, Icc_mem_nhds (ha _) (hb _))
lemma pi_Icc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Icc a' b' ‚àà ùìù x' :=
pi_Icc_mem_nhds ha hb
variables [nonempty Œπ]
lemma pi_Iio_mem_nhds (ha : ‚àÄ i, x i < a i) : Iio a ‚àà ùìù x :=
begin
  refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Œª i _, _))
    (pi_univ_Iio_subset a),
  exact Iio_mem_nhds (ha i)
end
lemma pi_Iio_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iio a' ‚àà ùìù x' :=
pi_Iio_mem_nhds ha
lemma pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=
@pi_Iio_mem_nhds Œπ (Œª i, (œÄ i)·µí·µà) _ _ _ _ _ _ _ ha
lemma pi_Ioi_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ioi a' ‚àà ùìù x' :=
pi_Ioi_mem_nhds ha
lemma pi_Ioc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioc a b ‚àà ùìù x :=
begin
  refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Œª i _, _))
    (pi_univ_Ioc_subset a b),
  exact Ioc_mem_nhds (ha i) (hb i)
end
lemma pi_Ioc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioc a' b' ‚àà ùìù x' :=
pi_Ioc_mem_nhds ha hb
lemma pi_Ico_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ico a b ‚àà ùìù x :=
begin
  refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Œª i _, _))
    (pi_univ_Ico_subset a b),
  exact Ico_mem_nhds (ha i) (hb i)
end
lemma pi_Ico_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ico a' b' ‚àà ùìù x' :=
pi_Ico_mem_nhds ha hb
lemma pi_Ioo_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioo a b ‚àà ùìù x :=
begin
  refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Œª i _, _))
    (pi_univ_Ioo_subset a b),
  exact Ioo_mem_nhds (ha i) (hb i)
end
lemma pi_Ioo_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioo a' b' ‚àà ùìù x' :=
pi_Ioo_mem_nhds ha hb
end pi
lemma disjoint_nhds_at_top [no_max_order Œ±] (x : Œ±) :
  disjoint (ùìù x) at_top :=
begin
  rcases exists_gt x with ‚ü®y, hy : x < y‚ü©,
  refine disjoint_of_disjoint_of_mem _ (Iio_mem_nhds hy) (mem_at_top y),
  exact disjoint_left.mpr (Œª z, not_le.2)
end
@[simp] lemma inf_nhds_at_top [no_max_order Œ±] (x : Œ±) :
  ùìù x ‚äì at_top = ‚ä• :=
disjoint_iff.1 (disjoint_nhds_at_top x)
lemma disjoint_nhds_at_bot [no_min_order Œ±] (x : Œ±) : disjoint (ùìù x) at_bot :=
@disjoint_nhds_at_top Œ±·µí·µà _ _ _ _ x
@[simp] lemma inf_nhds_at_bot [no_min_order Œ±] (x : Œ±) : ùìù x ‚äì at_bot = ‚ä• :=
@inf_nhds_at_top Œ±·µí·µà _ _ _ _ x
lemma not_tendsto_nhds_of_tendsto_at_top [no_max_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} (hf : tendsto f F at_top) (x : Œ±) :
  ¬¨ tendsto f F (ùìù x) :=
hf.not_tendsto (disjoint_nhds_at_top x).symm
lemma not_tendsto_at_top_of_tendsto_nhds [no_max_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} {x : Œ±} (hf : tendsto f F (ùìù x)) :
  ¬¨  tendsto f F at_top :=
hf.not_tendsto (disjoint_nhds_at_top x)
lemma not_tendsto_nhds_of_tendsto_at_bot [no_min_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} (hf : tendsto f F at_bot) (x : Œ±) :
  ¬¨ tendsto f F (ùìù x) :=
hf.not_tendsto (disjoint_nhds_at_bot x).symm
lemma not_tendsto_at_bot_of_tendsto_nhds [no_min_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} {x : Œ±} (hf : tendsto f F (ùìù x)) :
  ¬¨ tendsto f F at_bot :=
hf.not_tendsto (disjoint_nhds_at_bot x)
lemma tfae_mem_nhds_within_Ioi {a b : Œ±} (hab : a < b) (s : set Œ±) :
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[>] a ‚Üî ‚àÉu ‚àà Ioi a, Ioo a u ‚äÜ s :=
(tfae_mem_nhds_within_Ioi hu' s).out 0 4
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset [no_max_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[>] a ‚Üî ‚àÉu ‚àà Ioi a, Ioo a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := exists_gt a in mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'
lemma mem_nhds_within_Ioi_iff_exists_Ioc_subset [no_max_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[>] a ‚Üî ‚àÉu ‚àà Ioi a, Ioc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ioi_iff_exists_Ioo_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases exists_between au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ioo_subset_Ioc_self as‚ü© }
end
lemma tfae_mem_nhds_within_Iio {a b : Œ±} (h : a < b) (s : set Œ±) :
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[<] a ‚Üî ‚àÉl ‚àà Iio a, Ioo l a ‚äÜ s :=
(tfae_mem_nhds_within_Iio hl' s).out 0 4
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset [no_min_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[<] a ‚Üî ‚àÉl ‚àà Iio a, Ioo l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := exists_lt a in mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'
lemma mem_nhds_within_Iio_iff_exists_Ico_subset [no_min_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[<] a ‚Üî ‚àÉl ‚àà Iio a, Ico l a ‚äÜ s :=
begin
  have : of_dual ‚Åª¬π' s ‚àà ùìù[>] (to_dual a) ‚Üî _ :=
    mem_nhds_within_Ioi_iff_exists_Ioc_subset,
  simpa only [order_dual.exists, exists_prop, dual_Ioc] using this,
end
lemma tfae_mem_nhds_within_Ici {a b : Œ±} (hab : a < b) (s : set Œ±) :
lemma mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[‚â•] a ‚Üî ‚àÉu ‚àà Ioi a, Ico a u ‚äÜ s :=
(tfae_mem_nhds_within_Ici hu' s).out 0 4 (by norm_num) (by norm_num)
lemma mem_nhds_within_Ici_iff_exists_Ico_subset [no_max_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[‚â•] a ‚Üî ‚àÉu ‚àà Ioi a, Ico a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := exists_gt a in mem_nhds_within_Ici_iff_exists_Ico_subset' hu'
lemma mem_nhds_within_Ici_iff_exists_Icc_subset' [no_max_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[‚â•] a ‚Üî ‚àÉu ‚àà Ioi a, Icc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ici_iff_exists_Ico_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases exists_between au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü© }
end
lemma tfae_mem_nhds_within_Iic {a b : Œ±} (h : a < b) (s : set Œ±) :
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[‚â§] a ‚Üî ‚àÉl ‚àà Iio a, Ioc l a ‚äÜ s :=
(tfae_mem_nhds_within_Iic hl' s).out 0 4 (by norm_num) (by norm_num)
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset [no_min_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[‚â§] a ‚Üî ‚àÉl ‚àà Iio a, Ioc l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := exists_lt a in mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'
lemma mem_nhds_within_Iic_iff_exists_Icc_subset' [no_min_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[‚â§] a ‚Üî ‚àÉl ‚àà Iio a, Icc l a ‚äÜ s :=
begin
  convert @mem_nhds_within_Ici_iff_exists_Icc_subset' Œ±·µí·µà _ _ _ _ _ _ _,
  simp_rw (show ‚àÄ u : Œ±·µí·µà, @Icc Œ±·µí·µà _ a u = @Icc Œ± _ u a, from Œª u, dual_Icc),
  refl,
end
lemma mem_nhds_within_Ici_iff_exists_Icc_subset [no_max_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[‚â•] a ‚Üî ‚àÉu, a < u ‚àß Icc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ici_iff_exists_Ico_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases exists_between au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü© }
end
lemma mem_nhds_within_Iic_iff_exists_Icc_subset [no_min_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[‚â§] a ‚Üî ‚àÉl, l < a ‚àß Icc l a ‚äÜ s :=
begin
  rw mem_nhds_within_Iic_iff_exists_Ioc_subset,
  split,
  { rintros ‚ü®l, la, as‚ü©,
    rcases exists_between la with ‚ü®v, hv‚ü©,
    refine ‚ü®v, hv.2, Œªx hx, as ‚ü®lt_of_lt_of_le hv.1 hx.1, hx.2‚ü©‚ü©, },
  { rintros ‚ü®l, la, as‚ü©,
    exact ‚ü®l, la, subset.trans Ioc_subset_Icc_self as‚ü© }
end
end order_topology
end linear_order
section linear_ordered_add_comm_group
variables [topological_space Œ±] [linear_ordered_add_comm_group Œ±] [order_topology Œ±]
variables {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±}
lemma nhds_eq_infi_abs_sub (a : Œ±) : ùìù a = (‚®Ör>0, ùìü {b | |a - b| < r}) :=
begin
  simp only [le_antisymm_iff, nhds_eq_order, le_inf_iff, le_infi_iff, le_principal_iff, mem_Ioi,
    mem_Iio, abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt _ _ _ _ a, set_of_and],
  refine ‚ü®_, _, _‚ü©,
  { intros Œµ Œµ0,
    exact inter_mem_inf
      (mem_infi_of_mem (a - Œµ) $ mem_infi_of_mem (sub_lt_self a Œµ0) (mem_principal_self _))
      (mem_infi_of_mem (Œµ + a) $ mem_infi_of_mem (by simpa) (mem_principal_self _)) },
  { intros b hb,
    exact mem_infi_of_mem (a - b) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Ioi])) },
  { intros b hb,
    exact mem_infi_of_mem (b - a) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Iio])) }
end
lemma order_topology_of_nhds_abs {Œ± : Type*} [topological_space Œ±] [linear_ordered_add_comm_group Œ±]
  (h_nhds : ‚àÄa:Œ±, ùìù a = (‚®Ör>0, ùìü {b | |a - b| < r})) : order_topology Œ± :=
begin
  refine ‚ü®eq_of_nhds_eq_nhds $ Œª a, _‚ü©,
  rw [h_nhds],
  letI := preorder.topology Œ±, letI : order_topology Œ± := ‚ü®rfl‚ü©,
  exact (nhds_eq_infi_abs_sub a).symm
end
lemma linear_ordered_add_comm_group.tendsto_nhds {x : filter Œ≤} {a : Œ±} :
  tendsto f x (ùìù a) ‚Üî ‚àÄ Œµ > (0 : Œ±), ‚àÄ·∂† b in x, |f b - a| < Œµ :=
by simp [nhds_eq_infi_abs_sub, abs_sub_comm a]
lemma eventually_abs_sub_lt (a : Œ±) {Œµ : Œ±} (hŒµ : 0 < Œµ) : ‚àÄ·∂† x in ùìù a, |x - a| < Œµ :=
(nhds_eq_infi_abs_sub a).symm ‚ñ∏ mem_infi_of_mem Œµ
  (mem_infi_of_mem hŒµ $ by simp only [abs_sub_comm, mem_principal_self])
lemma nhds_basis_Ioo_pos_of_pos [no_min_order Œ±] [no_max_order Œ±]
  {a : Œ±} (ha : 0 < a) :
  (ùìù a).has_basis (Œª Œµ : Œ±, (0 : Œ±) < Œµ ‚àß Œµ ‚â§ a) (Œª Œµ, Ioo (a-Œµ) (a+Œµ)) :=
‚ü® Œª t, (nhds_basis_Ioo_pos a).mem_iff.trans
  ‚ü®Œª h, let ‚ü®i, hi, hit‚ü© := h in
    ‚ü®min i a, ‚ü®lt_min hi ha, min_le_right i a‚ü©, trans (Ioo_subset_Ioo
    (sub_le_sub_left (min_le_left i a) a) (add_le_add_left (min_le_left i a) a)) hit‚ü©,
  Œª h, let ‚ü®i, hi, hit‚ü© := h in ‚ü®i, hi.1, hit‚ü© ‚ü© ‚ü©
section
variables [topological_space Œ≤] {b : Œ≤} {a : Œ±} {s : set Œ≤}
lemma continuous.abs (h : continuous f) : continuous (Œª x, |f x|) := continuous_abs.comp h
lemma continuous_at.abs (h : continuous_at f b) : continuous_at (Œª x, |f x|) b := h.abs
lemma continuous_within_at.abs (h : continuous_within_at f s b) :
  continuous_within_at (Œª x, |f x|) s b := h.abs
lemma continuous_on.abs (h : continuous_on f s) : continuous_on (Œª x, |f x|) s :=
Œª x hx, (h x hx).abs
lemma tendsto_abs_nhds_within_zero : tendsto (abs : Œ± ‚Üí Œ±) (ùìù[‚â†] 0) (ùìù[>] 0) :=
(continuous_abs.tendsto' (0 : Œ±) 0 abs_zero).inf $ tendsto_principal_principal.2 $ Œª x, abs_pos.2
end
lemma filter.tendsto.add_at_top {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x + g x) l at_top :=
begin
  nontriviality Œ±,
  obtain ‚ü®C', hC'‚ü© : ‚àÉ C', C' < C := exists_lt C,
  refine tendsto_at_top_add_left_of_le' _ C' _ hg,
  exact (hf.eventually (lt_mem_nhds hC')).mono (Œª x, le_of_lt)
end
lemma filter.tendsto.add_at_bot {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x + g x) l at_bot :=
@filter.tendsto.add_at_top Œ±·µí·µà _ _ _ _ _ _ _ _ hf hg
lemma filter.tendsto.at_top_add {C : Œ±} (hf : tendsto f l at_top) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, f x + g x) l at_top :=
by { conv in (_ + _) { rw add_comm }, exact hg.add_at_top hf }
lemma filter.tendsto.at_bot_add {C : Œ±} (hf : tendsto f l at_bot) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, f x + g x) l at_bot :=
by { conv in (_ + _) { rw add_comm }, exact hg.add_at_bot hf }
end linear_ordered_add_comm_group
section linear_ordered_field
variables [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±]
variables {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±}
section continuous_mul
lemma mul_tendsto_nhds_zero_right (x : Œ±) :
  tendsto (uncurry ((*) : Œ± ‚Üí Œ± ‚Üí Œ±)) (ùìù 0 √ó·∂† ùìù x) $ ùìù 0 :=
begin
  have hx : 0 < 2 * (1 + |x|) := (mul_pos (zero_lt_two) $
    lt_of_lt_of_le zero_lt_one $ le_add_of_le_of_nonneg le_rfl (abs_nonneg x)),
  rw ((nhds_basis_zero_abs_sub_lt Œ±).prod $ nhds_basis_abs_sub_lt x).tendsto_iff
     (nhds_basis_zero_abs_sub_lt Œ±),
  refine Œª Œµ Œµ_pos, ‚ü®(Œµ/(2 * (1 + |x|)), 1), ‚ü®div_pos Œµ_pos hx, zero_lt_one‚ü©, _‚ü©,
  suffices : ‚àÄ (a b : Œ±), |a| < Œµ / (2 * (1 + |x|)) ‚Üí |b - x| < 1 ‚Üí |a| * |b| < Œµ,
  by simpa only [and_imp, prod.forall, mem_prod, ‚Üê abs_mul],
  intros a b h h',
  refine lt_of_le_of_lt (mul_le_mul_of_nonneg_left _ (abs_nonneg a)) ((lt_div_iff hx).1 h),
  calc |b| = |(b - x) + x| : by rw sub_add_cancel b x
    ... ‚â§ |b - x| + |x| : abs_add (b - x) x
    ... ‚â§ 1 + |x| : add_le_add_right (le_of_lt h') (|x|)
    ... ‚â§ 2 * (1 + |x|) : by linarith,
end
lemma mul_tendsto_nhds_zero_left (x : Œ±) :
  tendsto (uncurry ((*) : Œ± ‚Üí Œ± ‚Üí Œ±)) (ùìù x √ó·∂† ùìù 0) $ ùìù 0 :=
begin
  intros s hs,
  have := mul_tendsto_nhds_zero_right x hs,
  rw [filter.mem_map, mem_prod_iff] at this ‚ä¢,
  obtain ‚ü®U, hU, V, hV, h‚ü© := this,
  exact ‚ü®V, hV, U, hU, Œª y hy, ((mul_comm y.2 y.1) ‚ñ∏
    h (‚ü®hy.2, hy.1‚ü© : (prod.mk y.2 y.1) ‚àà U √óÀ¢ V) : y.1 * y.2 ‚àà s)‚ü©,
end
lemma nhds_eq_map_mul_left_nhds_one {x‚ÇÄ : Œ±} (hx‚ÇÄ : x‚ÇÄ ‚â† 0) :
  ùìù x‚ÇÄ = map (Œª x, x‚ÇÄ*x) (ùìù 1) :=
begin
  have hx‚ÇÄ' : 0 < |x‚ÇÄ| := abs_pos.2 hx‚ÇÄ,
  refine filter.ext (Œª t, _),
  simp only [exists_prop, set_of_subset_set_of, (nhds_basis_abs_sub_lt x‚ÇÄ).mem_iff,
    (nhds_basis_abs_sub_lt (1 : Œ±)).mem_iff, filter.mem_map'],
  refine ‚ü®Œª h, _, Œª h, _‚ü©,
  { obtain ‚ü®i, hi, hit‚ü© := h,
    refine ‚ü®i / (|x‚ÇÄ|), div_pos hi (abs_pos.2 hx‚ÇÄ), Œª x hx, hit _‚ü©,
    calc |x‚ÇÄ * x - x‚ÇÄ| = |x‚ÇÄ * (x - 1)| : congr_arg abs (by ring_nf)
      ... = |x‚ÇÄ| * |x - 1| : abs_mul x‚ÇÄ (x - 1)
      ... < |x‚ÇÄ| * (i / |x‚ÇÄ|) : mul_lt_mul' le_rfl hx (abs_nonneg (x - 1)) (abs_pos.2 hx‚ÇÄ)
      ... = |x‚ÇÄ| * i / |x‚ÇÄ| : by ring
      ... = i : mul_div_cancel_left i (Œª h, hx‚ÇÄ (abs_eq_zero.1 h)) },
  { obtain ‚ü®i, hi, hit‚ü© := h,
    refine ‚ü®i * |x‚ÇÄ|, mul_pos hi (abs_pos.2 hx‚ÇÄ), Œª x hx, _‚ü©,
    have : |x / x‚ÇÄ - 1| < i,
    calc |x / x‚ÇÄ - 1| = |x / x‚ÇÄ - x‚ÇÄ / x‚ÇÄ| : (by rw div_self hx‚ÇÄ)
    ... = |(x - x‚ÇÄ) / x‚ÇÄ| : congr_arg abs (sub_div x x‚ÇÄ x‚ÇÄ).symm
    ... = |x - x‚ÇÄ| / |x‚ÇÄ| : abs_div (x - x‚ÇÄ) x‚ÇÄ
    ... < i * |x‚ÇÄ| / |x‚ÇÄ| : div_lt_div hx le_rfl
      (mul_nonneg (le_of_lt hi) (abs_nonneg x‚ÇÄ)) (abs_pos.2 hx‚ÇÄ)
    ... = i : by rw [‚Üê mul_div_assoc', div_self (ne_of_lt $ abs_pos.2 hx‚ÇÄ).symm, mul_one],
    specialize hit (x / x‚ÇÄ) this,
    rwa [mul_div_assoc', mul_div_cancel_left x hx‚ÇÄ] at hit }
end
lemma nhds_eq_map_mul_right_nhds_one {x‚ÇÄ : Œ±} (hx‚ÇÄ : x‚ÇÄ ‚â† 0) :
  ùìù x‚ÇÄ = map (Œª x, x*x‚ÇÄ) (ùìù 1) :=
by simp_rw [mul_comm _ x‚ÇÄ, nhds_eq_map_mul_left_nhds_one hx‚ÇÄ]
lemma mul_tendsto_nhds_one_nhds_one :
  tendsto (uncurry ((*) : Œ± ‚Üí Œ± ‚Üí Œ±)) (ùìù 1 √ó·∂† ùìù 1) $ ùìù 1 :=
begin
  rw ((nhds_basis_Ioo_pos (1 : Œ±)).prod $ nhds_basis_Ioo_pos (1 : Œ±)).tendsto_iff
     (nhds_basis_Ioo_pos_of_pos (zero_lt_one : (0 : Œ±) < 1)),
  intros Œµ hŒµ,
  have hŒµ' : 0 ‚â§ 1 - Œµ / 4 := by linarith,
  have Œµ_pos : 0 < Œµ / 4 := by linarith,
  have Œµ_pos' : 0 < Œµ / 2 := by linarith,
  simp only [and_imp, prod.forall, mem_Ioo, function.uncurry_apply_pair, mem_prod, prod.exists],
  refine ‚ü®Œµ/4, Œµ/4, ‚ü®Œµ_pos, Œµ_pos‚ü©, Œª a b ha ha' hb hb', _‚ü©,
  have ha0 : 0 ‚â§ a := le_trans hŒµ' (le_of_lt ha),
  have hb0 : 0 ‚â§ b := le_trans hŒµ' (le_of_lt hb),
  refine ‚ü®lt_of_le_of_lt _ (mul_lt_mul'' ha hb hŒµ' hŒµ'),
    lt_of_lt_of_le (mul_lt_mul'' ha' hb' ha0 hb0) _‚ü©,
  { calc 1 - Œµ = 1 - Œµ / 2 - Œµ/2 : by ring_nf
    ... ‚â§ 1 - Œµ/2 - Œµ/2 + (Œµ/2)*(Œµ/2) : le_add_of_nonneg_right (le_of_lt (mul_pos Œµ_pos' Œµ_pos'))
    ... = (1 - Œµ/2) * (1 - Œµ/2) : by ring_nf
    ... ‚â§ (1 - Œµ/4) * (1 - Œµ/4) : mul_le_mul (by linarith) (by linarith) (by linarith) hŒµ' },
  { calc (1 + Œµ/4) * (1 + Œµ/4) = 1 + Œµ/2 + (Œµ/4)*(Œµ/4) : by ring_nf
    ... = 1 + Œµ/2 + (Œµ * Œµ) / 16 : by ring_nf
    ... ‚â§ 1 + Œµ/2 + Œµ/2 : add_le_add_left (div_le_div (le_of_lt hŒµ.1) (le_trans
      ((mul_le_mul_left hŒµ.1).2 hŒµ.2) (le_of_eq $ mul_one Œµ)) zero_lt_two (by linarith)) (1 + Œµ/2)
    ... ‚â§ 1 + Œµ : by ring_nf }
end
@[priority 100]
instance linear_ordered_field.has_continuous_mul : has_continuous_mul Œ± :=
‚ü®begin
  rw continuous_iff_continuous_at,
  rintro ‚ü®x‚ÇÄ, y‚ÇÄ‚ü©,
  by_cases hx‚ÇÄ : x‚ÇÄ = 0,
  { rw [hx‚ÇÄ, continuous_at, zero_mul, nhds_prod_eq],
    exact mul_tendsto_nhds_zero_right y‚ÇÄ },
  by_cases hy‚ÇÄ : y‚ÇÄ = 0,
  { rw [hy‚ÇÄ, continuous_at, mul_zero, nhds_prod_eq],
    exact mul_tendsto_nhds_zero_left x‚ÇÄ },
  have hxy : x‚ÇÄ * y‚ÇÄ ‚â† 0 := mul_ne_zero hx‚ÇÄ hy‚ÇÄ,
  have key : (Œª p : Œ± √ó Œ±, x‚ÇÄ * p.1 * (p.2 * y‚ÇÄ)) = ((Œª x, x‚ÇÄ*x) ‚àò (Œª x, x*y‚ÇÄ)) ‚àò (uncurry (*)),
  { ext p, simp [uncurry, mul_assoc] },
  have key‚ÇÇ : (Œª x, x‚ÇÄ*x) ‚àò (Œª x, y‚ÇÄ*x) = Œª x, (x‚ÇÄ *y‚ÇÄ)*x,
  { ext x, simp },
  calc map (uncurry (*)) (ùìù (x‚ÇÄ, y‚ÇÄ))
      = map (uncurry (*)) (ùìù x‚ÇÄ √ó·∂† ùìù y‚ÇÄ) : by rw nhds_prod_eq
  ... = map (Œª (p : Œ± √ó Œ±), x‚ÇÄ * p.1 * (p.2 * y‚ÇÄ)) ((ùìù 1) √ó·∂† (ùìù 1))
          : by rw [uncurry, nhds_eq_map_mul_left_nhds_one hx‚ÇÄ, nhds_eq_map_mul_right_nhds_one hy‚ÇÄ,
                    prod_map_map_eq, filter.map_map]
  ... = map ((Œª x, x‚ÇÄ * x) ‚àò Œª x, x * y‚ÇÄ) (map (uncurry (*)) (ùìù 1 √ó·∂† ùìù 1))
          : by rw [key, ‚Üê filter.map_map]
  ... ‚â§ map ((Œª (x : Œ±), x‚ÇÄ * x) ‚àò Œª x, x * y‚ÇÄ) (ùìù 1) : map_mono (mul_tendsto_nhds_one_nhds_one)
  ... = ùìù (x‚ÇÄ*y‚ÇÄ) : by rw [‚Üê filter.map_map, ‚Üê nhds_eq_map_mul_right_nhds_one hy‚ÇÄ,
    nhds_eq_map_mul_left_nhds_one hy‚ÇÄ, filter.map_map, key‚ÇÇ, ‚Üê nhds_eq_map_mul_left_nhds_one hxy],
end‚ü©
end continuous_mul
lemma filter.tendsto.at_top_mul {C : Œ±} (hC : 0 < C) (hf : tendsto f l at_top)
  (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, (f x * g x)) l at_top :=
begin
  refine tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC)),
  filter_upwards [hg.eventually (lt_mem_nhds (half_lt_self hC)),
    hf.eventually (eventually_ge_at_top 0)] with x hg hf using mul_le_mul_of_nonneg_left hg.le hf,
end
lemma filter.tendsto.mul_at_top {C : Œ±} (hC : 0 < C) (hf : tendsto f l (ùìù C))
  (hg : tendsto g l at_top) :
  tendsto (Œª x, (f x * g x)) l at_top :=
by simpa only [mul_comm] using hg.at_top_mul hC hf
lemma filter.tendsto.at_top_mul_neg {C : Œ±} (hC : C < 0) (hf : tendsto f l at_top)
  (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, (f x * g x)) l at_bot :=
by simpa only [(‚àò), neg_mul_eq_mul_neg, neg_neg]
  using tendsto_neg_at_top_at_bot.comp (hf.at_top_mul (neg_pos.2 hC) hg.neg)
lemma filter.tendsto.neg_mul_at_top {C : Œ±} (hC : C < 0) (hf : tendsto f l (ùìù C))
  (hg : tendsto g l at_top) :
  tendsto (Œª x, (f x * g x)) l at_bot :=
by simpa only [mul_comm] using hg.at_top_mul_neg hC hf
lemma filter.tendsto.at_bot_mul {C : Œ±} (hC : 0 < C) (hf : tendsto f l at_bot)
  (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, (f x * g x)) l at_bot :=
by simpa [(‚àò)]
  using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul hC hg)
lemma filter.tendsto.at_bot_mul_neg {C : Œ±} (hC : C < 0) (hf : tendsto f l at_bot)
  (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, (f x * g x)) l at_top :=
by simpa [(‚àò)]
  using tendsto_neg_at_bot_at_top.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul_neg hC hg)
lemma filter.tendsto.mul_at_bot {C : Œ±} (hC : 0 < C) (hf : tendsto f l (ùìù C))
  (hg : tendsto g l at_bot) :
  tendsto (Œª x, (f x * g x)) l at_bot :=
by simpa only [mul_comm] using hg.at_bot_mul hC hf
lemma filter.tendsto.neg_mul_at_bot {C : Œ±} (hC : C < 0) (hf : tendsto f l (ùìù C))
  (hg : tendsto g l at_bot) :
  tendsto (Œª x, (f x * g x)) l at_top :=
by simpa only [mul_comm] using hg.at_bot_mul_neg hC hf
lemma tendsto_inv_zero_at_top : tendsto (Œªx:Œ±, x‚Åª¬π) (ùìù[>] (0:Œ±)) at_top :=
begin
  refine (at_top_basis' 1).tendsto_right_iff.2 (Œª b hb, _),
  have hb' : 0 < b := zero_lt_one.trans_le hb,
  filter_upwards [Ioc_mem_nhds_within_Ioi ‚ü®le_rfl, inv_pos.2 hb'‚ü©]
    with x hx using (le_inv hx.1 hb').1 hx.2,
end
lemma tendsto_inv_at_top_zero' : tendsto (Œªr:Œ±, r‚Åª¬π) at_top (ùìù[>] (0:Œ±)) :=
begin
  refine (has_basis.tendsto_iff at_top_basis ‚ü®Œª s, mem_nhds_within_Ioi_iff_exists_Ioc_subset‚ü©).2 _,
  refine Œª b hb, ‚ü®b‚Åª¬π, trivial, Œª x hx, _‚ü©,
  have : 0 < x := lt_of_lt_of_le (inv_pos.2 hb) hx,
  exact ‚ü®inv_pos.2 this, (inv_le this hb).2 hx‚ü©
end
lemma tendsto_inv_at_top_zero : tendsto (Œªr:Œ±, r‚Åª¬π) at_top (ùìù 0) :=
tendsto_inv_at_top_zero'.mono_right inf_le_left
lemma filter.tendsto.div_at_top [has_continuous_mul Œ±] {f g : Œ≤ ‚Üí Œ±} {l : filter Œ≤} {a : Œ±}
  (h : tendsto f l (ùìù a)) (hg : tendsto g l at_top) : tendsto (Œª x, f x / g x) l (ùìù 0) :=
by { simp only [div_eq_mul_inv], exact mul_zero a ‚ñ∏ h.mul (tendsto_inv_at_top_zero.comp hg) }
lemma filter.tendsto.inv_tendsto_at_top (h : tendsto f l at_top) : tendsto (f‚Åª¬π) l (ùìù 0) :=
tendsto_inv_at_top_zero.comp h
lemma filter.tendsto.inv_tendsto_zero (h : tendsto f l (ùìù[>] 0)) :
  tendsto (f‚Åª¬π) l at_top :=
tendsto_inv_zero_at_top.comp h
lemma tendsto_pow_neg_at_top {n : ‚Ñï} (hn : 1 ‚â§ n) : tendsto (Œª x : Œ±, x ^ (-(n:‚Ñ§))) at_top (ùìù 0) :=
tendsto.congr (Œª x, (zpow_neg x n).symm)
  (filter.tendsto.inv_tendsto_at_top (by simpa [zpow_coe_nat] using tendsto_pow_at_top hn))
lemma tendsto_zpow_at_top_zero {n : ‚Ñ§} (hn : n < 0) :
  tendsto (Œª x : Œ±, x^n) at_top (ùìù 0) :=
begin
  have : 1 ‚â§ -n := le_neg.mp (int.le_of_lt_add_one (hn.trans_le (neg_add_self 1).symm.le)),
  apply tendsto.congr (show ‚àÄ x : Œ±, x^-(-n) = x^n, by simp),
  lift -n to ‚Ñï using le_of_lt (neg_pos.mpr hn) with N,
  exact tendsto_pow_neg_at_top (by exact_mod_cast this)
end
lemma tendsto_const_mul_zpow_at_top_zero {n : ‚Ñ§} {c : Œ±} (hn : n < 0) :
  tendsto (Œª x, c * x ^ n) at_top (ùìù 0) :=
(mul_zero c) ‚ñ∏ (filter.tendsto.const_mul c (tendsto_zpow_at_top_zero hn))
lemma tendsto_const_mul_pow_nhds_iff {n : ‚Ñï} {c d : Œ±} (hc : c ‚â† 0) :
  tendsto (Œª x : Œ±, c * x ^ n) at_top (ùìù d) ‚Üî n = 0 ‚àß c = d :=
begin
  refine ‚ü®Œª h, _, Œª h, _‚ü©,
  { have hn : n = 0,
    { by_contradiction hn,
      have hn : 1 ‚â§ n := nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn)),
      by_cases hc' : 0 < c,
      { have := (tendsto_const_mul_pow_at_top_iff c n).2 ‚ü®hn, hc'‚ü©,
        exact not_tendsto_nhds_of_tendsto_at_top this d h },
      { have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 ‚ü®hn, lt_of_le_of_ne (not_lt.1 hc') hc‚ü©,
        exact not_tendsto_nhds_of_tendsto_at_bot this d h } },
    have : (Œª x : Œ±, c * x ^ n) = (Œª x : Œ±, c), by simp [hn],
    rw [this, tendsto_const_nhds_iff] at h,
    exact ‚ü®hn, h‚ü© },
  { obtain ‚ü®hn, hcd‚ü© := h,
    simpa [hn, hcd] using tendsto_const_nhds }
end
lemma tendsto_const_mul_zpow_at_top_zero_iff {n : ‚Ñ§} {c d : Œ±} (hc : c ‚â† 0) :
  tendsto (Œª x : Œ±, c * x ^ n) at_top (ùìù d) ‚Üî
    (n = 0 ‚àß c = d) ‚à® (n < 0 ‚àß d = 0) :=
begin
  refine ‚ü®Œª h, _, Œª h, _‚ü©,
  { by_cases hn : 0 ‚â§ n,
    { lift n to ‚Ñï using hn,
      simp only [zpow_coe_nat] at h,
      rw [tendsto_const_mul_pow_nhds_iff hc, ‚Üê int.coe_nat_eq_zero] at h,
      exact or.inl h },
    { rw not_le at hn,
      refine or.inr ‚ü®hn, tendsto_nhds_unique h (tendsto_const_mul_zpow_at_top_zero hn)‚ü© } },
  { cases h,
    { simp only [h.left, h.right, zpow_zero, mul_one],
      exact tendsto_const_nhds },
    { exact h.2.symm ‚ñ∏ tendsto_const_mul_zpow_at_top_zero h.1} }
end
end linear_ordered_field
lemma preimage_neg [add_group Œ±] : preimage (has_neg.neg : Œ± ‚Üí Œ±) = image (has_neg.neg : Œ± ‚Üí Œ±) :=
(image_eq_preimage_of_inverse neg_neg neg_neg).symm
lemma filter.map_neg_eq_comap_neg [add_group Œ±] :
  map (has_neg.neg : Œ± ‚Üí Œ±) = comap (has_neg.neg : Œ± ‚Üí Œ±) :=
funext $ assume f, map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)
section order_topology
variables [topological_space Œ±] [topological_space Œ≤]
  [linear_order Œ±] [linear_order Œ≤] [order_topology Œ±] [order_topology Œ≤]
lemma is_lub.frequently_mem {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  ‚àÉ·∂† x in ùìù[‚â§] a, x ‚àà s :=
begin
  rcases hs with ‚ü®a', ha'‚ü©,
  intro h,
  rcases (ha.1 ha').eq_or_lt with (rfl|ha'a),
  { exact h.self_of_nhds_within le_rfl ha' },
  { rcases (mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h
      with ‚ü®b, hba, hb‚ü©,
    rcases ha.exists_between hba with ‚ü®b', hb's, hb'‚ü©,
    exact hb hb' hb's },
end
lemma is_lub.frequently_nhds_mem {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  ‚àÉ·∂† x in ùìù a, x ‚àà s :=
(ha.frequently_mem hs).filter_mono inf_le_left
lemma is_glb.frequently_mem {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty) :
  ‚àÉ·∂† x in ùìù[‚â•] a, x ‚àà s :=
@is_lub.frequently_mem Œ±·µí·µà _ _ _ _ _ ha hs
lemma is_glb.frequently_nhds_mem {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty) :
  ‚àÉ·∂† x in ùìù a, x ‚àà s :=
(ha.frequently_mem hs).filter_mono inf_le_left
lemma is_lub.mem_closure {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  a ‚àà closure s :=
(ha.frequently_nhds_mem hs).mem_closure
lemma is_glb.mem_closure {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty) :
  a ‚àà closure s :=
(ha.frequently_nhds_mem hs).mem_closure
lemma is_lub.nhds_within_ne_bot {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  ne_bot (ùìù[s] a) :=
mem_closure_iff_nhds_within_ne_bot.1 (ha.mem_closure hs)
lemma is_glb.nhds_within_ne_bot : ‚àÄ {a : Œ±} {s : set Œ±}, is_glb s a ‚Üí s.nonempty ‚Üí
  ne_bot (ùìù[s] a) :=
@is_lub.nhds_within_ne_bot Œ±·µí·µà _ _ _
lemma is_lub_of_mem_nhds {s : set Œ±} {a : Œ±} {f : filter Œ±}
  (hsa : a ‚àà upper_bounds s) (hsf : s ‚àà f) [ne_bot (f ‚äì ùìù a)] : is_lub s a :=
‚ü®hsa, assume b hb,
  not_lt.1 $ assume hba,
  have s ‚à© {a | b < a} ‚àà f ‚äì ùìù a,
    from inter_mem_inf hsf (is_open.mem_nhds (is_open_lt' _) hba),
  let ‚ü®x, ‚ü®hxs, hxb‚ü©‚ü© := filter.nonempty_of_mem this in
  have b < b, from lt_of_lt_of_le hxb $ hb hxs,
  lt_irrefl b this‚ü©
lemma is_lub_of_mem_closure {s : set Œ±} {a : Œ±} (hsa : a ‚àà upper_bounds s) (hsf : a ‚àà closure s) :
  is_lub s a :=
begin
  rw [mem_closure_iff_cluster_pt, cluster_pt, inf_comm] at hsf,
  haveI : (ùìü s ‚äì ùìù a).ne_bot := hsf,
  exact is_lub_of_mem_nhds hsa (mem_principal_self s),
end
lemma is_glb_of_mem_nhds : ‚àÄ {s : set Œ±} {a : Œ±} {f : filter Œ±},
  a ‚àà lower_bounds s ‚Üí s ‚àà f ‚Üí ne_bot (f ‚äì ùìù a) ‚Üí is_glb s a :=
@is_lub_of_mem_nhds Œ±·µí·µà _ _ _
lemma is_glb_of_mem_closure {s : set Œ±} {a : Œ±} (hsa : a ‚àà lower_bounds s) (hsf : a ‚àà closure s) :
  is_glb s a :=
@is_lub_of_mem_closure Œ±·µí·µà _ _ _ s a hsa hsf
lemma is_lub.mem_upper_bounds_of_tendsto [preorder Œ≥] [topological_space Œ≥]
  [order_closed_topology Œ≥] {f : Œ± ‚Üí Œ≥} {s : set Œ±} {a : Œ±} {b : Œ≥}
  (hf : monotone_on f s) (ha : is_lub s a)
  (hb : tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà upper_bounds (f '' s) :=
begin
  rintro _ ‚ü®x, hx, rfl‚ü©,
  replace ha := ha.inter_Ici_of_mem hx,
  haveI := ha.nhds_within_ne_bot ‚ü®x, hx, le_rfl‚ü©,
  refine ge_of_tendsto (hb.mono_left (nhds_within_mono _ (inter_subset_left s (Ici x)))) _,
  exact mem_of_superset self_mem_nhds_within (Œª y hy, hf hx hy.1 hy.2)
end
lemma is_lub.exists_seq_strict_mono_tendsto_of_not_mem {t : set Œ±} {x : Œ±}
  [is_countably_generated (ùìù x)] (htx : is_lub t x) (not_mem : x ‚àâ t) (ht : t.nonempty) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_mono u ‚àß (‚àÄ n, u n < x) ‚àß tendsto u at_top (ùìù x) ‚àß (‚àÄ n, u n ‚àà t) :=
begin
  rcases ht with ‚ü®l, hl‚ü©,
  have hl : l < x,
   from (htx.1 hl).eq_or_lt.resolve_left (Œª h,  (not_mem $ h ‚ñ∏ hl).elim),
  obtain ‚ü®s, hs‚ü© : ‚àÉ s : ‚Ñï ‚Üí set Œ±, (ùìù x).has_basis (Œª (_x : ‚Ñï), true) s :=
    let ‚ü®s, hs‚ü© := (ùìù x).exists_antitone_basis in ‚ü®s, hs.to_has_basis‚ü©,
  have : ‚àÄ n k, k < x ‚Üí ‚àÉ y, Icc y x ‚äÜ s n ‚àß k < y ‚àß y < x ‚àß y ‚àà t,
  { assume n k hk,
    obtain ‚ü®L, hL, h‚ü© : ‚àÉ (L : Œ±) (hL : L ‚àà Ico k x), Ioc L x ‚äÜ s n :=
      exists_Ioc_subset_of_mem_nhds' (hs.mem_of_mem trivial) hk,
    obtain ‚ü®y, hy‚ü© : ‚àÉ (y : Œ±), L < y ‚àß y < x ‚àß y ‚àà t,
    { rcases htx.exists_between' not_mem hL.2 with ‚ü®y, yt, hy‚ü©,
      refine ‚ü®y, hy.1, hy.2, yt‚ü© },
    exact ‚ü®y, Œª z hz, h ‚ü®hy.1.trans_le hz.1, hz.2‚ü©, hL.1.trans_lt hy.1, hy.2‚ü© },
  choose! f hf using this,
  let u : ‚Ñï ‚Üí Œ± := Œª n, nat.rec_on n (f 0 l) (Œª n h, f n.succ h),
  have I : ‚àÄ n, u n < x,
  { assume n,
    induction n with n IH,
    { exact (hf 0 l hl).2.2.1 },
    { exact (hf n.succ _ IH).2.2.1 } },
  have S : strict_mono u := strict_mono_nat_of_lt_succ (Œª n, (hf n.succ _ (I n)).2.1),
  refine ‚ü®u, S, I, hs.tendsto_right_iff.2 (Œª n _, _), (Œª n, _)‚ü©,
  { simp only [ge_iff_le, eventually_at_top],
    refine ‚ü®n, Œª p hp, _‚ü©,
    have up : u p ‚àà Icc (u n) x := ‚ü®S.monotone hp, (I p).le‚ü©,
    have : Icc (u n) x ‚äÜ s n,
      by { cases n, { exact (hf 0 l hl).1 }, { exact (hf n.succ (u n) (I n)).1 } },
    exact this up },
  { cases n,
    { exact (hf 0 l hl).2.2.2 },
    { exact (hf n.succ _ (I n)).2.2.2 } }
end
lemma is_lub.exists_seq_monotone_tendsto {t : set Œ±} {x : Œ±} [is_countably_generated (ùìù x)]
  (htx : is_lub t x) (ht : t.nonempty) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, monotone u ‚àß (‚àÄ n, u n ‚â§ x) ‚àß tendsto u at_top (ùìù x) ‚àß (‚àÄ n, u n ‚àà t) :=
begin
  by_cases h : x ‚àà t,
  { exact ‚ü®Œª n, x, monotone_const, Œª n, le_rfl, tendsto_const_nhds, Œª n, h‚ü© },
  { rcases htx.exists_seq_strict_mono_tendsto_of_not_mem h ht  with ‚ü®u, hu‚ü©,
    exact ‚ü®u, hu.1.monotone, Œª n, (hu.2.1 n).le, hu.2.2‚ü© }
end
lemma exists_seq_strict_mono_tendsto' {Œ± : Type*} [linear_order Œ±] [topological_space Œ±]
  [densely_ordered Œ±] [order_topology Œ±]
  [first_countable_topology Œ±] {x y : Œ±} (hy : y < x) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_mono u ‚àß (‚àÄ n, u n ‚àà Ioo y x) ‚àß tendsto u at_top (ùìù x) :=
begin
  have hx : x ‚àâ Ioo y x := Œª h, (lt_irrefl x h.2).elim,
  have ht : set.nonempty (Ioo y x) := nonempty_Ioo.2 hy,
  rcases (is_lub_Ioo hy).exists_seq_strict_mono_tendsto_of_not_mem hx ht with ‚ü®u, hu‚ü©,
  exact ‚ü®u, hu.1, hu.2.2.symm‚ü©
end
lemma exists_seq_strict_mono_tendsto [densely_ordered Œ±] [no_min_order Œ±]
  [first_countable_topology Œ±] (x : Œ±) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_mono u ‚àß (‚àÄ n, u n < x) ‚àß tendsto u at_top (ùìù x) :=
begin
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y < x := exists_lt x,
  rcases exists_seq_strict_mono_tendsto' hy with ‚ü®u, hu_mono, hu_mem, hux‚ü©,
  exact ‚ü®u, hu_mono, Œª n, (hu_mem n).2, hux‚ü©
end
lemma exists_seq_tendsto_Sup {Œ± : Type*} [conditionally_complete_linear_order Œ±]
  [topological_space Œ±] [order_topology Œ±] [first_countable_topology Œ±]
  {S : set Œ±} (hS : S.nonempty) (hS' : bdd_above S) :
  ‚àÉ (u : ‚Ñï ‚Üí Œ±), monotone u ‚àß tendsto u at_top (ùìù (Sup S)) ‚àß (‚àÄ n, u n ‚àà S) :=
begin
  rcases (is_lub_cSup hS hS').exists_seq_monotone_tendsto hS with ‚ü®u, hu‚ü©,
  exact ‚ü®u, hu.1, hu.2.2‚ü©,
end
lemma is_glb.exists_seq_strict_anti_tendsto_of_not_mem {t : set Œ±} {x : Œ±}
  [is_countably_generated (ùìù x)] (htx : is_glb t x) (not_mem : x ‚àâ t) (ht : t.nonempty) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_anti u ‚àß (‚àÄ n, x < u n) ‚àß
                        tendsto u at_top (ùìù x) ‚àß (‚àÄ n, u n ‚àà t) :=
@is_lub.exists_seq_strict_mono_tendsto_of_not_mem Œ±·µí·µà _ _ _ t x _ htx not_mem ht
lemma is_glb.exists_seq_antitone_tendsto {t : set Œ±} {x : Œ±} [is_countably_generated (ùìù x)]
  (htx : is_glb t x) (ht : t.nonempty) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, antitone u ‚àß (‚àÄ n, x ‚â§ u n) ‚àß
                        tendsto u at_top (ùìù x) ‚àß (‚àÄ n, u n ‚àà t) :=
@is_lub.exists_seq_monotone_tendsto Œ±·µí·µà _ _ _ t x _ htx ht
lemma exists_seq_strict_anti_tendsto' [densely_ordered Œ±]
  [first_countable_topology Œ±] {x y : Œ±} (hy : x < y) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_anti u ‚àß (‚àÄ n, u n ‚àà Ioo x y) ‚àß tendsto u at_top (ùìù x) :=
by simpa only [dual_Ioo] using exists_seq_strict_mono_tendsto' (order_dual.to_dual_lt_to_dual.2 hy)
lemma exists_seq_strict_anti_tendsto [densely_ordered Œ±] [no_max_order Œ±]
  [first_countable_topology Œ±] (x : Œ±) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_anti u ‚àß (‚àÄ n, x < u n) ‚àß tendsto u at_top (ùìù x) :=
@exists_seq_strict_mono_tendsto Œ±·µí·µà _ _ _ _ _ _ x
lemma exists_seq_strict_anti_strict_mono_tendsto [densely_ordered Œ±] [first_countable_topology Œ±]
  {x y : Œ±} (h : x < y) :
  ‚àÉ (u v : ‚Ñï ‚Üí Œ±), strict_anti u ‚àß strict_mono v ‚àß (‚àÄ k, u k ‚àà Ioo x y) ‚àß (‚àÄ l, v l ‚àà Ioo x y) ‚àß
    (‚àÄ k l, u k < v l) ‚àß tendsto u at_top (ùìù x) ‚àß tendsto v at_top (ùìù y) :=
begin
  rcases exists_seq_strict_anti_tendsto' h with ‚ü®u, hu_anti, hu_mem, hux‚ü©,
  rcases exists_seq_strict_mono_tendsto' (hu_mem 0).2 with ‚ü®v, hv_mono, hv_mem, hvy‚ü©,
  exact ‚ü®u, v, hu_anti, hv_mono, hu_mem, Œª l, ‚ü®(hu_mem 0).1.trans (hv_mem l).1, (hv_mem l).2‚ü©,
    Œª k l, (hu_anti.antitone (zero_le k)).trans_lt (hv_mem l).1, hux, hvy‚ü©
end
lemma exists_seq_tendsto_Inf {Œ± : Type*} [conditionally_complete_linear_order Œ±]
  [topological_space Œ±] [order_topology Œ±] [first_countable_topology Œ±]
  {S : set Œ±} (hS : S.nonempty) (hS' : bdd_below S) :
  ‚àÉ (u : ‚Ñï ‚Üí Œ±), antitone u ‚àß tendsto u at_top (ùìù (Inf S)) ‚àß (‚àÄ n, u n ‚àà S) :=
@exists_seq_tendsto_Sup Œ±·µí·µà _ _ _ _ S hS hS'
end order_topology
section densely_ordered
variables [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±]
{a b : Œ±} {s : set Œ±}
lemma closure_Ioi' {a : Œ±} (h : (Ioi a).nonempty) :
  closure (Ioi a) = Ici a :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioi_subset_Ici_self is_closed_Ici },
  { rw [‚Üê diff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff],
    exact is_glb_Ioi.mem_closure h }
end
@[simp] lemma closure_Ioi (a : Œ±) [no_max_order Œ±] :
  closure (Ioi a) = Ici a :=
closure_Ioi' nonempty_Ioi
lemma closure_Iio' (h : (Iio a).nonempty) : closure (Iio a) = Iic a := @closure_Ioi' Œ±·µí·µà _ _ _ _ _ h
@[simp] lemma closure_Iio (a : Œ±) [no_min_order Œ±] :
  closure (Iio a) = Iic a :=
closure_Iio' nonempty_Iio
@[simp] lemma closure_Ioo {a b : Œ±} (hab : a ‚â† b) :
  closure (Ioo a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioo_subset_Icc_self is_closed_Icc },
  { cases hab.lt_or_lt with hab hab,
    { rw [‚Üê diff_subset_closure_iff, Icc_diff_Ioo_same hab.le],
      have hab' : (Ioo a b).nonempty, from nonempty_Ioo.2 hab,
      simp only [insert_subset, singleton_subset_iff],
      exact ‚ü®(is_glb_Ioo hab).mem_closure hab', (is_lub_Ioo hab).mem_closure hab'‚ü© },
    { rw Icc_eq_empty_of_lt hab, exact empty_subset _ } }
end
@[simp] lemma closure_Ioc {a b : Œ±} (hab : a ‚â† b) :
  closure (Ioc a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioc_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ioc_self),
    rw closure_Ioo hab }
end
@[simp] lemma closure_Ico {a b : Œ±} (hab : a ‚â† b) :
  closure (Ico a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ico_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ico_self),
    rw closure_Ioo hab }
end
@[simp] lemma interior_Ici' {a : Œ±} (ha : (Iio a).nonempty) : interior (Ici a) = Ioi a :=
by rw [‚Üê compl_Iio, interior_compl, closure_Iio' ha, compl_Iic]
lemma interior_Ici [no_min_order Œ±] {a : Œ±} : interior (Ici a) = Ioi a :=
interior_Ici' nonempty_Iio
@[simp] lemma interior_Iic' {a : Œ±} (ha : (Ioi a).nonempty) : interior (Iic a) = Iio a :=
@interior_Ici' Œ±·µí·µà _ _ _ _ _ ha
lemma interior_Iic [no_max_order Œ±] {a : Œ±} : interior (Iic a) = Iio a :=
interior_Iic' nonempty_Ioi
@[simp] lemma interior_Icc [no_min_order Œ±] [no_max_order Œ±] {a b : Œ±}:
  interior (Icc a b) = Ioo a b :=
by rw [‚Üê Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]
@[simp] lemma interior_Ico [no_min_order Œ±] {a b : Œ±} : interior (Ico a b) = Ioo a b :=
by rw [‚Üê Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]
@[simp] lemma interior_Ioc [no_max_order Œ±] {a b : Œ±} : interior (Ioc a b) = Ioo a b :=
by rw [‚Üê Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]
lemma closure_interior_Icc {a b : Œ±} (h : a ‚â† b) : closure (interior (Icc a b)) = Icc a b :=
(closure_minimal interior_subset is_closed_Icc).antisymm $
calc Icc a b = closure (Ioo a b) : (closure_Ioo h).symm
... ‚äÜ closure (interior (Icc a b)) : closure_mono (interior_maximal Ioo_subset_Icc_self is_open_Ioo)
lemma Ioc_subset_closure_interior (a b : Œ±) : Ioc a b ‚äÜ closure (interior (Ioc a b)) :=
begin
  rcases eq_or_ne a b with rfl|h,
  { simp },
  { calc Ioc a b ‚äÜ Icc a b : Ioc_subset_Icc_self
    ... = closure (Ioo a b) : (closure_Ioo h).symm
    ... ‚äÜ closure (interior (Ioc a b)) :
      closure_mono (interior_maximal Ioo_subset_Ioc_self is_open_Ioo) }
end
lemma Ico_subset_closure_interior (a b : Œ±) : Ico a b ‚äÜ closure (interior (Ico a b)) :=
by simpa only [dual_Ioc]
  using Ioc_subset_closure_interior (order_dual.to_dual b) (order_dual.to_dual a)
@[simp] lemma frontier_Ici' {a : Œ±} (ha : (Iio a).nonempty) : frontier (Ici a) = {a} :=
by simp [frontier, ha]
lemma frontier_Ici [no_min_order Œ±] {a : Œ±} : frontier (Ici a) = {a} :=
frontier_Ici' nonempty_Iio
@[simp] lemma frontier_Iic' {a : Œ±} (ha : (Ioi a).nonempty) : frontier (Iic a) = {a} :=
by simp [frontier, ha]
lemma frontier_Iic [no_max_order Œ±] {a : Œ±} : frontier (Iic a) = {a} :=
frontier_Iic' nonempty_Ioi
@[simp] lemma frontier_Ioi' {a : Œ±} (ha : (Ioi a).nonempty) : frontier (Ioi a) = {a} :=
by simp [frontier, closure_Ioi' ha, Iic_diff_Iio, Icc_self]
lemma frontier_Ioi [no_max_order Œ±] {a : Œ±} : frontier (Ioi a) = {a} :=
frontier_Ioi' nonempty_Ioi
@[simp] lemma frontier_Iio' {a : Œ±} (ha : (Iio a).nonempty) : frontier (Iio a) = {a} :=
by simp [frontier, closure_Iio' ha, Iic_diff_Iio, Icc_self]
lemma frontier_Iio [no_min_order Œ±] {a : Œ±} : frontier (Iio a) = {a} :=
frontier_Iio' nonempty_Iio
@[simp] lemma frontier_Icc [no_min_order Œ±] [no_max_order Œ±] {a b : Œ±} (h : a < b) :
  frontier (Icc a b) = {a, b} :=
by simp [frontier, le_of_lt h, Icc_diff_Ioo_same]
@[simp] lemma frontier_Ioo {a b : Œ±} (h : a < b) : frontier (Ioo a b) = {a, b} :=
by rw [frontier, closure_Ioo h.ne, interior_Ioo, Icc_diff_Ioo_same h.le]
@[simp] lemma frontier_Ico [no_min_order Œ±] {a b : Œ±} (h : a < b) : frontier (Ico a b) = {a, b} :=
by rw [frontier, closure_Ico h.ne, interior_Ico, Icc_diff_Ioo_same h.le]
@[simp] lemma frontier_Ioc [no_max_order Œ±] {a b : Œ±} (h : a < b) : frontier (Ioc a b) = {a, b} :=
by rw [frontier, closure_Ioc h.ne, interior_Ioc, Icc_diff_Ioo_same h.le]
lemma nhds_within_Ioi_ne_bot' {a b : Œ±} (H‚ÇÅ : (Ioi a).nonempty) (H‚ÇÇ : a ‚â§ b) :
  ne_bot (ùìù[Ioi a] b) :=
mem_closure_iff_nhds_within_ne_bot.1 $ by rwa [closure_Ioi' H‚ÇÅ]
lemma nhds_within_Ioi_ne_bot [no_max_order Œ±] {a b : Œ±} (H : a ‚â§ b) :
  ne_bot (ùìù[Ioi a] b) :=
nhds_within_Ioi_ne_bot' nonempty_Ioi H
lemma nhds_within_Ioi_self_ne_bot' {a : Œ±} (H : (Ioi a).nonempty) :
  ne_bot (ùìù[>] a) :=
nhds_within_Ioi_ne_bot' H (le_refl a)
@[instance]
lemma nhds_within_Ioi_self_ne_bot [no_max_order Œ±] (a : Œ±) :
  ne_bot (ùìù[>] a) :=
nhds_within_Ioi_ne_bot (le_refl a)
lemma filter.eventually.exists_gt [no_max_order Œ±] {a : Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in ùìù a, p x) :
  ‚àÉ b > a, p b :=
by simpa only [exists_prop, gt_iff_lt, and_comm]
  using ((h.filter_mono (@nhds_within_le_nhds _ _ a (Ioi a))).and self_mem_nhds_within).exists
lemma nhds_within_Iio_ne_bot' {b c : Œ±} (H‚ÇÅ : (Iio c).nonempty) (H‚ÇÇ : b ‚â§ c) :
  ne_bot (ùìù[Iio c] b) :=
mem_closure_iff_nhds_within_ne_bot.1 $ by rwa closure_Iio' H‚ÇÅ
lemma nhds_within_Iio_ne_bot [no_min_order Œ±] {a b : Œ±} (H : a ‚â§ b) :
  ne_bot (ùìù[Iio b] a) :=
nhds_within_Iio_ne_bot' nonempty_Iio H
lemma nhds_within_Iio_self_ne_bot' {b : Œ±} (H : (Iio b).nonempty) :
  ne_bot (ùìù[<] b) :=
nhds_within_Iio_ne_bot' H (le_refl b)
@[instance]
lemma nhds_within_Iio_self_ne_bot [no_min_order Œ±] (a : Œ±) :
  ne_bot (ùìù[<] a) :=
nhds_within_Iio_ne_bot (le_refl a)
lemma filter.eventually.exists_lt [no_min_order Œ±] {a : Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in ùìù a, p x) :
  ‚àÉ b < a, p b :=
@filter.eventually.exists_gt Œ±·µí·µà _ _ _ _ _ _ _ h
lemma right_nhds_within_Ico_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ico a b] b) :=
(is_lub_Ico H).nhds_within_ne_bot (nonempty_Ico.2 H)
lemma left_nhds_within_Ioc_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioc a b] a) :=
(is_glb_Ioc H).nhds_within_ne_bot (nonempty_Ioc.2 H)
lemma left_nhds_within_Ioo_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioo a b] a) :=
(is_glb_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)
lemma right_nhds_within_Ioo_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioo a b] b) :=
(is_lub_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)
lemma comap_coe_nhds_within_Iio_of_Ioo_subset (hb : s ‚äÜ Iio b)
  (hs : s.nonempty ‚Üí ‚àÉ a < b, Ioo a b ‚äÜ s) :
  comap (coe : s ‚Üí Œ±) (ùìù[<] b) = at_top :=
begin
  nontriviality,
  haveI : nonempty s := nontrivial_iff_nonempty.1 ‚Äπ_‚Ä∫,
  rcases hs (nonempty_subtype.1 ‚Äπ_‚Ä∫) with ‚ü®a, h, hs‚ü©,
  ext u, split,
  { rintros ‚ü®t, ht, hts‚ü©,
    obtain ‚ü®x, ‚ü®hxa : a ‚â§ x, hxb : x < b‚ü©, hxt : Ioo x b ‚äÜ t‚ü© :=
      (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht,
    obtain ‚ü®y, hxy, hyb‚ü© := exists_between hxb,
    refine mem_of_superset (mem_at_top ‚ü®y, hs ‚ü®hxa.trans_lt hxy, hyb‚ü©‚ü©) _,
    rintros ‚ü®z, hzs‚ü© (hyz : y ‚â§ z),
    refine hts (hxt ‚ü®hxy.trans_le _, hb _‚ü©); assumption },
  { intros hu,
    obtain ‚ü®x : s, hx : ‚àÄ z, x ‚â§ z ‚Üí z ‚àà u‚ü© := mem_at_top_sets.1 hu,
    exact ‚ü®Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 $ hb x.2), Œª z hz, hx _ hz.1.le‚ü© }
end
lemma comap_coe_nhds_within_Ioi_of_Ioo_subset (ha : s ‚äÜ Ioi a)
  (hs : s.nonempty ‚Üí ‚àÉ b > a, Ioo a b ‚äÜ s) :
  comap (coe : s ‚Üí Œ±) (ùìù[>] a) = at_bot :=
comap_coe_nhds_within_Iio_of_Ioo_subset
  (show of_dual ‚Åª¬π' s ‚äÜ Iio (to_dual a), from ha)
  (Œª h, by simpa only [order_dual.exists, dual_Ioo] using hs h)
lemma map_coe_at_top_of_Ioo_subset (hb : s ‚äÜ Iio b)
  (hs : ‚àÄ a' < b, ‚àÉ a < b, Ioo a b ‚äÜ s) :
  map (coe : s ‚Üí Œ±) at_top = ùìù[<] b :=
begin
  rcases eq_empty_or_nonempty (Iio b) with (hb'|‚ü®a, ha‚ü©),
  { rw [filter_eq_bot_of_is_empty at_top, filter.map_bot, hb', nhds_within_empty],
    exact ‚ü®Œª x, hb'.subset (hb x.2)‚ü© },
  { rw [‚Üê comap_coe_nhds_within_Iio_of_Ioo_subset hb (Œª _, hs a ha), map_comap_of_mem],
    rw subtype.range_coe,
    exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha) },
end
lemma map_coe_at_bot_of_Ioo_subset (ha : s ‚äÜ Ioi a)
  (hs : ‚àÄ b' > a, ‚àÉ b > a, Ioo a b ‚äÜ s) :
  map (coe : s ‚Üí Œ±) at_bot = (ùìù[>] a) :=
begin
lemma comap_coe_Ioo_nhds_within_Iio (a b : Œ±) :
  comap (coe : Ioo a b ‚Üí Œ±) (ùìù[<] b) = at_top :=
comap_coe_nhds_within_Iio_of_Ioo_subset Ioo_subset_Iio_self $
  Œª h, ‚ü®a, nonempty_Ioo.1 h, subset.refl _‚ü©
lemma comap_coe_Ioo_nhds_within_Ioi (a b : Œ±) :
  comap (coe : Ioo a b ‚Üí Œ±) (ùìù[>] a) = at_bot :=
comap_coe_nhds_within_Ioi_of_Ioo_subset Ioo_subset_Ioi_self $
  Œª h, ‚ü®b, nonempty_Ioo.1 h, subset.refl _‚ü©
lemma comap_coe_Ioi_nhds_within_Ioi (a : Œ±) : comap (coe : Ioi a ‚Üí Œ±) (ùìù[>] a) = at_bot :=
comap_coe_nhds_within_Ioi_of_Ioo_subset (subset.refl _) $
  Œª ‚ü®x, hx‚ü©, ‚ü®x, hx, Ioo_subset_Ioi_self‚ü©
lemma comap_coe_Iio_nhds_within_Iio (a : Œ±) :
  comap (coe : Iio a ‚Üí Œ±) (ùìù[<] a) = at_top :=
@comap_coe_Ioi_nhds_within_Ioi Œ±·µí·µà _ _ _ _ a
@[simp] lemma map_coe_Ioo_at_top {a b : Œ±} (h : a < b) :
  map (coe : Ioo a b ‚Üí Œ±) at_top = ùìù[<] b :=
map_coe_at_top_of_Ioo_subset Ioo_subset_Iio_self $ Œª _ _, ‚ü®_, h, subset.refl _‚ü©
@[simp] lemma map_coe_Ioo_at_bot {a b : Œ±} (h : a < b) :
  map (coe : Ioo a b ‚Üí Œ±) at_bot = ùìù[>] a :=
map_coe_at_bot_of_Ioo_subset Ioo_subset_Ioi_self $ Œª _ _, ‚ü®_, h, subset.refl _‚ü©
@[simp] lemma map_coe_Ioi_at_bot (a : Œ±) :
  map (coe : Ioi a ‚Üí Œ±) at_bot = ùìù[>] a :=
map_coe_at_bot_of_Ioo_subset (subset.refl _) $ Œª b hb, ‚ü®b, hb, Ioo_subset_Ioi_self‚ü©
@[simp] lemma map_coe_Iio_at_top (a : Œ±) :
  map (coe : Iio a ‚Üí Œ±) at_top = ùìù[<] a :=
@map_coe_Ioi_at_bot Œ±·µí·µà _ _ _ _ _
variables {l : filter Œ≤} {f : Œ± ‚Üí Œ≤}
@[simp] lemma tendsto_comp_coe_Ioo_at_top (h : a < b) :
  tendsto (Œª x : Ioo a b, f x) at_top l ‚Üî tendsto f (ùìù[<] b) l :=
by rw [‚Üê map_coe_Ioo_at_top h, tendsto_map'_iff]
@[simp] lemma tendsto_comp_coe_Ioo_at_bot (h : a < b) :
  tendsto (Œª x : Ioo a b, f x) at_bot l ‚Üî tendsto f (ùìù[>] a) l :=
by rw [‚Üê map_coe_Ioo_at_bot h, tendsto_map'_iff]
@[simp] lemma tendsto_comp_coe_Ioi_at_bot :
  tendsto (Œª x : Ioi a, f x) at_bot l ‚Üî tendsto f (ùìù[>] a) l :=
by rw [‚Üê map_coe_Ioi_at_bot, tendsto_map'_iff]
@[simp] lemma tendsto_comp_coe_Iio_at_top :
  tendsto (Œª x : Iio a, f x) at_top l ‚Üî tendsto f (ùìù[<] a) l :=
by rw [‚Üê map_coe_Iio_at_top, tendsto_map'_iff]
@[simp] lemma tendsto_Ioo_at_top {f : Œ≤ ‚Üí Ioo a b} :
  tendsto f l at_top ‚Üî tendsto (Œª x, (f x : Œ±)) l (ùìù[<] b) :=
by rw [‚Üê comap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]
@[simp] lemma tendsto_Ioo_at_bot {f : Œ≤ ‚Üí Ioo a b} :
  tendsto f l at_bot ‚Üî tendsto (Œª x, (f x : Œ±)) l (ùìù[>] a) :=
by rw [‚Üê comap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]
@[simp] lemma tendsto_Ioi_at_bot {f : Œ≤ ‚Üí Ioi a} :
  tendsto f l at_bot ‚Üî tendsto (Œª x, (f x : Œ±)) l (ùìù[>] a) :=
by rw [‚Üê comap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]
@[simp] lemma tendsto_Iio_at_top {f : Œ≤ ‚Üí Iio a} :
  tendsto f l at_top ‚Üî tendsto (Œª x, (f x : Œ±)) l (ùìù[<] a) :=
by rw [‚Üê comap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]
instance (x : Œ±) [nontrivial Œ±] : ne_bot (ùìù[‚â†] x) :=
begin
  apply forall_mem_nonempty_iff_ne_bot.1 (Œª s hs, _),
  obtain ‚ü®u, u_open, xu, us‚ü© : ‚àÉ (u : set Œ±), is_open u ‚àß x ‚àà u ‚àß u ‚à© {x}·∂ú ‚äÜ s :=
    mem_nhds_within.1 hs,
  obtain ‚ü®a, b, a_lt_b, hab‚ü© : ‚àÉ (a b : Œ±), a < b ‚àß Ioo a b ‚äÜ u := u_open.exists_Ioo_subset ‚ü®x, xu‚ü©,
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, a < y ‚àß y < b := exists_between a_lt_b,
  rcases ne_or_eq x y with xy|rfl,
  { exact ‚ü®y, us ‚ü®hab hy, xy.symm‚ü©‚ü© },
  obtain ‚ü®z, hz‚ü© : ‚àÉ z, a < z ‚àß z < x := exists_between hy.1,
  exact ‚ü®z, us ‚ü®hab ‚ü®hz.1, hz.2.trans hy.2‚ü©, hz.2.ne‚ü©‚ü©,
end
lemma dense.exists_countable_dense_subset_no_bot_top [nontrivial Œ±]
  {s : set Œ±} [separable_space s] (hs : dense s) :
  ‚àÉ t ‚äÜ s, t.countable ‚àß dense t ‚àß (‚àÄ x, is_bot x ‚Üí x ‚àâ t) ‚àß (‚àÄ x, is_top x ‚Üí x ‚àâ t) :=
begin
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©,
  refine ‚ü®t \ ({x | is_bot x} ‚à™ {x | is_top x}), _, _, _, _, _‚ü©,
  { exact (diff_subset _ _).trans hts },
  { exact htc.mono (diff_subset _ _) },
  { exact htd.diff_finite ((subsingleton_is_bot Œ±).finite.union (subsingleton_is_top Œ±).finite) },
  { assume x hx, simp [hx] },
  { assume x hx, simp [hx] }
end
variable (Œ±)
lemma exists_countable_dense_no_bot_top [separable_space Œ±] [nontrivial Œ±] :
  ‚àÉ s : set Œ±, s.countable ‚àß dense s ‚àß (‚àÄ x, is_bot x ‚Üí x ‚àâ s) ‚àß (‚àÄ x, is_top x ‚Üí x ‚àâ s) :=
by simpa using dense_univ.exists_countable_dense_subset_no_bot_top
end densely_ordered
section complete_linear_order
variables [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [nonempty Œ≥]
lemma Sup_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) :
  Sup s ‚àà closure s :=
(is_lub_Sup s).mem_closure hs
lemma Inf_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) :
  Inf s ‚àà closure s :=
(is_glb_Inf s).mem_closure hs
lemma is_closed.Sup_mem {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) :
  Sup s ‚àà s :=
(is_lub_Sup s).mem_of_is_closed hs hc
lemma is_closed.Inf_mem {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) :
  Inf s ‚àà s :=
(is_glb_Inf s).mem_of_is_closed hs hc
lemma map_Sup_of_continuous_at_of_monotone' {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (hs : s.nonempty) :
  f (Sup s) = Sup (f '' s) :=
lemma map_Sup_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (fbot : f ‚ä• = ‚ä•) :
  f (Sup s) = Sup (f '' s) :=
begin
  cases s.eq_empty_or_nonempty with h h,
  { simp [h, fbot] },
  { exact map_Sup_of_continuous_at_of_monotone' Cf Mf h }
end
lemma map_supr_of_continuous_at_of_monotone' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (supr g)) (Mf : monotone f) :
  f (‚®Ü i, g i) = ‚®Ü i, f (g i) :=
by rw [supr, map_Sup_of_continuous_at_of_monotone' Cf Mf (range_nonempty g), ‚Üê range_comp, supr]
lemma map_supr_of_continuous_at_of_monotone {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (supr g)) (Mf : monotone f) (fbot : f ‚ä• = ‚ä•) :
  f (‚®Ü i, g i) = ‚®Ü i, f (g i) :=
by rw [supr, map_Sup_of_continuous_at_of_monotone Cf Mf fbot, ‚Üê range_comp, supr]
lemma map_Inf_of_continuous_at_of_monotone' {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (hs : s.nonempty) :
  f (Inf s) = Inf (f '' s) :=
@map_Sup_of_continuous_at_of_monotone' Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f s Cf Mf.dual hs
lemma map_Inf_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (ftop : f ‚ä§ = ‚ä§) :
  f (Inf s) = Inf (f '' s) :=
@map_Sup_of_continuous_at_of_monotone Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f s Cf Mf.dual ftop
lemma map_infi_of_continuous_at_of_monotone' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (infi g)) (Mf : monotone f) :
  f (‚®Ö i, g i) = ‚®Ö i, f (g i) :=
@map_supr_of_continuous_at_of_monotone' Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ Œπ _ f g Cf Mf.dual
lemma map_infi_of_continuous_at_of_monotone {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (infi g)) (Mf : monotone f) (ftop : f ‚ä§ = ‚ä§) :
  f (infi g) = infi (f ‚àò g) :=
@map_supr_of_continuous_at_of_monotone Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ Œπ f g Cf Mf.dual ftop
end complete_linear_order
section conditionally_complete_linear_order
variables [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [conditionally_complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [nonempty Œ≥]
lemma cSup_mem_closure {s : set Œ±} (hs : s.nonempty) (B : bdd_above s) : Sup s ‚àà closure s :=
(is_lub_cSup hs B).mem_closure hs
lemma cInf_mem_closure {s : set Œ±} (hs : s.nonempty) (B : bdd_below s) : Inf s ‚àà closure s :=
(is_glb_cInf hs B).mem_closure hs
lemma is_closed.cSup_mem {s : set Œ±} (hc : is_closed s) (hs : s.nonempty) (B : bdd_above s) :
  Sup s ‚àà s :=
(is_lub_cSup hs B).mem_of_is_closed hs hc
lemma is_closed.cInf_mem {s : set Œ±} (hc : is_closed s) (hs : s.nonempty) (B : bdd_below s) :
  Inf s ‚àà s :=
(is_glb_cInf hs B).mem_of_is_closed hs hc
lemma map_cSup_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (ne : s.nonempty) (H : bdd_above s) :
  f (Sup s) = Sup (f '' s) :=
begin
  refine ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm,
  refine (is_lub_cSup ne H).is_lub_of_tendsto (Œªx hx y hy xy, Mf xy)  ne _,
  exact Cf.mono_left inf_le_left
end
lemma map_csupr_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Cf : continuous_at f (‚®Ü i, g i)) (Mf : monotone f) (H : bdd_above (range g)) :
  f (‚®Ü i, g i) = ‚®Ü i, f (g i) :=
by rw [supr, map_cSup_of_continuous_at_of_monotone Cf Mf (range_nonempty _) H, ‚Üê range_comp, supr]
lemma map_cInf_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (ne : s.nonempty) (H : bdd_below s) :
  f (Inf s) = Inf (f '' s) :=
@map_cSup_of_continuous_at_of_monotone Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f s Cf Mf.dual ne H
lemma map_cinfi_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Cf : continuous_at f (‚®Ö i, g i)) (Mf : monotone f) (H : bdd_below (range g)) :
  f (‚®Ö i, g i) = ‚®Ö i, f (g i) :=
@map_csupr_of_continuous_at_of_monotone Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ _ _ _ _ Cf Mf.dual H
lemma monotone.tendsto_nhds_within_Iio
  {Œ± : Type*} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  {f : Œ± ‚Üí Œ≤} (Mf : monotone f) (x : Œ±) :
  tendsto f (ùìù[<] x) (ùìù (Sup (f '' (Iio x)))) :=
begin
  rcases eq_empty_or_nonempty (Iio x) with h|h, { simp [h] },
  refine tendsto_order.2 ‚ü®Œª l hl, _, Œª m hm, _‚ü©,
  { obtain ‚ü®z, zx, lz‚ü© : ‚àÉ (a : Œ±), a < x ‚àß l < f a,
      by simpa only [mem_image, exists_prop, exists_exists_and_eq_and]
        using exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl,
    exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2
      ‚ü®z, zx, Œª y hy, lz.trans_le (Mf (hy.1.le))‚ü© },
  { filter_upwards [self_mem_nhds_within] with _ hy,
    apply lt_of_le_of_lt _ hm,
    exact le_cSup (Mf.map_bdd_above bdd_above_Iio) (mem_image_of_mem _ hy), },
end
lemma monotone.tendsto_nhds_within_Ioi
  {Œ± : Type*} [linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  {f : Œ± ‚Üí Œ≤} (Mf : monotone f) (x : Œ±) :
  tendsto f (ùìù[>] x) (ùìù (Inf (f '' (Ioi x)))) :=
@monotone.tendsto_nhds_within_Iio Œ≤·µí·µà _ _ _ Œ±·µí·µà _ _ _ f Mf.dual x
end conditionally_complete_linear_order
end order_topology
