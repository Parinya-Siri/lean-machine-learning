import category_theory.groupoid
import algebraic_topology.fundamental_groupoid.basic
import topology.category.Top.limits
import topology.homotopy.product
import category_theory.limits.preserves.shapes.products
noncomputable theory
namespace fundamental_groupoid_functor
open_locale fundamental_groupoid
universes u
section pi
variables {I : Type u} (X : I ‚Üí Top.{u})
def proj (i : I) : œÄ‚Çì (Top.of (Œ† i, X i)) ‚•§ œÄ‚Çì (X i) := œÄ‚Çò ‚ü®_, continuous_apply i‚ü©
@[simp] lemma proj_map (i : I) (x‚ÇÄ x‚ÇÅ : œÄ‚Çì (Top.of (Œ† i, X i))) (p : x‚ÇÄ ‚ü∂ x‚ÇÅ) :
  (proj X i).map p = (@path.homotopic.proj _ _ _ _ _ i p) := rfl
@[simps]
def pi_to_pi_Top : (Œ† i, œÄ‚Çì (X i)) ‚•§ œÄ‚Çì (Top.of (Œ† i, X i)) :=
{ obj := Œª g, g,
  map := Œª v‚ÇÅ v‚ÇÇ p, path.homotopic.pi p,
  map_id' :=
  begin
    intro x,
    change path.homotopic.pi (Œª i, ùüô (x i)) = _,
    simp only [fundamental_groupoid.id_eq_path_refl, path.homotopic.pi_lift],
    refl,
  end,
  map_comp' := Œª x y z f g, (path.homotopic.comp_pi_eq_pi_comp f g).symm, }
@[simps]
def pi_iso : category_theory.Groupoid.of (Œ† i : I, œÄ‚Çì (X i)) ‚âÖ œÄ‚Çì (Top.of (Œ† i, X i)) :=
{ hom := pi_to_pi_Top X,
  inv := category_theory.functor.pi' (proj X),
  hom_inv_id' :=
  begin
    change pi_to_pi_Top X ‚ãô (category_theory.functor.pi' (proj X)) = ùü≠ _,
    apply category_theory.functor.ext; intros,
    { ext, simp, }, { refl, },
  end,
  inv_hom_id' :=
  begin
    change (category_theory.functor.pi' (proj X)) ‚ãô pi_to_pi_Top X = ùü≠ _,
    apply category_theory.functor.ext; intros,
    { suffices : path.homotopic.pi ((category_theory.functor.pi' (proj X)).map f) = f, { simpa, },
      change (category_theory.functor.pi' (proj X)).map f
        with Œª i, (category_theory.functor.pi' (proj X)).map f i,
      simp, }, { refl, }
  end }
section preserves
open category_theory
def cone_discrete_comp : limits.cone (discrete.functor X ‚ãô œÄ) ‚âå
  limits.cone (discrete.functor (Œª i, œÄ‚Çì (X i))) :=
limits.cones.postcompose_equivalence (discrete.comp_nat_iso_discrete X œÄ)
lemma cone_discrete_comp_obj_map_cone :
  (cone_discrete_comp X).functor.obj ((œÄ).map_cone (Top.pi_fan.{u} X))
  = limits.fan.mk (œÄ‚Çì (Top.of (Œ† i, X i))) (proj X) := rfl
def pi_Top_to_pi_cone : (limits.fan.mk (œÄ‚Çì (Top.of (Œ† i, X i))) (proj X)) ‚ü∂
  Groupoid.pi_limit_fan (Œª i : I, (œÄ‚Çì (X i))) := { hom := category_theory.functor.pi' (proj X) }
instance : is_iso (pi_Top_to_pi_cone X) :=
begin
  haveI : is_iso (pi_Top_to_pi_cone X).hom := (infer_instance : is_iso (pi_iso X).inv),
  exact limits.cones.cone_iso_of_hom_iso (pi_Top_to_pi_cone X),
end
def preserves_product : limits.preserves_limit (discrete.functor X) œÄ :=
begin
  apply limits.preserves_limit_of_preserves_limit_cone (Top.pi_fan_is_limit.{u} X),
  apply (limits.is_limit.of_cone_equiv (cone_discrete_comp X)).to_fun,
  simp only [cone_discrete_comp_obj_map_cone],
  apply limits.is_limit.of_iso_limit _ (as_iso (pi_Top_to_pi_cone X)).symm,
  exact Groupoid.pi_limit_fan_is_limit _,
end
end preserves
end pi
section prod
variables (A B : Top.{u})
def proj_left : œÄ‚Çì (Top.of (A √ó B)) ‚•§ œÄ‚Çì A := œÄ‚Çò ‚ü®_, continuous_fst‚ü©
def proj_right : œÄ‚Çì (Top.of (A √ó B)) ‚•§ œÄ‚Çì B := œÄ‚Çò ‚ü®_, continuous_snd‚ü©
@[simp] lemma proj_left_map (x‚ÇÄ x‚ÇÅ : œÄ‚Çì (Top.of (A √ó B))) (p : x‚ÇÄ ‚ü∂ x‚ÇÅ) :
  (proj_left A B).map p = path.homotopic.proj_left p := rfl
@[simp] lemma proj_right_map (x‚ÇÄ x‚ÇÅ : œÄ‚Çì (Top.of (A √ó B))) (p : x‚ÇÄ ‚ü∂ x‚ÇÅ) :
  (proj_right A B).map p = path.homotopic.proj_right p := rfl
@[simps obj]
def prod_to_prod_Top : (œÄ‚Çì A) √ó (œÄ‚Çì B) ‚•§ œÄ‚Çì (Top.of (A √ó B)) :=
{ obj := Œª g, g,
  map := Œª x y p, match x, y, p with
    | (x‚ÇÄ, x‚ÇÅ), (y‚ÇÄ, y‚ÇÅ), (p‚ÇÄ, p‚ÇÅ) := path.homotopic.prod p‚ÇÄ p‚ÇÅ
  end,
  map_id' :=
  begin
    rintro ‚ü®x‚ÇÄ, x‚ÇÅ‚ü©,
    simp only [category_theory.prod_id, fundamental_groupoid.id_eq_path_refl],
    unfold_aux, rw path.homotopic.prod_lift, refl,
  end,
  map_comp' := Œª x y z f g, match x, y, z, f, g with
    | (x‚ÇÄ, x‚ÇÅ), (y‚ÇÄ, y‚ÇÅ), (z‚ÇÄ, z‚ÇÅ), (f‚ÇÄ, f‚ÇÅ), (g‚ÇÄ, g‚ÇÅ) :=
    (path.homotopic.comp_prod_eq_prod_comp f‚ÇÄ f‚ÇÅ g‚ÇÄ g‚ÇÅ).symm
  end }
lemma prod_to_prod_Top_map {x‚ÇÄ x‚ÇÅ : œÄ‚Çì A} {y‚ÇÄ y‚ÇÅ : œÄ‚Çì B}
  (p‚ÇÄ : x‚ÇÄ ‚ü∂ x‚ÇÅ) (p‚ÇÅ : y‚ÇÄ ‚ü∂ y‚ÇÅ) :
  @category_theory.functor.map _ _ _ _
  (prod_to_prod_Top A B) (x‚ÇÄ, y‚ÇÄ) (x‚ÇÅ, y‚ÇÅ) (p‚ÇÄ, p‚ÇÅ) = path.homotopic.prod p‚ÇÄ p‚ÇÅ := rfl
@[simps]
def prod_iso : category_theory.Groupoid.of ((œÄ‚Çì A) √ó (œÄ‚Çì B)) ‚âÖ (œÄ‚Çì (Top.of (A √ó B))) :=
{ hom := prod_to_prod_Top A B,
  inv := (proj_left A B).prod' (proj_right A B),
  hom_inv_id' :=
  begin
    change prod_to_prod_Top A B ‚ãô ((proj_left A B).prod' (proj_right A B)) = ùü≠ _,
    apply category_theory.functor.hext, { intros, ext; simp; refl, },
    rintros ‚ü®x‚ÇÄ, x‚ÇÅ‚ü© ‚ü®y‚ÇÄ, y‚ÇÅ‚ü© ‚ü®f‚ÇÄ, f‚ÇÅ‚ü©,
    have := and.intro (path.homotopic.proj_left_prod f‚ÇÄ f‚ÇÅ) (path.homotopic.proj_right_prod f‚ÇÄ f‚ÇÅ),
    simpa,
  end,
  inv_hom_id' :=
  begin
    change ((proj_left A B).prod' (proj_right A B)) ‚ãô prod_to_prod_Top A B = ùü≠ _,
    apply category_theory.functor.hext, { intros, ext; simp; refl, },
    rintros ‚ü®x‚ÇÄ, x‚ÇÅ‚ü© ‚ü®y‚ÇÄ, y‚ÇÅ‚ü© f,
    have := path.homotopic.prod_proj_left_proj_right f,
    simpa,
  end }
end prod
end fundamental_groupoid_functor
