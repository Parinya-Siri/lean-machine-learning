import measure_theory.integral.set_to_l1
import analysis.normed_space.bounded_linear_maps
import topology.sequences
noncomputable theory
open_locale topological_space big_operators nnreal ennreal measure_theory
open set filter topological_space ennreal emetric
namespace measure_theory
variables {Î± E F ğ•œ : Type*}
section weighted_smul
open continuous_linear_map
variables [normed_group F] [normed_space â„ F] {m : measurable_space Î±} {Î¼ : measure Î±}
def weighted_smul {m : measurable_space Î±} (Î¼ : measure Î±) (s : set Î±) : F â†’L[â„] F :=
(Î¼ s).to_real â€¢ (continuous_linear_map.id â„ F)
lemma weighted_smul_apply {m : measurable_space Î±} (Î¼ : measure Î±) (s : set Î±) (x : F) :
  weighted_smul Î¼ s x = (Î¼ s).to_real â€¢ x :=
by simp [weighted_smul]
@[simp] lemma weighted_smul_zero_measure {m : measurable_space Î±} :
  weighted_smul (0 : measure Î±) = (0 : set Î± â†’ F â†’L[â„] F) :=
by { ext1, simp [weighted_smul], }
@[simp] lemma weighted_smul_empty {m : measurable_space Î±} (Î¼ : measure Î±) :
  weighted_smul Î¼ âˆ… = (0 : F â†’L[â„] F) :=
by { ext1 x, rw [weighted_smul_apply], simp, }
lemma weighted_smul_add_measure {m : measurable_space Î±} (Î¼ Î½ : measure Î±) {s : set Î±}
  (hÎ¼s : Î¼ s â‰  âˆ) (hÎ½s : Î½ s â‰  âˆ) :
  (weighted_smul (Î¼ + Î½) s : F â†’L[â„] F) = weighted_smul Î¼ s + weighted_smul Î½ s :=
begin
  ext1 x,
  push_cast,
  simp_rw [pi.add_apply, weighted_smul_apply],
  push_cast,
  rw [pi.add_apply, ennreal.to_real_add hÎ¼s hÎ½s, add_smul],
end
lemma weighted_smul_smul_measure {m : measurable_space Î±} (Î¼ : measure Î±) (c : â„â‰¥0âˆ) {s : set Î±} :
  (weighted_smul (c â€¢ Î¼) s : F â†’L[â„] F) = c.to_real â€¢ weighted_smul Î¼ s :=
begin
  ext1 x,
  push_cast,
  simp_rw [pi.smul_apply, weighted_smul_apply],
  push_cast,
  simp_rw [pi.smul_apply, smul_eq_mul, to_real_mul, smul_smul],
end
lemma weighted_smul_congr (s t : set Î±) (hst : Î¼ s = Î¼ t) :
  (weighted_smul Î¼ s : F â†’L[â„] F) = weighted_smul Î¼ t :=
by { ext1 x, simp_rw weighted_smul_apply, congr' 2, }
lemma weighted_smul_null {s : set Î±} (h_zero : Î¼ s = 0) : (weighted_smul Î¼ s : F â†’L[â„] F) = 0 :=
by { ext1 x, rw [weighted_smul_apply, h_zero], simp, }
lemma weighted_smul_union' (s t : set Î±) (ht : measurable_set t)
  (hs_finite : Î¼ s â‰  âˆ) (ht_finite : Î¼ t â‰  âˆ) (h_inter : s âˆ© t = âˆ…) :
  (weighted_smul Î¼ (s âˆª t) : F â†’L[â„] F) = weighted_smul Î¼ s + weighted_smul Î¼ t :=
begin
  ext1 x,
  simp_rw [add_apply, weighted_smul_apply,
    measure_union (set.disjoint_iff_inter_eq_empty.mpr h_inter) ht,
    ennreal.to_real_add hs_finite ht_finite, add_smul],
end
@[nolint unused_arguments]
lemma weighted_smul_union (s t : set Î±) (hs : measurable_set s) (ht : measurable_set t)
  (hs_finite : Î¼ s â‰  âˆ) (ht_finite : Î¼ t â‰  âˆ) (h_inter : s âˆ© t = âˆ…) :
  (weighted_smul Î¼ (s âˆª t) : F â†’L[â„] F) = weighted_smul Î¼ s + weighted_smul Î¼ t :=
weighted_smul_union' s t ht hs_finite ht_finite h_inter
lemma weighted_smul_smul [normed_field ğ•œ] [normed_space ğ•œ F] [smul_comm_class â„ ğ•œ F]
  (c : ğ•œ) (s : set Î±) (x : F) :
  weighted_smul Î¼ s (c â€¢ x) = c â€¢ weighted_smul Î¼ s x :=
by { simp_rw [weighted_smul_apply, smul_comm], }
lemma norm_weighted_smul_le (s : set Î±) : âˆ¥(weighted_smul Î¼ s : F â†’L[â„] F)âˆ¥ â‰¤ (Î¼ s).to_real :=
calc âˆ¥(weighted_smul Î¼ s : F â†’L[â„] F)âˆ¥ = âˆ¥(Î¼ s).to_realâˆ¥ * âˆ¥continuous_linear_map.id â„ Fâˆ¥ :
  norm_smul _ _
... â‰¤ âˆ¥(Î¼ s).to_realâˆ¥ : (mul_le_mul_of_nonneg_left norm_id_le (norm_nonneg _)).trans (mul_one _).le
... = abs (Î¼ s).to_real : real.norm_eq_abs _
... = (Î¼ s).to_real : abs_eq_self.mpr ennreal.to_real_nonneg
lemma dominated_fin_meas_additive_weighted_smul {m : measurable_space Î±} (Î¼ : measure Î±) :
  dominated_fin_meas_additive Î¼ (weighted_smul Î¼ : set Î± â†’ F â†’L[â„] F) 1 :=
âŸ¨weighted_smul_union, Î» s _ _, (norm_weighted_smul_le s).trans (one_mul _).symm.leâŸ©
lemma weighted_smul_nonneg (s : set Î±) (x : â„) (hx : 0 â‰¤ x) : 0 â‰¤ weighted_smul Î¼ s x :=
begin
  simp only [weighted_smul, algebra.id.smul_eq_mul, coe_smul', id.def, coe_id', pi.smul_apply],
  exact mul_nonneg to_real_nonneg hx,
end
end weighted_smul
local infixr ` â†’â‚› `:25 := simple_func
namespace simple_func
section pos_part
variables [linear_order E] [has_zero E] [measurable_space Î±]
def pos_part (f : Î± â†’â‚› E) : Î± â†’â‚› E := f.map (Î» b, max b 0)
def neg_part [has_neg E] (f : Î± â†’â‚› E) : Î± â†’â‚› E := pos_part (-f)
lemma pos_part_map_norm (f : Î± â†’â‚› â„) : (pos_part f).map norm = pos_part f :=
by { ext, rw [map_apply, real.norm_eq_abs, abs_of_nonneg], exact le_max_right _ _ }
lemma neg_part_map_norm (f : Î± â†’â‚› â„) : (neg_part f).map norm = neg_part f :=
by { rw neg_part, exact pos_part_map_norm _ }
lemma pos_part_sub_neg_part (f : Î± â†’â‚› â„) : f.pos_part - f.neg_part = f :=
begin
  simp only [pos_part, neg_part],
  ext a,
  rw coe_sub,
  exact max_zero_sub_eq_self (f a)
end
end pos_part
section integral
open finset
variables [normed_group E] [normed_group F] [normed_space â„ F] {p : â„â‰¥0âˆ}
  {G F' : Type*} [normed_group G] [normed_group F'] [normed_space â„ F']
  {m : measurable_space Î±} {Î¼ : measure Î±}
def integral {m : measurable_space Î±} (Î¼ : measure Î±) (f : Î± â†’â‚› F) : F :=
f.set_to_simple_func (weighted_smul Î¼)
lemma integral_def {m : measurable_space Î±} (Î¼ : measure Î±) (f : Î± â†’â‚› F) :
  f.integral Î¼ = f.set_to_simple_func (weighted_smul Î¼) := rfl
lemma integral_eq {m : measurable_space Î±} (Î¼ : measure Î±) (f : Î± â†’â‚› F) :
  f.integral Î¼ = âˆ‘ x in f.range, (Î¼ (f â»Â¹' {x})).to_real â€¢ x :=
by simp [integral, set_to_simple_func, weighted_smul_apply]
lemma integral_eq_sum_filter [decidable_pred (Î» x : F, x â‰  0)] {m : measurable_space Î±} (f : Î± â†’â‚› F)
  (Î¼ : measure Î±) :
  f.integral Î¼ = âˆ‘ x in f.range.filter (Î» x, x â‰  0), (Î¼ (f â»Â¹' {x})).to_real â€¢ x :=
by { rw [integral_def, set_to_simple_func_eq_sum_filter], simp_rw weighted_smul_apply, congr }
lemma integral_eq_sum_of_subset [decidable_pred (Î» x : F, x â‰  0)] {f : Î± â†’â‚› F} {s : finset F}
  (hs : f.range.filter (Î» x, x â‰  0) âŠ† s) : f.integral Î¼ = âˆ‘ x in s, (Î¼ (f â»Â¹' {x})).to_real â€¢ x :=
begin
  rw [simple_func.integral_eq_sum_filter, finset.sum_subset hs],
  rintro x - hx, rw [finset.mem_filter, not_and_distrib, ne.def, not_not] at hx,
  rcases hx with hx|rfl; [skip, simp],
  rw [simple_func.mem_range] at hx, rw [preimage_eq_empty]; simp [set.disjoint_singleton_left, hx]
end
@[simp] lemma integral_const {m : measurable_space Î±} (Î¼ : measure Î±) (y : F) :
  (const Î± y).integral Î¼ = (Î¼ univ).to_real â€¢ y :=
by classical; calc (const Î± y).integral Î¼ = âˆ‘ z in {y}, (Î¼ ((const Î± y) â»Â¹' {z})).to_real â€¢ z :
  integral_eq_sum_of_subset $ (filter_subset _ _).trans (range_const_subset _ _)
... = (Î¼ univ).to_real â€¢ y : by simp
@[simp] lemma integral_piecewise_zero {m : measurable_space Î±} (f : Î± â†’â‚› F) (Î¼ : measure Î±)
  {s : set Î±} (hs : measurable_set s) :
  (piecewise s hs f 0).integral Î¼ = f.integral (Î¼.restrict s) :=
begin
  classical,
  refine (integral_eq_sum_of_subset _).trans
    ((sum_congr rfl $ Î» y hy, _).trans (integral_eq_sum_filter _ _).symm),
  { intros y hy,
    simp only [mem_filter, mem_range, coe_piecewise, coe_zero, piecewise_eq_indicator,
      mem_range_indicator] at *,
    rcases hy with âŸ¨âŸ¨rfl, -âŸ©|âŸ¨x, hxs, rflâŸ©, hâ‚€âŸ©,
    exacts [(hâ‚€ rfl).elim, âŸ¨set.mem_range_self _, hâ‚€âŸ©] },
  { dsimp,
    rw [set.piecewise_eq_indicator, indicator_preimage_of_not_mem,
      measure.restrict_apply (f.measurable_set_preimage _)],
    exact Î» hâ‚€, (mem_filter.1 hy).2 (eq.symm hâ‚€) }
end
lemma map_integral (f : Î± â†’â‚› E) (g : E â†’ F) (hf : integrable f Î¼) (hg : g 0 = 0) :
  (f.map g).integral Î¼ = âˆ‘ x in f.range, (ennreal.to_real (Î¼ (f â»Â¹' {x}))) â€¢ (g x) :=
map_set_to_simple_func _ weighted_smul_union hf hg
lemma integral_eq_lintegral' {f : Î± â†’â‚› E} {g : E â†’ â„â‰¥0âˆ} (hf : integrable f Î¼) (hg0 : g 0 = 0)
  (ht : âˆ€ b, g b â‰  âˆ) :
  (f.map (ennreal.to_real âˆ˜ g)).integral Î¼ = ennreal.to_real (âˆ«â» a, g (f a) âˆ‚Î¼) :=
begin
  have hf' : f.fin_meas_supp Î¼ := integrable_iff_fin_meas_supp.1 hf,
  simp only [â† map_apply g f, lintegral_eq_lintegral],
  rw [map_integral f _ hf, map_lintegral, ennreal.to_real_sum],
  { refine finset.sum_congr rfl (Î»b hb, _),
    rw [smul_eq_mul, to_real_mul, mul_comm] },
  { assume a ha,
    by_cases a0 : a = 0,
    { rw [a0, hg0, zero_mul], exact with_top.zero_ne_top },
    { apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne } },
  { simp [hg0] }
end
variables [normed_field ğ•œ] [normed_space ğ•œ E] [normed_space â„ E] [smul_comm_class â„ ğ•œ E]
lemma integral_congr {f g : Î± â†’â‚› E} (hf : integrable f Î¼) (h : f =áµ[Î¼] g) :
  f.integral Î¼ = g.integral Î¼ :=
set_to_simple_func_congr (weighted_smul Î¼) (Î» s hs, weighted_smul_null) weighted_smul_union hf h
lemma integral_eq_lintegral {f : Î± â†’â‚› â„} (hf : integrable f Î¼) (h_pos : 0 â‰¤áµ[Î¼] f) :
  f.integral Î¼ = ennreal.to_real (âˆ«â» a, ennreal.of_real (f a) âˆ‚Î¼) :=
begin
  have : f =áµ[Î¼] f.map (ennreal.to_real âˆ˜ ennreal.of_real) :=
    h_pos.mono (Î» a h, (ennreal.to_real_of_real h).symm),
  rw [â† integral_eq_lintegral' hf],
  exacts [integral_congr hf this, ennreal.of_real_zero, Î» b, ennreal.of_real_ne_top]
end
lemma integral_add {f g : Î± â†’â‚› E} (hf : integrable f Î¼) (hg : integrable g Î¼) :
  integral Î¼ (f + g) = integral Î¼ f + integral Î¼ g :=
set_to_simple_func_add _ weighted_smul_union hf hg
lemma integral_neg {f : Î± â†’â‚› E} (hf : integrable f Î¼) : integral Î¼ (-f) = - integral Î¼ f :=
set_to_simple_func_neg _ weighted_smul_union hf
lemma integral_sub {f g : Î± â†’â‚› E} (hf : integrable f Î¼) (hg : integrable g Î¼) :
  integral Î¼ (f - g) = integral Î¼ f - integral Î¼ g :=
set_to_simple_func_sub _ weighted_smul_union hf hg
lemma integral_smul (c : ğ•œ) {f : Î± â†’â‚› E} (hf : integrable f Î¼) :
  integral Î¼ (c â€¢ f) = c â€¢ integral Î¼ f :=
set_to_simple_func_smul _ weighted_smul_union weighted_smul_smul c hf
lemma norm_set_to_simple_func_le_integral_norm (T : set Î± â†’ E â†’L[â„] F) {C : â„}
  (hT_norm : âˆ€ s, measurable_set s â†’ Î¼ s < âˆ â†’ âˆ¥T sâˆ¥ â‰¤ C * (Î¼ s).to_real) {f : Î± â†’â‚› E}
  (hf : integrable f Î¼) :
  âˆ¥f.set_to_simple_func Tâˆ¥ â‰¤ C * (f.map norm).integral Î¼ :=
calc âˆ¥f.set_to_simple_func Tâˆ¥
    â‰¤ C * âˆ‘ x in f.range, ennreal.to_real (Î¼ (f â»Â¹' {x})) * âˆ¥xâˆ¥ :
  norm_set_to_simple_func_le_sum_mul_norm_of_integrable T hT_norm f hf
... = C * (f.map norm).integral Î¼ : by { rw map_integral f norm hf norm_zero, simp_rw smul_eq_mul, }
lemma norm_integral_le_integral_norm (f : Î± â†’â‚› E) (hf : integrable f Î¼) :
  âˆ¥f.integral Î¼âˆ¥ â‰¤ (f.map norm).integral Î¼ :=
begin
  refine (norm_set_to_simple_func_le_integral_norm _ (Î» s _ _, _) hf).trans (one_mul _).le,
  exact (norm_weighted_smul_le s).trans (one_mul _).symm.le,
end
lemma integral_add_measure {Î½} (f : Î± â†’â‚› E) (hf : integrable f (Î¼ + Î½)) :
  f.integral (Î¼ + Î½) = f.integral Î¼ + f.integral Î½ :=
begin
  simp_rw [integral_def],
  refine set_to_simple_func_add_left' (weighted_smul Î¼) (weighted_smul Î½) (weighted_smul (Î¼ + Î½))
    (Î» s hs hÎ¼Î½s, _) hf,
  rw [lt_top_iff_ne_top, measure.coe_add, pi.add_apply, ennreal.add_ne_top] at hÎ¼Î½s,
  rw weighted_smul_add_measure _ _ hÎ¼Î½s.1 hÎ¼Î½s.2,
end
end integral
end simple_func
namespace L1
open ae_eq_fun Lp.simple_func Lp
variables [normed_group E] [normed_group F] {m : measurable_space Î±} {Î¼ : measure Î±}
variables {Î± E Î¼}
namespace simple_func
lemma norm_eq_integral (f : Î± â†’â‚â‚›[Î¼] E) : âˆ¥fâˆ¥ = ((to_simple_func f).map norm).integral Î¼ :=
begin
  rw [norm_eq_sum_mul f, (to_simple_func f).map_integral norm (simple_func.integrable f) norm_zero],
  simp_rw smul_eq_mul,
end
section pos_part
def pos_part (f : Î± â†’â‚â‚›[Î¼] â„) : Î± â†’â‚â‚›[Î¼] â„ := âŸ¨Lp.pos_part (f : Î± â†’â‚[Î¼] â„),
begin
  rcases f with âŸ¨f, s, hsfâŸ©,
  use s.pos_part,
  simp only [subtype.coe_mk, Lp.coe_pos_part, â† hsf, ae_eq_fun.pos_part_mk, simple_func.pos_part,
    simple_func.coe_map, mk_eq_mk],
end âŸ©
def neg_part (f : Î± â†’â‚â‚›[Î¼] â„) : Î± â†’â‚â‚›[Î¼] â„ := pos_part (-f)
@[norm_cast]
lemma coe_pos_part (f : Î± â†’â‚â‚›[Î¼] â„) : (pos_part f : Î± â†’â‚[Î¼] â„) = Lp.pos_part (f : Î± â†’â‚[Î¼] â„) := rfl
@[norm_cast]
lemma coe_neg_part (f : Î± â†’â‚â‚›[Î¼] â„) : (neg_part f : Î± â†’â‚[Î¼] â„) = Lp.neg_part (f : Î± â†’â‚[Î¼] â„) := rfl
end pos_part
section simple_func_integral
variables [normed_field ğ•œ] [normed_space ğ•œ E] [normed_space â„ E] [smul_comm_class â„ ğ•œ E]
  {F' : Type*} [normed_group F'] [normed_space â„ F']
local attribute [instance] simple_func.normed_space
def integral (f : Î± â†’â‚â‚›[Î¼] E) : E := ((to_simple_func f)).integral Î¼
lemma integral_eq_integral (f : Î± â†’â‚â‚›[Î¼] E) : integral f = ((to_simple_func f)).integral Î¼ := rfl
lemma integral_eq_lintegral {f : Î± â†’â‚â‚›[Î¼] â„} (h_pos : 0 â‰¤áµ[Î¼] (to_simple_func f)) :
  integral f = ennreal.to_real (âˆ«â» a, ennreal.of_real ((to_simple_func f) a) âˆ‚Î¼) :=
by rw [integral, simple_func.integral_eq_lintegral (simple_func.integrable f) h_pos]
lemma integral_eq_set_to_L1s (f : Î± â†’â‚â‚›[Î¼] E) : integral f = set_to_L1s (weighted_smul Î¼) f := rfl
lemma integral_congr {f g : Î± â†’â‚â‚›[Î¼] E} (h : to_simple_func f =áµ[Î¼] to_simple_func g) :
  integral f = integral g :=
simple_func.integral_congr (simple_func.integrable f) h
lemma integral_add (f g : Î± â†’â‚â‚›[Î¼] E) : integral (f + g) = integral f + integral g :=
set_to_L1s_add _ (Î» _ _, weighted_smul_null) weighted_smul_union _ _
lemma integral_smul (c : ğ•œ) (f : Î± â†’â‚â‚›[Î¼] E) :
  integral (c â€¢ f) = c â€¢ integral f :=
set_to_L1s_smul _ (Î» _ _, weighted_smul_null) weighted_smul_union weighted_smul_smul c f
lemma norm_integral_le_norm (f : Î± â†’â‚â‚›[Î¼] E) : âˆ¥integral fâˆ¥ â‰¤ âˆ¥fâˆ¥ :=
begin
  rw [integral, norm_eq_integral],
  exact (to_simple_func f).norm_integral_le_integral_norm (simple_func.integrable f)
end
variables {E' : Type*} [normed_group E'] [normed_space â„ E'] [normed_space ğ•œ E']
variables (Î± E Î¼ ğ•œ)
def integral_clm' : (Î± â†’â‚â‚›[Î¼] E) â†’L[ğ•œ] E :=
linear_map.mk_continuous âŸ¨integral, integral_add, integral_smulâŸ©
  1 (Î»f, le_trans (norm_integral_le_norm _) $ by rw one_mul)
def integral_clm : (Î± â†’â‚â‚›[Î¼] E) â†’L[â„] E := integral_clm' Î± E â„ Î¼
variables {Î± E Î¼ ğ•œ}
local notation `Integral` := integral_clm Î± E Î¼
open continuous_linear_map
lemma norm_Integral_le_one : âˆ¥Integralâˆ¥ â‰¤ 1 :=
linear_map.mk_continuous_norm_le _ (zero_le_one) _
section pos_part
lemma pos_part_to_simple_func (f : Î± â†’â‚â‚›[Î¼] â„) :
  to_simple_func (pos_part f) =áµ[Î¼] (to_simple_func f).pos_part :=
begin
  have eq : âˆ€ a, (to_simple_func f).pos_part a = max ((to_simple_func f) a) 0 := Î»a, rfl,
  have ae_eq : âˆ€áµ a âˆ‚Î¼, to_simple_func (pos_part f) a = max ((to_simple_func f) a) 0,
  { filter_upwards [to_simple_func_eq_to_fun (pos_part f), Lp.coe_fn_pos_part (f : Î± â†’â‚[Î¼] â„),
      to_simple_func_eq_to_fun f] with _ _ hâ‚‚ _,
    convert hâ‚‚, },
  refine ae_eq.mono (assume a h, _),
  rw [h, eq],
end
lemma neg_part_to_simple_func (f : Î± â†’â‚â‚›[Î¼] â„) :
  to_simple_func (neg_part f) =áµ[Î¼] (to_simple_func f).neg_part :=
begin
  rw [simple_func.neg_part, measure_theory.simple_func.neg_part],
  filter_upwards [pos_part_to_simple_func (-f), neg_to_simple_func f],
  assume a hâ‚ hâ‚‚,
  rw hâ‚,
  show max _ _ = max _ _,
  rw hâ‚‚,
  refl
end
lemma integral_eq_norm_pos_part_sub (f : Î± â†’â‚â‚›[Î¼] â„) :
  integral f = âˆ¥pos_part fâˆ¥ - âˆ¥neg_part fâˆ¥ :=
begin
def integral_clm' : (Î± â†’â‚[Î¼] E) â†’L[ğ•œ] E :=
(integral_clm' Î± E ğ•œ Î¼).extend
  (coe_to_Lp Î± E ğ•œ) (simple_func.dense_range one_ne_top) simple_func.uniform_inducing
variables {ğ•œ}
def integral_clm : (Î± â†’â‚[Î¼] E) â†’L[â„] E := integral_clm' â„
def integral (f : Î± â†’â‚[Î¼] E) : E := integral_clm f
lemma integral_eq (f : Î± â†’â‚[Î¼] E) : integral f = integral_clm f := rfl
lemma integral_eq_set_to_L1 (f : Î± â†’â‚[Î¼] E) :
  integral f = set_to_L1 (dominated_fin_meas_additive_weighted_smul Î¼) f :=
rfl
@[norm_cast] lemma simple_func.integral_L1_eq_integral (f : Î± â†’â‚â‚›[Î¼] E) :
  integral (f : Î± â†’â‚[Î¼] E) = (simple_func.integral f) :=
set_to_L1_eq_set_to_L1s_clm (dominated_fin_meas_additive_weighted_smul Î¼) f
variables (Î± E)
@[simp] lemma integral_zero : integral (0 : Î± â†’â‚[Î¼] E) = 0 :=
map_zero integral_clm
variables {Î± E}
lemma integral_add (f g : Î± â†’â‚[Î¼] E) : integral (f + g) = integral f + integral g :=
map_add integral_clm f g
lemma integral_neg (f : Î± â†’â‚[Î¼] E) : integral (-f) = - integral f :=
map_neg integral_clm f
lemma integral_sub (f g : Î± â†’â‚[Î¼] E) : integral (f - g) = integral f - integral g :=
map_sub integral_clm f g
lemma integral_smul (c : ğ•œ) (f : Î± â†’â‚[Î¼] E) : integral (c â€¢ f) = c â€¢ integral f :=
show (integral_clm' ğ•œ) (c â€¢ f) = c â€¢ (integral_clm' ğ•œ) f, from map_smul (integral_clm' ğ•œ) c f
local notation `Integral` := @integral_clm Î± E _ _ Î¼ _ _
local notation `sIntegral` := @simple_func.integral_clm Î± E _ _ Î¼ _
lemma norm_Integral_le_one : âˆ¥Integralâˆ¥ â‰¤ 1 :=
norm_set_to_L1_le (dominated_fin_meas_additive_weighted_smul Î¼) zero_le_one
lemma norm_integral_le (f : Î± â†’â‚[Î¼] E) : âˆ¥integral fâˆ¥ â‰¤ âˆ¥fâˆ¥ :=
calc âˆ¥integral fâˆ¥ = âˆ¥Integral fâˆ¥ : rfl
  ... â‰¤ âˆ¥Integralâˆ¥ * âˆ¥fâˆ¥ : le_op_norm _ _
  ... â‰¤ 1 * âˆ¥fâˆ¥ : mul_le_mul_of_nonneg_right norm_Integral_le_one $ norm_nonneg _
  ... = âˆ¥fâˆ¥ : one_mul _
@[continuity]
lemma continuous_integral : continuous (Î» (f : Î± â†’â‚[Î¼] E), integral f) :=
L1.integral_clm.continuous
section pos_part
lemma integral_eq_norm_pos_part_sub (f : Î± â†’â‚[Î¼] â„) :
  integral f = âˆ¥Lp.pos_part fâˆ¥ - âˆ¥Lp.neg_part fâˆ¥ :=
begin
variables [normed_group E] [normed_space â„ E] [complete_space E]
          [nondiscrete_normed_field ğ•œ] [normed_space ğ•œ E] [smul_comm_class â„ ğ•œ E]
          [normed_group F] [normed_space â„ F] [complete_space F]
section
open_locale classical
def integral {m : measurable_space Î±} (Î¼ : measure Î±) (f : Î± â†’ E) : E :=
if hf : integrable f Î¼ then L1.integral (hf.to_L1 f) else 0
end
notation `âˆ«` binders `, ` r:(scoped:60 f, f) ` âˆ‚` Î¼:70 := integral Î¼ r
notation `âˆ«` binders `, ` r:(scoped:60 f, integral volume f) := r
notation `âˆ«` binders ` in ` s `, ` r:(scoped:60 f, f) ` âˆ‚` Î¼:70 := integral (measure.restrict Î¼ s) r
notation `âˆ«` binders ` in ` s `, ` r:(scoped:60 f, integral (measure.restrict volume s) f) := r
section properties
open continuous_linear_map measure_theory.simple_func
variables {f g : Î± â†’ E} {m : measurable_space Î±} {Î¼ : measure Î±}
lemma integral_eq (f : Î± â†’ E) (hf : integrable f Î¼) :
  âˆ« a, f a âˆ‚Î¼ = L1.integral (hf.to_L1 f) :=
@dif_pos _ (id _) hf _ _ _
lemma integral_eq_set_to_fun (f : Î± â†’ E) :
  âˆ« a, f a âˆ‚Î¼ = set_to_fun Î¼ (weighted_smul Î¼) (dominated_fin_meas_additive_weighted_smul Î¼) f :=
rfl
lemma L1.integral_eq_integral (f : Î± â†’â‚[Î¼] E) : L1.integral f = âˆ« a, f a âˆ‚Î¼ :=
(L1.set_to_fun_eq_set_to_L1 (dominated_fin_meas_additive_weighted_smul Î¼) f).symm
lemma integral_undef (h : Â¬ integrable f Î¼) : âˆ« a, f a âˆ‚Î¼ = 0 :=
@dif_neg _ (id _) h _ _ _
lemma integral_non_ae_strongly_measurable (h : Â¬ ae_strongly_measurable f Î¼) : âˆ« a, f a âˆ‚Î¼ = 0 :=
integral_undef $ not_and_of_not_left _ h
variables (Î± E)
lemma integral_zero : âˆ« a : Î±, (0:E) âˆ‚Î¼ = 0 :=
set_to_fun_zero (dominated_fin_meas_additive_weighted_smul Î¼)
@[simp] lemma integral_zero' : integral Î¼ (0 : Î± â†’ E) = 0 :=
integral_zero Î± E
variables {Î± E}
lemma integral_add (hf : integrable f Î¼) (hg : integrable g Î¼) :
  âˆ« a, f a + g a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ + âˆ« a, g a âˆ‚Î¼ :=
set_to_fun_add (dominated_fin_meas_additive_weighted_smul Î¼) hf hg
lemma integral_add' (hf : integrable f Î¼) (hg : integrable g Î¼) :
  âˆ« a, (f + g) a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ + âˆ« a, g a âˆ‚Î¼ :=
integral_add hf hg
lemma integral_finset_sum {Î¹} (s : finset Î¹) {f : Î¹ â†’ Î± â†’ E} (hf : âˆ€ i âˆˆ s, integrable (f i) Î¼) :
  âˆ« a, âˆ‘ i in s, f i a âˆ‚Î¼ = âˆ‘ i in s, âˆ« a, f i a âˆ‚Î¼ :=
set_to_fun_finset_sum (dominated_fin_meas_additive_weighted_smul _) s hf
lemma integral_neg (f : Î± â†’ E) : âˆ« a, -f a âˆ‚Î¼ = - âˆ« a, f a âˆ‚Î¼ :=
set_to_fun_neg (dominated_fin_meas_additive_weighted_smul Î¼) f
lemma integral_neg' (f : Î± â†’ E) : âˆ« a, (-f) a âˆ‚Î¼ = - âˆ« a, f a âˆ‚Î¼ :=
integral_neg f
lemma integral_sub (hf : integrable f Î¼) (hg : integrable g Î¼) :
  âˆ« a, f a - g a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ - âˆ« a, g a âˆ‚Î¼ :=
set_to_fun_sub (dominated_fin_meas_additive_weighted_smul Î¼) hf hg
lemma integral_sub' (hf : integrable f Î¼) (hg : integrable g Î¼) :
  âˆ« a, (f - g) a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ - âˆ« a, g a âˆ‚Î¼ :=
integral_sub hf hg
lemma integral_smul (c : ğ•œ) (f : Î± â†’ E) :
  âˆ« a, c â€¢ (f a) âˆ‚Î¼ = c â€¢ âˆ« a, f a âˆ‚Î¼ :=
set_to_fun_smul (dominated_fin_meas_additive_weighted_smul Î¼) weighted_smul_smul c f
lemma integral_mul_left (r : â„) (f : Î± â†’ â„) : âˆ« a, r * (f a) âˆ‚Î¼ = r * âˆ« a, f a âˆ‚Î¼ :=
integral_smul r f
lemma integral_mul_right (r : â„) (f : Î± â†’ â„) : âˆ« a, (f a) * r âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ * r :=
by { simp only [mul_comm], exact integral_mul_left r f }
lemma integral_div (r : â„) (f : Î± â†’ â„) : âˆ« a, (f a) / r âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ / r :=
integral_mul_right râ»Â¹ f
lemma integral_congr_ae (h : f =áµ[Î¼] g) : âˆ« a, f a âˆ‚Î¼ = âˆ« a, g a âˆ‚Î¼ :=
set_to_fun_congr_ae (dominated_fin_meas_additive_weighted_smul Î¼) h
@[simp] lemma L1.integral_of_fun_eq_integral {f : Î± â†’ E} (hf : integrable f Î¼) :
  âˆ« a, (hf.to_L1 f) a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ :=
set_to_fun_to_L1 (dominated_fin_meas_additive_weighted_smul Î¼) hf
@[continuity]
lemma continuous_integral : continuous (Î» (f : Î± â†’â‚[Î¼] E), âˆ« a, f a âˆ‚Î¼) :=
continuous_set_to_fun (dominated_fin_meas_additive_weighted_smul Î¼)
lemma norm_integral_le_lintegral_norm (f : Î± â†’ E) :
  âˆ¥âˆ« a, f a âˆ‚Î¼âˆ¥ â‰¤ ennreal.to_real (âˆ«â» a, (ennreal.of_real âˆ¥f aâˆ¥) âˆ‚Î¼) :=
begin
  by_cases hf : integrable f Î¼,
  { rw [integral_eq f hf, â† integrable.norm_to_L1_eq_lintegral_norm f hf],
    exact L1.norm_integral_le _ },
  { rw [integral_undef hf, norm_zero], exact to_real_nonneg }
end
lemma ennnorm_integral_le_lintegral_ennnorm (f : Î± â†’ E) :
  (âˆ¥âˆ« a, f a âˆ‚Î¼âˆ¥â‚Š : â„â‰¥0âˆ) â‰¤ âˆ«â» a, âˆ¥f aâˆ¥â‚Š âˆ‚Î¼ :=
by { simp_rw [â† of_real_norm_eq_coe_nnnorm], apply ennreal.of_real_le_of_le_to_real,
  exact norm_integral_le_lintegral_norm f }
lemma integral_eq_zero_of_ae {f : Î± â†’ E} (hf : f =áµ[Î¼] 0) : âˆ« a, f a âˆ‚Î¼ = 0 :=
by simp [integral_congr_ae hf, integral_zero]
lemma has_finite_integral.tendsto_set_integral_nhds_zero {Î¹} {f : Î± â†’ E}
  (hf : has_finite_integral f Î¼) {l : filter Î¹} {s : Î¹ â†’ set Î±} (hs : tendsto (Î¼ âˆ˜ s) l (ğ“ 0)) :
  tendsto (Î» i, âˆ« x in s i, f x âˆ‚Î¼) l (ğ“ 0) :=
begin
  rw [tendsto_zero_iff_norm_tendsto_zero],
  simp_rw [â† coe_nnnorm, â† nnreal.coe_zero, nnreal.tendsto_coe, â† ennreal.tendsto_coe,
    ennreal.coe_zero],
  exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds
    (tendsto_set_lintegral_zero (ne_of_lt hf) hs) (Î» i, zero_le _)
    (Î» i, ennnorm_integral_le_lintegral_ennnorm _)
end
lemma integrable.tendsto_set_integral_nhds_zero {Î¹} {f : Î± â†’ E}
  (hf : integrable f Î¼) {l : filter Î¹} {s : Î¹ â†’ set Î±} (hs : tendsto (Î¼ âˆ˜ s) l (ğ“ 0)) :
  tendsto (Î» i, âˆ« x in s i, f x âˆ‚Î¼) l (ğ“ 0) :=
hf.2.tendsto_set_integral_nhds_zero hs
lemma tendsto_integral_of_L1 {Î¹} (f : Î± â†’ E) (hfi : integrable f Î¼)
  {F : Î¹ â†’ Î± â†’ E} {l : filter Î¹} (hFi : âˆ€á¶  i in l, integrable (F i) Î¼)
  (hF : tendsto (Î» i, âˆ«â» x, âˆ¥F i x - f xâˆ¥â‚Š âˆ‚Î¼) l (ğ“ 0)) :
  tendsto (Î» i, âˆ« x, F i x âˆ‚Î¼) l (ğ“ $ âˆ« x, f x âˆ‚Î¼) :=
begin
  rw [tendsto_iff_norm_tendsto_zero],
  replace hF : tendsto (Î» i, ennreal.to_real $ âˆ«â» x, âˆ¥F i x - f xâˆ¥â‚Š âˆ‚Î¼) l (ğ“ 0) :=
    (ennreal.tendsto_to_real zero_ne_top).comp hF,
  refine squeeze_zero_norm' (hFi.mp $ hFi.mono $ Î» i hFi hFm, _) hF,
  simp only [norm_norm, â† integral_sub hFi hfi],
  convert norm_integral_le_lintegral_norm (Î» x, F i x - f x),
  ext1 x,
  exact coe_nnreal_eq _
end
theorem tendsto_integral_of_dominated_convergence {F : â„• â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„)
  (F_measurable : âˆ€ n, ae_strongly_measurable (F n) Î¼)
  (bound_integrable : integrable bound Î¼)
  (h_bound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, âˆ¥F n aâˆ¥ â‰¤ bound a)
  (h_lim : âˆ€áµ a âˆ‚Î¼, tendsto (Î» n, F n a) at_top (ğ“ (f a))) :
  tendsto (Î»n, âˆ« a, F n a âˆ‚Î¼) at_top (ğ“ $ âˆ« a, f a âˆ‚Î¼) :=
tendsto_set_to_fun_of_dominated_convergence (dominated_fin_meas_additive_weighted_smul Î¼) bound
  F_measurable bound_integrable h_bound h_lim
lemma tendsto_integral_filter_of_dominated_convergence {Î¹} {l : filter Î¹}
  [l.is_countably_generated]
  {F : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„)
  (hF_meas : âˆ€á¶  n in l, ae_strongly_measurable (F n) Î¼)
  (h_bound : âˆ€á¶  n in l, âˆ€áµ a âˆ‚Î¼, âˆ¥F n aâˆ¥ â‰¤ bound a)
  (bound_integrable : integrable bound Î¼)
  (h_lim : âˆ€áµ a âˆ‚Î¼, tendsto (Î» n, F n a) l (ğ“ (f a))) :
  tendsto (Î»n, âˆ« a, F n a âˆ‚Î¼) l (ğ“ $ âˆ« a, f a âˆ‚Î¼) :=
tendsto_set_to_fun_filter_of_dominated_convergence (dominated_fin_meas_additive_weighted_smul Î¼)
  bound hF_meas h_bound bound_integrable h_lim
lemma has_sum_integral_of_dominated_convergence {Î¹} [encodable Î¹]
  {F : Î¹ â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î¹ â†’ Î± â†’ â„)
  (hF_meas : âˆ€ n, ae_strongly_measurable (F n) Î¼)
  (h_bound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, âˆ¥F n aâˆ¥ â‰¤ bound n a)
  (bound_summable : âˆ€áµ a âˆ‚Î¼, summable (Î» n, bound n a))
  (bound_integrable : integrable (Î» a, âˆ‘' n, bound n a) Î¼)
  (h_lim : âˆ€áµ a âˆ‚Î¼, has_sum (Î» n, F n a) (f a)) :
  has_sum (Î»n, âˆ« a, F n a âˆ‚Î¼) (âˆ« a, f a âˆ‚Î¼) :=
begin
  have hb_nonneg : âˆ€áµ a âˆ‚Î¼, âˆ€ n, 0 â‰¤ bound n a :=
    eventually_countable_forall.2 (Î» n, (h_bound n).mono $ Î» a, (norm_nonneg _).trans),
  have hb_le_tsum : âˆ€ n, bound n â‰¤áµ[Î¼] (Î» a, âˆ‘' n, bound n a),
  { intro n,
    filter_upwards [hb_nonneg, bound_summable] with _ ha0 ha_sum
      using le_tsum ha_sum _ (Î» i _, ha0 i) },
  have hF_integrable : âˆ€ n, integrable (F n) Î¼,
  { refine Î» n, bound_integrable.mono' (hF_meas n) _,
    exact eventually_le.trans (h_bound n) (hb_le_tsum n) },
  simp only [has_sum, â† integral_finset_sum _ (Î» n _, hF_integrable n)],
  refine tendsto_integral_filter_of_dominated_convergence (Î» a, âˆ‘' n, bound n a) _ _
    bound_integrable h_lim,
  { exact eventually_of_forall (Î» s, s.ae_strongly_measurable_sum $ Î» n hn, hF_meas n) },
  { refine eventually_of_forall (Î» s, _),
    filter_upwards [eventually_countable_forall.2 h_bound, hb_nonneg, bound_summable]
      with a hFa ha0 has,
    calc âˆ¥âˆ‘ n in s, F n aâˆ¥ â‰¤ âˆ‘ n in s, bound n a : norm_sum_le_of_le _ (Î» n hn, hFa n)
                       ... â‰¤ âˆ‘' n, bound n a     : sum_le_tsum _ (Î» n hn, ha0 n) has },
end
variables {X : Type*} [topological_space X] [first_countable_topology X]
lemma continuous_at_of_dominated {F : X â†’ Î± â†’ E} {xâ‚€ : X} {bound : Î± â†’ â„}
  (hF_meas : âˆ€á¶  x in ğ“ xâ‚€, ae_strongly_measurable (F x) Î¼)
  (h_bound : âˆ€á¶  x in ğ“ xâ‚€, âˆ€áµ a âˆ‚Î¼, âˆ¥F x aâˆ¥ â‰¤ bound a)
  (bound_integrable : integrable bound Î¼) (h_cont : âˆ€áµ a âˆ‚Î¼, continuous_at (Î» x, F x a) xâ‚€) :
  continuous_at (Î» x, âˆ« a, F x a âˆ‚Î¼) xâ‚€ :=
continuous_at_set_to_fun_of_dominated (dominated_fin_meas_additive_weighted_smul Î¼) hF_meas h_bound
  bound_integrable h_cont
lemma continuous_of_dominated {F : X â†’ Î± â†’ E} {bound : Î± â†’ â„}
  (hF_meas : âˆ€ x, ae_strongly_measurable (F x) Î¼) (h_bound : âˆ€ x, âˆ€áµ a âˆ‚Î¼, âˆ¥F x aâˆ¥ â‰¤ bound a)
  (bound_integrable : integrable bound Î¼) (h_cont : âˆ€áµ a âˆ‚Î¼, continuous (Î» x, F x a)) :
  continuous (Î» x, âˆ« a, F x a âˆ‚Î¼) :=
continuous_set_to_fun_of_dominated (dominated_fin_meas_additive_weighted_smul Î¼) hF_meas h_bound
  bound_integrable h_cont
lemma integral_eq_lintegral_pos_part_sub_lintegral_neg_part {f : Î± â†’ â„} (hf : integrable f Î¼) :
  âˆ« a, f a âˆ‚Î¼ =
  ennreal.to_real (âˆ«â» a, (ennreal.of_real $ f a) âˆ‚Î¼) -
  ennreal.to_real (âˆ«â» a, (ennreal.of_real $ - f a) âˆ‚Î¼) :=
let fâ‚ := hf.to_L1 f in
def simple_func.to_larger_space (hm : m â‰¤ m0) (f : @simple_func Î² m Î³) : simple_func Î² Î³ :=
âŸ¨@simple_func.to_fun Î² m Î³ f, Î» x, hm _ (@simple_func.measurable_set_fiber Î² Î³ m f x),
  @simple_func.finite_range Î² Î³ m fâŸ©
lemma simple_func.coe_to_larger_space_eq (hm : m â‰¤ m0) (f : @simple_func Î² m Î³) :
  â‡‘(f.to_larger_space hm) = f :=
rfl
lemma integral_simple_func_larger_space (hm : m â‰¤ m0) (f : @simple_func Î² m F)
  (hf_int : integrable f Î¼) :
  âˆ« x, f x âˆ‚Î¼ = âˆ‘ x in (@simple_func.range Î² F m f), (ennreal.to_real (Î¼ (f â»Â¹' {x}))) â€¢ x :=
begin
  simp_rw â† f.coe_to_larger_space_eq hm,
  have hf_int : integrable (f.to_larger_space hm) Î¼, by rwa simple_func.coe_to_larger_space_eq,
  rw simple_func.integral_eq_sum _ hf_int,
  congr,
end
lemma integral_trim_simple_func (hm : m â‰¤ m0) (f : @simple_func Î² m F) (hf_int : integrable f Î¼) :
  âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚(Î¼.trim hm) :=
begin
  have hf : strongly_measurable[m] f, from @simple_func.strongly_measurable Î² F m _ f,
  have hf_int_m := hf_int.trim hm hf,
  rw [integral_simple_func_larger_space (le_refl m) f hf_int_m,
    integral_simple_func_larger_space hm f hf_int],
  congr' with x,
  congr,
  exact (trim_measurable_set_eq hm (@simple_func.measurable_set_fiber Î² F m f x)).symm,
end
lemma integral_trim (hm : m â‰¤ m0) {f : Î² â†’ F} (hf : strongly_measurable[m] f) :
  âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚(Î¼.trim hm) :=
begin
  borelize F,
  by_cases hf_int : integrable f Î¼,
  swap,
  { have hf_int_m : Â¬ integrable f (Î¼.trim hm),
      from Î» hf_int_m, hf_int (integrable_of_integrable_trim hm hf_int_m),
    rw [integral_undef hf_int, integral_undef hf_int_m], },
  haveI : separable_space (range f âˆª {0} : set F) := hf.separable_space_range_union_singleton,
  let f_seq := @simple_func.approx_on F Î² _ _ _ m _ hf.measurable (range f âˆª {0}) 0 (by simp) _,
  have hf_seq_meas : âˆ€ n, strongly_measurable[m] (f_seq n),
    from Î» n, @simple_func.strongly_measurable Î² F m _ (f_seq n),
  have hf_seq_int : âˆ€ n, integrable (f_seq n) Î¼,
    from simple_func.integrable_approx_on_range (hf.mono hm).measurable hf_int,
  have hf_seq_int_m : âˆ€ n, integrable (f_seq n) (Î¼.trim hm),
    from Î» n, (hf_seq_int n).trim hm (hf_seq_meas n) ,
  have hf_seq_eq : âˆ€ n, âˆ« x, f_seq n x âˆ‚Î¼ = âˆ« x, f_seq n x âˆ‚(Î¼.trim hm),
    from Î» n, integral_trim_simple_func hm (f_seq n) (hf_seq_int n),
  have h_lim_1 : at_top.tendsto (Î» n, âˆ« x, f_seq n x âˆ‚Î¼) (ğ“ (âˆ« x, f x âˆ‚Î¼)),
  { refine tendsto_integral_of_L1 f hf_int (eventually_of_forall hf_seq_int) _,
    exact simple_func.tendsto_approx_on_range_L1_nnnorm (hf.mono hm).measurable hf_int, },
  have h_lim_2 : at_top.tendsto (Î» n, âˆ« x, f_seq n x âˆ‚Î¼) (ğ“ (âˆ« x, f x âˆ‚(Î¼.trim hm))),
  { simp_rw hf_seq_eq,
    refine @tendsto_integral_of_L1 Î² F _ _ _ m (Î¼.trim hm) _ f
      (hf_int.trim hm hf) _ _ (eventually_of_forall hf_seq_int_m) _,
    exact @simple_func.tendsto_approx_on_range_L1_nnnorm Î² F m _ _ _ f _ _
      hf.measurable (hf_int.trim hm hf), },
  exact tendsto_nhds_unique h_lim_1 h_lim_2,
end
lemma integral_trim_ae (hm : m â‰¤ m0) {f : Î² â†’ F} (hf : ae_strongly_measurable f (Î¼.trim hm)) :
  âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚(Î¼.trim hm) :=
begin
  rw [integral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), integral_congr_ae hf.ae_eq_mk],
  exact integral_trim hm hf.strongly_measurable_mk,
end
lemma ae_eq_trim_of_strongly_measurable
  [topological_space Î³] [metrizable_space Î³] (hm : m â‰¤ m0) {f g : Î² â†’ Î³}
  (hf : strongly_measurable[m] f) (hg : strongly_measurable[m] g) (hfg : f =áµ[Î¼] g) :
  f =áµ[Î¼.trim hm] g :=
begin
  rwa [eventually_eq, ae_iff, trim_measurable_set_eq hm _],
  exact (hf.measurable_set_eq_fun hg).compl
end
lemma ae_eq_trim_iff [topological_space Î³] [metrizable_space Î³]
  (hm : m â‰¤ m0) {f g : Î² â†’ Î³} (hf : strongly_measurable[m] f) (hg : strongly_measurable[m] g) :
  f =áµ[Î¼.trim hm] g â†” f =áµ[Î¼] g :=
âŸ¨ae_eq_of_ae_eq_trim, ae_eq_trim_of_strongly_measurable hm hf hgâŸ©
lemma ae_le_trim_of_strongly_measurable
  [linear_order Î³] [topological_space Î³] [order_closed_topology Î³] [pseudo_metrizable_space Î³]
  (hm : m â‰¤ m0) {f g : Î² â†’ Î³} (hf : strongly_measurable[m] f) (hg : strongly_measurable[m] g)
  (hfg : f â‰¤áµ[Î¼] g) :
  f â‰¤áµ[Î¼.trim hm] g :=
begin
  rwa [eventually_le, ae_iff, trim_measurable_set_eq hm _],
  exact (hf.measurable_set_le hg).compl,
end
lemma ae_le_trim_iff
  [linear_order Î³] [topological_space Î³] [order_closed_topology Î³] [pseudo_metrizable_space Î³]
  (hm : m â‰¤ m0) {f g : Î² â†’ Î³} (hf : strongly_measurable[m] f) (hg : strongly_measurable[m] g) :
  f â‰¤áµ[Î¼.trim hm] g â†” f â‰¤áµ[Î¼] g :=
âŸ¨ae_le_of_ae_le_trim, ae_le_trim_of_strongly_measurable hm hf hgâŸ©
end integral_trim
end measure_theory
