import topology.vector_bundle.basic
import geometry.manifold.smooth_manifold_with_corners
import data.set.prod
noncomputable theory
universe u
open topological_space set
open_locale manifold topological_space
structure basic_smooth_vector_bundle_core {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
{E : Type*} [normed_group E] [normed_space ğ•œ E]
{H : Type*} [topological_space H] (I : model_with_corners ğ•œ E H)
(M : Type*) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]
(F : Type*) [normed_group F] [normed_space ğ•œ F] :=
(coord_change      : atlas H M â†’ atlas H M â†’ H â†’ (F â†’L[ğ•œ] F))
(coord_change_self : âˆ€ i : atlas H M, âˆ€ x âˆˆ i.1.target, âˆ€ v, coord_change i i x v = v)
(coord_change_comp : âˆ€ i j k : atlas H M,
  âˆ€ x âˆˆ ((i.1.symm.trans j.1).trans (j.1.symm.trans k.1)).source, âˆ€ v,
  (coord_change j k ((i.1.symm.trans j.1) x)) (coord_change i j x v) = coord_change i k x v)
(coord_change_smooth_clm : âˆ€ i j : atlas H M,
  cont_diff_on ğ•œ âˆ ((coord_change i j) âˆ˜ I.symm) (I '' (i.1.symm.trans j.1).source))
def trivial_basic_smooth_vector_bundle_core {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
{E : Type*} [normed_group E] [normed_space ğ•œ E]
{H : Type*} [topological_space H] (I : model_with_corners ğ•œ E H)
(M : Type*) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]
(F : Type*) [normed_group F] [normed_space ğ•œ F] : basic_smooth_vector_bundle_core I M F :=
{ coord_change := Î» i j x, continuous_linear_map.id ğ•œ F,
  coord_change_self := Î» i x hx v, rfl,
  coord_change_comp := Î» i j k x hx v, rfl,
  coord_change_smooth_clm := Î» i j, by { dsimp, exact cont_diff_on_const } }
namespace basic_smooth_vector_bundle_core
variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
{E : Type*} [normed_group E] [normed_space ğ•œ E]
{H : Type*} [topological_space H] {I : model_with_corners ğ•œ E H}
{M : Type*} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]
{F : Type*} [normed_group F] [normed_space ğ•œ F]
(Z : basic_smooth_vector_bundle_core I M F)
instance : inhabited (basic_smooth_vector_bundle_core I M F) :=
âŸ¨trivial_basic_smooth_vector_bundle_core I M FâŸ©
lemma coord_change_continuous (i j : atlas H M) :
  continuous_on (Z.coord_change i j) (i.1.symm.trans j.1).source :=
begin
  assume x hx,
  apply (((Z.coord_change_smooth_clm i j).continuous_on.continuous_within_at
    (mem_image_of_mem I hx)).comp I.continuous_within_at _).congr,
  { assume y hy,
    simp only with mfld_simps },
  { simp only with mfld_simps },
  { exact maps_to_image I _ },
end
lemma coord_change_smooth (i j : atlas H M) :
  cont_diff_on ğ•œ âˆ (Î» p : E Ã— F, Z.coord_change i j (I.symm p.1) p.2)
    ((I '' (i.1.symm.trans j.1).source) Ã—Ë¢ (univ : set F)) :=
begin
  have A : cont_diff ğ•œ âˆ (Î» p : (F â†’L[ğ•œ] F) Ã— F, p.1 p.2),
  { apply is_bounded_bilinear_map.cont_diff,
    exact is_bounded_bilinear_map_apply },
  have B : cont_diff_on ğ•œ âˆ (Î» (p : E Ã— F), (Z.coord_change i j (I.symm p.1), p.snd))
    ((I '' (i.1.symm.trans j.1).source) Ã—Ë¢ (univ : set F)),
  { apply cont_diff_on.prod _ _,
    { exact (Z.coord_change_smooth_clm i j).comp cont_diff_fst.cont_diff_on
       (prod_subset_preimage_fst _ _) },
    { exact is_bounded_linear_map.snd.cont_diff.cont_diff_on } },
  exact A.comp_cont_diff_on B,
end
def to_topological_vector_bundle_core : topological_vector_bundle_core ğ•œ M F (atlas H M) :=
{ base_set := Î» i, i.1.source,
  is_open_base_set := Î» i, i.1.open_source,
  index_at := Î» x, âŸ¨chart_at H x, chart_mem_atlas H xâŸ©,
  mem_base_set_at := Î» x, mem_chart_source H x,
  coord_change := Î» i j x, Z.coord_change i j (i.1 x),
  coord_change_self := Î» i x hx v, Z.coord_change_self i (i.1 x) (i.1.map_source hx) v,
  coord_change_comp := Î» i j k x âŸ¨âŸ¨hx1, hx2âŸ©, hx3âŸ© v, begin
    have := Z.coord_change_comp i j k (i.1 x) _ v,
    convert this using 2,
    { simp only [hx1] with mfld_simps },
    { simp only [hx1, hx2, hx3] with mfld_simps }
  end,
  coord_change_continuous := Î» i j, begin
    refine ((Z.coord_change_continuous i j).comp' i.1.continuous_on).mono _,
    rintros p âŸ¨hpâ‚, hpâ‚‚âŸ©,
    refine âŸ¨hpâ‚, i.1.maps_to hpâ‚, _âŸ©,
    simp only [i.1.left_inv hpâ‚, hpâ‚‚] with mfld_simps
  end }
@[simp, mfld_simps] lemma base_set (i : atlas H M) :
  (Z.to_topological_vector_bundle_core.local_triv i).base_set = i.1.source := rfl
@[simp, mfld_simps] lemma target (i : atlas H M) :
  (Z.to_topological_vector_bundle_core.local_triv i).target = i.1.source Ã—Ë¢ (univ : set F) := rfl
def chart {e : local_homeomorph M H} (he : e âˆˆ atlas H M) :
  local_homeomorph (Z.to_topological_vector_bundle_core.total_space) (model_prod H F) :=
(Z.to_topological_vector_bundle_core.local_triv âŸ¨e, heâŸ©).to_local_homeomorph.trans
  (local_homeomorph.prod e (local_homeomorph.refl F))
@[simp, mfld_simps] lemma chart_source (e : local_homeomorph M H) (he : e âˆˆ atlas H M) :
  (Z.chart he).source = Z.to_topological_vector_bundle_core.proj â»Â¹' e.source :=
by { simp only [chart, mem_prod], mfld_set_tac }
@[simp, mfld_simps] lemma chart_target (e : local_homeomorph M H) (he : e âˆˆ atlas H M) :
  (Z.chart he).target = e.target Ã—Ë¢ (univ : set F) :=
by { simp only [chart], mfld_set_tac }
instance to_charted_space :
  charted_space (model_prod H F) Z.to_topological_vector_bundle_core.total_space :=
{ atlas := â‹ƒ(e : local_homeomorph M H) (he : e âˆˆ atlas H M), {Z.chart he},
  chart_at := Î» p, Z.chart (chart_mem_atlas H p.1),
  mem_chart_source := Î» p, by simp [mem_chart_source],
  chart_mem_atlas := Î» p, begin
    simp only [mem_Union, mem_singleton_iff, chart_mem_atlas],
    exact âŸ¨chart_at H p.1, chart_mem_atlas H p.1, rflâŸ©
  end }
lemma mem_atlas_iff
  (f : local_homeomorph Z.to_topological_vector_bundle_core.total_space (model_prod H F)) :
  f âˆˆ atlas (model_prod H F) Z.to_topological_vector_bundle_core.total_space â†”
  âˆƒ(e : local_homeomorph M H) (he : e âˆˆ atlas H M), f = Z.chart he :=
by simp only [atlas, mem_Union, mem_singleton_iff]
@[simp, mfld_simps] lemma mem_chart_source_iff
  (p q : Z.to_topological_vector_bundle_core.total_space) :
  p âˆˆ (chart_at (model_prod H F) q).source â†” p.1 âˆˆ (chart_at H q.1).source :=
by simp only [chart_at] with mfld_simps
@[simp, mfld_simps] lemma mem_chart_target_iff
  (p : H Ã— F) (q : Z.to_topological_vector_bundle_core.total_space) :
  p âˆˆ (chart_at (model_prod H F) q).target â†” p.1 âˆˆ (chart_at H q.1).target :=
by simp only [chart_at] with mfld_simps
@[simp, mfld_simps] lemma coe_chart_at_fst (p q : Z.to_topological_vector_bundle_core.total_space) :
  ((chart_at (model_prod H F) q) p).1 = chart_at H q.1 p.1 := rfl
@[simp, mfld_simps] lemma coe_chart_at_symm_fst
  (p : H Ã— F) (q : Z.to_topological_vector_bundle_core.total_space) :
  ((chart_at (model_prod H F) q).symm p).1 = ((chart_at H q.1).symm : H â†’ M) p.1 := rfl
instance to_smooth_manifold :
  smooth_manifold_with_corners (I.prod (ğ“˜(ğ•œ, F))) Z.to_topological_vector_bundle_core.total_space :=
begin
  let J := model_with_corners.to_local_equiv (I.prod (ğ“˜(ğ•œ, F))),
  have A : âˆ€ (e e' : local_homeomorph M H) (he : e âˆˆ atlas H M) (he' : e' âˆˆ atlas H M),
    cont_diff_on ğ•œ âˆ
    (J âˆ˜ ((Z.chart he).symm.trans (Z.chart he')) âˆ˜ J.symm)
    (J.symm â»Â¹' ((Z.chart he).symm.trans (Z.chart he')).source âˆ© range J),
  { assume e e' he he',
    have : J.symm â»Â¹' ((chart Z he).symm.trans (chart Z he')).source âˆ© range J =
      (I.symm â»Â¹' (e.symm.trans e').source âˆ© range I) Ã—Ë¢ (univ : set F),
      by { simp only [J, chart, model_with_corners.prod], mfld_set_tac },
    rw this,
      have := Z.coord_change_smooth âŸ¨e, heâŸ© âŸ¨e', he'âŸ©,
      rw I.image_eq at this,
      apply cont_diff_on.congr this,
      rintros âŸ¨x, vâŸ© hx,
      simp only with mfld_simps at hx,
      let f := chart_at H (e.symm (I.symm x)),
      have A : I.symm x âˆˆ ((e.symm.trans f).trans (f.symm.trans e')).source,
        by simp only [hx.1.1, hx.1.2] with mfld_simps,
      rw e.right_inv hx.1.1,
      have := Z.coord_change_comp âŸ¨e, heâŸ© âŸ¨f, chart_mem_atlas _ _âŸ© âŸ¨e', he'âŸ© (I.symm x) A v,
      simpa only [] using this } },
  refine @smooth_manifold_with_corners.mk _ _ _ _ _ _ _ _ _ _ _ âŸ¨_âŸ©,
  assume eâ‚€ eâ‚€' heâ‚€ heâ‚€',
  rcases (Z.mem_atlas_iff _).1 heâ‚€ with âŸ¨e, he, rflâŸ©,
  rcases (Z.mem_atlas_iff _).1 heâ‚€' with âŸ¨e', he', rflâŸ©,
  rw [cont_diff_groupoid, mem_groupoid_of_pregroupoid],
  exact âŸ¨A e e' he he', A e' e he' heâŸ©
end
end basic_smooth_vector_bundle_core
section tangent_bundle
variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
{E : Type*} [normed_group E] [normed_space ğ•œ E]
{H : Type*} [topological_space H] (I : model_with_corners ğ•œ E H)
(M : Type*) [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]
def tangent_bundle_core : basic_smooth_vector_bundle_core I M E :=
{ coord_change := Î» i j x, (fderiv_within ğ•œ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm) (range I) (I x)),
  coord_change_smooth_clm := Î» i j,
  begin
    rw I.image_eq,
    have A : cont_diff_on ğ•œ âˆ
      (I âˆ˜ (i.1.symm.trans j.1) âˆ˜ I.symm)
      (I.symm â»Â¹' (i.1.symm.trans j.1).source âˆ© range I) :=
      (has_groupoid.compatible (cont_diff_groupoid âˆ I) i.2 j.2).1,
    have B : unique_diff_on ğ•œ (I.symm â»Â¹' (i.1.symm.trans j.1).source âˆ© range I) :=
      I.unique_diff_preimage_source,
    have C : cont_diff_on ğ•œ âˆ
      (Î» (p : E Ã— E), (fderiv_within ğ•œ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm)
            (I.symm â»Â¹' (i.1.symm.trans j.1).source âˆ© range I) p.1 : E â†’ E) p.2)
      ((I.symm â»Â¹' (i.1.symm.trans j.1).source âˆ© range I) Ã—Ë¢ (univ : set E)) :=
      cont_diff_on_fderiv_within_apply A B le_top,
    have D : âˆ€ x âˆˆ (I.symm â»Â¹' (i.1.symm.trans j.1).source âˆ© range I),
      fderiv_within ğ•œ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm)
            (range I) x =
      fderiv_within ğ•œ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm)
            (I.symm â»Â¹' (i.1.symm.trans j.1).source âˆ© range I) x,
    { assume x hx,
      have N : I.symm â»Â¹' (i.1.symm.trans j.1).source âˆˆ nhds x :=
        I.continuous_symm.continuous_at.preimage_mem_nhds
          (is_open.mem_nhds (local_homeomorph.open_source _) hx.1),
      symmetry,
      rw inter_comm,
      exact fderiv_within_inter N (I.unique_diff _ hx.2) },
    apply (A.fderiv_within B le_top).congr,
    assume x hx,
    simp only with mfld_simps at hx,
    simp only [hx, D] with mfld_simps,
  end,
  coord_change_self := Î» i x hx v, begin
    have A : I.symm â»Â¹' (i.1.symm.trans i.1).source âˆ© range I âˆˆ ğ“[range I] (I x),
    { rw inter_comm,
      apply inter_mem_nhds_within,
      apply I.continuous_symm.continuous_at.preimage_mem_nhds
        (is_open.mem_nhds (local_homeomorph.open_source _) _),
      simp only [hx, i.1.map_target] with mfld_simps },
    have B : âˆ€á¶  y in ğ“[range I] (I x),
      (I âˆ˜ i.1 âˆ˜ i.1.symm âˆ˜ I.symm) y = (id : E â†’ E) y,
    { filter_upwards [A] with _ hy,
      rw â† I.image_eq at hy,
      rcases hy with âŸ¨z, hzâŸ©,
      simp only with mfld_simps at hz,
      simp only [hz.2.symm, hz.1] with mfld_simps, },
    have C : fderiv_within ğ•œ (I âˆ˜ i.1 âˆ˜ i.1.symm âˆ˜ I.symm) (range I) (I x) =
             fderiv_within ğ•œ (id : E â†’ E) (range I) (I x) :=
      filter.eventually_eq.fderiv_within_eq I.unique_diff_at_image B
      (by simp only [hx] with mfld_simps),
    rw fderiv_within_id I.unique_diff_at_image at C,
    rw C,
    refl
  end,
  coord_change_comp := Î» i j u x hx, begin
    have M : I x âˆˆ
      (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I) :=
    âŸ¨by simpa only [mem_preimage, model_with_corners.left_inv] using hx, mem_range_self _âŸ©,
    have U : unique_diff_within_at ğ•œ
      (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I) (I x) :=
      I.unique_diff_preimage_source _ M,
    have A : fderiv_within ğ•œ ((I âˆ˜ u.1 âˆ˜ j.1.symm âˆ˜ I.symm) âˆ˜ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm))
             (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I)
             (I x)
      = (fderiv_within ğ•œ (I âˆ˜ u.1 âˆ˜ j.1.symm âˆ˜ I.symm)
             (I.symm â»Â¹' (j.1.symm.trans u.1).source âˆ© range I)
             ((I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm) (I x))).comp
        (fderiv_within ğ•œ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm)
             (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I)
             (I x)),
    { apply fderiv_within.comp _ _ _ _ U,
      show differentiable_within_at ğ•œ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm)
        (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I)
        (I x),
      { have A : cont_diff_on ğ•œ âˆ
          (I âˆ˜ (i.1.symm.trans j.1) âˆ˜ I.symm)
          (I.symm â»Â¹' (i.1.symm.trans j.1).source âˆ© range I) :=
        (has_groupoid.compatible (cont_diff_groupoid âˆ I) i.2 j.2).1,
        have B : differentiable_on ğ•œ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm)
          (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I),
        { apply (A.differentiable_on le_top).mono,
          have : ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âŠ†
            (i.1.symm.trans j.1).source := inter_subset_left _ _,
          exact inter_subset_inter (preimage_mono this) (subset.refl (range I)) },
        apply B,
        simpa only [] with mfld_simps using hx },
      show differentiable_within_at ğ•œ (I âˆ˜ u.1 âˆ˜ j.1.symm âˆ˜ I.symm)
        (I.symm â»Â¹' (j.1.symm.trans u.1).source âˆ© range I)
        ((I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm) (I x)),
      { have A : cont_diff_on ğ•œ âˆ
          (I âˆ˜ (j.1.symm.trans u.1) âˆ˜ I.symm)
          (I.symm â»Â¹' (j.1.symm.trans u.1).source âˆ© range I) :=
        (has_groupoid.compatible (cont_diff_groupoid âˆ I) j.2 u.2).1,
        apply A.differentiable_on le_top,
        rw [local_homeomorph.trans_source] at hx,
        simp only with mfld_simps,
        exact hx.2 },
      show (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I)
        âŠ† (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm) â»Â¹' (I.symm â»Â¹' (j.1.symm.trans u.1).source âˆ© range I),
      { assume y hy,
        simp only with mfld_simps at hy,
        rw [local_homeomorph.left_inv] at hy,
        { simp only [hy] with mfld_simps },
        { exact hy.1.1.2 } } },
    have B : fderiv_within ğ•œ ((I âˆ˜ u.1 âˆ˜ j.1.symm âˆ˜ I.symm)
                          âˆ˜ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm))
             (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I)
             (I x)
             = fderiv_within ğ•œ (I âˆ˜ u.1 âˆ˜ i.1.symm âˆ˜ I.symm)
             (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I)
             (I x),
    { have E :
        âˆ€ y âˆˆ (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I),
          ((I âˆ˜ u.1 âˆ˜ j.1.symm âˆ˜ I.symm) âˆ˜ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm)) y =
            (I âˆ˜ u.1 âˆ˜ i.1.symm âˆ˜ I.symm) y,
      { assume y hy,
        simp only [function.comp_app, model_with_corners.left_inv],
        rw [j.1.left_inv],
        exact hy.1.1.2 },
      exact fderiv_within_congr U E (E _ M) },
    have C : fderiv_within ğ•œ (I âˆ˜ u.1 âˆ˜ i.1.symm âˆ˜ I.symm)
             (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I)
             (I x) =
             fderiv_within ğ•œ (I âˆ˜ u.1 âˆ˜ i.1.symm âˆ˜ I.symm)
             (range I) (I x),
    { rw inter_comm,
      apply fderiv_within_inter _ I.unique_diff_at_image,
      apply I.continuous_symm.continuous_at.preimage_mem_nhds
        (is_open.mem_nhds (local_homeomorph.open_source _) _),
      simpa only [model_with_corners.left_inv] using hx },
    have D : fderiv_within ğ•œ (I âˆ˜ u.1 âˆ˜ j.1.symm âˆ˜ I.symm)
      (I.symm â»Â¹' (j.1.symm.trans u.1).source âˆ© range I) ((I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm) (I x)) =
      fderiv_within ğ•œ (I âˆ˜ u.1 âˆ˜ j.1.symm âˆ˜ I.symm) (range I) ((I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm) (I x)),
    { rw inter_comm,
      apply fderiv_within_inter _ I.unique_diff_at_image,
      apply I.continuous_symm.continuous_at.preimage_mem_nhds
        (is_open.mem_nhds (local_homeomorph.open_source _) _),
      rw [local_homeomorph.trans_source] at hx,
      simp only with mfld_simps,
      exact hx.2 },
    have E : fderiv_within ğ•œ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm)
               (I.symm â»Â¹' ((i.1.symm.trans j.1).trans (j.1.symm.trans u.1)).source âˆ© range I)
               (I x) =
             fderiv_within ğ•œ (I âˆ˜ j.1 âˆ˜ i.1.symm âˆ˜ I.symm) (range I) (I x),
    { rw inter_comm,
      apply fderiv_within_inter _ I.unique_diff_at_image,
      apply I.continuous_symm.continuous_at.preimage_mem_nhds
        (is_open.mem_nhds (local_homeomorph.open_source _) _),
      simpa only [model_with_corners.left_inv] using hx },
    rw [B, C, D, E] at A,
    simp only [A, continuous_linear_map.coe_comp'] with mfld_simps,
  end }
variable {M}
include I
@[nolint unused_arguments]
def tangent_space (x : M) : Type* := E
omit I
variable (M)
def tangent_bundle.proj : TM â†’ M :=
Î» p, p.1
variable {M}
@[simp, mfld_simps] lemma tangent_bundle.proj_apply (x : M) (v : tangent_space I x) :
  tangent_bundle.proj I M âŸ¨x, vâŸ© = x :=
rfl
section tangent_bundle_instances
section
local attribute [reducible] tangent_space
variables {M} (x : M)
instance : topological_space (tangent_space I x) := by apply_instance
instance : add_comm_group (tangent_space I x) := by apply_instance
instance : topological_add_group (tangent_space I x) := by apply_instance
instance : module ğ•œ (tangent_space I x) := by apply_instance
instance : inhabited (tangent_space I x) := âŸ¨0âŸ©
end
variable (M)
instance : topological_space TM :=
(tangent_bundle_core I M).to_topological_vector_bundle_core.to_topological_space (atlas H M)
instance : charted_space (model_prod H E) TM :=
(tangent_bundle_core I M).to_charted_space
instance : smooth_manifold_with_corners I.tangent TM :=
(tangent_bundle_core I M).to_smooth_manifold
instance : topological_vector_bundle ğ•œ E (tangent_space I : M â†’ Type*) :=
topological_vector_bundle_core.fiber.topological_vector_bundle
  (tangent_bundle_core I M).to_topological_vector_bundle_core
end tangent_bundle_instances
variable (M)
lemma tangent_bundle_proj_continuous : continuous (tangent_bundle.proj I M) :=
((tangent_bundle_core I M).to_topological_vector_bundle_core).continuous_proj
lemma tangent_bundle_proj_open : is_open_map (tangent_bundle.proj I M) :=
((tangent_bundle_core I M).to_topological_vector_bundle_core).is_open_map_proj
@[simp, mfld_simps] lemma tangent_bundle_model_space_chart_at (p : tangent_bundle I H) :
  (chart_at (model_prod H E) p).to_local_equiv = (equiv.sigma_equiv_prod H E).to_local_equiv :=
begin
  have A : âˆ€ x_fst, fderiv_within ğ•œ (I âˆ˜ I.symm) (range I) (I x_fst) = continuous_linear_map.id ğ•œ E,
  { assume x_fst,
    have : fderiv_within ğ•œ (I âˆ˜ I.symm) (range I) (I x_fst)
         = fderiv_within ğ•œ id (range I) (I x_fst),
    { refine fderiv_within_congr I.unique_diff_at_image (Î» y hy, _) (by simp),
      exact model_with_corners.right_inv _ hy },
    rwa fderiv_within_id I.unique_diff_at_image at this },
  ext x : 1,
  show (chart_at (model_prod H E) p : tangent_bundle I H â†’ model_prod H E) x =
    (equiv.sigma_equiv_prod H E) x,
  { cases x,
    simp only [chart_at, basic_smooth_vector_bundle_core.chart, tangent_bundle_core,
      basic_smooth_vector_bundle_core.to_topological_vector_bundle_core, A, prod.mk.inj_iff,
      continuous_linear_map.coe_id'] with mfld_simps,
      exact (tangent_bundle_core I H).coord_change_self _ _ trivial x_snd, },
  show âˆ€ x, ((chart_at (model_prod H E) p).to_local_equiv).symm x =
    (equiv.sigma_equiv_prod H E).symm x,
  { rintros âŸ¨x_fst, x_sndâŸ©,
    simp only [basic_smooth_vector_bundle_core.to_topological_vector_bundle_core,
      tangent_bundle_core, A, continuous_linear_map.coe_id', basic_smooth_vector_bundle_core.chart,
      chart_at, continuous_linear_map.coe_coe, sigma.mk.inj_iff] with mfld_simps, },
  show ((chart_at (model_prod H E) p).to_local_equiv).source = univ,
    by simp only [chart_at] with mfld_simps,
end
@[simp, mfld_simps] lemma tangent_bundle_model_space_coe_chart_at (p : tangent_bundle I H) :
  â‡‘(chart_at (model_prod H E) p) = equiv.sigma_equiv_prod H E :=
by { unfold_coes, simp only with mfld_simps }
@[simp, mfld_simps] lemma tangent_bundle_model_space_coe_chart_at_symm (p : tangent_bundle I H) :
  ((chart_at (model_prod H E) p).symm : model_prod H E â†’ tangent_bundle I H) =
  (equiv.sigma_equiv_prod H E).symm :=
by { unfold_coes, simp only with mfld_simps }
variable (H)
def tangent_bundle_model_space_homeomorph : tangent_bundle I H â‰ƒâ‚œ model_prod H E :=
{ continuous_to_fun :=
  begin
    let p : tangent_bundle I H := âŸ¨I.symm (0 : E), (0 : E)âŸ©,
    have : continuous (chart_at (model_prod H E) p),
    { rw continuous_iff_continuous_on_univ,
      convert local_homeomorph.continuous_on _,
      simp only with mfld_simps },
    simpa only with mfld_simps using this,
  end,
  continuous_inv_fun :=
  begin
    let p : tangent_bundle I H := âŸ¨I.symm (0 : E), (0 : E)âŸ©,
    have : continuous (chart_at (model_prod H E) p).symm,
    { rw continuous_iff_continuous_on_univ,
      convert local_homeomorph.continuous_on _,
      simp only with mfld_simps },
    simpa only with mfld_simps using this,
  end,
  .. equiv.sigma_equiv_prod H E }
@[simp, mfld_simps] lemma tangent_bundle_model_space_homeomorph_coe :
  (tangent_bundle_model_space_homeomorph H I : tangent_bundle I H â†’ model_prod H E)
  = equiv.sigma_equiv_prod H E :=
rfl
@[simp, mfld_simps] lemma tangent_bundle_model_space_homeomorph_coe_symm :
  ((tangent_bundle_model_space_homeomorph H I).symm : model_prod H E â†’ tangent_bundle I H)
  = (equiv.sigma_equiv_prod H E).symm :=
rfl
end tangent_bundle
