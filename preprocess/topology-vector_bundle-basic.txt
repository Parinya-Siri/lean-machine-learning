import analysis.normed_space.bounded_linear_maps
import topology.fiber_bundle
noncomputable theory
open bundle set
open_locale classical
variables (R ùïú : Type*) {B : Type*} (F : Type*) (E : B ‚Üí Type*)
section topological_vector_space
variables [semiring R] [‚àÄ x, add_comm_monoid (E x)] [‚àÄ x, module R (E x)]
  [topological_space F] [add_comm_monoid F] [module R F] [topological_space B]
@[nolint has_inhabited_instance]
structure topological_vector_bundle.pretrivialization extends to_fiber_bundle_pretrivialization :
  topological_fiber_bundle.pretrivialization F (@total_space.proj B E) :=
(linear' : ‚àÄ x ‚àà base_set, is_linear_map R (Œª y : E x, (to_fun (total_space_mk x y)).2))
instance : has_coe_to_fun (topological_vector_bundle.pretrivialization R F E) _ := ‚ü®Œª e, e.to_fun‚ü©
instance : has_coe (topological_vector_bundle.pretrivialization R F E)
  (topological_fiber_bundle.pretrivialization F (@total_space.proj B E)) :=
‚ü®topological_vector_bundle.pretrivialization.to_fiber_bundle_pretrivialization‚ü©
namespace topological_vector_bundle.pretrivialization
open topological_vector_bundle
variables {R F E} (e : pretrivialization R F E) {x : total_space E} {b : B} {y : E b}
protected lemma linear (hb : b ‚àà e.base_set) :
  is_linear_map R (Œª y : E b, (e (total_space_mk b y)).2) :=
e.linear' b hb
@[simp, mfld_simps] lemma coe_coe : ‚áëe.to_local_equiv = e := rfl
@[simp, mfld_simps] lemma coe_fst (ex : x ‚àà e.source) : (e x).1 = x.proj := e.proj_to_fun x ex
lemma mem_source : x ‚àà e.source ‚Üî x.proj ‚àà e.base_set := by rw [e.source_eq, mem_preimage]
lemma coe_mem_source : ‚Üëy ‚àà e.source ‚Üî b ‚àà e.base_set := e.mem_source
lemma coe_fst' (ex : x.proj ‚àà e.base_set) : (e x).1 = x.proj :=
e.coe_fst (e.mem_source.2 ex)
protected lemma eq_on : eq_on (prod.fst ‚àò e) total_space.proj e.source := Œª x hx, e.coe_fst hx
lemma mk_proj_snd (ex : x ‚àà e.source) : (x.proj, (e x).2) = e x :=
prod.ext (e.coe_fst ex).symm rfl
@[simp, mfld_simps] lemma coe_coe_fst (hb : b ‚àà e.base_set) : (e y).1 = b :=
e.coe_fst (e.mem_source.2 hb)
lemma mk_proj_snd' (ex : x.proj ‚àà e.base_set) : (x.proj, (e x).2) = e x :=
prod.ext (e.coe_fst' ex).symm rfl
lemma mem_target {x : B √ó F} : x ‚àà e.target ‚Üî x.1 ‚àà e.base_set :=
e.to_fiber_bundle_pretrivialization.mem_target
lemma mk_mem_target {x : B} {y : F} : (x, y) ‚àà e.target ‚Üî x ‚àà e.base_set :=
e.mem_target
lemma proj_symm_apply {x : B √ó F} (hx : x ‚àà e.target) : (e.to_local_equiv.symm x).proj = x.1 :=
e.to_fiber_bundle_pretrivialization.proj_symm_apply hx
lemma proj_symm_apply' {b : B} {x : F} (hx : b ‚àà e.base_set) :
  (e.to_local_equiv.symm (b, x)).proj = b :=
e.proj_symm_apply (e.mem_target.2 hx)
lemma apply_symm_apply {x : B √ó F} (hx : x ‚àà e.target) : e (e.to_local_equiv.symm x) = x :=
e.to_local_equiv.right_inv hx
lemma symm_apply_apply {x : total_space E} (hx : x ‚àà e.source) : e.to_local_equiv.symm (e x) = x :=
e.to_local_equiv.left_inv hx
lemma apply_symm_apply' {b : B} {x : F} (hx : b ‚àà e.base_set) :
  e (e.to_local_equiv.symm (b, x)) = (b, x) :=
e.apply_symm_apply (e.mem_target.2 hx)
@[simp, mfld_simps] lemma symm_apply_mk_proj (ex : x ‚àà e.source) :
  e.to_local_equiv.symm (x.proj, (e x).2) = x :=
by rw [‚Üê e.coe_fst ex, prod.mk.eta, ‚Üê e.coe_coe, e.to_local_equiv.left_inv ex]
@[simp, mfld_simps] lemma preimage_symm_proj_base_set :
  (e.to_local_equiv.symm ‚Åª¬π' (total_space.proj ‚Åª¬π' e.base_set)) ‚à© e.target  = e.target :=
e.to_fiber_bundle_pretrivialization.preimage_symm_proj_base_set
lemma symm_coe_proj {x : B} {y : F} (e : pretrivialization R F E) (h : x ‚àà e.base_set) :
  (e.to_local_equiv.symm (x, y)).1 = x :=
e.proj_symm_apply' h
protected def symm (e : pretrivialization R F E) (b : B) (y : F) : E b :=
if hb : b ‚àà e.base_set
then cast (congr_arg E (e.proj_symm_apply' hb)) (e.to_local_equiv.symm (b, y)).2
else 0
lemma symm_apply (e : pretrivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : F) :
  e.symm b y = cast (congr_arg E (e.symm_coe_proj hb)) (e.to_local_equiv.symm (b, y)).2 :=
dif_pos hb
lemma symm_apply_of_not_mem (e : pretrivialization R F E) {b : B} (hb : b ‚àâ e.base_set) (y : F) :
  e.symm b y = 0 :=
dif_neg hb
lemma coe_symm_of_not_mem (e : pretrivialization R F E) {b : B} (hb : b ‚àâ e.base_set) :
  (e.symm b : F ‚Üí E b) = 0 :=
funext $ Œª y, dif_neg hb
lemma mk_symm (e : pretrivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : F) :
  total_space_mk b (e.symm b y) = e.to_local_equiv.symm (b, y) :=
by rw [e.symm_apply hb, total_space.mk_cast, total_space.eta]
lemma symm_proj_apply (e : pretrivialization R F E) (z : total_space E)
  (hz : z.proj ‚àà e.base_set) : e.symm z.proj (e z).2 = z.2 :=
by rw [e.symm_apply hz, cast_eq_iff_heq, e.mk_proj_snd' hz,
  e.symm_apply_apply (e.mem_source.mpr hz)]
lemma symm_apply_apply_mk (e : pretrivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : E b) :
  e.symm b (e (total_space_mk b y)).2 = y :=
e.symm_proj_apply (total_space_mk b y) hb
lemma apply_mk_symm (e : pretrivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : F) :
  e (total_space_mk b (e.symm b y)) = (b, y) :=
by rw [e.mk_symm hb, e.apply_symm_apply (e.mk_mem_target.mpr hb)]
@[simps] protected def symm‚Çó (e : pretrivialization R F E) (b : B) : F ‚Üí‚Çó[R] E b :=
begin
  refine is_linear_map.mk' (e.symm b) _,
  by_cases hb : b ‚àà e.base_set,
  { exact (((e.linear hb).mk' _).inverse (e.symm b) (e.symm_apply_apply_mk hb)
      (Œª v, congr_arg prod.snd $ e.apply_mk_symm hb v)).is_linear },
  { rw [e.coe_symm_of_not_mem hb], exact (0 : F ‚Üí‚Çó[R] E b).is_linear }
end
@[simps {fully_applied := ff}] def linear_equiv_at (e : pretrivialization R F E) (b : B)
  (hb : b ‚àà e.base_set) :
  E b ‚âÉ‚Çó[R] F :=
{ to_fun := Œª y, (e (total_space_mk b y)).2,
  inv_fun := e.symm b,
  left_inv := e.symm_apply_apply_mk hb,
  right_inv := Œª v, by simp_rw [e.apply_mk_symm hb v],
  map_add' := Œª v w, (e.linear hb).map_add v w,
  map_smul' := Œª c v, (e.linear hb).map_smul c v }
protected def linear_map_at (e : pretrivialization R F E) (b : B) : E b ‚Üí‚Çó[R] F :=
if hb : b ‚àà e.base_set then e.linear_equiv_at b hb else 0
lemma coe_linear_map_at (e : pretrivialization R F E) (b : B) :
  ‚áë(e.linear_map_at b) = Œª y, if b ‚àà e.base_set then (e (total_space_mk b y)).2 else 0 :=
by { rw [pretrivialization.linear_map_at], split_ifs; refl }
lemma coe_linear_map_at_of_mem (e : pretrivialization R F E) {b : B} (hb : b ‚àà e.base_set) :
  ‚áë(e.linear_map_at b) = Œª y, (e (total_space_mk b y)).2 :=
by simp_rw [coe_linear_map_at, if_pos hb]
lemma linear_map_at_apply (e : pretrivialization R F E) {b : B} (y : E b) :
  e.linear_map_at b y = if b ‚àà e.base_set then (e (total_space_mk b y)).2 else 0 :=
by rw [coe_linear_map_at]
lemma linear_map_at_def_of_mem (e : pretrivialization R F E) {b : B} (hb : b ‚àà e.base_set) :
  e.linear_map_at b = e.linear_equiv_at b hb :=
dif_pos hb
lemma linear_map_at_def_of_not_mem (e : pretrivialization R F E) {b : B} (hb : b ‚àâ e.base_set) :
  e.linear_map_at b = 0 :=
dif_neg hb
lemma linear_map_at_eq_zero (e : pretrivialization R F E) {b : B} (hb : b ‚àâ e.base_set) :
  e.linear_map_at b = 0 :=
dif_neg hb
lemma symm‚Çó_linear_map_at (e : pretrivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : E b) :
  e.symm‚Çó b (e.linear_map_at b y) = y :=
by { rw [e.linear_map_at_def_of_mem hb], exact (e.linear_equiv_at b hb).left_inv y }
lemma linear_map_at_symm‚Çó (e : pretrivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : F) :
  e.linear_map_at b (e.symm‚Çó b y) = y :=
by { rw [e.linear_map_at_def_of_mem hb], exact (e.linear_equiv_at b hb).right_inv y }
end topological_vector_bundle.pretrivialization
variable [topological_space (total_space E)]
@[nolint has_inhabited_instance]
structure topological_vector_bundle.trivialization extends to_fiber_bundle_trivialization :
  topological_fiber_bundle.trivialization F (@total_space.proj B E) :=
(linear' : ‚àÄ x ‚àà base_set, is_linear_map R (Œª y : E x, (to_fun (total_space_mk x y)).2))
open topological_vector_bundle
instance : has_coe_to_fun (trivialization R F E) (Œª _, total_space E ‚Üí B √ó F) := ‚ü®Œª e, e.to_fun‚ü©
instance : has_coe (trivialization R F E)
  (topological_fiber_bundle.trivialization F (@total_space.proj B E)) :=
‚ü®topological_vector_bundle.trivialization.to_fiber_bundle_trivialization‚ü©
namespace topological_vector_bundle.trivialization
variables {R F E} (e : trivialization R F E) {x : total_space E} {b : B} {y : E b}
def to_pretrivialization (e : trivialization R F E) :
  topological_vector_bundle.pretrivialization R F E := { ..e }
protected lemma linear (hb : b ‚àà e.base_set) :
  is_linear_map R (Œª y : E b, (e (total_space_mk b y)).2) :=
e.linear' b hb
protected lemma continuous_on : continuous_on e e.source := e.continuous_to_fun
@[simp, mfld_simps] lemma coe_coe : ‚áëe.to_local_homeomorph = e := rfl
@[simp, mfld_simps] lemma coe_fst (ex : x ‚àà e.source) : (e x).1 = x.proj := e.proj_to_fun x ex
lemma mem_source : x ‚àà e.source ‚Üî x.proj ‚àà e.base_set := by rw [e.source_eq, mem_preimage]
lemma coe_mem_source : ‚Üëy ‚àà e.source ‚Üî b ‚àà e.base_set := e.mem_source
lemma coe_fst' (ex : x.proj ‚àà e.base_set) : (e x).1 = x.proj :=
e.coe_fst (e.mem_source.2 ex)
protected lemma eq_on : eq_on (prod.fst ‚àò e) total_space.proj e.source := Œª x hx, e.coe_fst hx
lemma mk_proj_snd (ex : x ‚àà e.source) : (x.proj, (e x).2) = e x :=
prod.ext (e.coe_fst ex).symm rfl
lemma mk_proj_snd' (ex : x.proj ‚àà e.base_set) : (x.proj, (e x).2) = e x :=
prod.ext (e.coe_fst' ex).symm rfl
lemma open_target : is_open e.target :=
by { rw e.target_eq, exact e.open_base_set.prod is_open_univ }
@[simp, mfld_simps] lemma coe_coe_fst (hb : b ‚àà e.base_set) : (e y).1 = b :=
e.coe_fst (e.mem_source.2 hb)
lemma source_inter_preimage_target_inter (s : set (B √ó F)) :
  e.source ‚à© (e ‚Åª¬π' (e.target ‚à© s)) = e.source ‚à© (e ‚Åª¬π' s) :=
e.to_local_homeomorph.source_inter_preimage_target_inter s
lemma mem_target {x : B √ó F} : x ‚àà e.target ‚Üî x.1 ‚àà e.base_set :=
e.to_pretrivialization.mem_target
lemma mk_mem_target {y : F} : (b, y) ‚àà e.target ‚Üî b ‚àà e.base_set :=
e.to_pretrivialization.mem_target
lemma map_target {x : B √ó F} (hx : x ‚àà e.target) : e.to_local_homeomorph.symm x ‚àà e.source :=
e.to_local_homeomorph.map_target hx
lemma proj_symm_apply {x : B √ó F} (hx : x ‚àà e.target) :
  (e.to_local_homeomorph.symm x).proj = x.1 :=
e.to_pretrivialization.proj_symm_apply hx
lemma proj_symm_apply' {b : B} {x : F} (hx : b ‚àà e.base_set) :
  (e.to_local_homeomorph.symm (b, x)).proj  = b :=
e.to_pretrivialization.proj_symm_apply' hx
lemma apply_symm_apply {x : B √ó F} (hx : x ‚àà e.target) : e (e.to_local_homeomorph.symm x) = x :=
e.to_local_homeomorph.right_inv hx
lemma apply_symm_apply' {b : B} {x : F} (hx : b ‚àà e.base_set) :
  e (e.to_local_homeomorph.symm (b, x)) = (b, x) :=
e.to_pretrivialization.apply_symm_apply' hx
lemma symm_apply_apply {x : total_space E} (hx : x ‚àà e.source) :
  e.to_local_homeomorph.symm (e x) = x :=
e.to_local_equiv.left_inv hx
@[simp, mfld_simps] lemma symm_coe_proj {x : B} {y : F}
  (e : trivialization R F E) (h : x ‚àà e.base_set) :
  (e.to_local_homeomorph.symm (x, y)).1 = x := e.proj_symm_apply' h
protected def symm (e : trivialization R F E) (b : B) (y : F) : E b :=
e.to_pretrivialization.symm b y
lemma symm_apply (e : trivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : F) :
  e.symm b y = cast (congr_arg E (e.symm_coe_proj hb)) (e.to_local_homeomorph.symm (b, y)).2 :=
dif_pos hb
lemma symm_apply_of_not_mem (e : trivialization R F E) {b : B} (hb : b ‚àâ e.base_set) (y : F) :
  e.symm b y = 0 :=
dif_neg hb
lemma mk_symm (e : trivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : F) :
  total_space_mk b (e.symm b y) = e.to_local_homeomorph.symm (b, y) :=
e.to_pretrivialization.mk_symm hb y
lemma symm_proj_apply (e : trivialization R F E) (z : total_space E)
  (hz : z.proj ‚àà e.base_set) : e.symm z.proj (e z).2 = z.2 :=
e.to_pretrivialization.symm_proj_apply z hz
lemma symm_apply_apply_mk (e : trivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : E b) :
  e.symm b (e (total_space_mk b y)).2 = y :=
e.symm_proj_apply (total_space_mk b y) hb
lemma apply_mk_symm (e : trivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : F) :
  e (total_space_mk b (e.symm b y)) = (b, y) :=
e.to_pretrivialization.apply_mk_symm hb y
lemma continuous_on_symm (e : trivialization R F E) :
  continuous_on (Œª z : B √ó F, total_space_mk z.1 (e.symm z.1 z.2))
    (e.base_set √óÀ¢ (univ : set F)) :=
begin
  have : ‚àÄ (z : B √ó F) (hz : z ‚àà e.base_set √óÀ¢ (univ : set F)),
    total_space_mk z.1 (e.symm z.1 z.2) = e.to_local_homeomorph.symm z,
  { rintro x ‚ü®hx : x.1 ‚àà e.base_set, _‚ü©, simp_rw [e.mk_symm hx, prod.mk.eta] },
  refine continuous_on.congr _ this,
  rw [‚Üê e.target_eq],
  exact e.to_local_homeomorph.continuous_on_symm
end
def linear_equiv_at (e : trivialization R F E) (b : B) (hb : b ‚àà e.base_set) :
  E b ‚âÉ‚Çó[R] F :=
e.to_pretrivialization.linear_equiv_at b hb
@[simp]
lemma linear_equiv_at_apply (e : trivialization R F E) (b : B) (hb : b ‚àà e.base_set) (v : E b) :
  e.linear_equiv_at b hb v = (e (total_space_mk b v)).2 := rfl
@[simp]
lemma linear_equiv_at_symm_apply (e : trivialization R F E) (b : B) (hb : b ‚àà e.base_set) (v : F) :
  (e.linear_equiv_at b hb).symm v = e.symm b v := rfl
protected def symm‚Çó (e : trivialization R F E) (b : B) : F ‚Üí‚Çó[R] E b :=
e.to_pretrivialization.symm‚Çó b
lemma coe_symm‚Çó (e : trivialization R F E) (b : B) : ‚áë(e.symm‚Çó b) = e.symm b :=
rfl
protected def linear_map_at (e : trivialization R F E) (b : B) : E b ‚Üí‚Çó[R] F :=
e.to_pretrivialization.linear_map_at b
lemma coe_linear_map_at (e : trivialization R F E) (b : B) :
  ‚áë(e.linear_map_at b) = Œª y, if b ‚àà e.base_set then (e (total_space_mk b y)).2 else 0 :=
e.to_pretrivialization.coe_linear_map_at b
lemma coe_linear_map_at_of_mem (e : trivialization R F E) {b : B} (hb : b ‚àà e.base_set) :
  ‚áë(e.linear_map_at b) = Œª y, (e (total_space_mk b y)).2 :=
by simp_rw [coe_linear_map_at, if_pos hb]
lemma linear_map_at_apply (e : trivialization R F E) {b : B} (y : E b) :
  e.linear_map_at b y = if b ‚àà e.base_set then (e (total_space_mk b y)).2 else 0 :=
by rw [coe_linear_map_at]
lemma linear_map_at_def_of_mem (e : trivialization R F E) {b : B} (hb : b ‚àà e.base_set) :
  e.linear_map_at b = e.linear_equiv_at b hb :=
dif_pos hb
lemma linear_map_at_def_of_not_mem (e : trivialization R F E) {b : B} (hb : b ‚àâ e.base_set) :
  e.linear_map_at b = 0 :=
dif_neg hb
lemma symm‚Çó_linear_map_at (e : trivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : E b) :
  e.symm‚Çó b (e.linear_map_at b y) = y :=
e.to_pretrivialization.symm‚Çó_linear_map_at hb y
lemma linear_map_at_symm‚Çó (e : trivialization R F E) {b : B} (hb : b ‚àà e.base_set) (y : F) :
  e.linear_map_at b (e.symm‚Çó b y) = y :=
e.to_pretrivialization.linear_map_at_symm‚Çó hb y
def coord_change (e e' : trivialization R F E) (b : B) : F ‚âÉL[R] F :=
{ continuous_to_fun := begin
    by_cases hb : b ‚àà e.base_set ‚à© e'.base_set,
    { simp_rw [dif_pos hb],
      refine (e'.continuous_on.comp_continuous _ _).snd,
      exact e.continuous_on_symm.comp_continuous (continuous.prod.mk b)
        (Œª y, mk_mem_prod hb.1 (mem_univ y)),
      exact (Œª y, e'.mem_source.mpr hb.2) },
    { rw [dif_neg hb], exact continuous_id }
  end,
  continuous_inv_fun := begin
    by_cases hb : b ‚àà e.base_set ‚à© e'.base_set,
    { simp_rw [dif_pos hb],
      refine (e.continuous_on.comp_continuous _ _).snd,
      exact e'.continuous_on_symm.comp_continuous (continuous.prod.mk b)
        (Œª y, mk_mem_prod hb.2 (mem_univ y)),
      exact (Œª y, e.mem_source.mpr hb.1) },
    { rw [dif_neg hb], exact continuous_id }
  end,
  .. if hb : b ‚àà e.base_set ‚à© e'.base_set then
     (e.linear_equiv_at b (hb.1 : _)).symm.trans (e'.linear_equiv_at b hb.2)
    else linear_equiv.refl R F }
lemma coe_coord_change (e e' : trivialization R F E) {b : B}
  (hb : b ‚àà e.base_set ‚à© e'.base_set) :
  ‚áë(coord_change e e' b) = (e.linear_equiv_at b hb.1).symm.trans (e'.linear_equiv_at b hb.2) :=
congr_arg linear_equiv.to_fun (dif_pos hb)
lemma coord_change_apply (e e' : trivialization R F E) {b : B}
  (hb : b ‚àà e.base_set ‚à© e'.base_set) (y : F) :
  coord_change e e' b y = (e' (total_space_mk b (e.symm b y))).2 :=
congr_arg (Œª f, linear_equiv.to_fun f y) (dif_pos hb)
lemma mk_coord_change (e e' : trivialization R F E) {b : B}
  (hb : b ‚àà e.base_set ‚à© e'.base_set) (y : F) :
  (b, coord_change e e' b y) = e' (total_space_mk b (e.symm b y)) :=
begin
  ext,
  { rw [e.mk_symm hb.1 y, e'.coe_fst', e.proj_symm_apply' hb.1],
    rw [e.proj_symm_apply' hb.1], exact hb.2 },
  { exact e.coord_change_apply e' hb y }
end
lemma coord_change_apply' (e e' : trivialization R F E) {b : B}
  (hb : b ‚àà e.base_set ‚à© e'.base_set) (y : F) :
  coord_change e e' b y = (e' (e.to_local_homeomorph.symm (b, y))).2 :=
by rw [e.coord_change_apply e' hb, e.mk_symm hb.1]
lemma coord_change_symm_apply (e e' : trivialization R F E) {b : B}
  (hb : b ‚àà e.base_set ‚à© e'.base_set) :
  ‚áë(coord_change e e' b).symm = (e'.linear_equiv_at b hb.2).symm.trans (e.linear_equiv_at b hb.1) :=
congr_arg linear_equiv.inv_fun (dif_pos hb)
end topological_vector_bundle.trivialization
end topological_vector_space
section
open topological_vector_bundle
variables (B)
variables [nondiscrete_normed_field R] [‚àÄ x, add_comm_monoid (E x)] [‚àÄ x, module R (E x)]
  [normed_group F] [normed_space R F] [topological_space B]
  [topological_space (total_space E)] [‚àÄ x, topological_space (E x)]
def continuous_transitions (e : local_equiv (B √ó F) (B √ó F)) : Prop :=
‚àÉ s : set B, e.source = s √óÀ¢ (univ : set F) ‚àß e.target = s √óÀ¢ (univ : set F)
    ‚àß ‚àÉ Œµ : B ‚Üí (F ‚âÉL[R] F), continuous_on (Œª b, (Œµ b : F ‚ÜíL[R] F)) s
      ‚àß ‚àÄ b ‚àà s, ‚àÄ v : F, e (b, v) = (b, Œµ b v)
variables {B}
class topological_vector_bundle :=
(total_space_mk_inducing [] : ‚àÄ (b : B), inducing (@total_space_mk B E b))
(trivialization_atlas [] : set (trivialization R F E))
(trivialization_at [] : B ‚Üí trivialization R F E)
(mem_base_set_trivialization_at [] : ‚àÄ b : B, b ‚àà (trivialization_at b).base_set)
(trivialization_mem_atlas [] : ‚àÄ b : B, trivialization_at b ‚àà trivialization_atlas)
(continuous_on_coord_change [] : ‚àÄ (e e' ‚àà trivialization_atlas), continuous_on
  (Œª b, trivialization.coord_change e e' b : B ‚Üí F ‚ÜíL[R] F) (e.base_set ‚à© e'.base_set))
export topological_vector_bundle (trivialization_atlas trivialization_at
  mem_base_set_trivialization_at trivialization_mem_atlas continuous_on_coord_change)
variables {R F E} [topological_vector_bundle R F E]
namespace topological_vector_bundle
namespace trivialization
@[simps apply {fully_applied := ff}]
def continuous_linear_map_at (e : trivialization R F E) (b : B) :
  E b ‚ÜíL[R] F :=
@[simps apply {fully_applied := ff}]
def symmL (e : trivialization R F E) (b : B) : F ‚ÜíL[R] E b :=
@[simps apply symm_apply {fully_applied := ff}]
def continuous_linear_equiv_at (e : trivialization R F E) (b : B)
  (hb : b ‚àà e.base_set) : E b ‚âÉL[R] F :=
def trivialization : trivialization R F (bundle.trivial B F) :=
{ to_fun := Œª x, (x.fst, x.snd),
  inv_fun := Œª y, ‚ü®y.fst, y.snd‚ü©,
  source := univ,
  target := univ,
  map_source' := Œª x h, mem_univ (x.fst, x.snd),
  map_target' := Œª y h,  mem_univ ‚ü®y.fst, y.snd‚ü©,
  left_inv' := Œª x h, sigma.eq rfl rfl,
  right_inv' := Œª x h, prod.ext rfl rfl,
  open_source := is_open_univ,
  open_target := is_open_univ,
  continuous_to_fun := by { rw [‚Üêcontinuous_iff_continuous_on_univ, continuous_iff_le_induced],
    simp only [prod.topological_space, induced_inf, induced_compose], exact le_rfl, },
  continuous_inv_fun := by { rw [‚Üêcontinuous_iff_continuous_on_univ, continuous_iff_le_induced],
    simp only [bundle.total_space.topological_space, induced_inf, induced_compose],
    exact le_rfl, },
  base_set := univ,
  open_base_set := is_open_univ,
  source_eq := rfl,
  target_eq := by simp only [univ_prod_univ],
  proj_to_fun := Œª y hy, rfl,
  linear' := Œª x hx, ‚ü®Œª y z, rfl, Œª c y, rfl‚ü© }
lemma trivialization.coord_change (b : B) :
  (trivialization R B F).coord_change
    (trivialization R B F) b = continuous_linear_equiv.refl R F :=
begin
  ext v,
  rw [trivialization.coord_change_apply'],
  exacts [rfl, ‚ü®mem_univ _, mem_univ _‚ü©]
end
@[simp]
lemma trivialization_source : (trivialization R B F).source = univ := rfl
@[simp]
lemma trivialization_target : (trivialization R B F).target = univ := rfl
instance topological_vector_bundle :
  topological_vector_bundle R F (bundle.trivial B F) :=
{ trivialization_atlas := {trivial_topological_vector_bundle.trivialization R B F},
  trivialization_at := Œª x, trivial_topological_vector_bundle.trivialization R B F,
  mem_base_set_trivialization_at := mem_univ,
  trivialization_mem_atlas := Œª x, mem_singleton _,
  total_space_mk_inducing := Œª b, ‚ü®begin
    have : (Œª (x : trivial B F b), x) = @id F, by { ext x, refl },
    simp only [total_space.topological_space, induced_inf, induced_compose, function.comp,
      total_space.proj, induced_const, top_inf_eq, trivial.proj_snd, id.def,
      trivial.topological_space, this, induced_id],
  end‚ü©,
  continuous_on_coord_change := begin
    intros e he e' he',
    rw [mem_singleton_iff.mp he, mem_singleton_iff.mp he'],
    simp_rw [trivial_topological_vector_bundle.trivialization.coord_change],
    exact continuous_const.continuous_on
  end }
end trivial_topological_vector_bundle
lemma is_topological_vector_bundle_is_topological_fiber_bundle :
  is_topological_fiber_bundle F (@total_space.proj B E) :=
Œª x, ‚ü®(trivialization_at R F E x).to_fiber_bundle_trivialization,
  mem_base_set_trivialization_at R F E x‚ü©
include R F
lemma continuous_total_space_mk (x : B) : continuous (@total_space_mk B E x) :=
(topological_vector_bundle.total_space_mk_inducing R F E x).continuous
variables (R B F)
@[continuity] lemma continuous_proj : continuous (@total_space.proj B E) :=
begin
  apply @is_topological_fiber_bundle.continuous_proj B F,
  apply @is_topological_vector_bundle_is_topological_fiber_bundle R,
end
end topological_vector_bundle
variables (R B F)
structure topological_vector_bundle_core (Œπ : Type*) :=
(base_set          : Œπ ‚Üí set B)
(is_open_base_set  : ‚àÄ i, is_open (base_set i))
(index_at          : B ‚Üí Œπ)
(mem_base_set_at   : ‚àÄ x, x ‚àà base_set (index_at x))
(coord_change      : Œπ ‚Üí Œπ ‚Üí B ‚Üí (F ‚ÜíL[R] F))
(coord_change_self : ‚àÄ i, ‚àÄ x ‚àà base_set i, ‚àÄ v, coord_change i i x v = v)
(coord_change_continuous : ‚àÄ i j, continuous_on (coord_change i j) (base_set i ‚à© base_set j))
(coord_change_comp : ‚àÄ i j k, ‚àÄ x ‚àà (base_set i) ‚à© (base_set j) ‚à© (base_set k), ‚àÄ v,
  (coord_change j k x) (coord_change i j x v) = coord_change i k x v)
def trivial_topological_vector_bundle_core (Œπ : Type*) [inhabited Œπ] :
  topological_vector_bundle_core R B F Œπ :=
{ base_set := Œª Œπ, univ,
  is_open_base_set := Œª i, is_open_univ,
  index_at := default,
  mem_base_set_at := Œª x, mem_univ x,
  coord_change := Œª i j x, continuous_linear_map.id R F,
  coord_change_self := Œª i x hx v, rfl,
  coord_change_comp := Œª i j k x hx v, rfl,
  coord_change_continuous := Œª i j, continuous_on_const }
instance (Œπ : Type*) [inhabited Œπ] : inhabited (topological_vector_bundle_core R B F Œπ) :=
‚ü®trivial_topological_vector_bundle_core R B F Œπ‚ü©
namespace topological_vector_bundle_core
variables {R B F} {Œπ : Type*} (Z : topological_vector_bundle_core R B F Œπ)
def to_topological_fiber_bundle_core : topological_fiber_bundle_core Œπ B F :=
{ coord_change := Œª i j b, Z.coord_change i j b,
  coord_change_continuous := Œª i j, is_bounded_bilinear_map_apply.continuous.comp_continuous_on
      ((Z.coord_change_continuous i j).prod_map continuous_on_id),
  ..Z }
instance to_topological_fiber_bundle_core_coe : has_coe (topological_vector_bundle_core R B F Œπ)
  (topological_fiber_bundle_core Œπ B F) := ‚ü®to_topological_fiber_bundle_core‚ü©
include Z
lemma coord_change_linear_comp (i j k : Œπ): ‚àÄ x ‚àà (Z.base_set i) ‚à© (Z.base_set j) ‚à© (Z.base_set k),
  (Z.coord_change j k x).comp (Z.coord_change i j x) = Z.coord_change i k x :=
Œª x hx, by { ext v, exact Z.coord_change_comp i j k x hx v }
@[nolint unused_arguments has_inhabited_instance]
def index := Œπ
@[nolint unused_arguments, reducible]
def base := B
@[nolint unused_arguments has_inhabited_instance]
def fiber (x : B) := F
instance topological_space_fiber (x : B) : topological_space (Z.fiber x) :=
by delta_instance topological_vector_bundle_core.fiber
instance add_comm_monoid_fiber : ‚àÄ (x : B), add_comm_monoid (Z.fiber x) :=
by delta_instance topological_vector_bundle_core.fiber
instance module_fiber : ‚àÄ (x : B), module R (Z.fiber x) :=
by delta_instance topological_vector_bundle_core.fiber
instance add_comm_group_fiber [add_comm_group F] : ‚àÄ (x : B), add_comm_group (Z.fiber x) :=
by delta_instance topological_vector_bundle_core.fiber
@[reducible, simp, mfld_simps] def proj : total_space Z.fiber ‚Üí B := total_space.proj
@[nolint unused_arguments, reducible]
def total_space := bundle.total_space Z.fiber
def triv_change (i j : Œπ) : local_homeomorph (B √ó F) (B √ó F) :=
topological_fiber_bundle_core.triv_change ‚ÜëZ i j
@[simp, mfld_simps] lemma mem_triv_change_source (i j : Œπ) (p : B √ó F) :
  p ‚àà (Z.triv_change i j).source ‚Üî p.1 ‚àà Z.base_set i ‚à© Z.base_set j :=
topological_fiber_bundle_core.mem_triv_change_source ‚ÜëZ i j p
variable (Œπ)
instance to_topological_space : topological_space (Z.total_space) :=
topological_fiber_bundle_core.to_topological_space Œπ ‚ÜëZ
variables {Œπ} (b : B) (a : F)
@[simp, mfld_simps] lemma coe_coord_change (i j : Œπ) :
  topological_fiber_bundle_core.coord_change ‚ÜëZ i j b = Z.coord_change i j b := rfl
def local_triv (i : Œπ) : topological_vector_bundle.trivialization R F Z.fiber :=
{ linear' := Œª x hx,
  { map_add := Œª v w, by simp only [continuous_linear_map.map_add] with mfld_simps,
    map_smul := Œª r v, by simp only [continuous_linear_map.map_smul] with mfld_simps},
  ..topological_fiber_bundle_core.local_triv ‚ÜëZ i }
variables (i j : Œπ)
@[simp, mfld_simps] lemma mem_local_triv_source (p : Z.total_space) :
  p ‚àà (Z.local_triv i).source ‚Üî p.1 ‚àà Z.base_set i := iff.rfl
@[simp, mfld_simps] lemma base_set_at : Z.base_set i = (Z.local_triv i).base_set := rfl
@[simp, mfld_simps] lemma local_triv_apply (p : Z.total_space) :
  (Z.local_triv i) p = ‚ü®p.1, Z.coord_change (Z.index_at p.1) i p.1 p.2‚ü© := rfl
@[simp, mfld_simps] lemma mem_local_triv_target (p : B √ó F) :
  p ‚àà (Z.local_triv i).target ‚Üî p.1 ‚àà (Z.local_triv i).base_set :=
topological_fiber_bundle_core.mem_local_triv_target Z i p
@[simp, mfld_simps] lemma local_triv_symm_fst (p : B √ó F) :
  (Z.local_triv i).to_local_homeomorph.symm p =
    ‚ü®p.1, Z.coord_change i (Z.index_at p.1) p.1 p.2‚ü© := rfl
@[simp, mfld_simps] lemma local_triv_symm_apply {b : B} (hb : b ‚àà Z.base_set i) (v : F) :
  (Z.local_triv i).symm b v = Z.coord_change i (Z.index_at b) b v :=
by apply (Z.local_triv i).symm_apply hb v
@[simp, mfld_simps] lemma local_triv_coord_change_eq {b : B} (hb : b ‚àà Z.base_set i ‚à© Z.base_set j)
  (v : F) :
  (Z.local_triv i).coord_change (Z.local_triv j) b v = Z.coord_change i j b v :=
begin
  rw [trivialization.coord_change_apply', local_triv_symm_fst, local_triv_apply,
    coord_change_comp],
  exacts [‚ü®‚ü®hb.1, Z.mem_base_set_at b‚ü©, hb.2‚ü©, hb]
end
def local_triv_at (b : B) : topological_vector_bundle.trivialization R F Z.fiber :=
Z.local_triv (Z.index_at b)
@[simp, mfld_simps] lemma local_triv_at_def :
  Z.local_triv (Z.index_at b) = Z.local_triv_at b := rfl
@[simp, mfld_simps] lemma mem_source_at : (‚ü®b, a‚ü© : Z.total_space) ‚àà (Z.local_triv_at b).source :=
by { rw [local_triv_at, mem_local_triv_source], exact Z.mem_base_set_at b }
@[simp, mfld_simps] lemma local_triv_at_apply (p : Z.total_space) :
  ((Z.local_triv_at p.1) p) = ‚ü®p.1, p.2‚ü© :=
topological_fiber_bundle_core.local_triv_at_apply Z p
@[simp, mfld_simps] lemma local_triv_at_apply_mk (b : B) (a : F) :
  ((Z.local_triv_at b) ‚ü®b, a‚ü©) = ‚ü®b, a‚ü© :=
Z.local_triv_at_apply _
@[simp, mfld_simps] lemma mem_local_triv_at_base_set :
  b ‚àà (Z.local_triv_at b).base_set :=
topological_fiber_bundle_core.mem_local_triv_at_base_set Z b
instance : topological_vector_bundle R F Z.fiber :=
{ total_space_mk_inducing := Œª b, ‚ü® begin refine le_antisymm _ (Œª s h, _),
    { rw ‚Üêcontinuous_iff_le_induced,
      exact topological_fiber_bundle_core.continuous_total_space_mk ‚ÜëZ b, },
    { refine is_open_induced_iff.mpr ‚ü®(Z.local_triv_at b).source ‚à© (Z.local_triv_at b) ‚Åª¬π'
        ((Z.local_triv_at b).base_set √óÀ¢ s), (continuous_on_open_iff
        (Z.local_triv_at b).open_source).mp (Z.local_triv_at b).continuous_to_fun _
        ((Z.local_triv_at b).open_base_set.prod h), _‚ü©,
      rw [preimage_inter, ‚Üêpreimage_comp, function.comp],
      simp only [total_space_mk],
      refine ext_iff.mpr (Œª a, ‚ü®Œª ha, _, Œª ha, ‚ü®Z.mem_base_set_at b, _‚ü©‚ü©),
      { simp only [mem_prod, mem_preimage, mem_inter_eq, local_triv_at_apply_mk] at ha,
        exact ha.2.2, },
      { simp only [mem_prod, mem_preimage, mem_inter_eq, local_triv_at_apply_mk],
        exact ‚ü®Z.mem_base_set_at b, ha‚ü©, } } end‚ü©,
  trivialization_atlas := set.range Z.local_triv,
  trivialization_at := Z.local_triv_at,
  mem_base_set_trivialization_at := Z.mem_base_set_at,
  trivialization_mem_atlas := Œª b, ‚ü®Z.index_at b, rfl‚ü©,
  continuous_on_coord_change := begin
    rintros _ ‚ü®i, rfl‚ü© _ ‚ü®i', rfl‚ü©,
    refine (Z.coord_change_continuous i i').congr (Œª b hb, _),
    ext v,
    simp_rw [continuous_linear_equiv.coe_coe, Z.local_triv_coord_change_eq i i' hb],
  end }
@[continuity] lemma continuous_proj : continuous Z.proj :=
topological_fiber_bundle_core.continuous_proj Z
lemma is_open_map_proj : is_open_map Z.proj :=
topological_fiber_bundle_core.is_open_map_proj Z
end topological_vector_bundle_core
end
section
variables [nondiscrete_normed_field R] [‚àÄ x, add_comm_monoid (E x)] [‚àÄ x, module R (E x)]
  [normed_group F] [normed_space R F] [topological_space B]
open topological_space
open topological_vector_bundle
@[nolint has_inhabited_instance]
structure topological_vector_prebundle :=
(pretrivialization_atlas : set (pretrivialization R F E))
(pretrivialization_at : B ‚Üí pretrivialization R F E)
(mem_base_pretrivialization_at : ‚àÄ x : B, x ‚àà (pretrivialization_at x).base_set)
(pretrivialization_mem_atlas : ‚àÄ x : B, pretrivialization_at x ‚àà pretrivialization_atlas)
(exists_coord_change : ‚àÄ (e e' ‚àà pretrivialization_atlas), ‚àÉ f : B ‚Üí F ‚ÜíL[R] F,
  continuous_on f (e.base_set ‚à© e'.base_set) ‚àß
  ‚àÄ (b : B) (hb : b ‚àà e.base_set ‚à© e'.base_set) (v : F),
    f b v = (e' (total_space_mk b (e.symm b v))).2)
namespace topological_vector_prebundle
variables {R E F}
def coord_change (a : topological_vector_prebundle R F E)
  {e e' : pretrivialization R F E} (he : e ‚àà a.pretrivialization_atlas)
  (he' : e' ‚àà a.pretrivialization_atlas) (b : B) : F ‚ÜíL[R] F :=
classical.some (a.exists_coord_change e he e' he') b
lemma continuous_on_coord_change (a : topological_vector_prebundle R F E)
  {e e' : pretrivialization R F E} (he : e ‚àà a.pretrivialization_atlas)
  (he' : e' ‚àà a.pretrivialization_atlas) :
  continuous_on (a.coord_change he he') (e.base_set ‚à© e'.base_set) :=
(classical.some_spec (a.exists_coord_change e he e' he')).1
lemma coord_change_apply (a : topological_vector_prebundle R F E)
  {e e' : pretrivialization R F E} (he : e ‚àà a.pretrivialization_atlas)
  (he' : e' ‚àà a.pretrivialization_atlas) {b : B} (hb : b ‚àà e.base_set ‚à© e'.base_set) (v : F) :
  a.coord_change he he' b v = (e' (total_space_mk b (e.symm b v))).2 :=
(classical.some_spec (a.exists_coord_change e he e' he')).2 b hb v
lemma mk_coord_change (a : topological_vector_prebundle R F E)
  {e e' : pretrivialization R F E} (he : e ‚àà a.pretrivialization_atlas)
  (he' : e' ‚àà a.pretrivialization_atlas) {b : B} (hb : b ‚àà e.base_set ‚à© e'.base_set) (v : F) :
  (b, a.coord_change he he' b v) = e' (total_space_mk b (e.symm b v)) :=
begin
  ext,
  { rw [e.mk_symm hb.1 v, e'.coe_fst', e.proj_symm_apply' hb.1],
    rw [e.proj_symm_apply' hb.1], exact hb.2 },
  { exact a.coord_change_apply he he' hb v }
end
def to_topological_fiber_prebundle (a : topological_vector_prebundle R F E) :
  topological_fiber_prebundle F (@total_space.proj B E) :=
{ pretrivialization_atlas :=
    pretrivialization.to_fiber_bundle_pretrivialization '' a.pretrivialization_atlas,
  pretrivialization_at := Œª x, (a.pretrivialization_at x).to_fiber_bundle_pretrivialization,
  pretrivialization_mem_atlas := Œª x, ‚ü®_, a.pretrivialization_mem_atlas x, rfl‚ü©,
  continuous_triv_change := begin
    rintros _ ‚ü®e, he, rfl‚ü© _ ‚ü®e', he', rfl‚ü©,
    have := is_bounded_bilinear_map_apply.continuous.comp_continuous_on
      ((a.continuous_on_coord_change he' he).prod_map continuous_on_id),
    have H : e'.to_fiber_bundle_pretrivialization.to_local_equiv.target ‚à©
      e'.to_fiber_bundle_pretrivialization.to_local_equiv.symm ‚Åª¬π'
      e.to_fiber_bundle_pretrivialization.to_local_equiv.source =
      (e'.base_set ‚à© e.base_set) √óÀ¢ (univ : set F),
    { rw [e'.target_eq, e.source_eq],
      ext ‚ü®b, f‚ü©,
      simp only [-total_space.proj, and.congr_right_iff, e'.proj_symm_apply', iff_self,
        implies_true_iff] with mfld_simps {contextual := tt} },
    rw [H],
    refine (continuous_on_fst.prod this).congr _,
    rintros ‚ü®b, f‚ü© ‚ü®hb, -‚ü©,
    dsimp only [function.comp, prod.map],
    rw [a.mk_coord_change _ _ hb, e'.mk_symm hb.1],
    refl,
  end,
  .. a }
def total_space_topology (a : topological_vector_prebundle R F E) :
  topological_space (total_space E) :=
a.to_topological_fiber_prebundle.total_space_topology
def trivialization_of_mem_pretrivialization_atlas (a : topological_vector_prebundle R F E)
  {e : topological_vector_bundle.pretrivialization R F E} (he : e ‚àà a.pretrivialization_atlas) :
  @topological_vector_bundle.trivialization R _ F E _ _ _ _ _ _ _ a.total_space_topology :=
begin
  letI := a.total_space_topology,
  exact { linear' := Œª b, e.linear,
  ..a.to_topological_fiber_prebundle.trivialization_of_mem_pretrivialization_atlas ‚ü®e, he, rfl‚ü© }
end
variable (a : topological_vector_prebundle R F E)
lemma mem_trivialization_at_source (b : B) (x : E b) :
  total_space_mk b x ‚àà (a.pretrivialization_at b).source :=
begin
  simp only [(a.pretrivialization_at b).source_eq, mem_preimage, total_space.proj],
  exact a.mem_base_pretrivialization_at b,
end
@[simp] lemma total_space_mk_preimage_source (b : B) :
  (total_space_mk b) ‚Åª¬π' (a.pretrivialization_at b).source = univ :=
begin
  apply eq_univ_of_univ_subset,
  rw [(a.pretrivialization_at b).source_eq, ‚Üêpreimage_comp, function.comp],
  simp only [total_space.proj],
  rw preimage_const_of_mem _,
  exact a.mem_base_pretrivialization_at b,
end
def fiber_topology (b : B) : topological_space (E b) :=
topological_space.induced (total_space_mk b) a.total_space_topology
@[continuity] lemma inducing_total_space_mk (b : B) :
  @inducing _ _ (a.fiber_topology b) a.total_space_topology (total_space_mk b) :=
by { letI := a.total_space_topology, letI := a.fiber_topology b, exact ‚ü®rfl‚ü© }
@[continuity] lemma continuous_total_space_mk (b : B) :
  @continuous _ _ (a.fiber_topology b) a.total_space_topology (total_space_mk b) :=
begin
  letI := a.total_space_topology, letI := a.fiber_topology b,
  exact (a.inducing_total_space_mk b).continuous
end
def to_topological_vector_bundle :
  @topological_vector_bundle R _ F E _ _ _ _ _ _ a.total_space_topology a.fiber_topology :=
{ total_space_mk_inducing := a.inducing_total_space_mk,
  trivialization_atlas := {e | ‚àÉ e‚ÇÄ (he‚ÇÄ : e‚ÇÄ ‚àà a.pretrivialization_atlas),
    e = a.trivialization_of_mem_pretrivialization_atlas he‚ÇÄ},
  trivialization_at := Œª x, a.trivialization_of_mem_pretrivialization_atlas
    (a.pretrivialization_mem_atlas x),
  mem_base_set_trivialization_at := a.mem_base_pretrivialization_at,
  trivialization_mem_atlas := Œª x, ‚ü®_, a.pretrivialization_mem_atlas x, rfl‚ü©,
  continuous_on_coord_change := begin
    rintros _ ‚ü®e, he, rfl‚ü© _ ‚ü®e', he', rfl‚ü©,
    refine (a.continuous_on_coord_change he he').congr _,
    intros b hb,
    ext v,
    rw [a.coord_change_apply he he' hb v, continuous_linear_equiv.coe_coe,
      trivialization.coord_change_apply],
    exacts [rfl, hb]
  end }
end topological_vector_prebundle
end
